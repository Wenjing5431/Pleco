{"ast":null,"code":"\"use strict\";\n\nvar GLMath = GLMath || {},\n    ZoomCharts = ZoomCharts || {};\n!function (t) {\n  /*!\n  @license\n  DVSL Charting library, version 1.18.10 (2019-11-06).\n  (c) 2013 - 2019 Data Visualization Software Lab\n  https://zoomcharts.com\n  Embedded 3rd party software libraries:\n  CssColorParser.js\n  author : Dean McNamee <dean@gmail.com>, 2012.\n  license : MIT\n  github.com/deanm/css-color-parser-js\n  SHA-256 implementation in JavaScript\n  author : Chris Veness\n  license: MIT\n  github.com/chrisveness/crypto\n  jsrsasign (RSA-Sign JavaScript Library)\n  version : 4.7.2\n  author : Kenji Urushima\n  license : MIT\n  kjur.github.io/jsrsasign/\n  jsbn (RSA and ECC in JavaScript)\n  version : 1.4\n  author : Tom Wu\n  license : BSD (http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE)\n  www-cs-students.stanford.edu/~tjw/jsbn/\n  */\n  var _e2 = t.Configuration || (t.Configuration = {}),\n      i = t.Internal || (t.Internal = {});\n\n  t.PackageInfo = {\n    LibraryName: \"zoomcharts\",\n    Version: \"1.18.10 (2019-11-06)\",\n    Revision: \"861e7a911c477cdb9a37de7c68776c6179cf4140\",\n    Built: \"2019-11-08\"\n  };\n\n  var n = function n(t, e) {\n    function i() {\n      this.constructor = t;\n    }\n\n    t.__baseType = e;\n\n    for (var n in e) {\n      e.hasOwnProperty(n) && (t[n] = e[n]);\n    }\n\n    t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());\n  };\n\n  !function (i) {\n    var r = i.GeoChart || (i.GeoChart = {}),\n        s = i.FacetChart || (i.FacetChart = {}),\n        a = i.PieChart || (i.PieChart = {}),\n        o = i.TimeChart || (i.TimeChart = {}),\n        l = i.LinearChart || (i.LinearChart = {}),\n        h = i.NetChart || (i.NetChart = {}),\n        u = i.ItemsChart || (i.ItemsChart = {}),\n        c = i.Resources || (i.Resources = {}),\n        d = i.Base || (i.Base = {});\n    \"undefined\" != typeof module && module.exports && (module.exports.Internal = i), function (r) {\n      function s() {}\n\n      function a(t, e) {\n        for (var i in e) {\n          e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i]);\n        }\n      }\n\n      var o = r.Bar || (r.Bar = {}),\n          l = Object.prototype.hasOwnProperty,\n          h = (\"undefined\" == typeof console ? null : console) || {};\n      h.log || (h.log = s), h.warn || (h.warn = s), h.error || (h.error = s), h.info || (h.info = s), r.overlayConsole = !1;\n\n      var u = \"undefined\" != typeof Document && !(document instanceof Document),\n          d = function () {\n        function t() {}\n\n        return t.exportSymbol = function (t, e) {\n          \"undefined\" != typeof window && (window[t] = e), \"undefined\" != typeof module && module.exports && (module.exports[t] = e);\n        }, t.extendStyleTo = function (t, e, i) {\n          void 0 === i && (i = !0);\n\n          for (var n = Object.keys(t), r = 0; r < n.length; r++) {\n            var s = n[r],\n                a = t[s];\n            void 0 === a || !i && void 0 !== e[s] || (e[s] = a);\n          }\n        }, t.extendDataItem = function (e, i) {\n          for (var n = e, r = Object.keys(i), s = 0; s < r.length; s++) {\n            var a = r[s],\n                o = i[a];\n            \"style\" === a ? n.style ? t.extendDeep(n.style, o) : n.style = t.realClone(o) : n[a] = o;\n          }\n\n          return n;\n        }, t.extendDeep = function (e, i) {\n          if (null == e) throw new Error(\"Target object is not defined.\");\n          if (!t.isObjectOrArray(e)) throw new Error(\"Target is not an object.\");\n\n          for (var n = Object.keys(i), r = 0; r < n.length; r++) {\n            var s = n[r],\n                a = i[s],\n                o = e[s];\n            null == o && t.isObjectOrArray(a) && !t.isDomObject(a) ? e[s] = this.realClone(a) : t.isObjectOrArray(o) && t.isObjectOrArray(a) && !t.isDomObject(o) && !t.isDomObject(a) ? this.extendDeep(o, a) : e[s] = a;\n          }\n        }, t.extendCopy = function (t, e, i) {\n          if (void 0 === i && (i = null), !e) return t;\n\n          for (var n = Object.keys(e), r = 0; r < n.length; r++) {\n            var s = n[r],\n                a = e[s];\n\n            if (i && (a = i(s, a)), void 0 !== a) {\n              var o = t[s];\n              this.isDomObject(a) ? t[s] = a : this.isObjectOrArray(o) && this.isObjectOrArray(a) ? this.extendCopy(o, a, i) : this.isObjectOrArray(a) ? Array.isArray(a) ? t[s] = this.extendCopy([], a, i) : t[s] = this.extendCopy({}, a, i) : t[s] = a;\n            }\n          }\n\n          return t;\n        }, t.clone = function (e) {\n          if (null == e) return e;\n          var i;\n          i = t.isObjectOrArray(e) ? new e.constructor() : e.constructor();\n\n          for (var n = Object.keys(e), r = 0; r < n.length; r++) {\n            var s = n[r],\n                a = e[s];\n            i[s] = a;\n          }\n\n          return i;\n        }, t.isObjectOrArray = function (t) {\n          return null !== t && \"object\" == typeof t;\n        }, t.isDomObject = function (t) {\n          return t && (t instanceof Element || t instanceof CanvasGradient || t instanceof CanvasPattern || u && 2 === t.ATTRIBUTE_NODE);\n        }, t.isFunction = function (t) {\n          return \"function\" == typeof t;\n        }, t.isNumber = function (t) {\n          return !isNaN(t) && (\"number\" == typeof t || t instanceof Number);\n        }, t.isString = function (t) {\n          return \"string\" == typeof t || t instanceof String;\n        }, t.tryParseInt = function (t, e) {\n          void 0 === e && (e = 0);\n          var i = parseInt(t, 10);\n          return isNaN(i) ? e : i;\n        }, t.tryParseFloat = function (t, e) {\n          void 0 === e && (e = 0);\n          var i = parseFloat(t);\n          return isNaN(i) ? e : i;\n        }, t.hasProperty = function (t, e) {\n          return l.call(t, e);\n        }, t.hasProperties = function (t) {\n          return !!t && Object.keys(t).length > 0;\n        }, t.removePropertyValue = function (t) {\n          var e = Object.keys(t);\n          if (0 === e.length) return null;\n          var i = e[0],\n              n = t[i];\n          return delete t[i], {\n            key: i,\n            value: n\n          };\n        }, t.countProperties = function (t) {\n          return Object.keys(t).length;\n        }, t.realClone = function (t, e) {\n          if (this.isFunction(t) || void 0 !== e && e || this.isDomObject(t)) return t;\n\n          if (Array.isArray(t)) {\n            for (var i = new Array(t.length), n = 0; n < t.length; n++) {\n              i[n] = this.realClone(t[n], e);\n            }\n\n            return i;\n          }\n\n          if (this.isObjectOrArray(t)) {\n            for (var r = new t.constructor(), s = Object.keys(t), n = 0; n < s.length; n++) {\n              var a = s[n];\n              r[a] = this.realClone(t[a], e);\n            }\n\n            return r;\n          }\n\n          return t;\n        }, t.realCloneSafe = function (t, e) {\n          if (void 0 === e && (e = []), this.isFunction(t) || this.isDomObject(t)) return t;\n\n          if (Array.isArray(t)) {\n            for (var i = 0; i < e.length; i++) {\n              var n = e[i];\n              if (n.from === t) return n.to;\n            }\n\n            var r = new Array(t.length);\n            e.push({\n              from: t,\n              to: r\n            });\n\n            for (var i = 0; i < t.length; i++) {\n              r[i] = this.realCloneSafe(t[i], e);\n            }\n\n            return r;\n          }\n\n          if (this.isObjectOrArray(t)) {\n            for (var i = 0; i < e.length; i++) {\n              var n = e[i];\n              if (n.from === t) return n.to;\n            }\n\n            var s = new t.constructor();\n            e.push({\n              from: t,\n              to: s\n            });\n\n            for (var a = Object.keys(t), i = 0; i < a.length; i++) {\n              var o = a[i];\n              s[o] = this.realCloneSafe(t[o], e);\n            }\n\n            return s;\n          }\n\n          return t;\n        }, t.trunc = function (t) {\n          return t >= 0 ? Math.floor(t) : Math.ceil(t);\n        }, t.removeFromArray = function (t, e) {\n          for (var i, n = !1; (i = t.indexOf(e)) > -1;) {\n            t.splice(i, 1), n = !0;\n          }\n\n          return n;\n        }, t.removeFromArrayHasty = function (t, e) {\n          var i = t.indexOf(e);\n          if (i < 0) return !1;\n          var n = t.pop();\n          return i !== t.length && (t[i] = n), !0;\n        }, t.arrayToMap = function (t, e) {\n          for (var i = {}, n = 0; n < t.length; n++) {\n            var r = t[n];\n            r.index = n, i[r[e]] = r;\n          }\n\n          return i;\n        }, t.firstNonNullInArray = function (e, i, n) {\n          return t.visitArrayForwards(e, t.nonNullArrayVisitor, i, n);\n        }, t.lastNonNullInArray = function (e, i, n) {\n          return t.visitArrayBackwards(e, t.nonNullArrayVisitor, i, n);\n        }, t.nonNullArrayVisitor = function (e, i) {\n          return t.nonNullGuard(i, void 0);\n        }, t.nonNull = function (t) {\n          return null !== t && void 0 !== t;\n        }, t.isNull = function (e) {\n          return !t.nonNull(e);\n        }, t.nonNullGuard = function (e, i) {\n          return t.nonNull(e) ? e : i;\n        }, t.firstIndexLessThanInArray = function (e, i, n, r) {\n          return t.someIndexCompareInArray(e, i, function (t, e) {\n            return t >= e;\n          }, t.visitArrayForwards, n, r);\n        }, t.lastIndexLessThanInArray = function (e, i, n, r) {\n          return t.someIndexCompareInArray(e, i, function (t, e) {\n            return t >= e;\n          }, t.visitArrayBackwards, n, r);\n        }, t.firstIndexCompareInArray = function (e, i, n, r, s) {\n          return t.someIndexCompareInArray(e, i, n, t.visitArrayForwards, r, s);\n        }, t.lastIndexCompareInArray = function (e, i, n, r, s) {\n          return t.someIndexCompareInArray(e, i, n, t.visitArrayBackwards, r, s);\n        }, t.someIndexCompareInArray = function (t, e, i, n, r, s) {\n          return n(t, function (t, n) {\n            return i(n, e) ? t : void 0;\n          }, r, s);\n        }, t.visitArrayForwards = function (e, i, n, r) {\n          var s = t.nonNullGuard(n, 0);\n          return t.visitArray(e, s, function (t) {\n            return t + 1;\n          }, i, n, r);\n        }, t.visitArrayBackwards = function (e, i, n, r) {\n          var s = t.nonNullGuard(r, e.length) - 1;\n          return t.visitArray(e, s, function (t) {\n            return t - 1;\n          }, i, n, r);\n        }, t.visitArray = function (e, i, n, r, s, a) {\n          var o = i;\n\n          for (s = t.nonNullGuard(s, 0), a = t.nonNullGuard(a, e.length); o >= s && o < a;) {\n            var l = r(o, e[o]);\n            if (void 0 !== l) return l;\n            o = n(o);\n          }\n\n          return null;\n        }, t.cond = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          for (var i = 0; i < t.length; i++) {\n            if (t[i][0]) return t[i][1];\n          }\n\n          return null;\n        }, t.arraysToMatrix = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) {\n            t[e] = arguments[e];\n          }\n\n          for (var i = [], n = 0; n < t.length; n++) {\n            i.push(t[n]);\n          }\n\n          return i;\n        }, t.transposeMatrix = function (t) {\n          for (var e = [], i = 0; i < t[0].length; i++) {\n            for (var n = [], r = 0; r < t.length; r++) {\n              n.push(t[r][i]);\n            }\n\n            e.push(n);\n          }\n\n          return e;\n        }, t.overlayConsoleMessage = function (e, i, n) {\n          var r = document.getElementById(\"zoomChartsOverlayConsole\");\n          r || (r = document.createElement(\"div\"), r.id = \"zoomChartsOverlayConsole\", t.extendCopy(r.style, {\n            position: \"absolute\",\n            top: \"10px\",\n            left: \"10px\",\n            width: \"50%\",\n            height: \"300px\",\n            overflow: \"auto\",\n            backgroundColor: \"rgba(255,255,255,0.75)\",\n            border: \"1px solid black\",\n            zIndex: \"99999\"\n          }), document.body.appendChild(r));\n          var s = document.createElement(\"div\");\n          s.style.color = \"error\" === e ? \"red\" : \"warn\" === e ? \"yellow\" : \"black\", s.innerText = i + n.map(function (t) {\n            return JSON.stringify(t);\n          }).join(\"\"), r.appendChild(s), r.scrollTop = r.scrollHeight;\n        }, t.log = function (e) {\n          for (var i = [], n = 1; n < arguments.length; n++) {\n            i[n - 1] = arguments[n];\n          }\n\n          r.overlayConsole ? t.overlayConsoleMessage(\"log\", e, i) : i && i.length ? h.info.apply(h, [e].concat(i)) : h.info(e);\n        }, t.warn = function (e, i, n) {\n          if (void 0 === n && (n = null), n) {\n            var s = new Date().getTime();\n            if (this._previousConsoleMessages[e] > s) return;\n            n === !0 && (n = 5e3), this._previousConsoleMessages[e] = s + n;\n          }\n\n          r.overlayConsole ? t.overlayConsoleMessage(\"warn\", e, i) : i && i.length ? h.warn.apply(h, [e].concat(i)) : h.warn(e);\n        }, t.error = function (e) {\n          for (var i = [], n = 1; n < arguments.length; n++) {\n            i[n - 1] = arguments[n];\n          }\n\n          r.overlayConsole ? t.overlayConsoleMessage(\"error\", e, i) : i && i.length ? h.error.apply(h, [e].concat(i)) : h.error(e);\n        }, t.createDom = function (t, e, i, n) {\n          void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);\n          var r = document.createElement(t);\n          return null !== e && (r.className = e), null !== i && (r.innerHTML = i), null !== n && n.appendChild(r), r;\n        }, t.addClass = function (t, e) {\n          if (e = (e || \"\").trim()) {\n            var i = e.indexOf(\" \");\n            if (i > -1 && (this.addClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.add(e);else {\n              var n = t.className.length > 0 && new RegExp(\"(^|s)\" + e.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\") + \"(s|$)\").test(t.className);\n              n || (t.className.length > 0 && (e = \" \" + e), t.className = e);\n            }\n          }\n        }, t.removeClass = function (t, e) {\n          if (e = (e || \"\").trim()) {\n            var i = e.indexOf(\" \");\n            if (i > -1 && (this.removeClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.remove(e);else {\n              var n = function n(t, i) {\n                return i === e ? \"\" : t;\n              };\n\n              t.className = t.className.replace(/(\\S+)\\s*/g, n).trim();\n            }\n          }\n        }, t.isStyleSheetDefined = function (t, e) {\n          var i = document.createElement(\"dvsl-test\"),\n              n = document.body;\n          n.appendChild(i);\n\n          try {\n            var r = window.getComputedStyle(i),\n                s = r[e];\n            return i.className = t, n.removeChild(i), n.appendChild(i), s !== r[e];\n          } finally {\n            n.removeChild(i);\n          }\n        }, t.listen = function (t, e, i) {\n          t.addEventListener(e, i);\n        }, t.unlisten = function (t, e, i) {\n          t.removeEventListener(e, i);\n        }, t.stopPropagation = function (t) {\n          t.stopPropagation();\n        }, t.canvasScaling = function () {\n          var t, e;\n          return window.screen.deviceXDPI ? (t = window.screen.deviceXDPI / window.screen.logicalXDPI, e = window.screen.deviceYDPI / window.screen.logicalYDPI) : t = e = window.devicePixelRatio ? window.devicePixelRatio : 1, {\n            x: t,\n            y: e\n          };\n        }, t.convertPointFromPageToNode = function (t, e, i, n, r) {\n          if (window && window.webkitConvertPointFromPageToNode) {\n            var s = window.webkitConvertPointFromPageToNode(t, new WebKitPoint(e, i));\n            if (s) return s;\n          }\n\n          var a = t.getBoundingClientRect();\n          return {\n            x: n - a.left,\n            y: r - a.top\n          };\n        }, t.elementPos = function (t) {\n          var e = t.getBoundingClientRect(),\n              i = e.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0),\n              n = e.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0);\n          return {\n            left: n,\n            top: i\n          };\n        }, t.isParentOf = function (t, e) {\n          for (; e;) {\n            if (e === t) return !0;\n            e = e.parentElement;\n          }\n\n          return !1;\n        }, t.getProp = function (t, e, i) {\n          void 0 === i && (i = !1);\n\n          for (var n = 0, r = e.split(\".\"); n < r.length; n++) {\n            var s = r[n];\n            if (null == t || !this.hasProperty(t, s)) return;\n\n            if (i && n === r.length - 1) {\n              var a = t[s];\n              delete t[s], t = a;\n            } else t = t[s];\n          }\n\n          return t;\n        }, t.wrapValue = function (t, e) {\n          for (var i = t, n = e.split(\".\").reverse(), r = 0; r < n.length; r++) {\n            var s = n[r];\n            a = {}, a[s] = i, i = a;\n          }\n\n          return i;\n          var a;\n        }, t.hasProp = function (e, i) {\n          return void 0 !== t.getProp(e, i);\n        }, t.sign = function (t) {\n          return t ? t < 0 ? -1 : 1 : 0;\n        }, t.reversePolyline = function (t) {\n          var e = [];\n          if (t.length % 2 !== 0) throw new Error(\"The length of a given polyline must be dividable by 2\");\n\n          for (var i = t.length - 1; i >= 0; i += -2) {\n            e.push(t[i - 1], t[i]);\n          }\n\n          return e;\n        }, t.toleranceMax = function (t, e, i) {\n          return t >= e * i ? t : e;\n        }, t.toleranceMin = function (t, e, i) {\n          return t * i <= e ? t : e;\n        }, t.getIdentifierStr = function () {\n          return t.SeparatorChar + (t.nextIdentifier++).toString();\n        }, t.doPostRequest = function (t, e, i, n, r) {\n          this.isString(i) || (i = JSON.stringify(i)), this.doRequestRaw(t, e, \"POST\", i, n, r);\n        }, t.doRequest = function (t, e, i, n, r) {\n          if (i && i.length) {\n            t += t.indexOf(\"?\") !== -1 ? \"&\" : \"?\";\n\n            for (var s = 0; s < i.length; s++) {\n              var a = i[s];\n              s > 0 && (t += \"&\"), t += encodeURIComponent(a[0]) + \"=\" + encodeURIComponent(a[1]);\n            }\n          }\n\n          this.doRequestRaw(t, e, \"GET\", \"\", n, r);\n        }, t.doRequestRaw = function (t, e, i, n, r, s) {\n          var a;\n          if (\"undefined\" == typeof XMLHttpRequest) throw new Error(\"Cannot create XMLHttpRequest. Please verify if the feature is not disabled in the browser configuration.\");\n          a = new XMLHttpRequest(), a.onreadystatechange = function () {\n            4 === a.readyState && (200 === a.status ? r(a.responseText) : s(a.responseText));\n          };\n\n          try {\n            a.open(i, t, !0), a.timeout = e, a.ontimeout = function () {\n              s('{\"error\": \"Request timeout.\"}');\n            }, a.send(n);\n          } catch (t) {\n            return void window.setTimeout(function () {\n              return s(t);\n            }, 1);\n          }\n        }, t.openUrl = function (t, e) {\n          return window.open(t, e || \"_blank\");\n        }, t.parseData = function (t, e, i) {\n          void 0 === i && (i = !1);\n          var n = null,\n              s = null;\n          if (e = e.toLowerCase(), \"json\" === e || \"geojson\" === e) {\n            if (r.Helpers.isString(t)) try {\n              s = JSON.parse(t);\n            } catch (e) {\n              n = i ? t : \"Failed to parse JSON response: \" + e + \". Response text: \" + t;\n            } else s = t;\n          } else n = \"Unsupported data format: \" + e;\n          return null == s && null == n && (n = \"NULL response\"), n ? {\n            error: n\n          } : s;\n        }, t.valueUnitFactorFromName = function (t) {\n          return this.numberUnitMap[t];\n        }, t.valueUnitAndName = function (t, e) {\n          e = r.Helpers.nonNullGuard(e, this.numberUnitMap), t = Math.abs(t);\n          var i = 1,\n              n = \"\",\n              s = Number.POSITIVE_INFINITY;\n\n          for (var a in e) {\n            var o = e[a],\n                l = Math.abs(t / o);\n            l < s && l >= 1 && (i = o, n = a, s = l);\n          }\n\n          var h = 0;\n\n          if (t > 0) {\n            var u = t / i;\n            Math.floor(u) !== u && (h = u.toString().split(\".\")[1].length || 0), h = Math.min(h, 3);\n          }\n\n          return {\n            unit: i,\n            digitsAfterComma: h,\n            name: n\n          };\n        }, t.valueShorteningWithUnit = function (t, e, i, n) {\n          var s = r.Helpers.isNull(e) ? this.autoValueUnit(t, n) : e;\n          return i = r.Helpers.nonNullGuard(i, this.numberUnitMap), r.Helpers.nonNull(t) && (t /= i[s]), {\n            value: t,\n            valueUnit: s\n          };\n        }, t.decimalShortening = function (t, e) {\n          if (r.Helpers.isNull(e)) return e;\n          var i = null !== t && \"auto\" != t ? t : 2;\n          return e.toFixed(i);\n        }, t.autoValueUnit = function (t, e) {\n          if (r.Helpers.isNull(t)) return \"\";\n          e = r.Helpers.nonNullGuard(e, this.reverseNumberUnitMap);\n          var i = Math.log(Math.abs(t)) / (3 * Math.LN10),\n              n = Math.min(Math.max(i, 0), 4);\n          return e[Math.floor(n)];\n        }, t.clamp = function (t, e, i) {\n          return t >= i ? i || 0 : t <= e ? e || 0 : t;\n        }, t.numberFormat = function (t, e, i, n) {\n          void 0 === e && (e = 2), void 0 === i && (i = \".\"), void 0 === n && (n = \" \");\n          var r = parseFloat(t);\n          if (isNaN(r)) return \"—\";\n          var s;\n          r < 0 ? (s = \"-\", r = -r) : s = \"\";\n\n          for (var a, o = Math.floor(r), l = r - o, h = e > 0 ? i + l.toFixed(e).substr(2) : \"\";;) {\n            if (a = o % 1e3, h = a.toFixed(0) + h, !(o >= 1e3)) break;\n            o = Math.floor(o / 1e3), a < 10 ? h = \"00\" + h : a < 100 && (h = \"0\" + h), h = n + h;\n          }\n\n          return s + h;\n        }, t.printPercentValue = function (t, e, i) {\n          void 0 === i && (i = \"\");\n          var n = \"\",\n              s = 0;\n\n          if (e[1]) {\n            var a = e[1];\n            n = a.charAt(0), s = a.length - 1;\n          }\n\n          var o = e[2],\n              l = (100 * t).toFixed(s),\n              h = r.Helpers.numberFormat(l, s, n);\n          return \"\" !== i && \" \" === o.charAt(0) && (i = \" \" + i), h + i + o;\n        }, t.printCurrencyValue = function (t, e, i) {\n          void 0 === i && (i = \"\");\n          var n = \"\",\n              s = 0;\n\n          if (e[2]) {\n            var a = e[2];\n            n = a.charAt(0), s = a.length - 1;\n          }\n\n          var o = e[1] ? e[1] : \"\",\n              l = e[3] ? e[3] : \"\",\n              h = r.Helpers.numberFormat(t, s, n);\n          return \"\" !== i && \" \" === l.charAt(0) && (i = \" \" + i), o && l && (l.indexOf(\"%\") > -1 || o.indexOf(\"%\") > -1) ? (this.warn(\"Incorrect valueFormat using '%'. To format as percentage, '%' must be used after digits without any prefix.\"), r.Helpers.numberFormat(t)) : o + h + i + l;\n        }, t.matchPercentFormat = function (t) {\n          return /^0([.,]0+)?( ?%)$/.exec(t);\n        }, t.matchCurrencyFormat = function (t) {\n          return /^([^0-9]+)?0?([.,]0+)?([^0-9]+)?$/.exec(t);\n        }, t.buildImage = function (t, e, i, n) {\n          var r = this,\n              s = document.createElement(\"img\"),\n              a = function a() {\n            return i(s);\n          },\n              o = function o(a) {\n            e ? r.buildImage(t, null, i, n) : n(s);\n          };\n\n          return e && (s.crossOrigin = e), s.src = t, s.complete ? s.width > 0 ? a() : setTimeout(a, 0) : (s.onload = a, s.onerror = o), s;\n        }, t.sort = function (t, e) {\n          e || (e = function e(t, _e) {\n            return t - _e;\n          });\n\n          for (var i, n, r = t, s = Math.floor(r.length), a = 0; a <= s - 2; a += 2) {\n            i = r[a], n = r[a + 1], e(i, n) > 0 && (r[a] = n, r[a + 1] = i);\n          }\n\n          for (var o = r.slice(0), l = 2; l < s;) {\n            for (var h = l << 1, u = 0; u <= s - 1; u += h) {\n              var c = u,\n                  d = u + l;\n              if (d >= s) for (var a = c; a <= s - 1; a++) {\n                o[a] = r[a];\n              } else {\n                var p = d,\n                    f = Math.min(d + l, s),\n                    g = u;\n\n                for (i = r[c], n = r[d];;) {\n                  if (e(i, n) <= 0) {\n                    if (o[g] = i, g = Math.floor(g + 1), c = Math.floor(c + 1), c === p) {\n                      for (o[g] = n, g = Math.floor(g + 1), d = Math.floor(d + 1); d < f;) {\n                        o[g] = r[d], g = Math.floor(g + 1), d = Math.floor(d + 1);\n                      }\n\n                      break;\n                    }\n\n                    i = r[c];\n                  } else {\n                    if (o[g] = n, g = Math.floor(g + 1), d = Math.floor(d + 1), d === f) {\n                      for (o[g] = i, g = Math.floor(g + 1), c = Math.floor(c + 1); c < p;) {\n                        o[g] = r[c], g = Math.floor(g + 1), c = Math.floor(c + 1);\n                      }\n\n                      break;\n                    }\n\n                    n = r[d];\n                  }\n                }\n              }\n            }\n\n            l = h;\n            var v = o;\n            o = r, r = v;\n          }\n\n          if (t !== r) {\n            for (var a = 0; a <= s - 1; a++) {\n              t[a] = r[a];\n            }\n\n            r.length = 0;\n          } else o.length = 0;\n\n          return t;\n        }, t.binSearch = function (t, e) {\n          for (var i = 0, n = t.length - 1; i < n;) {\n            var r = Math.floor((n + i) / 2);\n            if (t[r] < e) i = r + 1;else {\n              if (!(t[r] > e)) {\n                for (; r > 0 && t[r - 1] === e;) {\n                  r -= 1;\n                }\n\n                return r;\n              }\n\n              n = r;\n            }\n          }\n\n          return i < t.length && t[i] < e ? i + 1 : i;\n        }, t.listenResize = function (e, i) {\n          var n = document.documentMode;\n          if (n && n < 11) e.onresize = i;else {\n            var r = e,\n                s = document.createElement(\"div\"),\n                a = function a(e) {\n              i(), t.updateResizeTriggers(s);\n            };\n\n            \"static\" === window.getComputedStyle(r).position && (r.style.position = \"relative\"), r.__resizeTriggers__ = s, s.className = \"DVSL-resize-triggers\", s.innerHTML = '<div class=\"DVSL-expand-trigger\"><div></div></div><div class=\"DVSL-contract-trigger\"></div>', r.insertBefore(s, r.firstChild), t.updateResize(s), r.__resizeListener__ = a, r.addEventListener(\"scroll\", a, !0);\n          }\n        }, t.updateResize = function (t) {\n          var e = t.__resizeTriggers__;\n          e && this.updateResizeTriggers(e);\n        }, t.updateResizeTriggers = function (t) {\n          var e = t.firstElementChild || t.firstChild,\n              i = t.lastElementChild || t.lastChild,\n              n = e.firstElementChild || e.firstChild;\n          i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight, n.style.width = e.offsetWidth + 1 + \"px\", n.style.height = e.offsetHeight + 1 + \"px\", e.scrollLeft = e.scrollWidth, e.scrollTop = e.scrollHeight;\n        }, t.unlistenResize = function (t) {\n          var e = t,\n              i = e.__resizeTriggers__;\n          i ? (e.removeEventListener(\"scroll\", e.__resizeListener__, !0), i.parentNode && i.parentNode.removeChild(i), delete e.__resizeListener__, delete e.__resizeTriggers__) : delete t.onresize;\n        }, t.decodeEntities = function (e) {\n          return e.indexOf(\"&\") === -1 ? e : (t.decodeTextarea || (t.decodeTextarea = document.createElement(\"textarea\")), t.decodeTextarea.innerHTML = e, t.decodeTextarea.value);\n        }, t.base64Encode = function (t) {\n          if (window.btoa) return window.btoa(t);\n\n          for (var e = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", i = \"\", n = 0, r = 0; t.charAt(Math.floor(r)) || (e = \"=\", r % 1); i += e.charAt(63 & n >> 8 - r % 1 * 8)) {\n            var s = t.charCodeAt(r += .75);\n            if (s > 255) throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            n = n << 8 | s;\n          }\n\n          return i;\n        }, t.compareVersions = function (t, e) {\n          for (var i = t.split(\".\"), n = i.length, r = e.length, s = 0; s < Math.max(n, r); s++) {\n            var a = s < n ? parseInt(i[s], 10) : 0,\n                o = s < r ? e[s] : 0;\n            if (a > o) return !0;\n            if (a < o) return !1;\n          }\n\n          return !0;\n        }, t.aggregate = function (t, e, i) {\n          for (var n = 0, r = this.aggregationCallbacks[t], s = r.start; e();) {\n            var a = i();\n            r.increment(s, a), n += 1;\n          }\n\n          return n > 0 ? r.result(s, n) : null;\n        }, t.getRelativeClientRect = function (t) {\n          if (!t) return null;\n          if (!t.offsetParent) return null;\n          var e = t.getBoundingClientRect(),\n              i = t.offsetParent.getBoundingClientRect();\n          return {\n            bottom: i.bottom - e.bottom,\n            height: e.height,\n            left: e.left - i.left,\n            right: i.right - e.right,\n            top: e.top - i.top,\n            width: e.width\n          };\n        }, t.countDecimals = function (t) {\n          return t ? Math.floor(t) === t ? 0 : t.toString().split(\".\")[1].length || 0 : 0;\n        }, t;\n      }();\n\n      if (d._previousConsoleMessages = {}, d.SeparatorChar = String.fromCharCode(63743), d.nextIdentifier = 0, d.numberUnitMap = {\n        \"\": 1,\n        K: 1e3,\n        M: 1e6,\n        bn: 1e9,\n        T: 1e12\n      }, d.reverseNumberUnitMap = [\"\", \"K\", \"M\", \"bn\", \"T\"], d.decodeTextarea = null, d.aggregationCallbacks = {\n        sum: {\n          start: 0,\n          increment: function increment(t, e) {\n            return t + e;\n          },\n          result: function result(t, e) {\n            return t;\n          }\n        },\n        min: {\n          start: 1 / 0,\n          increment: function increment(t, e) {\n            return Math.min(t, e);\n          },\n          result: function result(t, e) {\n            return t;\n          }\n        },\n        max: {\n          start: -(1 / 0),\n          increment: function increment(t, e) {\n            return Math.max(t, e);\n          },\n          result: function result(t, e) {\n            return t;\n          }\n        },\n        avg: {\n          start: 0,\n          increment: function increment(t, e) {\n            return t + e;\n          },\n          result: function result(t, e) {\n            return t / e;\n          }\n        },\n        count: {\n          start: 0,\n          increment: function increment(t, e) {\n            return 0;\n          },\n          result: function result(t, e) {\n            return e;\n          }\n        },\n        first: {\n          start: null,\n          increment: function increment(t, e) {\n            return null !== t && void 0 !== t ? t : e;\n          },\n          result: function result(t, e) {\n            return t;\n          }\n        },\n        last: {\n          start: null,\n          increment: function increment(t, e) {\n            return null !== e && void 0 !== e ? e : t;\n          },\n          result: function result(t, e) {\n            return t;\n          }\n        }\n      }, r.Helpers = d, \"undefined\" != typeof window) {\n        var p = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame,\n            f = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame;\n\n        if (!p) {\n          var g = 0;\n          p = function p(t) {\n            var e = new Date().getTime(),\n                i = Math.max(0, 16 - (e - g)),\n                n = window.setTimeout(function () {\n              return t(e + i);\n            }, i);\n            return g = e + i, n;\n          }, f = window.clearTimeout;\n        }\n\n        f || (f = function f() {}), d.requestAnimationFrame = function (t) {\n          return p.call(window, t);\n        }, d.cancelAnimationFrame = function (t) {\n          return f.call(window, t);\n        };\n        var v = new Date().getTime();\n        \"performance\" in window == !1 ? d.performanceNow = function () {\n          return new Date().getTime() - v;\n        } : \"now\" in window.performance == !1 ? (performance.timing && performance.timing.navigationStart && (v = performance.timing.navigationStart), d.performanceNow = function () {\n          return new Date().getTime() - v;\n        }) : d.performanceNow = function () {\n          return window.performance.now();\n        };\n        var m = v - d.performanceNow();\n\n        d.timeToPerfNow = function (t) {\n          return t - m;\n        };\n      }\n\n      var y = function () {\n        function t() {\n          this.id = \"default\", this.url = null, this.urlParameters = [], this.postprocessorFunction = null, this.preloaded = null, this.format = \"JSON\", this.requestTimeout = 4e4, this.numberOfParallelRequests = 3;\n        }\n\n        return t;\n      }();\n\n      r.SettingsData = y;\n\n      var S = function () {\n        function t(t, e) {\n          this.removed = !1, this.requestScheduled = !1, this.requestsRunning = !1, this.requestCount = 0, this.dataSettings = e, this.chart = t, this.settings = t.settings;\n        }\n\n        return t.doRequest = function (t, e, i, n, r) {\n          if (e.urlParameters.length) {\n            i = i.slice();\n\n            for (var s = 0; s < e.urlParameters.length; s++) {\n              var a = e.urlParameters[s];\n              i.push([a.name, a.value]);\n            }\n          }\n\n          var o;\n          o = e.postprocessorFunction ? function (t) {\n            return n(e.postprocessorFunction(t));\n          } : n, d.doRequest(t, e.requestTimeout, i, o, r);\n        }, t.prototype.buildRequest = function () {\n          return null;\n        }, t.prototype.verifyData = function (t, e) {\n          return !0;\n        }, t.prototype.addVerifiedData = function (t, e) {\n          return {};\n        }, t.prototype.requestFailedPermanently = function (t) {}, t.prototype.remove = function () {\n          this.removed = !0;\n        }, t.prototype.hasPendingRequests = function () {\n          return !this.removed && this.requestCount > 0;\n        }, t.prototype.addData = function (t) {\n          this._dataArrived(null, t);\n        }, t.prototype.applyPreloadedData = function () {\n          this.dataSettings.preloaded && this._dataArrived(null, this.dataSettings.preloaded);\n        }, t.prototype.scheduleRequests = function (t) {\n          var e = this;\n          void 0 === t && (t = !1), t ? this._runRequests() : this.requestScheduled || (this.requestScheduled = !0, setTimeout(function () {\n            return e._runRequests();\n          }, 0));\n        }, t.prototype._runRequests = function () {\n          var t = this;\n\n          if (!this.removed && !this.requestsRunning) {\n            this.requestScheduled = !1;\n            var e;\n\n            try {\n              for (this.requestsRunning = !0; this.requestCount < this.dataSettings.numberOfParallelRequests && (e = this.buildRequest(), null !== e);) {\n                !function (e) {\n                  var i = function i(_i) {\n                    return t._dataArrived(e, _i);\n                  },\n                      n = function n(i) {\n                    return t._dataError(e, i);\n                  };\n\n                  t.requestCount += 1, t.chart.log(\"Requesting data for\", e), t.dataFunc(e, i, n);\n                }(e);\n              }\n            } finally {\n              this.requestsRunning = !1;\n            }\n          }\n        }, t.prototype._dataError = function (t, e) {\n          if (!this.removed) {\n            var i = d.parseData(e, this.dataSettings.format, !0),\n                n = i && i.error ? i.error : \"Unknown error\";\n            t ? (this.requestCount -= 1, this.chart.error(\"Data request failed: \" + n, t)) : this.chart.error(\"Data loading failed: \" + n), this.requestFailedPermanently(t), this._runRequests();\n          }\n        }, t.prototype._dataArrived = function (t, e) {\n          if (!this.removed) {\n            var i = d.parseData(e, this.dataSettings.format);\n\n            if (t ? (this.requestCount -= 1, i.error ? this.chart.error(\"Data request succeeded, but contained an error: \" + i.error, t) : this.chart.log(\"Data arrived for request\", t)) : i.error ? this.chart.error(\"Loaded data contains error: \" + i.error) : this.chart.log(\"Data loaded\"), !i.error && this.verifyData(t, i)) {\n              var n = this.addVerifiedData(t, i);\n              n.dataArrived || (n.dataArrived = {}), n.dataArrived[this.dataSettings.id] = !0;\n              var r = this.chart.createEventArguments(null, \"api\");\n              r.dataArrived = i, r.dataRemoved = null, this.chart.notifyDataUpdated(r), this.chart.events.notifySceneChanges(n);\n            } else t && this.requestFailedPermanently(t);\n\n            this._runRequests();\n          }\n        }, t;\n      }();\n\n      r.Data = S;\n\n      var b = function () {\n        function t() {}\n\n        return t.detect = function () {\n          return this._cached || this.run();\n        }, t.run = function () {\n          var t,\n              e = window,\n              i = document.body;\n          document.domain && (t = document.createElement(\"iframe\"), i.appendChild(t), e = t.contentWindow);\n          var n;\n\n          try {\n            n = this.check(e);\n          } catch (t) {\n            n = this.check(window);\n          }\n\n          return this._cached = n, t && i.removeChild(t), n;\n        }, t.check = function (t) {\n          return {\n            isSafariDesktop: !!t.safari && !!t.safari.pushNotification,\n            isChrome: !!t.chrome && !!t.chrome.loadTimes\n          };\n        }, t;\n      }();\n\n      b._cached = null, r.Browser = b;\n\n      var x = function () {\n        function t(t, e, i, n) {\n          this.consumed = !1, this.defaultPrevented = !1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.wheely = 0, this.wheelx = 0, this.identifier = \"0\", this.pressed = !1, this.touch = !1, this.pageX = 0, this.pageY = 0, this.shiftKey = !1, this.altKey = !1, this.ctrlKey = !1, this.target = null, this.isRightMB = !1, this._vx = null, this._vy = null, this.velocityPointer = null, this._leaving = !1, this.swipeUp = !1, this.swipeDown = !1, this.swipeLeft = !1, this.swipeRight = !1, this.swipeSpeed = null, this.capture = !1, this.hovered = !1, this.cursor = null, this.changedPointerCount = 1, this.identifier = n, this.timeStamp = i, this.y = e, this.x = t;\n        }\n\n        return t.prototype.preventDefault = function () {\n          this.defaultPrevented = !0;\n        }, Object.defineProperty(t.prototype, \"vx\", {\n          get: function get() {\n            return null === this._vx && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vx || 0;\n          },\n          set: function set(t) {\n            this._vx = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"vy\", {\n          get: function get() {\n            return null === this._vy && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vy || 0;\n          },\n          set: function set(t) {\n            this._vy = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.distance = function (t) {\n          return Math.sqrt((t.x - this.x) * (t.x - this.x) + (t.y - this.y) * (t.y - this.y));\n        }, t.prototype.isWithinDistance = function (t, e, i) {\n          if (!t) return !1;\n          var n = this.pageX - t.pageX,\n              r = this.pageY - t.pageY;\n          return n * n + r * r < e * e && (null == i || t.timeStamp + i > this.timeStamp);\n        }, t;\n      }();\n\n      r.MouseEvent = x;\n\n      var C = function () {\n        function t(t, e) {\n          this.noClick = !1, this.scrolling = !1, this.ptsIndex = 0, this.ptsLength = 3, this.ptsMax = 72, this.settings = e, this.identifier = t.identifier, this.touch = !1, this.x = t.x, this.y = t.y, this.pageX = t.pageX, this.pageY = t.pageY, this.timeStamp = t.timeStamp, \"undefined\" != typeof Int32Array ? this.pts = new Int32Array(this.ptsMax) : this.pts = new Array(this.ptsMax), this.pts[0] = Math.floor(this.x), this.pts[1] = Math.floor(this.y), this.pts[2] = 0;\n        }\n\n        return t.prototype.moveTo = function (t) {\n          var e = this.ptsIndex + this.ptsLength,\n              i = Math.floor(t.timeStamp - this.timeStamp),\n              n = this.ptsMax;\n          i === this.pts[e - 1] && (this.ptsLength -= 3, e -= 3), t.x || t.y ? (t.dx = t.x - this.x, t.dy = t.y - this.y, this.x = t.x, this.y = t.y) : (t.dx = 0, t.dy = 0, t.x = this.x, t.y = this.y), e === this.ptsMax && (e = 0), this.pts[e++] = Math.floor(this.x), this.pts[e++] = Math.floor(this.y), this.pts[e++] = Math.floor(i), (this.ptsLength += 3) > n && (this.ptsLength -= 3, n === (this.ptsIndex += 3) && (this.ptsIndex = 0));\n        }, t.prototype.getPosAndSpeed = function (t) {\n          t.touch = this.touch, t.velocityPointer = this, t.vx = null, t.vy = null;\n        }, t.prototype.calculatePosAndSpeed = function (t) {\n          var e,\n              i,\n              n = this.pts,\n              r = this.ptsMax,\n              s = 10 * r,\n              a = 50,\n              o = Math.floor(t.timeStamp - this.timeStamp) - s;\n\n          for (e = this.ptsIndex; e < this.ptsIndex + this.ptsLength && (i = e % r, !(n[i + 2] > o)); e += 3) {\n            ;\n          }\n\n          return s = Math.floor(t.timeStamp - this.timeStamp) - n[i + 2], e === this.ptsIndex + this.ptsLength || s < a ? (t.vx = 0, void (t.vy = 0)) : (t.vx = (this.x - n[i + 0]) / s, void (t.vy = (this.y - n[i + 1]) / s));\n        }, t;\n      }(),\n          w = function () {\n        function t(e, i, n, r) {\n          void 0 === n && (n = null);\n          var s = this;\n          this.scaleX = 1, this.scaleY = 1, this.nextFakeMouseId = 1, this.doubleClickTimeout = null, this.longPressTimeout = null, this.longPressInitiator = null, this.listeners = {}, this.downPointers = {}, this.inPointers = {}, this.containerList = [], this.clickCounter = 1, this.lastClickEvent = null, this.topWindowEvents = {}, this.ID_MOUSE = \"mouse\", this.settings = i, this.container = e, this.lastEvent = null, this.lastTouchEvent = null, this.clickEvent = null, this.containerEvents = {\n            contextmenu: function contextmenu(t) {\n              return s.filterEvent(t) && s.handleCMenu(t);\n            },\n            wheel: function wheel(t) {\n              return s.filterEvent(t) && s.handleMouseWheel(t);\n            },\n            dragover: function dragover(t) {\n              return s.filterEvent(t) && s.handleMouseMove(t);\n            }\n          }, this.transform = r;\n          var a = \"undefined\" != typeof PointerEvent,\n              o = \"undefined\" != typeof TouchEvent,\n              l = !a && \"undefined\" != typeof MSPointerEvent;\n          l ? (this.container.style.msTouchAction = \"none\", this.windowEvents = (c = {}, c.MSPointerDown = function (t) {\n            return s.filterEvent(t) && s.handlePointerDown(t);\n          }, c.MSPointerMove = function (t) {\n            return s.filterEvent(t) && s.handlePointerMove(t);\n          }, c.MSPointerUp = function (t) {\n            return s.filterEvent(t) && s.handlePointerUp(t);\n          }, c.MSPointerCancel = function (t) {\n            return s.filterEvent(t) && s.handlePointerCancel(t);\n          }, c.MSPointerOut = function (t) {\n            return s.filterEvent(t) && s.handlePointerLeave(t);\n          }, c)) : a && !o ? (this.container.style.touchAction = \"none\", this.windowEvents = (p = {}, p.pointerdown = function (t) {\n            return s.filterEvent(t) && s.handlePointerDown(t);\n          }, p.pointermove = function (t) {\n            return s.filterEvent(t) && s.handlePointerMove(t);\n          }, p.pointerup = function (t) {\n            return s.filterEvent(t) && s.handlePointerUp(t);\n          }, p.pointercancel = function (t) {\n            return s.filterEvent(t) && s.handlePointerCancel(t);\n          }, p.pointerout = function (t) {\n            return s.filterEvent(t) && s.handlePointerLeave(t);\n          }, p)) : (this.windowEvents = {\n            mousedown: function mousedown(t) {\n              return s.filterEvent(t) && s.handleMouseDown(t);\n            },\n            mouseup: function mouseup(t) {\n              return s.filterEvent(t) && s.handleMouseUp(t);\n            },\n            mousemove: function mousemove(t) {\n              return s.filterEvent(t) && s.handleMouseMove(t);\n            },\n            mouseout: function mouseout(t) {\n              return s.filterEvent(t) && s.handleMouseLeave(t);\n            },\n            touchstart: function touchstart(t) {\n              return s.filterEvent(t) && s.handleTouchStart(t);\n            },\n            touchend: function touchend(t) {\n              return s.filterEvent(t) && s.handleTouchEnd(t);\n            },\n            touchcancel: function touchcancel(t) {\n              return s.filterEvent(t) && s.handleTouchCancel(t);\n            },\n            touchmove: function touchmove(t) {\n              return s.filterEvent(t) && s.handleTouchMove(t);\n            }\n          }, this.topWindowEvents = {\n            mouseup: function mouseup(t) {\n              return s.filterEvent(t) && s.handleMouseUp(t);\n            },\n            touchend: function touchend(t) {\n              return s.filterEvent(t) && s.handleTouchEnd(t);\n            }\n          }), !t._ignoreWindowTop && window.top && this.addTopWindowHandlers(), b.detect().isSafariDesktop && this.addSelectPrevention();\n\n          for (var h in this.windowEvents) {\n            d.listen(window, h, this.windowEvents[h]);\n          }\n\n          if (this.addContainer(e), n) for (var u = 0; u < n.length; u++) {\n            this.addContainer(n[u]);\n          }\n          var c, p;\n        }\n\n        return t.prototype.addSelectPrevention = function () {\n          var t = this;\n          document.addEventListener(\"selectstart\", function (e) {\n            Object.keys(t.downPointers).length && e.preventDefault();\n          });\n        }, t.prototype.addTopWindowHandlers = function () {\n          try {\n            for (var e in this.topWindowEvents) {\n              d.listen(window.top, e, this.topWindowEvents[e]);\n            }\n          } catch (e) {\n            t._ignoreWindowTop = !0;\n          }\n        }, t.prototype.addContainer = function (t) {\n          this.containerList.push(t);\n          var e;\n\n          for (e in this.containerEvents) {\n            d.listen(t, e, this.containerEvents[e]);\n          }\n\n          for (e in this.windowEvents) {\n            d.listen(t, e, this.windowEvents[e]);\n          }\n        }, t.prototype.remove = function () {\n          for (var e in this.windowEvents) {\n            d.unlisten(window, e, this.windowEvents[e]);\n          }\n\n          if (!t._ignoreWindowTop && window.top) for (var e in this.topWindowEvents) {\n            d.unlisten(window.top, e, this.topWindowEvents[e]);\n          }\n\n          for (var i = 0; i < this.containerList.length; i++) {\n            var n = this.containerList[i];\n\n            for (var e in this.containerEvents) {\n              d.unlisten(n, e, this.containerEvents[e]);\n            }\n          }\n        }, t.prototype.listen = function (t, e) {\n          this.listeners[t] = e;\n        }, t.prototype.processConsumed = function (t, e, i) {\n          e && (d.stopPropagation(t), i && t.preventDefault());\n        }, t.prototype.capturePointer = function (t) {\n          var e = t.target;\n          e.setPointerCapture ? e.setPointerCapture(t.pointerId) : e.msSetPointerCapture ? e.msSetPointerCapture(t.pointerId) : this.captureMouse(t);\n        }, t.prototype.releasePointer = function (t) {\n          this.releaseMouse(t);\n        }, t.prototype.releaseMouse = function (t) {\n          document.releaseCapture && document.releaseCapture();\n        }, t.prototype.captureMouse = function (t) {\n          var e = t.target;\n          e.setCapture && e.setCapture(!0);\n        }, t.prototype.filterEvent = function (t) {\n          return t !== this.lastEvent && (this.lastEvent = t, !0);\n        }, t.prototype.handlePointerDown = function (t) {\n          var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);\n          t.currentTarget !== window && this.capturePointer(t), this.downHappened(e), this.processConsumed(t, e.consumed);\n        }, t.prototype.handlePointerMove = function (t) {\n          var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);\n          this.moveHappened(e), this.processConsumed(t, e.consumed, !0);\n        }, t.prototype.handlePointerUp = function (t) {\n          if (0 === t.buttons) {\n            var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);\n            this.releasePointer(t), this.upHappened(e), this.processConsumed(t, e.consumed);\n          }\n        }, t.prototype.handlePointerCancel = function (t) {\n          var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);\n          this.cancelHappened(e);\n        }, t.prototype.handleMouseDown = function (t) {\n          if (!(t.timeStamp < this.lastTouchEvent)) {\n            var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);\n            t.currentTarget !== window && this.captureMouse(t), this.downHappened(e), this.processConsumed(t, e.consumed);\n          }\n        }, t.prototype.handleCMenu = function (t) {\n          this.processConsumed(t, !0, !0);\n        }, t.prototype.handleMouseWheel = function (t) {\n          if (this.isTargetOkay(t.target) && (!this.settings.mouseWheelRequiresFocus || document.activeElement === this.container)) {\n            if (5 === t.mozInputSource || 0 === t.deltaX && 0 === t.deltaY) return void d.stopPropagation(t);\n\n            if (t.deltaMode !== t.DOM_DELTA_PAGE) {\n              var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0),\n                  i = t.deltaMode === t.DOM_DELTA_LINE ? -40 : -1;\n              e.wheely = t.deltaY * i, e.wheelx = t.deltaX * i, this.wheelHappened(e), this.processConsumed(t, e.consumed, !0);\n            }\n          }\n        }, t.prototype.handleMouseUp = function (t) {\n          if (t.shiftKey && t.ctrlKey) return this.ID_MOUSE = \"mouse\" + this.nextFakeMouseId, void (this.nextFakeMouseId += 1);\n          var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);\n          this.releaseMouse(t), this.upHappened(e), this.processConsumed(t, e.consumed);\n        }, t.prototype.handlePointerLeave = function (t) {\n          var e = t.pointerId.toString();\n          this.inPointers[e] && !this.downPointers[e] && this.pointerLeave(this.buildEvent(t, e, t.timeStamp, !1));\n        }, t.prototype.handleMouseLeave = function (t) {\n          t.timeStamp < this.lastTouchEvent || this.inPointers[this.ID_MOUSE] && !this.downPointers[this.ID_MOUSE] && this.pointerLeave(this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1));\n        }, t.prototype.handleMouseMove = function (t) {\n          if (!(t.timeStamp < this.lastTouchEvent)) {\n            var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);\n            this.moveHappened(e), this.processConsumed(t, e.consumed, !0);\n          }\n        }, t.prototype.handleTouchStart = function (t) {\n          this.lastTouchEvent = t.timeStamp + 2e3, this.removeLostTouches(t, t.touches, t.changedTouches);\n\n          for (var e, i = !1, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {\n            var s = n[r];\n            e = this.buildTouchEvent(t, s, !0, n.length), this.downHappened(e), i = i || e.consumed;\n          }\n\n          this.processConsumed(t, i);\n        }, t.prototype.handleTouchEnd = function (t) {\n          this.lastTouchEvent = t.timeStamp + 2e3;\n\n          for (var e = t.changedTouches || t.touches, i = !1, n = 0; n < e.length; n++) {\n            var r = e[n],\n                s = this.buildTouchEvent(t, r, !1, e.length),\n                a = this.buildTouchEvent(t, r, !1, e.length);\n            a.x = a.y = a.pageX = a.pageY = -1e9, this.upHappened(s), this.pointerLeave(a), i = i || s.consumed || a.consumed, this.removeLostTouches(t, t.touches);\n          }\n\n          this.processConsumed(t, i);\n        }, t.prototype.handleTouchCancel = function (t) {\n          this.lastTouchEvent = t.timeStamp + 2e3;\n\n          for (var e = t.changedTouches || t.touches, i = 0; i < e.length; i++) {\n            var n = e[i],\n                r = this.buildTouchEvent(t, n, !1, e.length);\n            this.cancelHappened(r);\n          }\n\n          this.removeLostTouches(t, t.touches);\n        }, t.prototype.handleTouchMove = function (t) {\n          this.lastTouchEvent = t.timeStamp + 2e3;\n          var e = !1;\n          this.removeLostTouches(t, t.touches);\n\n          for (var i, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {\n            var s = n[r];\n            i = this.buildTouchEvent(t, s, !0, n.length), this.moveHappened(i), e = e || i.consumed;\n          }\n\n          this.processConsumed(t, e, !0);\n        }, t.prototype.removeLostTouches = function (t, e, i) {\n          void 0 === i && (i = null);\n\n          for (var n = Object.create(null), r = 0; r < e.length; r++) {\n            var s = e[r];\n            n[s.identifier] = !0;\n          }\n\n          for (var a in this.downPointers) {\n            var o = this.downPointers[a];\n\n            if (this.downPointers.hasOwnProperty(a) && !n[a]) {\n              var l = this.rebuildEvent(t, o, !1);\n              this.upHappened(l);\n            }\n          }\n\n          if (null !== i) for (var r = 0; r < i.length; r++) {\n            var s = i[r],\n                o = this.downPointers[s.identifier];\n\n            if (o) {\n              var l = this.rebuildEvent(t, o, !1);\n              this.upHappened(l);\n            }\n          }\n        }, t.prototype.rebuildEvent = function (t, e, i) {\n          var n = new x(e.x, e.y, t.timeStamp, e.identifier);\n          return n.pageX = e.pageX, n.pageY = e.pageY, n.pressed = i, n.shiftKey = t.shiftKey, n.altKey = t.altKey, n.ctrlKey = t.ctrlKey, n;\n        }, t.prototype.extractCSSTransformScale = function (t, e, i) {\n          if (t.indexOf(\"scale\") > -1) {\n            var n = t.match(/scale(3d|)\\(([0-9\\.]+), ?([0-9\\.]+)/);\n            n && (e *= parseFloat(n[2]), i *= parseFloat(n[3]));\n          }\n\n          return [e, i];\n        }, t.prototype.buildTouchEvent = function (t, e, i, n) {\n          var r = d.convertPointFromPageToNode(this.container, e.pageX, e.pageY, e.clientX, e.clientY);\n\n          if (!window || !window.webkitConvertPointFromPageToNode) {\n            for (var s = this.container, a = 1, o = 1, l = 0; l < 5; l++) {\n              if (s.style.transform) {\n                var h = this.extractCSSTransformScale(s.style.transform, a, o);\n                a = h[0], o = h[1];\n              }\n\n              if (!s.parentElement) break;\n              s = s.parentElement;\n            }\n\n            r.x /= a, r.y /= o;\n          }\n\n          var u = r.x,\n              c = r.y;\n\n          if (this.transform) {\n            var p = xt.transformVec2d(u, c, this.transform);\n            u = p.x, c = p.y;\n          }\n\n          var f = new x(Math.round(u * this.scaleX), Math.round(c * this.scaleY), t.timeStamp, \"\" + e.identifier);\n          return f.target = e.target || t.target || t.srcElement, f.pageX = e.pageX, f.pageY = e.pageY, f.shiftKey = t.shiftKey, f.altKey = t.altKey, f.ctrlKey = t.ctrlKey, f.pressed = i, f.changedPointerCount = n, f.touch = !0, f;\n        }, t.prototype.buildEvent = function (t, e, i, n, r) {\n          void 0 === r && (r = 1);\n          var s,\n              a,\n              o = t.pageX,\n              l = t.pageY,\n              h = (!t.currentTarget || t.currentTarget === this.container) && t.target === this.container;\n          if (h && void 0 !== t.offsetX) s = t.offsetX, a = t.offsetY;else if (h && void 0 !== t.layerX) s = t.layerX, a = t.layerY;else {\n            var u = d.convertPointFromPageToNode(this.container, o, l, t.clientX, t.clientY);\n            s = u.x, a = u.y;\n          }\n\n          if (this.transform) {\n            var u = xt.transformVec2d(s, a, this.transform);\n            s = u.x, a = u.y;\n          }\n\n          var c = new x(Math.round(s * this.scaleX), Math.round(a * this.scaleY), i, \"\" + e);\n          return c.target = t.target || t.srcElement, c.pageX = o, c.pageY = l, c.shiftKey = t.shiftKey, c.altKey = t.altKey, c.ctrlKey = t.ctrlKey, c.pressed = n, c.changedPointerCount = r, c.touch = \"touch\" === t.pointerType || 2 === t.pointerType, t.which ? c.isRightMB = 3 === t.which : c.isRightMB = 2 === t.button, c;\n        }, t.prototype.downHappened = function (e) {\n          if (e.pressed = !0, this.fireEvent(t.EVENT_GLOBAL_DOWN, e), this.isTargetOkay(e.target) && !this.downPointers[e.identifier]) {\n            this.click_Hold();\n            var i = new C(e, this.settings);\n            this.downPointers[e.identifier] = i, i.touch = e.touch, this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_DOWN, e), this.startLongPress(e);\n          }\n        }, t.prototype.upHappened = function (e) {\n          var i = this.downPointers[e.identifier];\n\n          if (i) {\n            this.cancelLongPress(), i.moveTo(e), i.getPosAndSpeed(e), delete this.downPointers[e.identifier];\n            var n = e.vx,\n                r = e.vy,\n                s = Math.abs(n),\n                a = Math.abs(r);\n            s > 2 * a ? (e.swipeSpeed = s, n > 0 ? e.swipeLeft = !0 : e.swipeRight = !0) : a > 2 * s && (e.swipeSpeed = a, r < 0 ? e.swipeUp = !0 : e.swipeDown = !0), this.fireEvent(t.EVENT_UP, e), !i.noClick && e.isWithinDistance(i, this.settings.clickSensitivity, this.settings.doubleClickTimeout) && this.click_Next(e);\n          }\n        }, t.prototype.cancelHappened = function (e) {\n          this.downPointers[e.identifier] && (this.cancelLongPress(), delete this.downPointers[e.identifier], this.fireEvent(t.EVENT_CANCEL, e));\n        }, t.prototype.moveHappened = function (e) {\n          var i = this.downPointers[e.identifier];\n          e.pressed = void 0 !== i && null !== i, void 0 !== i && null !== i ? (this.cancelLongPress(e), i.scrolling = !0, i.moveTo(e), i.getPosAndSpeed(e), this.fireEvent(t.EVENT_DRAG, e), this.click_Cancel(e)) : this.click_OnMove(e) || (this.isTargetOkay(e.target) ? (this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_MOVE, e)) : this.pointerLeave(e));\n        }, t.prototype.wheelHappened = function (e) {\n          this.fireEvent(t.EVENT_WHEEL, e);\n        }, t.prototype.pointerLeave = function (e) {\n          this.inPointers.hasOwnProperty(e.identifier) && (this.click_Cancel(e) || this.fireEvent(t.EVENT_LEAVE, e), delete this.inPointers[e.identifier]);\n        }, t.prototype.click_Next = function (e) {\n          var i = this;\n          if (e.isRightMB) return void this.fireEvent(t.EVENT_RCLICK, e);\n          this.settings.scrollIntoView && this.container.scrollIntoView();\n          var n;\n\n          switch (this.clickCounter) {\n            case 1:\n              n = t.EVENT_CLICK;\n              break;\n\n            case 2:\n              n = t.EVENT_DBLCLICK;\n              break;\n\n            default:\n            case 3:\n              n = t.EVENT_TPLCLICK;\n          }\n\n          var r = null !== this.clickEvent && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= e.timeStamp && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity;\n          r && clearTimeout(this.doubleClickTimeout), (r || 1 === this.clickCounter) && (this.settings.noClickOnDoubleClick && (this.doubleClickTimeout = setTimeout(function () {\n            return i.fireClick(n);\n          }, this.settings.doubleClickTimeout)), this.settings.noClickOnDoubleClick || this.fireEvent(n, e), this.lastClickEvent = n), this.fireEvent(t.EVENT_INSTACLICK, e), this.clickEvent = e, this.clickCounter++, this.settings.noClickOnDoubleClick || setTimeout(function () {\n            i.clickEvent = i.lastClickEvent = null, i.clickCounter = 1;\n          }, this.settings.doubleClickTimeout);\n        }, t.prototype.click_Cancel = function (t) {\n          return !(!this.clickEvent || this.clickEvent.identifier !== t.identifier) && (this.clickEvent._leaving = !0, !0);\n        }, t.prototype.click_Hold = function () {\n          void 0 !== this.doubleClickTimeout && null !== this.doubleClickTimeout && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null);\n        }, t.prototype.click_OnMove = function (t) {\n          return !(!this.clickEvent || !this.settings.noClickOnDoubleClick) && (this.clickEvent.distance(t) < this.settings.doubleClickSensitivity || (this.fireEvent(this.lastClickEvent, this.clickEvent), this.clickEvent = this.lastClickEvent = null, this.clickCounter = 1, !1));\n        }, t.prototype.fireClick = function (e) {\n          this.clickEvent && (this.fireEvent(e, this.clickEvent), this.clickEvent._leaving && this.fireEvent(t.EVENT_LEAVE, this.clickEvent), this.clickEvent = null, this.clickCounter = 1);\n        }, t.prototype.startLongPress = function (e) {\n          var i = this;\n\n          if (!e.isRightMB) {\n            var n = function n() {\n              i.longPressTimeout = null, e.consumed = !1, i.downPointers[e.identifier].noClick = !0, i.fireEvent(t.EVENT_LONGPRESS, e), e.consumed || (e.touch && i.cancelHappened(e), i.fireEvent(t.EVENT_RCLICK, e));\n            };\n\n            this.cancelLongPress(), this.longPressTimeout = setTimeout(n, this.settings.longPressTimeout), this.longPressInitiator = e;\n          }\n        }, t.prototype.cancelLongPress = function (t) {\n          if (null !== this.longPressTimeout) {\n            if (t && t.isWithinDistance(this.longPressInitiator, this.settings.longPressSensitivity)) return;\n            clearTimeout(this.longPressTimeout), this.longPressTimeout = null;\n          }\n        }, t.prototype.fireEvent = function (t, e) {\n          this.listeners[t] && this.listeners[t].call(this, e);\n        }, t.prototype.isTargetOkay = function (t) {\n          return this.containerList.indexOf(t) !== -1 || d.isParentOf(this.container, t);\n        }, t;\n      }();\n\n      w._ignoreWindowTop = !1, w.EVENT_MOVE = \"move\", w.EVENT_DOWN = \"down\", w.EVENT_GLOBAL_DOWN = \"gdown\", w.EVENT_DRAG = \"drag\", w.EVENT_CANCEL = \"cancel\", w.EVENT_UP = \"up\", w.EVENT_LEAVE = \"leave\", w.EVENT_CLICK = \"click\", w.EVENT_RCLICK = \"rclick\", w.EVENT_DBLCLICK = \"dblclick\", w.EVENT_INSTACLICK = \"instaclick\", w.EVENT_LONGPRESS = \"longpress\", w.EVENT_TPLCLICK = \"tplclick\", w.EVENT_WHEEL = \"mwheel\", w.EVENT_KEY = \"key\", r.MouseEvents = w;\n\n      var L = function () {\n        function t() {\n          this.timeStamp = 0, this.dtime = 0, this.animating = !1, this.isExport = !1, this.context = null, this.scaleX = 1, this.scaleY = 1, this.labelRenderer = null, this.changes = {};\n        }\n\n        return t;\n      }();\n\n      r.UpdateEvent = L;\n\n      var T = function () {\n        function t() {\n          this.keyCode = null, this.capture = !1, this.consumed = !1, this.noDefault = !1, this.cursor = null, this.target = null;\n        }\n\n        return t;\n      }();\n\n      r.KeyEvent = T;\n\n      var k = function () {\n        function t() {\n          this.animationOrder = 0, this.updateOrder = 0, this.paintOrder = 0;\n        }\n\n        return t.prototype.remove = function () {}, t.prototype.onSceneChange = function (t) {}, t.prototype.getPanels = function (t) {\n          return [];\n        }, t.prototype.doAnimations = function (t) {}, t.prototype.paintScene = function (t) {}, t.prototype.previewMouseEvent = function (t, e) {\n          this[\"preview\" + t](e);\n        }, t.prototype.onMouseEvent = function (t, e) {\n          this[\"on\" + t](e);\n        }, t.prototype.onClick = function (t) {}, t.prototype.onInstantClick = function (t) {}, t.prototype.onLongPress = function (t) {}, t.prototype.onRightClick = function (t) {}, t.prototype.onDoubleClick = function (t) {}, t.prototype.onTripleClick = function (t) {}, t.prototype.onPointerDown = function (t) {}, t.prototype.onPointerUp = function (t) {}, t.prototype.onPointerDrag = function (t) {}, t.prototype.onPointerMove = function (t) {}, t.prototype.onPointerOut = function (t) {}, t.prototype.onPointerCancel = function (t) {}, t.prototype.onWheel = function (t) {}, t.prototype.onKeyDown = function (t) {}, t.prototype.onGlobalPointerDown = function (t) {}, t.prototype.previewDoubleClick = function (t) {}, t.prototype.previewTripleClick = function (t) {}, t.prototype.previewRightClick = function (t) {}, t.prototype.previewClick = function (t) {}, t.prototype.previewInstantClick = function (t) {}, t.prototype.previewLongPress = function (t) {}, t.prototype.previewWheel = function (t) {}, t.prototype.previewGlobalPointerDown = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t.prototype.previewPointerUp = function (t) {}, t.prototype.previewPointerDrag = function (t) {}, t.prototype.previewPointerMove = function (t) {}, t.prototype.previewPointerOut = function (t) {}, t.prototype.previewPointerCancel = function (t) {}, t.prototype.containsCoordinate = function (t, e) {\n          var i = this.getPanels(!1);\n          if (!i || !i.length) return !1;\n\n          for (var n = 0; n < i.length; n++) {\n            var r = i[n];\n            if (r.left < t && r.right > t && r.top < e && r.bottom > e) return !0;\n          }\n\n          return !1;\n        }, t;\n      }();\n\n      r.ChartElement = k;\n\n      var M = function () {\n        function t(t, e, i, n) {\n          this.side = \"top\", this.align = \"fill\", this.floating = !1, this.margin = 0, this.location = \"outside\", this.packingOrder = void 0, void 0 !== t && (this.side = t), void 0 !== e && (this.align = e), void 0 !== i && (this.margin = i), void 0 !== n && (this.packingOrder = n);\n        }\n\n        return t;\n      }();\n\n      r.SettingsChartPanel = M;\n\n      var A = function () {\n        function t() {\n          this.packingOrder = 0, this.location = \"outside\", this.side = \"top\", this.align = \"fill\", this.outsideEdge = !1, this.floating = !1, this.desiredWidth = 0, this.desiredHeight = 0, this.margin = 0, this.left = 0, this.top = 0, this.right = 0, this.bottom = 0, this.visible = !1, this.enableClipping = !1, this._tempData = null;\n        }\n\n        return t.prototype.pushClip = function (t) {\n          this.enableClipping && r.Graphics.pushClip(t, this.left, this.top, this.right - this.left, this.bottom - this.top);\n        }, t.prototype.popClip = function (t) {\n          this.enableClipping && r.Graphics.popClip(t);\n        }, t.prototype.computeSize = function (t, e, i, n) {\n          return {\n            width: this.desiredWidth,\n            height: this.desiredHeight\n          };\n        }, t.prototype.placePanel = function (t, e, i, n) {\n          this.bottom = n, this.right = i, this.top = e, this.left = t;\n        }, t;\n      }();\n\n      r.ChartPanel = A;\n\n      var I = function () {\n        function t(t) {\n          this.framesCount = 0, this.shell = t, this.measureFpsIters = 0, this.measureFpsT0 = 0, this.measureFpsIter = 0, this.measureFpsCallback = null;\n        }\n\n        return t.prototype.hasPendingRequests = function () {\n          return this.shell.chart.hasPendingRequests();\n        }, t.prototype.measureFps = function (t, e) {\n          var i = this;\n          this.measureFpsCallback = e, this.measureFpsIters = t;\n          var n = this.shell.settings.advanced.useAnimationFrame;\n\n          if (n) {\n            this.shell.chart.updateSettings({\n              advanced: {\n                useAnimationFrame: !1\n              }\n            });\n            var r = this.measureFpsCallback;\n\n            this.measureFpsCallback = function (t, e, n) {\n              i.shell.chart.updateSettings({\n                advanced: {\n                  useAnimationFrame: !0\n                }\n              }), r && r.call(window, t, e, n);\n            };\n          }\n\n          return this.measureFpsIter = 0, this.measureFpsT0 = new Date().getTime(), this.shell.events.notifySceneChanges({\n            requestPaint: !0\n          }), !0;\n        }, t.prototype.paintDone = function () {\n          if (this.framesCount += 1, this.measureFpsIters) {\n            this.measureFpsIter += 1;\n            var t = new Date().getTime() - this.measureFpsT0;\n\n            if (this.measureFpsIter >= this.measureFpsIters && t > 4e3 || t > 1e4 && this.measureFpsIter >= 5) {\n              var e = 1e3 * this.measureFpsIter / Math.max(1e-4, t);\n              this.measureFpsCallback(e, this.measureFpsIter, t), this.measureFpsCallback = null, this.measureFpsIters = 0;\n            } else this.shell.events.notifySceneChanges({\n              requestPaint: !0\n            });\n          }\n        }, t;\n      }();\n\n      r.Profiler = I;\n\n      var P = function () {\n        function t() {\n          this.subchart = null, this.element = null;\n        }\n\n        return t;\n      }(),\n          D = function () {\n        function t(t, e) {\n          this.sceneChanges = {}, this.forceFloating = !1, this._paintSuspended = 0, this.pointerState = {}, this.animationOrder = [], this.updateOrder = [], this.paintOrder = [], this.subcharts = [], this._lastPanelCount = [0, 0, 0], this.chartBounds = new mt(0, 0, 1, 1), this.chartOuterBounds = new mt(0, 0, 1, 1), this.chartBoundsIsOuter = !0, this.chart = t, this.shell = e, this.scene = t.scene;\n        }\n\n        return t.panelSortCallback = function (t, e) {\n          return t.packingOrder - e.packingOrder;\n        }, t.prototype.addElement = function (t) {\n          if (!t) throw new Error(\"`element` must be defined.\");\n          return this.paintOrder.push(t), this.updateOrder.push(t), this.animationOrder.push(t), this.refreshElementOrder(), t;\n        }, t.prototype.refreshElementOrder = function () {\n          this.animationOrder.sort(function (t, e) {\n            return t.animationOrder - e.animationOrder;\n          }), this.paintOrder.sort(function (t, e) {\n            return t.paintOrder - e.paintOrder;\n          }), this.updateOrder.sort(function (t, e) {\n            return t.updateOrder - e.updateOrder;\n          });\n        }, t.prototype.removeElement = function (t) {\n          d.removeFromArray(this.paintOrder, t), d.removeFromArray(this.animationOrder, t), d.removeFromArray(this.updateOrder, t);\n        }, t.prototype.addSubchart = function (t) {\n          this.subcharts.push(t);\n        }, t.prototype.removeSubchart = function (t) {\n          d.removeFromArray(this.subcharts, t);\n\n          for (var e in this.pointerState) {\n            var i = this.pointerState[e];\n            i.subchart === t && (i.subchart = null);\n          }\n        }, t.prototype.suspendPaint = function () {\n          this._paintSuspended++;\n        }, t.prototype.resumePaint = function () {\n          this._paintSuspended--, this._paintSuspended <= 0 && (this._paintSuspended = 0, this.requestPaint());\n        }, t.prototype.notifySceneChanges = function (t, e) {\n          if (d.hasProperties(t)) {\n            var i = t.settingsChanges;\n            void 0 !== i && i instanceof r.Settings ? (this.sceneChanges.settingsChanges = d.extendCopy(this.sceneChanges.settingsChanges || {}, i, function (t, e) {\n              return \"_\" === t[0] || e;\n            }), delete t.settingsChanges, d.extendDeep(this.sceneChanges, t), t.settingsChanges = i) : d.extendDeep(this.sceneChanges, t), this.requestPaint(e);\n          }\n        }, t.prototype.requestPaint = function (t) {\n          this._paintSuspended <= 0 && this.shell.requestPaint(t);\n        }, t.prototype.paintNow = function (t) {\n          void 0 === t && (t = !1), this.shell.paintNow(t = !1);\n        }, t.prototype.clearSceneChanges = function (t) {\n          for (var e in t) {\n            delete this.sceneChanges[e];\n          }\n        }, t.prototype.onMouseEvent = function (t, e) {\n          var i = e.name;\n          t.changes = {}, t.capture = !1;\n          var n,\n              r,\n              s = null,\n              a = null,\n              o = void 0,\n              l = t.identifier,\n              h = this.pointerState[l];\n          h || (h = new P(), h.identifier = l, this.pointerState[l] = h);\n\n          for (var u = 0; u < this.updateOrder.length; u++) {\n            r = this.updateOrder[u], r.previewMouseEvent(i, t);\n          }\n\n          if (h.subchart) {\n            var c = h.subchart.events;\n            c.onMouseEvent(t, e), t.consumed || t.hovered || t.capture ? (a = h.subchart, t.capture = !0, o = t.cursor) : c.onMouseEvent(t, {\n              ev: w.EVENT_LEAVE,\n              name: \"PointerOut\"\n            });\n          }\n\n          if (n = r = h.element, r && (r.onMouseEvent(i, t), (t.consumed || t.capture || e.captures && e.needsCapture) && !e.releasesCapture && (s = r, t.capture = !0, o = t.cursor)), !t.capture && !e.needsCapture) for (var d = this.subcharts.length - 1; d >= 0; d -= 1) {\n            var p = this.subcharts[d],\n                c = p.events;\n\n            if (c.chartOuterBounds.containsPoint(t.x, t.y)) {\n              if (c.onMouseEvent(t, e), t.consumed || t.hovered || t.capture) {\n                a = p, t.capture = !0;\n                break;\n              }\n\n              c.onMouseEvent(t, {\n                ev: w.EVENT_LEAVE,\n                name: \"PointerOut\"\n              });\n            }\n          }\n          if (!t.capture && !e.needsCapture) for (var u = 0; u < this.updateOrder.length; u++) {\n            if (r = this.updateOrder[u], r !== n && (r.onMouseEvent(i, t), t.consumed || t.capture)) {\n              o = t.cursor, s = r, t.capture = !0;\n              break;\n            }\n          }\n          void 0 !== o && (t.cursor = o), (e.releasesCapture || e.captures) && (h.element = e.captures ? s : null, h.subchart = e.captures ? a : null), this.notifySceneChanges(t.changes);\n        }, t.prototype.setNewSize = function (t, e, i) {\n          if (i || !this.chartBounds.equals(t) || e !== this.chartBoundsIsOuter) {\n            this.chartBounds = t.clone();\n            var n = this.chart.settings.horizontal;\n\n            if (n) {\n              var r = this.chartBounds.x0;\n              this.chartBounds.x0 = this.chartBounds.y1, this.chartBounds.y1 = r, r = this.chartBounds.y0, this.chartBounds.y0 = this.chartBounds.x1, this.chartBounds.x1 = r;\n            }\n\n            this.chartBoundsIsOuter = e, this.notifySceneChanges({\n              bounds: !0\n            });\n          }\n        }, t.prototype.updateLayout = function (e) {\n          for (var i = this.scene, n = new Array(this._lastPanelCount[0]), r = new Array(this._lastPanelCount[1]), s = new Array(this._lastPanelCount[2]), a = 0, o = 0, l = 0, h = 0; h < this.paintOrder.length; h++) {\n            for (var u = this.paintOrder[h], c = u.getPanels(e.isExport), p = 0; p < c.length; p++) {\n              var f = c[p],\n                  g = f.location;\n              \"external\" === g ? s[l++] = f : \"outside\" === g ? r[o++] = f : \"inside\" === g && (n[a++] = f);\n            }\n          }\n\n          this._lastPanelCount = [a, o, l], n.length = a, r.length = o, s.length = l, d.sort(n, t.panelSortCallback), d.sort(r, t.panelSortCallback), d.sort(s, t.panelSortCallback);\n          var v, m, y;\n\n          if (this.chartBoundsIsOuter) {\n            v = this.chartBounds.clone();\n\n            for (var S = 0; S < l; S++) {\n              this._placePanel(s[S], v, !0, e);\n            }\n\n            m = this.chartBounds.clone(), y = this.chartBounds.clone();\n\n            for (var S = 0; S < o; S++) {\n              this._placePanel(r[S], y, !1, e);\n            }\n          } else {\n            y = this.chartBounds.clone(), m = this.chartBounds.clone();\n\n            for (var S = 0; S < o; S++) {\n              this._placePanel(r[S], m, !0, e);\n            }\n\n            v = m.clone();\n\n            for (var S = 0; S < l; S++) {\n              this._placePanel(s[S], v, !0, e);\n            }\n          }\n\n          this.chartOuterBounds = m, i.chartLeft = m.x0, i.chartTop = m.y0, i.chartHeight = m.h(), i.chartWidth = m.w();\n\n          for (var S = 0; S < l; S++) {\n            this._placePanelFinal(s[S], y);\n          }\n\n          for (var S = 0; S < o; S++) {\n            var f = r[S];\n\n            this._placePanelFinal(f, f.outsideEdge ? m : y);\n          }\n\n          var b = this.chart.settings.horizontal;\n          i.x0 === y.x0 && i.y0 === y.y0 && i.width === y.w() && i.height === y.h() || this.chart.events.notifySceneChanges({\n            bounds: !0\n          }), i.x0 = y.x0, i.y0 = y.y0, i.width = y.w(), i.height = y.h(), i.leftMargin = y.x0 - m.x0, i.rightMargin = m.x1 - y.x1, i.topMargin = y.y0 - m.y0, i.bottomMargin = m.y1 - y.y1, b && i.prepareRotationMatrix(!0);\n\n          for (var S = 0; S < a; S++) {\n            var f = n[S];\n            this._placePanel(f, y, !1, e), this._placePanelFinal(f, y);\n          }\n\n          return v;\n        }, t.prototype._placePanel = function (t, e, i, n) {\n          var r = e.x0,\n              s = e.y0,\n              a = e.x1,\n              o = e.y1,\n              l = t.margin || 0,\n              h = t.computeSize(e.x1 - e.x0, e.y1 - e.y0, n.context, n.labelRenderer),\n              u = h.width || 0,\n              c = h.height || 0;\n          u += 2 * l, c += 2 * l, i ? \"top\" === t.side ? (o = s, s = o - c, t.floating || this.forceFloating || (e.y0 = s)) : \"bottom\" === t.side ? (s = o, o = s + c, t.floating || this.forceFloating || (e.y1 = o)) : \"left\" === t.side ? (a = r, r = a - u, t.floating || this.forceFloating || (e.x0 = r)) : \"right\" === t.side && (r = a, a = r + u, t.floating || this.forceFloating || (e.x1 = a)) : \"top\" === t.side ? (o = Math.min(o, s + c), t.floating || this.forceFloating || (e.y0 = o)) : \"bottom\" === t.side ? (s = Math.max(s, o - c), t.floating || this.forceFloating || (e.y1 = s)) : \"left\" === t.side ? (a = Math.min(a, r + u), t.floating || this.forceFloating || (e.x0 = a)) : \"right\" === t.side && (r = Math.max(r, a - u), t.floating || this.forceFloating || (e.x1 = r)), t._tempData = {\n            left: r,\n            right: a,\n            top: s,\n            bottom: o,\n            desiredWidth: u,\n            desiredHeight: c\n          };\n        }, t.prototype._placePanelFinal = function (t, e) {\n          var i = t._tempData.left,\n              n = t._tempData.right,\n              r = t._tempData.top,\n              s = t._tempData.bottom,\n              a = t._tempData.desiredWidth,\n              o = t._tempData.desiredHeight;\n          if (\"outside\" === t.location && (\"top\" === t.side || \"bottom\" === t.side ? (i = Math.max(i, e.x0), n = Math.min(n, e.x1)) : (r = Math.max(r, e.y0), s = Math.min(s, e.y1))), \"left\" === t.align) n = Math.min(n, i + a);else if (\"right\" === t.align) i = Math.max(i, n - a);else if (\"top\" === t.align) s = Math.min(s, r + o);else if (\"bottom\" === t.align) r = Math.max(r, s - o);else if (\"center\" === t.align) {\n            var l = Math.max(0, n - i - a) / 2,\n                h = Math.max(0, s - r - o) / 2;\n            i += l, n -= l, r += h, s -= h;\n          }\n          var u = t.margin;\n          t.placePanel(i + u, r + u, n - u, s - u);\n        }, t.prototype.animateFrame = function (t) {\n          this.chart.settings.callbacks.renderStart && this.chart.settings.callbacks.renderStart(), this.shell.prepareContext(t), t.changes = this.sceneChanges, this.sceneChanges = {};\n\n          for (var e = 0; e < this.updateOrder.length; e++) {\n            var i = this.updateOrder[e];\n            i.onSceneChange(t);\n          }\n\n          t.changes.bounds && this.updateLayout(t);\n\n          for (var n = 0; n < this.animationOrder.length; n++) {\n            var r = this.animationOrder[n];\n            r.doAnimations(t);\n          }\n\n          for (var s = 0; s < this.paintOrder.length; s++) {\n            var a = this.paintOrder[s];\n            a.paintScene(t);\n          }\n\n          t.changes.position && this.chart.notifyPositionChange(this.chart.createEventArguments(null, \"api\")), t.changes = null;\n          var o = [];\n\n          for (var l in this.pointerState) {\n            var h = this.pointerState[l];\n            h.subchart && o.push(h.subchart);\n          }\n\n          for (var u = 0; u < this.subcharts.length; u += 1) {\n            var c = this.subcharts[u];\n\n            if (!(o.indexOf(c) > -1)) {\n              var d = c.events;\n              (d.sceneChanges.bounds || d.chartOuterBounds.overlaps(this.chartOuterBounds)) && d.animateFrame(t);\n            }\n          }\n\n          for (var u = 0; u < o.length; u += 1) {\n            var c = o[u];\n            c.events.animateFrame(t);\n          }\n\n          this.shell.finalizeContext(t), this.chart.settings.callbacks.renderFinish && this.chart.settings.callbacks.renderFinish();\n        }, t.prototype.doPaint = function (t) {\n          for (var e = 0; e < this.paintOrder.length; e++) {\n            var i = this.paintOrder[e];\n            i.paintScene(t);\n          }\n\n          for (var n = 0; n < this.subcharts.length; n += 1) {\n            var r = this.subcharts[n],\n                s = r.events;\n            s.chartOuterBounds.overlaps(this.chartOuterBounds) && s.doPaint(t);\n          }\n        }, t;\n      }();\n\n      r.ChartEvents = D;\n\n      var N = function () {\n        function t() {\n          this.enabled = !1, this.enabledOnExport = !1, this.url = \"http://zoomcharts.com\", this.urlTarget = \"_blank\", this.image = \"builtin://logo-supported-by\", this.imageScaling = .5, this.location = \"outside\", this.imageExport = null;\n        }\n\n        return t;\n      }();\n\n      r.SettingsCredits = N;\n\n      var F = function (t) {\n        function e(e, i) {\n          var n = t.call(this) || this;\n          n.animationOrder = 2e3, n.paintOrder = 60, n.updateOrder = 400, n.settings = i, n.chart = e, n.scene = e.scene, (i.enabledOnExport || i.enabled) && (n.chart.assetsLoader.getAssetImage(n.settings.image, function (t) {\n            return n.imageLoaded(t);\n          }), n.settings.imageExport && n.settings.image !== n.settings.imageExport && n.chart.assetsLoader.getAssetImage(n.settings.imageExport, function (t) {\n            return n.imageLoaded(t);\n          }));\n          var r = n.panel = new A();\n          return r.packingOrder = 0, r.side = \"bottom\", r.align = \"right\", r.visible = !1, r.margin = 3, n;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          var e = t.changes;\n          e.settings && e.settingsChanges.credits && (e.bounds = !0);\n        }, e.prototype.getPanels = function (t) {\n          var e = this,\n              i = this.settings,\n              n = t ? i.enabledOnExport : i.enabled,\n              r = this.panel;\n\n          if (n) {\n            r.location = \"outside\", r.outsideEdge = !0, \"outside\" === i.location ? (r.floating = !1, t && !i.enabled && (r.location = \"external\")) : r.floating = !0;\n            var s = this.chart.assetsLoader.getAssetImage(i.image, function (t) {\n              return e.imageLoaded(t);\n            });\n            if (s) return r.desiredWidth = s.width * i.imageScaling, r.desiredHeight = s.height * i.imageScaling, r.visible = !0, [r];\n          }\n\n          return r.visible = !1, [];\n        }, e.prototype.paintScene = function (t) {\n          var e = this,\n              i = this.panel;\n\n          if (i.visible) {\n            var n = this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {\n              return e.imageLoaded(t);\n            }),\n                r = this.settings.imageExport ? this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (t) {\n              return e.imageLoaded(t);\n            }) : n;\n            t.isExport && (n = r), n ? t.context.drawImage(n, 0, 0, n.width, n.height, i.left, i.top, i.right - i.left, i.bottom - i.top) : t.animating = !0;\n          }\n        }, e.prototype.onPointerMove = function (t) {\n          var e = t.x,\n              i = t.y,\n              n = this.panel;\n          n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && this.settings.url && (t.cursor = \"pointer\");\n        }, e.prototype.onClick = function (t) {\n          var e = t.x,\n              i = t.y,\n              n = this.panel,\n              r = this.settings;\n          n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && r.url && (this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented || d.openUrl(r.url, r.urlTarget), t.consumed = !0);\n        }, e.prototype.imageLoaded = function (t) {\n          this.chart.updateSize(!0), this.chart.events.notifySceneChanges({\n            settings: !0,\n            settingsChanges: {\n              credits: !0\n            }\n          });\n        }, e.prototype.buildEventArgs = function (t) {\n          var e = this.chart.createEventArguments(t, \"user\");\n          return e.clickCredits = !0, e.credits = {\n            url: this.settings.url,\n            urlTarget: this.settings.urlTarget\n          }, e;\n        }, e;\n      }(k);\n\n      r.Credits = F;\n\n      var O = function () {\n        function t() {}\n\n        return t.isLight = function (t) {\n          return null == t ? null : .299 * t.R + .587 * t.G + .114 * t.B > 128;\n        }, t.format = function (t) {\n          return null == t ? null : \"rgba(\" + Math.floor(t.R) + \",\" + Math.floor(t.G) + \",\" + Math.floor(t.B) + \",\" + t.A.toFixed(3) + \")\";\n        }, t.areEqual = function (t, e) {\n          return null == t ? null == e : null != e && t.R === e.R && t.G === e.G && t.B === e.B && t.A === e.A;\n        }, t.parse = function (t) {\n          var e = E.parseCSSColor(t);\n          return null == e && t && d.warn(\"Color value '\" + t + \"' could not be parsed.\", null, !0), e;\n        }, t.normalize = function (t) {\n          return this.format(E.parseCSSColor(t));\n        }, t.derive = function (t, e, i) {\n          var n = \"string\" == typeof t,\n              r = n ? this.parse(t) : t,\n              s = 255 * (e - 1),\n              a = {\n            R: Math.round(Math.min(255, Math.max(0, r.R + s))),\n            G: Math.round(Math.min(255, Math.max(0, r.G + s))),\n            B: Math.round(Math.min(255, Math.max(0, r.B + s))),\n            A: Math.min(1, r.A * i)\n          };\n          return n ? this.format(a) : a;\n        }, t.blend = function (t, e, i, n) {\n          void 0 === n && (n = !0);\n          var r,\n              s = \"string\" == typeof t,\n              a = s ? this.parse(t) : t,\n              o = s ? this.parse(e) : e;\n\n          if (n) {\n            var l = 1 - i;\n            r = {\n              R: Math.round(o.R * i + a.R * l),\n              G: Math.round(o.G * i + a.G * l),\n              B: Math.round(o.B * i + a.B * l),\n              A: o.A * i + a.A * l\n            };\n          } else r = this._blendSlow(a, o, i);\n\n          return s ? this.format(r) : r;\n        }, t._blendSlow = function (t, e, i) {\n          var n = this._rgb2lab(t),\n              r = this._rgb2lab(e),\n              s = 1 - i,\n              a = Math.round(r.L * i + n.L * s),\n              o = Math.round(r.A * i + n.A * s),\n              l = Math.round(r.B * i + n.B * s),\n              h = this._lab2rgb(a, o, l);\n\n          return h.R = Math.max(0, Math.min(255, h.R)), h.G = Math.max(0, Math.min(255, h.G)), h.B = Math.max(0, Math.min(255, h.B)), h.A = e.A * i + t.A * s, h;\n        }, t.colorTone = function (t, e, i) {\n          var n = this.parse(t),\n              r = this.derive(n, e, i);\n          return {\n            color: this.format(r),\n            opacity: n.A\n          };\n        }, t.copyHue = function (t, e) {\n          var i = \"string\" == typeof t,\n              n = i ? this.parse(t) : t,\n              r = i ? this.parse(e) : e,\n              s = (n.R + n.G + n.B) / 765,\n              a = (r.R + r.G + r.B) / 765,\n              o = {\n            R: Math.round(n.R / s * a),\n            G: Math.round(n.G / s * a),\n            B: Math.round(n.B / s * a),\n            A: r.A\n          };\n          return i ? this.format(o) : o;\n        }, t.inverse = function (t) {\n          var e = \"string\" == typeof t,\n              i = e ? this.parse(t) : t,\n              n = {\n            R: 255 - i.R,\n            G: 255 - i.G,\n            B: 255 - i.B,\n            A: i.A\n          };\n          return e ? this.format(n) : n;\n        }, t._rgb2xyz = function (t) {\n          var e = t.R / 255,\n              i = t.G / 255,\n              n = t.B / 255;\n          return e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92, i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92, n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92, {\n            X: .4124 * e + .3576 * i + .1805 * n,\n            Y: .2126 * e + .7152 * i + .0722 * n,\n            Z: .0193 * e + .1192 * i + .9505 * n\n          };\n        }, t._rgb2lab = function (t) {\n          if (t._lab) return t._lab;\n\n          var e = this._rgb2xyz(t),\n              i = e.X / .95047,\n              n = e.Y,\n              r = e.Z / 1.08883;\n\n          return i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, t._lab = {\n            L: 116 * n - 16,\n            A: 500 * (i - n),\n            B: 200 * (n - r)\n          };\n        }, t._xyz2rgb = function (t, e, i) {\n          var n = 3.2406 * t + e * -1.5372 + i * -.4986,\n              r = t * -.9689 + 1.8758 * e + .0415 * i,\n              s = .0557 * t + e * -.204 + 1.057 * i;\n          return n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, s = s > .0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : 12.92 * s, {\n            R: Math.round(255 * n),\n            G: Math.round(255 * r),\n            B: Math.round(255 * s),\n            A: 1\n          };\n        }, t._lab2rgb = function (t, e, i) {\n          var n = (t + 16) / 116,\n              r = e / 500 + n,\n              s = n - i / 200;\n          n = n > this._lab2rgbConst ? Math.pow(n, 3) : (n - 16 / 116) / 7.787, r = r > this._lab2rgbConst ? Math.pow(r, 3) : (r - 16 / 116) / 7.787, s = s > this._lab2rgbConst ? Math.pow(s, 3) : (s - 16 / 116) / 7.787;\n\n          var a = this._xyz2rgb(.95047 * r, n, 1.08883 * s);\n\n          return a._lab = {\n            L: t,\n            A: e,\n            B: i\n          }, a;\n        }, t;\n      }();\n\n      O._lab2rgbConst = Math.pow(.008856, 1 / 3), r.Colors = O;\n\n      var E = function () {\n        function t() {}\n\n        return t.clamp_css_byte = function (t) {\n          return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t;\n        }, t.clamp_css_float = function (t) {\n          return t < 0 ? 0 : t > 1 ? 1 : t;\n        }, t.parse_css_int = function (e) {\n          return \"%\" === e[e.length - 1] ? t.clamp_css_byte(parseFloat(e) / 100 * 255) : t.clamp_css_byte(parseInt(e, 10));\n        }, t.parse_css_float = function (e) {\n          return \"%\" === e[e.length - 1] ? t.clamp_css_float(parseFloat(e) / 100) : t.clamp_css_float(parseFloat(e));\n        }, t.css_hue_to_rgb = function (t, e, i) {\n          return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;\n        }, t.parseCSSColor = function (e) {\n          if (null == e) return {\n            R: 0,\n            G: 0,\n            B: 0,\n            A: 0\n          };\n          var i = e.replace(RegExp(\" \", \"g\"), \"\").toLowerCase();\n\n          if (i in t.kCSSColorTable) {\n            var n = t.kCSSColorTable[i];\n            return {\n              R: n[0],\n              G: n[1],\n              B: n[2],\n              A: n[3]\n            };\n          }\n\n          if (\"#\" === i[0]) {\n            if (4 === i.length) {\n              var r = parseInt(i.substr(1), 16);\n              return r >= 0 && r <= 4095 ? {\n                R: (3840 & r) >> 4 | (3840 & r) >> 8,\n                G: 240 & r | (240 & r) >> 4,\n                B: 15 & r | (15 & r) << 4,\n                A: 1\n              } : null;\n            }\n\n            if (7 === i.length) {\n              var r = parseInt(i.substr(1), 16);\n              return r >= 0 && r <= 16777215 ? {\n                R: (16711680 & r) >> 16,\n                G: (65280 & r) >> 8,\n                B: 255 & r,\n                A: 1\n              } : null;\n            }\n\n            return null;\n          }\n\n          var s = i.indexOf(\"(\"),\n              a = i.indexOf(\")\");\n\n          if (s !== -1 && a + 1 === i.length) {\n            var o = i.substr(0, s),\n                l = i.substr(s + 1, a - (s + 1)).split(\",\"),\n                h = 1;\n\n            if (\"rgba\" === o) {\n              if (4 !== l.length) return null;\n              h = t.parse_css_float(l.pop());\n            }\n\n            if (\"rgba\" === o || \"rgb\" === o) return 3 !== l.length ? null : {\n              R: t.parse_css_int(l[0]),\n              G: t.parse_css_int(l[1]),\n              B: t.parse_css_int(l[2]),\n              A: h\n            };\n\n            if (\"hsla\" === o) {\n              if (4 !== l.length) return null;\n              h = t.parse_css_float(l.pop());\n            }\n\n            if (\"hsla\" === o || \"hsl\" === o) {\n              if (3 !== l.length) return null;\n              var u = (parseFloat(l[0]) % 360 + 360) % 360 / 360,\n                  c = t.parse_css_float(l[1]),\n                  d = t.parse_css_float(l[2]),\n                  p = d <= .5 ? d * (c + 1) : d + c - d * c,\n                  f = 2 * d - p;\n              return {\n                R: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u + 1 / 3)),\n                G: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u)),\n                B: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u - 1 / 3)),\n                A: h\n              };\n            }\n          }\n\n          return null;\n        }, t;\n      }();\n\n      E.kCSSColorTable = {\n        transparent: [0, 0, 0, 0],\n        aliceblue: [240, 248, 255, 1],\n        antiquewhite: [250, 235, 215, 1],\n        aqua: [0, 255, 255, 1],\n        aquamarine: [127, 255, 212, 1],\n        azure: [240, 255, 255, 1],\n        beige: [245, 245, 220, 1],\n        bisque: [255, 228, 196, 1],\n        black: [0, 0, 0, 1],\n        blanchedalmond: [255, 235, 205, 1],\n        blue: [0, 0, 255, 1],\n        blueviolet: [138, 43, 226, 1],\n        brown: [165, 42, 42, 1],\n        burlywood: [222, 184, 135, 1],\n        cadetblue: [95, 158, 160, 1],\n        chartreuse: [127, 255, 0, 1],\n        chocolate: [210, 105, 30, 1],\n        coral: [255, 127, 80, 1],\n        cornflowerblue: [100, 149, 237, 1],\n        cornsilk: [255, 248, 220, 1],\n        crimson: [220, 20, 60, 1],\n        cyan: [0, 255, 255, 1],\n        darkblue: [0, 0, 139, 1],\n        darkcyan: [0, 139, 139, 1],\n        darkgoldenrod: [184, 134, 11, 1],\n        darkgray: [169, 169, 169, 1],\n        darkgreen: [0, 100, 0, 1],\n        darkgrey: [169, 169, 169, 1],\n        darkkhaki: [189, 183, 107, 1],\n        darkmagenta: [139, 0, 139, 1],\n        darkolivegreen: [85, 107, 47, 1],\n        darkorange: [255, 140, 0, 1],\n        darkorchid: [153, 50, 204, 1],\n        darkred: [139, 0, 0, 1],\n        darksalmon: [233, 150, 122, 1],\n        darkseagreen: [143, 188, 143, 1],\n        darkslateblue: [72, 61, 139, 1],\n        darkslategray: [47, 79, 79, 1],\n        darkslategrey: [47, 79, 79, 1],\n        darkturquoise: [0, 206, 209, 1],\n        darkviolet: [148, 0, 211, 1],\n        deeppink: [255, 20, 147, 1],\n        deepskyblue: [0, 191, 255, 1],\n        dimgray: [105, 105, 105, 1],\n        dimgrey: [105, 105, 105, 1],\n        dodgerblue: [30, 144, 255, 1],\n        firebrick: [178, 34, 34, 1],\n        floralwhite: [255, 250, 240, 1],\n        forestgreen: [34, 139, 34, 1],\n        fuchsia: [255, 0, 255, 1],\n        gainsboro: [220, 220, 220, 1],\n        ghostwhite: [248, 248, 255, 1],\n        gold: [255, 215, 0, 1],\n        goldenrod: [218, 165, 32, 1],\n        gray: [128, 128, 128, 1],\n        green: [0, 128, 0, 1],\n        greenyellow: [173, 255, 47, 1],\n        grey: [128, 128, 128, 1],\n        honeydew: [240, 255, 240, 1],\n        hotpink: [255, 105, 180, 1],\n        indianred: [205, 92, 92, 1],\n        indigo: [75, 0, 130, 1],\n        ivory: [255, 255, 240, 1],\n        khaki: [240, 230, 140, 1],\n        lavender: [230, 230, 250, 1],\n        lavenderblush: [255, 240, 245, 1],\n        lawngreen: [124, 252, 0, 1],\n        lemonchiffon: [255, 250, 205, 1],\n        lightblue: [173, 216, 230, 1],\n        lightcoral: [240, 128, 128, 1],\n        lightcyan: [224, 255, 255, 1],\n        lightgoldenrodyellow: [250, 250, 210, 1],\n        lightgray: [211, 211, 211, 1],\n        lightgreen: [144, 238, 144, 1],\n        lightgrey: [211, 211, 211, 1],\n        lightpink: [255, 182, 193, 1],\n        lightsalmon: [255, 160, 122, 1],\n        lightseagreen: [32, 178, 170, 1],\n        lightskyblue: [135, 206, 250, 1],\n        lightslategray: [119, 136, 153, 1],\n        lightslategrey: [119, 136, 153, 1],\n        lightsteelblue: [176, 196, 222, 1],\n        lightyellow: [255, 255, 224, 1],\n        lime: [0, 255, 0, 1],\n        limegreen: [50, 205, 50, 1],\n        linen: [250, 240, 230, 1],\n        magenta: [255, 0, 255, 1],\n        maroon: [128, 0, 0, 1],\n        mediumaquamarine: [102, 205, 170, 1],\n        mediumblue: [0, 0, 205, 1],\n        mediumorchid: [186, 85, 211, 1],\n        mediumpurple: [147, 112, 219, 1],\n        mediumseagreen: [60, 179, 113, 1],\n        mediumslateblue: [123, 104, 238, 1],\n        mediumspringgreen: [0, 250, 154, 1],\n        mediumturquoise: [72, 209, 204, 1],\n        mediumvioletred: [199, 21, 133, 1],\n        midnightblue: [25, 25, 112, 1],\n        mintcream: [245, 255, 250, 1],\n        mistyrose: [255, 228, 225, 1],\n        moccasin: [255, 228, 181, 1],\n        navajowhite: [255, 222, 173, 1],\n        navy: [0, 0, 128, 1],\n        oldlace: [253, 245, 230, 1],\n        olive: [128, 128, 0, 1],\n        olivedrab: [107, 142, 35, 1],\n        orange: [255, 165, 0, 1],\n        orangered: [255, 69, 0, 1],\n        orchid: [218, 112, 214, 1],\n        palegoldenrod: [238, 232, 170, 1],\n        palegreen: [152, 251, 152, 1],\n        paleturquoise: [175, 238, 238, 1],\n        palevioletred: [219, 112, 147, 1],\n        papayawhip: [255, 239, 213, 1],\n        peachpuff: [255, 218, 185, 1],\n        peru: [205, 133, 63, 1],\n        pink: [255, 192, 203, 1],\n        plum: [221, 160, 221, 1],\n        powderblue: [176, 224, 230, 1],\n        purple: [128, 0, 128, 1],\n        red: [255, 0, 0, 1],\n        rosybrown: [188, 143, 143, 1],\n        royalblue: [65, 105, 225, 1],\n        saddlebrown: [139, 69, 19, 1],\n        salmon: [250, 128, 114, 1],\n        sandybrown: [244, 164, 96, 1],\n        seagreen: [46, 139, 87, 1],\n        seashell: [255, 245, 238, 1],\n        sienna: [160, 82, 45, 1],\n        silver: [192, 192, 192, 1],\n        skyblue: [135, 206, 235, 1],\n        slateblue: [106, 90, 205, 1],\n        slategray: [112, 128, 144, 1],\n        slategrey: [112, 128, 144, 1],\n        snow: [255, 250, 250, 1],\n        springgreen: [0, 255, 127, 1],\n        steelblue: [70, 130, 180, 1],\n        tan: [210, 180, 140, 1],\n        teal: [0, 128, 128, 1],\n        thistle: [216, 191, 216, 1],\n        tomato: [255, 99, 71, 1],\n        turquoise: [64, 224, 208, 1],\n        violet: [238, 130, 238, 1],\n        wheat: [245, 222, 179, 1],\n        white: [255, 255, 255, 1],\n        whitesmoke: [245, 245, 245, 1],\n        yellow: [255, 255, 0, 1],\n        yellowgreen: [154, 205, 50, 1]\n      };\n\n      var R = function () {\n        function t(t, e, i) {\n          this.isFilling = i, this.lineDash = e, this.g = t, this.beginPath();\n        }\n\n        return t.prototype.beginPath = function () {\n          this.remaining = this.lineDash[0], this.dashes = [], this.pos = 0, this.x0 = 0, this.y0 = 0, this.x = 0, this.y = 0, this.hasPos = !1;\n        }, t.prototype.moveTo = function (t, e) {\n          this.y = e, this.x = t, this.isFilling && this.dashes.push(0, t, e), this.g.moveTo(t, e), this.x0 = t, this.y0 = e, this.hasPos = !0;\n        }, t.prototype.rect = function (t, e, i, n) {\n          this.moveTo(t, e), this.lineTo(t + i, n), this.lineTo(t + i, e + n), this.lineTo(t, e + n), this.lineTo(t, e);\n        }, t.prototype.lineTo = function (t, e) {\n          this.isFilling && this.g.lineTo(t, e);\n          var i = t - this.x,\n              n = e - this.y,\n              r = this.x,\n              s = this.y;\n          this.x = t, this.y = e;\n          var a = Math.sqrt(i * i + n * n),\n              o = 1 / a;\n          i *= o, n *= o;\n\n          for (var l = this.lineDash.length, h = this.pos, u = this.remaining;;) {\n            var c = Math.min(a, u);\n\n            if (r += i * c, s += n * c, h % 2 === 0 ? this.isFilling ? this.dashes.push(1, r, s) : this.g.lineTo(r, s) : this.isFilling ? this.dashes.push(0, r, s) : this.g.moveTo(r, s), !(a > c)) {\n              u -= c;\n              break;\n            }\n\n            h = (h + 1) % l, u = this.lineDash[h], a -= c;\n          }\n\n          this.pos = h, this.remaining = u, this.hasPos = !0;\n        }, t.prototype.arc = function (t, e, i, n, r, s) {\n          var a = 2 * Math.PI,\n              o = Math.min(.6, 2 / i),\n              l = Math.cos(o),\n              h = Math.sin(o),\n              u = Math.sin(n) * i,\n              c = Math.cos(n) * i,\n              d = Math.sin(r) * i,\n              p = Math.cos(r) * i;\n\n          if (this.hasPos || (this.moveTo(t + c, e + u), this.hasPos = !0), s) {\n            n < r && (n += a);\n\n            for (var f = (n - r) / o, g = f; g >= 0; g--) {\n              if (g - 1 <= 0) {\n                this.lineTo(t + p, e + d);\n                break;\n              }\n\n              this.lineTo(t + c, e + u);\n              var v = c * l + u * h,\n                  m = -c * h + u * l;\n              c = v, u = m;\n            }\n          } else {\n            n > r && (n -= 2 * Math.PI);\n\n            for (var f = (r - n) / o, g = f; g >= 0; g--) {\n              if (g - 1 <= 0) {\n                this.lineTo(t + p, e + d);\n                break;\n              }\n\n              this.lineTo(t + c, e + u);\n              var v = c * l - u * h,\n                  m = c * h + u * l;\n              c = v, u = m;\n            }\n          }\n        }, t.prototype.quadraticCurveTo = function (e, i, n, r) {\n          this.g.quadraticCurveTo(e, i, n, r), t.bezierWarning || (t.bezierWarning = !0, d.warn(\"Dashed Bézier curves not supported in this browser!\"));\n        }, t.prototype.bezierCurveTo = function (e, i, n, r, s, a) {\n          this.g.bezierCurveTo(e, i, n, r, s, a), t.bezierWarning || (t.bezierWarning = !0, d.warn(\"Dashed Bézier curves not supported in this browser!\"));\n        }, t.prototype.closePath = function () {\n          this.lineTo(this.x0, this.y0);\n        }, t.prototype.strokeDashes = function () {\n          for (var t = this.dashes, e = 0; e < t.length; e += 3) {\n            var i = t[e],\n                n = t[e + 1],\n                r = t[e + 2];\n            0 === i ? this.g.moveTo(n, r) : this.g.lineTo(n, r);\n          }\n        }, t;\n      }();\n\n      R.bezierWarning = !1, r.GraphicsDashedLineContext = R;\n\n      var H = function () {\n        function t() {}\n\n        return t.stroke = function (t, e) {\n          0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && e.lineDash.length > 0 && \"undefined\" != typeof t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke(), e.lineWidth && (t.lineWidth = 1));\n        }, t.strokeWithShadow = function (t, e) {\n          0 !== e.lineWidth && e.lineColor && !e.shadowColor && (e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, t.stroke(), e.lineWidth && (t.lineWidth = 1), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\"));\n        }, t.beginStroke = function (t, e, i) {\n          return void 0 === i && (i = !1), t.beginPath(), e.lineColor && e.lineDash && e.lineDash.length > 1 && \"undefined\" == typeof t.setLineDash ? (i && !e.fillColor && (i = !1), new R(t, e.lineDash, i)) : t;\n        }, t.endStroke = function (e, i, n, r) {\n          void 0 === r && (r = !1), i instanceof R ? (i.isFilling && (t.fill(e, n), e.beginPath(), i.strokeDashes()), t.strokeWithShadow(e, n)) : r ? t.paint(e, n) : t.stroke(e, n);\n        }, t.beginStrokeAndFill = function (e, i) {\n          return t.beginStroke(e, i, !0);\n        }, t.endStrokeAndFill = function (e, i, n) {\n          return t.endStroke(e, i, n, !0);\n        }, t.fill = function (t, e) {\n          e.fillColor && (t.fillStyle = e.fillColor, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.fill(), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\"));\n        }, t.paint = function (t, e) {\n          e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.fillColor && (t.fillStyle = e.fillColor, t.fill()), 0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && \"undefined\" != typeof t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke()), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = \"transparent\");\n        }, t.textStyle = function (t, e) {\n          t.__textStyle && this.resetTextStyle(t);\n          var i = e.fillColor;\n          void 0 === i && (i = \"#000\"), t.fillStyle = i, t.__font = t.font = e.font || null, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.outlineColor && (t.strokeStyle = e.outlineColor, t.lineWidth = 2 * (e.outlineWidth || 1), t.lineJoin = e.outlineJoin || \"miter\", t.miterLimit = 2), t.__textStyle = e;\n        }, t.getTextWidth = function (t, e, i) {\n          if (e) {\n            var n = e.font;\n            t.__font !== n && (t.__textStyle = null, t.__font = t.font = n || null);\n          }\n\n          var r = t.measureText(i).width;\n          return e.outlineColor && (r += 2 * (e.outlineWidth || 1)), r;\n        }, t.drawText = function (t, e, i, n, r) {\n          t.__textStyle !== e && this.textStyle(t, e), null != i && i.length && (e.outlineColor && t.strokeText(i, n, r), t.fillText(i, n, r));\n        }, t.resetTextStyle = function (t) {\n          t.__font = null;\n          var e = t.__textStyle;\n          e && (e.shadowColor && (t.shadowColor = \"transparent\", t.shadowBlur = 0), e.outlineColor && (t.lineJoin = \"miter\", t.miterLimit = 10, t.lineWidth = 1), t.__textStyle = null);\n        }, t.restore = function (t) {\n          this.resetTextStyle(t), t.restore();\n        }, t.rectStyle = function (t, e) {\n          void 0 !== e.lineColor && (t.strokeStyle = e.lineColor), void 0 !== e.fillColor && (t.fillStyle = e.fillColor), void 0 !== e.lineWidth && (t.lineWidth = e.lineWidth);\n        }, t.pushClip = function (t, e, i, n, r) {\n          var s = t.context,\n              a = t.scaleX,\n              o = t.scaleY;\n          1 === a && 1 === o || !window.screen.deviceXDPI ? (s.save(), s.beginPath(), s.rect(e, i, n, r), s.clip()) : (s.save(), s.transform(1 / a, 0, 0, 1 / o, 0, 0), s.beginPath(), s.rect(Math.floor(e * a), Math.floor(i * o), Math.floor(n * a), Math.floor(r * o)), s.clip(), s.transform(a, 0, 0, o, 0, 0));\n        }, t.popClip = function (t) {\n          this.restore(t.context);\n        }, t.arcBetweenTwoPoints = function (t, e, i, n, r, s, a, o) {\n          var l = (r + a) / 2,\n              h = (s + o) / 2,\n              u = o - s,\n              c = r - a,\n              d = u * u + c * c;\n\n          if (0 !== d) {\n            var p = Math.sqrt(d);\n            n = Math.min(Math.max(n, p / 2), 3 * p);\n            var f = Math.sqrt(n * n / d - .25),\n                g = l + u * f,\n                v = h + c * f,\n                m = l - u * f,\n                y = h - c * f,\n                S = (g - e) * (g - e) + (v - i) * (v - i),\n                b = (m - e) * (m - e) + (y - i) * (y - i);\n            S > b ? (e = m, i = y) : (e = g, i = v);\n            var x = Math.atan2(s - i, r - e),\n                C = Math.atan2(o - i, a - e);\n            C < x && (C += 2 * Math.PI);\n            var w = Math.abs(x - C) > Math.PI;\n            t.arc(e, i, n, x, C, w);\n          }\n        }, t.strokeMarker = function (e, i, n, r, s) {\n          var a = 1.41421356237 * s;\n\n          switch (i) {\n            case \"rect\":\n            case \"square\":\n              e.moveTo(n - s, r - s), e.lineTo(n + s, r - s), e.lineTo(n + s, r + s), e.lineTo(n - s, r + s), e.lineTo(n - s, r - s);\n              break;\n\n            case \"romb\":\n            case \"rhombus\":\n              a = .9 * a, e.moveTo(n - a, r), e.lineTo(n, r - a), e.lineTo(n + a, r), e.lineTo(n, r + a), e.lineTo(n - a, r);\n              break;\n\n            case \"triangle\":\n              var o = t.SQRT3D6 * (3 * s);\n              e.moveTo(n - s, r + o), e.lineTo(n + s, r + o), e.lineTo(n, r - o), e.lineTo(n - s, r + o);\n              break;\n\n            case \"triangle2\":\n              e.moveTo(n - a, r - a), e.lineTo(n + a, r - a), e.lineTo(n, r + a), e.lineTo(n - a, r - a);\n              break;\n\n            case \"circle\":\n              e.moveTo(n + s, r), e.arc(n, r, s, 0, 2 * Math.PI, !1);\n              break;\n\n            default:\n              throw new Error(\"Unknown marker shape \" + i + \". Valid values are `square`, `rhombus`, `triangle`, `triangle2`, `circle`.\");\n          }\n        }, t.strokeBalloon = function (t, e, i, n, r) {\n          n = Math.max(n, 2 * r);\n          var s = 5,\n              a = 4,\n              o = (r + 2 * a) / 2,\n              l = e,\n              h = i;\n          t.moveTo(l, h), l += 3, h += s + 1, t.lineTo(l, h), l += n - a, t.lineTo(l, h), t.arc(l, h + o, o, -Math.PI / 2, Math.PI / 2), h += 2 * o, l -= n - a, t.lineTo(l, h), t.arc(l, h - o, o, .5 * Math.PI, 1.3 * Math.PI), t.closePath();\n        }, t.strokeBalloon2 = function (t, e, i, n, r) {\n          var s = 4,\n              a = (r + 2 * s) / 2;\n          n = Math.max(n, 2 * r) / 2 - s;\n          var o = e + n,\n              l = i - a;\n          t.moveTo(o, l), t.arc(o, l + a, a, -Math.PI / 2, Math.PI / 2, !1), l += 2 * a, o -= 2 * n, t.lineTo(o, l), t.arc(o, l - a, a, .5 * Math.PI, 1.5 * Math.PI, !1), t.closePath();\n        }, t.applyColorToImage = function (t, e, i) {\n          void 0 === i && (i = !0);\n          var n = O.parse(e),\n              r = n.R,\n              s = n.G,\n              a = n.B,\n              o = document.createElement(\"canvas\"),\n              l = o.width = t.width,\n              h = o.height = t.height,\n              u = o.getContext(\"2d\");\n          u.drawImage(t, 0, 0);\n          var c = u.getImageData(0, 0, l, h),\n              d = c.data;\n          if (i) for (var p = 0; p <= d.length; p += 4) {\n            255 === d[p + 3] && (d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8);\n          } else for (var p = 0; p <= d.length; p += 4) {\n            d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8;\n          }\n          return u.putImageData(c, 0, 0), o;\n        }, t.cropImageToCircle = function (t, e) {\n          var i = Math.min(t.width, t.height),\n              n = Math.max(t.width, t.height),\n              r = Math.min(n, 2 * i),\n              s = document.createElement(\"canvas\");\n          s.width = r, s.height = r;\n          var a = s.getContext(\"2d\"),\n              o = t.width,\n              l = t.height;\n          a.fillStyle = \"rgba(0,0,0,1)\", a.beginPath(), a.arc(r / 2, r / 2, r / 2, 0, 2 * -Math.PI, !1), a.fill();\n          var h = a.globalCompositeOperation;\n\n          if (a.globalCompositeOperation = \"source-in\", \"crop\" === e) {\n            var u = Math.min(o, l) / 2;\n            a.drawImage(t, o / 2 - u, l / 2 - u, 2 * u, 2 * u, 0, 0, r, r);\n          } else if (\"letterbox\" === e) {\n            a.fillStyle = \"black\", a.fillRect(0, 0, r, r);\n            var c = r / Math.max(o, l);\n            a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c);\n          } else if (\"fit\" === e) {\n            a.fillStyle = \"black\", a.fillRect(0, 0, r, r);\n            var c = r / Math.sqrt(o * o + l * l);\n            a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c);\n          } else a.drawImage(t, 0, 0, o, l, 0, 0, r, r);\n\n          return a.globalCompositeOperation = h, s;\n        }, t.applyShadow = function (t, e) {\n          e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor);\n        }, t.clearShadow = function (t) {\n          t.shadowBlur = 0, t.shadowColor = \"transparent\";\n        }, t.drawImageInSquare = function (t, e, i, n, r, s, a, o, l) {\n          var h = l / Math.max(r, s),\n              u = r * h,\n              c = s * h;\n          this.drawImageHighQuality(t, e, i, n, r, s, a - u, o - c, 2 * u, 2 * c);\n        }, t.drawImageHighQuality = function (t, e, i, n, r, s, a, o, l, h) {\n          void 0 === a && (a = i, o = n, l = r, h = s, r = e.width, s = e.height, i = 0, n = 0);\n          var u = t.__scaleX || 1,\n              c = t.__scaleY || 1;\n\n          if (!(h < 1 / c || l < 1 / u)) {\n            for (var d = r, p = s, f = e, g = 1, v = \"__size:\" + i + \"/\" + n + \"/\" + r + \"/\" + s + \"/\"; d >= l * u * 2 && p >= h * c * 2;) {\n              var m = Math.round(d / 2),\n                  y = Math.round(p / 2);\n              g /= 2;\n              var S = v + g,\n                  b = e[S];\n\n              if (!b) {\n                b = e[S] = document.createElement(\"canvas\"), b.width = m, b.height = y;\n                var x = b.getContext(\"2d\");\n                x.drawImage(f, i, n, d, p, 0, 0, m, y);\n              }\n\n              i = 0, n = 0, f = b, p = y, d = m;\n            }\n\n            t.drawImage(f, i, n, Math.floor(d), Math.floor(p), a, o, l, h);\n          }\n        }, t.getTextHeightWithoutContext = function (e) {\n          return t.getTextHeight(null, e);\n        }, t.getTextHeight = function (e, i) {\n          var n = t._heightCache;\n          if (n.hasOwnProperty(i)) return n[i];\n          var s = t._heightElem;\n\n          if (!s) {\n            var a = document.createElement(\"div\");\n            a.className = \"DVSL-font-height\", t._heightElem = s = document.createElement(\"div\"), s.appendChild(document.createTextNode(\"Mg9!\")), a.appendChild(s), document.body.appendChild(a);\n          }\n\n          s.style.font = i;\n          var o = s.getBoundingClientRect();\n          return o.top >= 0 && o.left >= 0 ? (r.Helpers.error(\"getTextHeight called before CSS loaded\"), o.height) : n[i] = o.height;\n        }, t.mat3ToMat2d = function (t) {\n          var e = t.all();\n          return [e[0], e[3], e[1], e[4], e[2], e[5]];\n        }, t.transformVec2d = function (t, e) {\n          var i = t.x,\n              n = t.y;\n          return {\n            x: e[0] * i + e[2] * n + e[4],\n            y: e[1] * i + e[3] * n + e[5]\n          };\n        }, t;\n      }();\n\n      H.SQRT3D6 = Math.sqrt(3) / 6, H._heightElem = null, H._heightCache = {}, r.Graphics = H;\n\n      var z = function () {\n        function t() {\n          this.enabled = !0, this.enabledOnExport = !0, this.align = \"center\", this.verticalAlign = \"center\", this.margin = 25, this.style = {\n            font: \"20px Arial\",\n            fillColor: \"#000\"\n          }, this.text = \"\", this.advanced = {\n            addAfterToolbar: !1\n          };\n        }\n\n        return t;\n      }();\n\n      r.SettingsTitle = z;\n\n      var B = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.lineSpacing = 0, i.animationOrder = 2e3, i.paintOrder = 55, i.updateOrder = 500, i.chart = e, i.scene = e.scene, i.settings = i.scene.settings.title, i.panel = new A(), i.panel.packingOrder = 10, i.settings.advanced && i.settings.advanced.addAfterToolbar === !0 && (i.panel.packingOrder = 20), i.panel.side = \"top\", i.panel.outsideEdge = !0, i.panel.align = \"fill\", i.panel.visible = !1, i.panel.computeSize = function (t, e, n) {\n            return i.computePanelSize(t, e, n);\n          }, i.lines = null, i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          var e = t.changes;\n          e.settings && e.settingsChanges.title && (e.bounds = !0);\n        }, e.prototype.getPanels = function (t) {\n          var e = this.settings;\n          return this.panel.visible = !!e.text && (t ? e.enabledOnExport : e.enabled), this.panel.visible ? (this.panel.margin = e.margin, t && !e.enabled ? this.panel.location = \"external\" : this.panel.location = \"outside\", [this.panel]) : [];\n        }, e.prototype.computePanelSize = function (t, e, i) {\n          if (!this.chart.assetsLoaded) return {\n            width: 0,\n            height: 0\n          };\n          this.lines = [];\n          var n = this.settings.text,\n              r = this.settings.style;\n          i.save();\n          var s = H.getTextWidth(i, r, n),\n              a = H.getTextHeight(i, r.font);\n\n          if (this.lineSpacing = 1.15 * a, s > t) {\n            for (var o = 0, l = n.split(\" \"), h = l[0], u = H.getTextWidth(i, r, h), c = 1; c <= l.length - 1; c++) {\n              var d = h + \" \" + l[c],\n                  p = H.getTextWidth(i, r, d);\n              p <= t ? (h = d, u = p) : (this.lines.push(h), s = Math.max(s, u), h = l[c], u = H.getTextWidth(i, r, h));\n            }\n\n            this.lines.push(h), s = Math.max(o, u);\n          } else this.lines.push(n);\n\n          return H.restore(i), a = (this.lines.length - 1) * this.lineSpacing + a, {\n            width: s,\n            height: a\n          };\n        }, e.prototype.paintScene = function (t) {\n          if (this.panel.visible && this.lines) {\n            var e = t.context;\n            e.textBaseline = \"top\";\n            var i = this.computeTitleStartX(this.settings, e),\n                n = this.computeTitleStartY(this.settings);\n            this.paintTitle(e, this.settings.style, i, n);\n          }\n        }, e.prototype.paintTitle = function (t, e, i, n) {\n          for (var r = 0; r < this.lines.length; r++) {\n            H.drawText(t, e, this.lines[r], i, n), n += this.lineSpacing;\n          }\n\n          H.resetTextStyle(t);\n        }, e.prototype.computeTitleStartX = function (t, e) {\n          switch (t.align) {\n            case \"left\":\n              return e.textAlign = \"start\", this.panel.left;\n\n            case \"right\":\n              return e.textAlign = \"end\", this.panel.right;\n\n            default:\n              return e.textAlign = \"center\", (this.panel.left + this.panel.right) / 2;\n          }\n        }, e.prototype.computeTitleStartY = function (t) {\n          var e = this.panel.top;\n\n          switch (t.verticalAlign) {\n            case \"top\":\n              return e - t.margin;\n\n            case \"bottom\":\n              return e + t.margin;\n\n            default:\n              return e;\n          }\n        }, e;\n      }(k);\n\n      r.Title = B;\n\n      var U = function () {\n        function t(t, e) {\n          void 0 === e && (e = !1), this.style = {\n            textStyle: {}\n          }, this._textOverride = void 0, this.visible = !0, this.allowCache = !0, this.shouldBeVisible = !0, this.userPlaced = !1, this.rows = null, this.lineHeight = 0, this.lineHeightM = 0, this.hwidth = null, this.hheight = null, this.currentBounds = null, this.x = null, this.originX = null, this.y = null, this.prop = null, this._pendingImage = !1, this._textCache = null, this._measureStyles = null, t || (t = {}), t.textStyle || (t.textStyle = {}), null == t.lineSpacing && (t.lineSpacing = .2), e ? this.style = t : this.deepCloneStyle(t);\n        }\n\n        return Object.defineProperty(t.prototype, \"text\", {\n          get: function get() {\n            var t = this._textOverride;\n            return void 0 === t && (t = this.style.text, null != t && \"string\" != typeof t && (t = \"\" + t)), t;\n          },\n          set: function set(t) {\n            void 0 === t && (t = null), null != t && \"string\" != typeof t && (t = \"\" + t), this._textOverride = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.deepCloneStyle = function (t) {\n          var e = {};\n\n          for (var i in t) {\n            e[i] = t[i];\n          }\n\n          if (this.style = e, t.imageSlicing) {\n            for (var n = [], s = 0; s < t.imageSlicing.length; s++) {\n              n.push(t.imageSlicing[s]);\n            }\n\n            this.style.imageSlicing = n;\n          }\n\n          var a = {};\n\n          for (var i in t.textStyle) {\n            a[i] = t.textStyle[i];\n          }\n\n          if (this.style.textStyle = a, t.backgroundStyle) {\n            var o = {};\n\n            for (var i in t.backgroundStyle) {\n              o[i] = t.backgroundStyle[i];\n            }\n\n            if (t.backgroundStyle.lineDash) {\n              o.lineDash = [];\n\n              for (var s = 0; s < t.backgroundStyle.lineDash.length; s++) {\n                o.lineDash.push(t.backgroundStyle.lineDash[s]);\n              }\n            }\n\n            this.style.backgroundStyle = o;\n          }\n\n          this.style.extra = r.Helpers.realClone(t.extra, !0);\n        }, t.prototype.needTextParsing = function () {\n          var t = this._textCache;\n          return !t || t.sourceText !== this.text || t.sourceFont !== this.style.textStyle.font;\n        }, t.prototype.needMeasure = function () {\n          var t = this._measureStyles,\n              e = t && t.customMeasure;\n          if (this._pendingImage) return !e || null;\n          var i = this.style,\n              n = i.textStyle,\n              r = !t || t.align !== i.align || t.text !== this.text || t.aspectRatio !== i.aspectRatio || t.borderRadius !== i.borderRadius || t.font !== n.font || t.image !== i.image || t.imageSlicing !== \"\" + i.imageSlicing || t.margin !== i.margin || t.maxWidth !== i.maxWidth || t.padding !== i.padding;\n          return r && e ? null : r;\n        }, t.prototype.measureComplete = function (t) {\n          var e = this.style,\n              i = e.textStyle;\n          this._measureStyles = {\n            customMeasure: t,\n            text: this.text,\n            align: e.align,\n            aspectRatio: e.aspectRatio,\n            borderRadius: e.borderRadius,\n            font: i.font,\n            image: e.image,\n            imageSlicing: \"\" + e.imageSlicing,\n            lineSpacing: e.lineSpacing,\n            margin: e.margin,\n            maxWidth: e.maxWidth,\n            padding: e.padding\n          };\n        }, t;\n      }();\n\n      r.Label = U;\n\n      var G = function () {\n        function t(t, e, i) {\n          if (this.cache = {}, this.frameLabels = {}, this.numPaints = 0, this.numCachedPaints = 0, this.allowCache = !0, this.chartArea = 0, this.scaleX = 0, this.scaleY = 0, this.settings = t, this.assetsLoader = e, !i) throw new Error(\"chartContainer must be specified\");\n          this.chartContainer = i;\n        }\n\n        return t.prototype.startFrame = function (t, e, i, n) {\n          this.chartArea = t * e, this.scaleX = i, this.scaleY = n;\n        }, t.prototype.finishFrame = function () {\n          var t = d.countProperties(this.cache);\n\n          if (!(t < 1e3)) {\n            var e = d.countProperties(this.frameLabels);\n            if (t > 3 * e) for (var i in this.cache) {\n              this.frameLabels[i] || delete this.cache[i];\n            }\n            this.frameLabels = {};\n          }\n        }, t.prototype.measure = function (t, e) {\n          var i = e.needMeasure();\n\n          if (i === !0) {\n            var n = e.style,\n                r = new V().totalPadding(n),\n                s = 0,\n                a = 0;\n\n            if (e.text) {\n              var o = this.measureText(t, e),\n                  l = o.w,\n                  h = o.h;\n              a = Math.max(a, h), s += l;\n            } else e.rows = {\n              subLines: [],\n              rowWidths: []\n            };\n\n            if (n.image) {\n              var u = n.imageSlicing;\n              if (u) s += u[2], a = Math.max(a, u[3]);else {\n                var c = this.assetsLoader.getAssetImage(n.image, null);\n                c && c.width ? (s += c.width, a = Math.max(a, c.height)) : e._pendingImage = !0;\n              }\n            }\n\n            if (0 === s && (s = 10, a = 10), s += 2 * r, a += 2 * r, n.borderRadius > 0 && e.text) {\n              var d = Math.min(n.borderRadius, a / 2);\n              s += .45 * d, n.image || (s += .45 * d);\n            }\n\n            e.hwidth = s / 2, e.hheight = a / 2, e.measureComplete(!1);\n          } else if (null === i) throw new Error(\"Label.needMeasure assert.\");\n        }, t.prototype.measureText = function (t, e) {\n          var i,\n              n,\n              r = e.style,\n              s = r.aspectRatio,\n              a = r.maxWidth,\n              o = new V(),\n              l = o.styleTagParser(t, e);\n\n          if ((s > 0 || a > 0) && l.maxLines > 1) {\n            s || (s = 1e9), a || (a = 1e9);\n\n            var h = function h(t) {\n              return {\n                x: 0,\n                y: 0,\n                dx: 0,\n                dy: 0,\n                width: Math.min(a, t * (s + .2))\n              };\n            };\n\n            o.fitLabelInRect(t, e, h, !1), i = 2 * e.hwidth, n = 2 * e.hheight;\n          } else {\n            for (var u = l.words, c = l.breaks, d = 0; d < c.length; d++) {\n              c[d] = c[d] - 1;\n            }\n\n            var p = o.stringsByFont(u, c);\n            e.lineHeight = n = H.getTextHeight(t, r.textStyle.font), e.rows = p, i = p.rowWidths.reduce(function (t, e) {\n              return Math.max(t, e);\n            }), n = n * (1 + (r.lineSpacing || 0)) * p.rowWidths.length;\n          }\n\n          return {\n            w: i,\n            h: n\n          };\n        }, t.prototype.canCache = function (t, e) {\n          var i = this.settings.advanced,\n              n = t.style;\n          if (!this.allowCache || !t.allowCache || !i.labelCache) return !1;\n          if (n.angle && !i.labelCacheRotated) return !1;\n          var r = 2 * (t.hwidth * t.hheight * e * e);\n          if (this.chartArea / r < 10) return !1;\n\n          if (n.image) {\n            var s = this.assetsLoader.getAssetImage(n.image, null);\n            if (!s) return !1;\n          }\n\n          return !0;\n        }, t.prototype.styleRequiresDocumentCanvas = function (t) {\n          return !!(t && t.font && /[0-9]+em/.test(t.font));\n        }, t.prototype.realPaint = function (t, e, i, n) {\n          var r = n.hwidth,\n              s = n.hheight,\n              a = n.style,\n              o = a.backgroundStyle,\n              l = new V().totalPadding(a),\n              h = Math.min(a.borderRadius || 0, s);\n\n          if (o) {\n            var u = o.lineWidth;\n            u = null == u && o.lineColor ? .5 : (u || 0) / 2, r -= u, s -= u;\n            var c = H.beginStrokeAndFill(t, o);\n\n            if (h >= s) {\n              var d = e + r - s;\n              c.moveTo(d, i - s), c.arc(d, i, s, -Math.PI / 2, Math.PI / 2, !1), d = e - r + s, c.lineTo(d, i + s), c.arc(d, i, s, Math.PI / 2, -Math.PI / 2, !1), c.closePath();\n            } else h > 0 ? (c.moveTo(e - r + h, i - s), c.lineTo(e + r - h, i - s), c.arc(e + r - h, i - s + h, h, -Math.PI / 2, 0, !1), c.lineTo(e + r, i + s - h), c.arc(e + r - h, i + s - h, h, 0, +Math.PI / 2, !1), c.lineTo(e - r + h, i + s), c.arc(e - r + h, i + s - h, h, +Math.PI / 2, Math.PI, !1), c.lineTo(e - r, i - s + h), c.arc(e - r + h, i - s + h, h, Math.PI, Math.PI + Math.PI / 2, !1)) : (c.moveTo(e - r, i - s), c.lineTo(e + r, i - s), c.lineTo(e + r, i + s), c.lineTo(e - r, i + s), c.closePath());\n\n            H.endStrokeAndFill(t, c, o), r += u, s += u;\n          }\n\n          var p = a.image;\n          r -= l, s -= l;\n          var f = e - r,\n              g = e + r;\n\n          if (p) {\n            var v = this.assetsLoader.getAssetImage(p);\n\n            if (v) {\n              var m = a.imageSlicing;\n              m ? (H.drawImageHighQuality(t, v, m[0], m[1], m[2], m[3], e - r, i - s, m[2], m[3]), f += m[2]) : (t.drawImage(v, e - r, i - s), f += v.width);\n            }\n          }\n\n          var y = n.rows.subLines,\n              S = n.rows.rowWidths,\n              b = S.length;\n\n          if (y.length > 0) {\n            var x = n.lineHeight * (1 + (a.lineSpacing || 0)),\n                C = a.align,\n                w = void 0,\n                L = void 0;\n            t.textBaseline = \"bottom\";\n            var T = i - (b + 1) * x / 2 + .58 * n.lineHeight;\n            \"left\" === C ? (L = f, p || (L += .45 * h), w = \"start\") : \"right\" === C ? (L = g - .45 * h, w = \"end\") : (L = (f + g) / 2, w = \"center\");\n            var k = a.textStyle,\n                M = -1,\n                A = 0;\n            t.textAlign = w;\n            var I = void 0;\n            H.textStyle(t, k);\n\n            for (var P = k.font, D = 0; D < y.length; D++) {\n              var N = y[D],\n                  F = A;\n\n              if (A += N.width, M !== N.row) {\n                M = N.row, T += x, F = 0, A = N.width;\n                var O = S[M];\n                I = \"center\" === w ? L - O / 2 : \"start\" === w ? L : L - O;\n              }\n\n              t.textAlign = \"left\", P !== N.font && (t.font = P = N.font), F += I, H.drawText(t, k, N.text, F, T);\n            }\n\n            H.resetTextStyle(t);\n          }\n        }, t.prototype.paint = function (t, e, i, n, s) {\n          this.measure(t, s);\n          var a = s.style,\n              o = (a.angle || 0) / 180 * Math.PI,\n              l = this.scaleX,\n              h = this.scaleY,\n              u = 0 === (a.angle || 0) ? 1 : 1.7,\n              c = l * n * u,\n              d = h * n * u,\n              p = this.canCache(s, n),\n              f = s.hwidth,\n              g = s.hheight,\n              v = 3 / h;\n\n          if (s.currentBounds = new mt(e - f * n, i - g * n, e + f * n, i + g * n), p) {\n            var m = c,\n                y = d;\n            g * d < v && (y = v / g, m = c / d * y);\n            var S = s.text + JSON.stringify(s.style) + m.toFixed(2) + \",\" + y.toFixed(2) + \",\" + s.hwidth + \",\" + s.hheight,\n                b = this.cache[S] || null,\n                x = void 0,\n                C = void 0,\n                w = void 0,\n                L = void 0;\n            if (b) x = b.width, C = b.height, w = x / 2, L = C / 2, this.numCachedPaints += 1;else {\n              var T = a.backgroundStyle,\n                  k = T && T.lineWidth ? T.lineWidth : 0;\n              x = Math.ceil((2 * f + k + 1) * m), C = Math.ceil((2 * g + k + 1) * y), b = document.createElement(\"canvas\"), x += x % 2, C += C % 2, w = x / 2, L = C / 2, b.width = x, b.height = C;\n              var M = this.styleRequiresDocumentCanvas(a.textStyle),\n                  A = void 0;\n              M && (A = this.chartContainer, A.ownerDocument || (r.Helpers.warn(\"chartContainer must be appended to the document in order to use `em` when specifying font size.\"), A = document.body), b.style.display = \"none\", A.appendChild(b));\n              var I = b.getContext(\"2d\");\n              I.transform(m, 0, 0, y, w, L), this.realPaint(I, 0, 0, s), M && A.removeChild(b), this.cache[S] = b, this.numPaints += 1;\n            }\n            var P = x / c * n,\n                D = C / d * n;\n            m !== c && (P = P / m * c, D = D / y * d), P = Math.round(P / 2 * 1e3) / 1e3, D = Math.round(D / 2 * 1e3) / 1e3;\n            var N = e - P,\n                F = i - D;\n            0 !== o ? (t.save(), t.translate(e, i), t.rotate(o), N = -P, F = -D) : m === c && (N = Math.round(N * l) / l, F = Math.round(F * h) / h), H.drawImageHighQuality(t, b, 0, 0, x, C, N, F, 2 * P, 2 * D), this.frameLabels[S] = 1, 0 !== o && H.restore(t);\n          } else {\n            var O = 1 !== n || 0 !== o;\n            O && (t.save(), t.transform(n, 0, 0, n, e, i), 0 !== o && t.rotate(o), e = 0, i = 0), this.realPaint(t, e, i, s), this.numPaints += 1, O && H.restore(t);\n          }\n        }, t;\n      }();\n\n      r.LabelRenderer = G;\n\n      var V = function () {\n        function t() {}\n\n        return t.prototype.totalPadding = function (t) {\n          var e = t.padding || 0,\n              i = t.backgroundStyle;\n\n          if (i) {\n            var n = i.lineWidth;\n            e += null == n && i.lineColor ? 1 : n || 0;\n          }\n\n          return e;\n        }, t.prototype.fitLabelInRect = function (t, e, i, n) {\n          void 0 === n && (n = !0);\n          var r = e.style,\n              s = r.margin || 0,\n              a = this.totalPadding(r),\n              o = H.getTextHeight(t, r.textStyle.font),\n              l = r.lineSpacing || 0,\n              h = o * (l + 1),\n              u = -o * l;\n          e.needTextParsing() && this.styleTagParser(t, e);\n\n          for (var c, d, p = e._textCache.words, f = e._textCache.breaks, g = e._textCache.maxLines, v = -(1 / 0), m = null, y = 0, S = 0, b = 0, x = 0, C = Math.min(g, f.length); C <= g; C++) {\n            var w = u + h * C,\n                L = i(w / 2 + s + a),\n                T = L.width;\n            T -= 2 * (s + a);\n            var k = this.splitWordsToLines(p, f, C, function () {\n              return T;\n            }),\n                M = k.prop,\n                A = k.actualWidthForLines,\n                I = k.positions;\n\n            if (M > v) {\n              m = I, v = M, c = L.dx, d = L.dy, y = L.x, S = L.y, b = T, x = 0;\n\n              for (var P = 0; P < A.length; P++) {\n                var D = A[P];\n                x = Math.max(D, x);\n              }\n            }\n\n            if (M >= 1) break;\n          }\n\n          if (m) {\n            if (!e.userPlaced) {\n              var N = e.style.align,\n                  F = void 0;\n              F = \"left\" === N ? (x - b) / 2 : \"right\" === N ? (b - x) / 2 : 0, y += c * F, S += d * F;\n            }\n\n            n && (e.x = y, e.y = S), e.rows = this.stringsByFont(p, m), e.hheight = (u + h * m.length) / 2 + a, e.lineHeight = o, e.lineHeightM = h, e.hwidth = x / 2 + a, e.visible = !0, e.measureComplete(!0), r.borderRadius > 0 && (e.hwidth += .45 * Math.min(r.borderRadius, e.hheight));\n          } else e.rows = {\n            subLines: [],\n            rowWidths: []\n          }, e.visible = !1;\n\n          return v;\n        }, t.prototype.styleTagParser = function (t, e) {\n          return e.needTextParsing() && (e._textCache = this.styleTagParser2(t, e.text, e.style.textStyle)), e._textCache;\n        }, t.prototype.styleTagParser2 = function (e, i, n) {\n          var r = n.font,\n              s = null;\n          r ? (e.font = r, s = e.font) : r = \"11px Arial\";\n          var a = t._spaceWidth;\n          a[r] || (a[r] = H.getTextWidth(e, {\n            font: r\n          }, \" \"));\n          var o = r,\n              l = 0,\n              h = 0,\n              u = !0,\n              c = i;\n          i = null == i ? \"\" : \"\" + i;\n          var p = 0,\n              f = 0,\n              g = [],\n              v = [],\n              m = -1;\n          g.push({\n            word: \"\",\n            width: 0,\n            font: o,\n            spaceWidth: 0\n          });\n          var y = {\n            word: \"\",\n            width: 0,\n            font: o,\n            spaceWidth: 0\n          };\n          g.push(y);\n\n          for (var S = i.length, b = 0 === S ? -1 : i.charCodeAt(0); p < S;) {\n            switch (b) {\n              case 32:\n                for (; 32 === b && ++p < S;) {\n                  b = i.charCodeAt(p);\n                }\n\n                u || (y.spaceWidth = a[o], u = !0), f = p;\n                break;\n\n              case 60:\n                if (p + 4 > S) {\n                  b = -1;\n                  break;\n                }\n\n                var x = p,\n                    C = i.charCodeAt(++p),\n                    w = 47 === C ? -1 : 1;\n                w < 0 && (C = i.charCodeAt(++p));\n                var L = i.charCodeAt(++p),\n                    T = -1;\n\n                if (98 === C || 66 === C ? 82 === L || 114 === L ? (L = ++p === S ? -1 : i.charCodeAt(p), T = 2) : T = 0 : 73 !== C && 105 !== C || (T = 1), T > -1 && 62 === L) {\n                  b = ++p === S ? -1 : i.charCodeAt(p), f = p;\n                  var k = !1,\n                      M = y.word || y.spaceWidth > 0;\n                  if (2 === T) m === g.length - 1 && (M = !0), v.push(m = g.length - (M ? 0 : 1)), u = !0, k = !0;else {\n                    1 === T ? h = Math.max(0, h + w) : l = Math.max(0, l + w);\n                    var A = (h ? \"italic \" : \"\") + (l ? \"bold \" : \"\") + r;\n                    A !== o && (k = !0, o = A, a[o] || (a[o] = H.getTextWidth(e, {\n                      font: o\n                    }, \" \")));\n                  }\n                  k && (M ? (y = {\n                    word: \"\",\n                    width: 0,\n                    font: o,\n                    spaceWidth: 0\n                  }, g.push(y)) : y.font = o);\n                } else p = x, b = -1;\n\n                break;\n\n              default:\n                for (var I = !1; 32 !== b && 60 !== b && ++p < S;) {\n                  I = I || 38 === b, b = i.charCodeAt(p);\n                }\n\n                var P = i.substring(f, p);\n                I && (P = d.decodeEntities(P)), y.spaceWidth > 0 || y.font !== o ? (y = {\n                  word: P,\n                  width: 0,\n                  font: o,\n                  spaceWidth: 0\n                }, g.push(y)) : y.word += P, u = !1, f = p;\n            }\n          }\n\n          for (var D = 0; D < g.length; D++) {\n            var N = g[D];\n            N.word && (N.width = H.getTextWidth(e, {\n              font: N.font\n            }, N.word));\n          }\n\n          H.resetTextStyle(e);\n          var F = g.length;\n          v[v.length - 1] !== F && v.push(F);\n          var O = F;\n          0 === g[0].width && O--;\n\n          for (var D = F - 1; D >= 0; D--) {\n            var N = g[D];\n            if (N.width > 0) break;\n            O--;\n          }\n\n          return {\n            sourceText: c,\n            sourceFont: n.font,\n            breaks: v,\n            maxLines: O,\n            words: g\n          };\n        }, t.prototype.stringsByFont = function (t, e) {\n          for (var i = t[0].font, n = e.slice(0), r = [], s = [], a = 0, o = 0, l = \"\", h = 0, u = 0, c = 0; c <= t.length - 1; c++) {\n            var d = t[c];\n            u = d.spaceWidth;\n            var p = c === n[0];\n            d.font !== i && (o && r.push({\n              text: l,\n              width: o,\n              font: i,\n              row: h\n            }), i = d.font, l = \"\", o = 0), o += d.width, l += d.word, a += d.width + d.spaceWidth, p && (r.push({\n              text: l,\n              width: o,\n              font: i,\n              row: h\n            }), s.push(a - d.spaceWidth), l = \"\", h++, o = a = 0, n.shift()), p || d.spaceWidth && (o += d.spaceWidth, l += \" \");\n          }\n\n          return l && (r.push({\n            text: l,\n            width: o,\n            font: i,\n            row: h\n          }), s.push(a - u)), {\n            subLines: r,\n            rowWidths: s\n          };\n        }, t.prototype.fitLabelInLines = function (t, e, i, n, r, s, a) {\n          var o = e.style,\n              l = o.margin || 0,\n              h = this.totalPadding(o),\n              u = H.getTextHeight(t, o.textStyle.font),\n              c = o.lineSpacing || 0,\n              d = u * (c + 1),\n              p = -u * c;\n          this.styleTagParser(t, e);\n          var f = e._textCache.words,\n              g = e._textCache.breaks,\n              v = e._textCache.maxLines,\n              m = -(1 / 0),\n              y = null,\n              S = null,\n              b = null,\n              x = 0,\n              C = [],\n              w = [];\n          w.push(a(i, n));\n\n          for (var L = 1; L <= g.length - 1; L++) {\n            var T = p + d * L,\n                k = void 0;\n            k = L % 2 === 1 ? C : w;\n            var M = a(i, n - T / 2 - l);\n            k.unshift([M[0] - l, M[1] - l]), M = a(i, n + T / 2 + l), k.push([M[0] - l, M[1] - l]);\n          }\n\n          for (var L = Math.min(v, g.length); L <= v; L++) {\n            var A,\n                T = p + d * L;\n            A = L % 2 === 1 ? C : w;\n            var M = a(i, n - T / 2 - l);\n            A.unshift([M[0] - l, M[1] - l]), M = a(i, n + T / 2 + l), A.push([M[0] - l, M[1] - l]);\n\n            var I = function I(t) {\n              return Math.min(A[t][0] + A[t][1], A[t + 1][0] + A[t + 1][1]);\n            },\n                P = this.splitWordsToLines(f, g, L, I),\n                D = P.prop,\n                N = P.actualWidthForLines,\n                F = P.positions;\n\n            if (D > m && (x = n - T / 2, y = F, m = D, S = N, b = A.slice(0), F.length + 1 > A.length)) throw new Error(\"Internal error - fitLabelInLines\");\n            if (D >= 1) break;\n          }\n\n          if (y) {\n            var O = 0,\n                E = 0,\n                R = void 0,\n                z = void 0;\n\n            if (\"left\" === r) {\n              for (var B = 1e30, U = 0; U <= y.length; U++) {\n                B = Math.min(b[U][0]);\n              }\n\n              var G = -B;\n              R = G, z = G;\n\n              for (var U = 0; U <= y.length - 1; U++) {\n                var V = S[U],\n                    j = Math.min(b[U][1], b[U + 1][1]);\n                z = Math.max(G + V), E = Math.max(E, V - (j - G));\n              }\n            } else if (\"right\" === r) {\n              for (var j = 1e30, U = 0; U <= y.length; U++) {\n                j = Math.min(b[U][1]);\n              }\n\n              var W = j;\n              R = W, z = W;\n\n              for (var U = 0; U <= y.length - 1; U++) {\n                var V = S[U];\n                R = Math.min(W - V), O = Math.max(O, V - (j + W));\n              }\n            } else if (\"center\" === r) {\n              for (var B = 1e30, j = 1e30, U = 0; U <= y.length - 1; U++) {\n                var V = S[U] / 2;\n                B = Math.min(b[U][0] - V, Math.min(b[U + 1][0] - V, B)), j = Math.min(b[U][1] - V, Math.min(b[U + 1][1] - V, j));\n              }\n\n              var Z = void 0;\n              Z = B > 0 && j > 0 ? 0 : B > -j ? j : j > -B ? -B : (j - B) / 2, R = Z, z = Z;\n\n              for (var U = 0; U <= y.length - 1; U++) {\n                var V = S[U];\n                B = Math.min(b[U][0], b[U + 1][0]), j = Math.min(b[U][1], b[U + 1][1]), R = Math.min(R, Z - V / 2), z = Math.max(z, Z + V / 2), O = Math.max(O, V / 2 - B - Z), E = Math.max(E, V / 2 - j + Z);\n              }\n            }\n\n            if (\"left\" === s && O > 0) R += O, z += O;else if (\"right\" === s && E > 0) R -= E, z -= E;else if (\"center\" === s) {\n              var Y = (O - E) / 2;\n              R += Y, z += Y;\n            }\n            e.rows = this.stringsByFont(f, y), e.hwidth = (z - R) / 2 + h, e.hheight = (p + d * y.length) / 2 + h, e.lineHeight = u, e.lineHeightM = d, e.visible = !0, e.measureComplete(!0), o.borderRadius > 0 && (e.hwidth += .45 * Math.min(o.borderRadius, e.hheight)), e.userPlaced || (e.x = i + (R + z) / 2, e.y = x + e.hheight);\n          } else e.rows = {\n            subLines: [],\n            rowWidths: []\n          }, e.visible = !1;\n\n          return m;\n        }, t.prototype.splitWordsToLines = function (t, e, i, n) {\n          for (var r = 100, s = [], a = [], o = 0, l = e[o], h = i - e.length, u = t[0], c = 0, d = n(0), p = 0, f = 1; f <= t.length - 1; f++) {\n            var g = t[f],\n                v = c + (u.spaceWidth + g.width);\n            l === f || u.spaceWidth > 0 && v > d && h > 0 ? (a.push(f - 1), s.push(c), r = Math.min(r, d / c), c = g.width, p += 1, d = n(p), l !== f ? h -= 1 : (o += 1, l = e[o])) : c = v, u = g;\n          }\n\n          return a.push(t.length), s.push(c), r = Math.min(r, d / c), {\n            prop: r,\n            actualWidthForLines: s,\n            positions: a\n          };\n        }, t.prototype.getFormatedText = function (t, e, i, n, r) {\n          var s,\n              a = e.style,\n              o = a.textStyle,\n              l = H.getTextHeight(t, a.textStyle.font),\n              h = a.lineSpacing || 0,\n              u = l * (h + 1),\n              c = a.margin || 0,\n              d = this.totalPadding(a),\n              p = !a.angle || 0 === a.angle,\n              f = 90 === a.angle || a.angle === -90,\n              g = p || f;\n          if (f) s = n - 2 * c, n = i - c;else {\n            n -= c;\n            var v = r(l / 2 + d, i - 2 * c, n - c);\n            s = v.width;\n          }\n          var m = this.getIncludingPart(t, o, e.text, \"\", s, 0),\n              y = e.text,\n              S = null,\n              b = !1,\n              x = H.getTextWidth(t, e.style.textStyle, \"…\");\n          if (g) for (var C = Math.floor(n / l) - 2, w = 0; w <= C;) {\n            if (y = y.replace(/\\s+$/g, \"\"), m = this.getIncludingPart(t, o, y, \"\", s, 0), m === y) {\n              this.addLine(t, e, m, w, b);\n              break;\n            }\n\n            if (b = !0, m.length <= 1) {\n              m = y.slice(0, 1), b = e.text !== m, this.addLine(t, e, m, w, b), S = e.rows.rowWidths[0];\n              break;\n            }\n\n            if (w === C) m = this.getIncludingPart(t, o, y, \"\", s - x, 0);else {\n              var L = m.lastIndexOf(\" \"),\n                  T = void 0;\n\n              if (L === -1) {\n                T = y.indexOf(\" \");\n                var k = T === -1 ? y : y.substring(0, T);\n                b = m !== k, b && (m = this.getIncludingPart(t, o, y, \"\", s - x, 0).replace(/\\s+$/g, \"\"), T = y.indexOf(\" \"), k = T === -1 ? y : y.substring(0, T)), y = y.substr(m.length), T = y.indexOf(\" \"), y = T === -1 ? \"\" : y.substr(T + 1);\n              } else m = m.substr(0, L), y = y.substr(L + 1), b = !1;\n            }\n\n            if (m.length <= 1) {\n              if (0 !== w) break;\n              m = e.text.slice(0, 1);\n            }\n\n            if (this.addLine(t, e, m, w, b), \"\" === y) break;\n            y = y.trim(), b = !1, w++;\n          } else b = m !== y, b && (m = this.getIncludingPart(t, o, y, \"\", s - x, 0).replace(/\\s+$/g, \"\")), this.addLine(t, e, m, 0, b);\n          e.rows || this.addLine(t, e, \"\", 0, !1);\n          var M = (u * e.rows.subLines.length - l * h) / 2,\n              A = 0;\n\n          if (\"left\" === a.align || \"right\" === a.align) {\n            var I = Math.max.apply(Math, e.rows.rowWidths),\n                P = (s - I) / 2;\n            A = \"right\" === a.align ? P : -P;\n          }\n\n          a.angle && (S = Math.max.apply(Math, e.rows.rowWidths));\n          var D = r(M, S || i, n);\n          e.x = D.x + D.dx * A, e.y = c + D.y, e.hheight = M + d, e.hwidth = Math.max.apply(Math, e.rows.rowWidths) / 2 + d, e.lineHeight = l, e.lineHeightM = u, e.visible = !0, e.measureComplete(!0), a.borderRadius > 0 && (e.hwidth += .45 * Math.min(a.borderRadius, e.hheight));\n        }, t.prototype.addLine = function (t, e, i, n, r) {\n          r && (i = i.replace(/\\s+$/g, \"\") + \"…\");\n          var s = e.style.textStyle,\n              a = H.getTextWidth(t, s, i);\n          null == e.rows && (e.rows = {\n            rowWidths: [],\n            subLines: []\n          }), e.rows.rowWidths.push(a), e.rows.subLines.push({\n            font: s.font,\n            row: n,\n            text: i,\n            width: a\n          });\n        }, t.prototype.getIncludingPart = function (t, e, i, n, r, s) {\n          if (i.length <= 1) {\n            var a = H.getTextWidth(t, e, i);\n            return s + a <= r && (n += i), n;\n          }\n\n          var o = i.slice(0, i.length / 2),\n              l = H.getTextWidth(t, e, o);\n          if (s + l <= r && (n += o), s + l === r) return n;\n\n          if (s + l < r) {\n            var h = i.slice(i.length / 2, i.length);\n            return s += l, this.getIncludingPart(t, e, h, n, r, s);\n          }\n\n          return this.getIncludingPart(t, e, o, n, r, s);\n        }, t;\n      }();\n\n      V._spaceWidth = {}, r.LabelLayoutBase = V;\n\n      var j = function () {\n        function t(t, e, i, n) {\n          this.labelEnabled = null, this.labelDisabled = null, this.groupId = null, this.hoverCount = 0, this.enabled = !0, this.labelText = t, this.textColorEnabled = e, this.textColorDisabled = i, this.groupId = n;\n        }\n\n        return t.prototype.isHovered = function () {\n          return this.hoverCount > 0;\n        }, t.prototype.isEnabled = function () {\n          return this.enabled;\n        }, t;\n      }();\n\n      r.LegendEntry = j;\n\n      var W = function () {\n        function t() {\n          this.enabled = !1, this.width = null, this.height = null, this.minWidth = null, this.minHeight = null, this.numberOfRows = null, this.numberOfColumns = null, this.margin = 1, this.padding = 5, this.maxLineSymbols = 15, this.lineSpacing = .2, this.text = {\n            font: \"12px Arial\",\n            fillColor: \"#000\"\n          }, this.marker = new _(), this.equalizeRowsColumns = !0, this.panel = new q(\"left\", \"fill\", 1), this.advanced = new Y(), this.interaction = new Z();\n        }\n\n        return t;\n      }();\n\n      r.SettingsLegend = W;\n\n      var Z = function () {\n        function t() {\n          this.click = !0;\n        }\n\n        return t;\n      }();\n\n      r.SettingsLegendInteraction = Z;\n\n      var Y = function () {\n        function t() {\n          this.selectedBackground = \"rgba(208,233,255,0.3)\", this.selectedBorder = \"rgba(208,233,255,0.3)\";\n        }\n\n        return t;\n      }();\n\n      r.SettingsLegendAdvanced = Y;\n\n      var q = function (t) {\n        function e(e, i, n, r, s) {\n          var a = t.call(this, e, i, n, r) || this;\n          return a.padding = 0, void 0 !== s && (a.padding = s), a;\n        }\n\n        return n(e, t), e;\n      }(r.SettingsChartPanel);\n\n      r.SettingsLegendPanel = q;\n\n      var _ = function () {\n        function t() {\n          this.size = 20, this.alignment = \"left\", this.lineColor = \"#fff\";\n        }\n\n        return t;\n      }();\n\n      r.SettingsLegendMarker = _;\n\n      var X = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 300, i.entries = [], i.hoverPointers = {}, i.hoverOrder = [], i.entryWidth = 0, i.textHeight = 0, i.columns = null, i.rows = null, i.contentWidth = 0, i.contentHeight = 0, i.markerSize = 0, i.drawingEntries = 0, i.lastInsensitive = !1, i.needsMeasure = !1, i.chart = e, i.settings = e.settings.legend, i.panel = new A(), i.panel.packingOrder = 50, i.panel.location = \"outside\", i.panel.computeSize = function (t, e, n, r) {\n            return i.computePanelSize(t, e, n, r);\n          }, d.extendDeep(i.panel, i.settings.panel), i.orientation = \"left\" === i.settings.panel.side || \"right\" === i.settings.panel.side ? \"vertical\" : \"horizontal\", i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          var e = t.changes;\n          e.settings && e.settingsChanges.legend && (e.bounds = !0, d.extendDeep(this.panel, this.settings.panel));\n        }, e.prototype.getPanels = function () {\n          return this.settings.enabled ? [this.panel] : [];\n        }, e.prototype.computePanelSize = function (t, e, i, n) {\n          if (this.needsMeasure = !1, !this.settings.enabled || 0 === this.entries.length || !this.chart.assetsLoaded) return {\n            width: 0,\n            height: 0\n          };\n\n          for (var r = H.getTextWidth(i, this.settings.text, \"M\") * this.settings.maxLineSymbols, s = 0, a = this.settings.numberOfRows, o = this.settings.numberOfColumns, l = 2 * (this.settings.margin + this.settings.padding), h = 2 * (this.settings.panel.margin + this.settings.panel.padding), u = 0; u < this.entries.length; u++) {\n            var c = this.entries[u],\n                d = {\n              lineSpacing: this.settings.lineSpacing,\n              textStyle: this.settings.text,\n              text: c.labelText,\n              maxWidth: r,\n              align: \"left\",\n              padding: 0,\n              aspectRatio: null\n            };\n            c.labelEnabled = new U(d), c.labelEnabled.style.textStyle.fillColor = c.textColorEnabled, c.labelDisabled = new U(d), c.labelDisabled.style.textStyle.fillColor = c.textColorDisabled, n.measure(i, c.labelEnabled), n.measure(i, c.labelDisabled), s = Math.max(s, 2 * c.labelEnabled.hheight, 2 * c.labelDisabled.hheight);\n          }\n\n          this.textHeight = this.entries[0].labelEnabled.lineHeight, this.markerSize = this.settings.marker.size || this.textHeight, s = Math.max(s, this.markerSize), this.entryHeight = Math.max(s, this.markerSize) + l, this.entryWidth = r + this.markerSize + this.settings.padding + l;\n          var p,\n              f,\n              g = (this.settings.width > 0 ? Math.min(t, Math.max(this.settings.width, this.entryWidth) + h) : t) - h,\n              v = (this.settings.height > 0 ? Math.min(e, Math.max(this.settings.height, this.entryHeight) + h) : e) - h;\n\n          if (\"vertical\" === this.orientation) {\n            this.rows = Math.floor(v / this.entryHeight);\n            var m = Math.min(Math.ceil(this.entries.length / this.rows), Math.max(1, Math.floor(g / this.entryWidth)));\n            this.columns = o > 0 ? Math.min(o, m) : m, this.drawingEntries = Math.min(Math.floor(v / this.entryHeight) * this.columns, this.entries.length), f = this.columns * this.entryWidth, this.drawingEntries > this.rows ? (this.settings.equalizeRowsColumns && (this.rows = Math.ceil(this.drawingEntries / this.columns)), p = this.rows * this.entryHeight) : p = this.drawingEntries * this.entryHeight;\n          }\n\n          if (\"horizontal\" === this.orientation) {\n            this.columns = Math.floor(g / this.entryWidth);\n            var y = Math.min(Math.ceil(this.entries.length / this.columns), Math.max(1, Math.floor(v / this.entryHeight)));\n            this.rows = a > 0 ? Math.min(a, y) : y, this.drawingEntries = Math.min(Math.floor(g / this.entryWidth) * this.rows, this.entries.length), p = this.rows * this.entryHeight, this.drawingEntries > this.columns ? (this.settings.equalizeRowsColumns && (this.columns = Math.ceil(this.drawingEntries / this.rows)), f = this.columns * this.entryWidth) : f = this.drawingEntries * this.entryWidth;\n          }\n\n          if (f <= 0 || p <= 0) return {\n            width: this.settings.minWidth ? this.settings.minWidth : 0,\n            height: this.settings.minHeight ? this.settings.minHeight : 0\n          };\n          this.contentHeight = p, this.contentWidth = f;\n          var S = this.settings.panel.padding;\n          return this.resetHovers(), {\n            width: Math.max(this.settings.minWidth ? this.settings.minWidth : 0, f + 2 * S),\n            height: Math.max(this.settings.minHeight ? this.settings.minHeight : 0, p + 2 * S)\n          };\n        }, e.prototype.paintScene = function (t) {\n          if (!(this.needsMeasure || !this.settings.enabled || this.entries.length < 1 || this.drawingEntries < 1)) {\n            this.lastInsensitive = !1;\n\n            for (var e = t.context, i = t.labelRenderer, n = this.panel.top, s = this.panel.left, a = this.settings.margin, o = this.settings.padding, l = this.settings.panel.padding, h = 0, u = 0, c = 0; c < this.drawingEntries; c++) {\n              var d = l + a,\n                  p = s + d + h * this.entryWidth,\n                  f = n + d + u * this.entryHeight,\n                  g = this.entries[c],\n                  v = g.isEnabled() ? g.labelEnabled : g.labelDisabled,\n                  m = void 0,\n                  y = void 0;\n              \"right\" === this.settings.marker.alignment ? (m = p + o + v.hwidth, y = p + this.entryWidth - 2 * (a + o) - this.markerSize / 2) : (m = p + this.markerSize + 2 * o + v.hwidth, y = p + o + this.markerSize / 2);\n              var S = v.hheight > this.markerSize / 2 ? 0 : this.markerSize / 2 - this.textHeight / 2,\n                  b = f + o + this.markerSize / 2,\n                  x = f + S + o + v.hheight;\n\n              if (this.drawingEntries < this.entries.length && c + 1 === this.drawingEntries) {\n                this.lastInsensitive = !0, r.Graphics.resetTextStyle(e), e.fillStyle = \"#000\", e.textAlign = \"left\", e.font = \"bold 12px Arial\", e.fillText(\". . .\", m - v.hwidth, x);\n                break;\n              }\n\n              if (g.isHovered() && this.rect(e, p, f, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * a, this.entryHeight - 2 * a), i.paint(e, m, x, 1, v), this.paintMarker(t, y, b, this.markerSize / 2, g), \"vertical\" === this.orientation) {\n                if (u += 1, u === this.rows && (u = 0, h += 1), h === this.columns) break;\n              } else if (h += 1, h === this.columns && (h = 0, u += 1), u === this.rows) break;\n            }\n          }\n        }, e.prototype.findItemAt = function (t, e) {\n          if (0 === this.entries.length) return null;\n          var i = this.panel.top + this.settings.panel.padding,\n              n = this.panel.left + this.settings.panel.padding,\n              r = t < n || t > n + this.contentWidth || e < i || e > i + this.contentHeight;\n          if (r) return null;\n          var s,\n              a,\n              o = \"vertical\" === this.orientation ? Math.abs(this.contentHeight / this.entryHeight) : Math.abs(this.contentWidth / this.entryWidth);\n          \"vertical\" === this.orientation ? (s = Math.floor((t - n) / this.entryWidth), a = Math.floor((e - i) / this.entryHeight)) : (s = Math.floor((e - i) / this.entryHeight), a = Math.floor((t - n) / this.entryWidth));\n          var l = Math.floor(o * s + a);\n          return l > this.drawingEntries - 1 ? null : this.lastInsensitive && l === this.drawingEntries - 1 ? null : this.entries[l];\n        }, e.prototype.rect = function (t, e, i, n, r, s, a) {\n          t.beginPath(), t.rect(e, i, s, a), t.fillStyle = r, t.fill(), t.lineWidth = 1, t.strokeStyle = n, t.stroke();\n        }, e.prototype.resetEntries = function (t) {\n          this.entries = t, this.needsMeasure = !0;\n        }, e.prototype.getLastHoveredEntry = function () {\n          return this.hoverOrder.length < 1 ? null : this.hoverOrder[this.hoverOrder.length - 1].entry;\n        }, e.prototype.resetHovers = function () {\n          for (var t = this.hoverOrder.length - 1; t >= 0; t--) {\n            var e = this.hoverOrder[t],\n                i = this.findItemAt(e.lastX, e.lastY);\n            e.entry !== i && (i ? (this.itemUnhovered(null, e.entry), e.entry = i, this.itemHovered(null, i)) : (this.itemUnhovered(null, e.entry), delete this.hoverPointers[e.id], this.hoverOrder.splice(t, 1)));\n          }\n        }, e.prototype.pointerHoverIn = function (t) {\n          var e = this.hoverPointers[t.identifier],\n              i = this.findItemAt(t.x, t.y);\n          return i ? (this.settings.interaction.click && (t.cursor = \"pointer\"), void (e ? (e.lastX = t.x, e.lastY = t.y, e.entry !== i && (this.itemUnhovered(t, e.entry), e.entry = i, this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1), this.hoverOrder.push(e), this.itemHovered(t, i))) : (e = {\n            id: t.identifier,\n            lastX: t.x,\n            lastY: t.y,\n            entry: i\n          }, this.hoverPointers[t.identifier] = e, this.hoverOrder.push(e), this.itemHovered(t, i)))) : void (e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1)));\n        }, e.prototype.pointerHoverOut = function (t) {\n          var e = this.hoverPointers[t.identifier];\n          e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1));\n        }, e.prototype.itemHovered = function (t, e) {\n          e.hoverCount++, 1 === e.hoverCount && this.chart.events.notifySceneChanges({\n            hover: !0\n          });\n        }, e.prototype.itemUnhovered = function (t, e) {\n          e.hoverCount--, 0 === e.hoverCount && this.chart.events.notifySceneChanges({\n            hover: !0\n          });\n        }, e.prototype.itemClicked = function (t, e) {\n          if (this.chart.events.requestPaint(), this.chart.notifyChartUpdate(\"user\", !0), t.consumed = !0, t.preventDefault(), null == e.groupId || !e.enabled) return void (e.enabled = !e.enabled);\n          var i = this.entries.filter(function (t) {\n            return t.groupId === e.groupId;\n          });\n          if (i.length < 2) return void (e.enabled = !e.enabled);\n\n          for (var n = !1, r = !1, s = 0; s < i.length; s++) {\n            if (i[s] !== e) if (i[s].enabled) {\n              if (n = !0, r) break;\n            } else if (r = !0, n) break;\n          }\n\n          if (n) {\n            if (r) e.enabled = !e.enabled;else for (var s = 0; s < i.length; s++) {\n              i[s] !== e && (i[s].enabled = !1);\n            }\n          } else for (var s = 0; s < i.length; s++) {\n            i[s].enabled = !0;\n          }\n        }, e.prototype.previewPointerMove = function (t) {\n          this.pointerHoverIn(t);\n        }, e.prototype.previewPointerCancel = function (t) {\n          this.pointerHoverOut(t);\n        }, e.prototype.previewPointerOut = function (t) {\n          this.pointerHoverOut(t);\n        }, e.prototype.previewPointerUp = function (t) {\n          t.touch ? this.pointerHoverOut(t) : this.pointerHoverIn(t);\n        }, e.prototype.previewPointerDown = function (t) {\n          this.pointerHoverIn(t), this.settings.interaction.click && this.hoverPointers[t.identifier] && (t.consumed = !0);\n        }, e.prototype.previewInstantClick = function (t) {\n          if (this.settings.interaction.click) {\n            var e = this.findItemAt(t.x, t.y);\n            e && this.itemClicked(t, e);\n          }\n        }, e;\n      }(k);\n\n      r.Legend = X, function (t) {\n        var e = function () {\n          function t(t, e) {\n            this.chart = t, this.domElement = null, e instanceof K ? this.options = e : (this.options = new K(), st.updateRecursive(this.options, e, nt.BaseSettingsToolbarItem, {}));\n          }\n\n          return t.prototype.onSceneChange = function (t) {}, t.prototype.doAnimations = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t;\n        }();\n\n        t.Item = e;\n\n        var i = function (t) {\n          function e(e, i, n, r) {\n            void 0 === r && (r = !0);\n            var s = t.call(this, e, i) || this;\n            return s.captureClick = r, s.onClickProxy = function (t) {\n              return s.onClick(t);\n            }, s.createButton(n), s;\n          }\n\n          return n(e, t), e.prototype.createButton = function (t) {\n            this.domElement = d.createDom(\"li\", null, null, null), this.a = d.createDom(\"a\", null, null, this.domElement), this.p = t ? this.a : d.createDom(\"p\", null, null, this.a), d.listen(this.a, \"click\", this.onClickProxy), this.updateSettings();\n          }, e.prototype.updateSettings = function () {\n            var t = this.options,\n                e = t.title || t.label || \"\",\n                i = t.image;\n            this.a.title = e;\n            var n = \"DVSL-bar-btn \" + (t.cssClass ? t.cssClass : i ? \"DVSL-bar-btn-image\" : \"DVSL-bar-btn-none\");\n            t.enabled || (n += \" DVSL-bar-disabled\"), this.a.className = n, this.p.innerHTML = t.showLabel !== !1 && t.label || \"\", this.p.style.backgroundImage = i ? 'url(\"' + encodeURI(i) + '\")' : null;\n          }, e.prototype.remove = function () {\n            d.unlisten(this.a, \"click\", this.onClickProxy);\n          }, e.prototype.onClick = function (t) {\n            var e = this.options;\n            e.enabled && e.onClick && (e.onClick(t, this.chart.api), this.captureClick && d.stopPropagation(t));\n          }, e;\n        }(e);\n\n        t.Button = i;\n\n        var s = function (t) {\n          function e(e, i) {\n            return t.call(this, e, i) || this;\n          }\n\n          return n(e, t), e.prototype.createButton = function () {\n            t.prototype.createButton.call(this), d.createDom(\"span\", null, null, this.a), d.addClass(this.a, \"DVSL-bar-show-more\");\n          }, e.prototype.buildDropdownList = function () {\n            return [];\n          }, e.prototype.onHideDropdown = function () {}, e.prototype.onClick = function (e) {\n            this.dropdown ? this.hideDropdown() : this.showDropdown(), t.prototype.onClick.call(this, e), d.stopPropagation(e);\n          }, e.prototype.showDropdown = function () {\n            var t = this.dropdown = d.createDom(\"div\", \"DVSL-bar-dropdown\", null, this.domElement);\n            t.style.display = \"block\";\n\n            for (var e = d.createDom(\"ul\", null, null, t), i = this.buildDropdownList(), n = 0; n < i.length; n++) {\n              var s = i[n];\n              e.appendChild(s);\n            }\n\n            var a = t.getBoundingClientRect();\n            if (a.top < 0) t.style.marginBottom = r.Helpers.trunc(a.top) + \"px\", t.className += \" DVSL-no-triangle\";else {\n              var o = Math.max(window.innerHeight - a.bottom, -a.top);\n              o < 0 && (t.style.marginTop = r.Helpers.trunc(o) + \"px\", t.className += \" DVSL-no-triangle\");\n            }\n          }, e.prototype.hideDropdown = function () {\n            this.onHideDropdown(), this.dropdown.parentNode.removeChild(this.dropdown), this.dropdown = null, this.chart.shell && this.chart.shell.forceChromeRedraw();\n          }, e.prototype.previewPointerDown = function (t) {\n            var e = d.isParentOf(this.domElement, t.target);\n\n            if (this.dropdown && !e) {\n              var i = d.elementPos(this.chart.shell.interactiveContainer),\n                  n = i.left,\n                  r = i.top;\n              i = d.elementPos(this.dropdown);\n              var s = i.left,\n                  a = i.top;\n              s -= n, a -= r;\n              var o = s + this.dropdown.offsetWidth,\n                  l = a + this.dropdown.offsetHeight;\n              (s > t.x || a > t.y || l < t.y || o < t.x) && this.hideDropdown();\n            }\n          }, e;\n        }(i);\n\n        t.DropdownBase = s;\n\n        var a = function (e) {\n          function i(i, n) {\n            var r = e.call(this, i, n) || this;\n            r.htmlItems = [], r.clickProxy = function () {\n              r.hideDropdown();\n            };\n            var s = n.dropDownItems;\n            r.items = new Array(s.length);\n\n            for (var a = 0; a < s.length; a++) {\n              r.items[a] = new t.Button(i, s[a], !0, !1);\n            }\n\n            return r;\n          }\n\n          return n(i, e), i.prototype.buildDropdownList = function () {\n            this.htmlItems = new Array(this.items.length);\n\n            for (var t = 0; t < this.items.length; t++) {\n              var e = this.items[t];\n              d.listen(e.domElement, \"click\", this.clickProxy), this.htmlItems[t] = e.domElement;\n            }\n\n            return this.htmlItems;\n          }, i.prototype.onHideDropdown = function () {\n            if (this.htmlItems) {\n              for (var t = 0; t < this.htmlItems.length; t++) {\n                var e = this.htmlItems[t];\n                e.parentNode.removeChild(e), d.unlisten(e, \"click\", this.clickProxy);\n              }\n\n              this.htmlItems = null;\n            }\n          }, i;\n        }(s);\n\n        t.Dropdown = a;\n\n        var o = function (t) {\n          function e(e, i) {\n            var n = t.call(this, e, i) || this;\n            return n._lastLabel = \"\", n;\n          }\n\n          return n(e, t), e.prototype.buildDropdownList = function () {\n            for (var t = this, e = [], i = 0, n = this.getItems(); i < n.length; i++) {\n              var r = n[i],\n                  s = d.createDom(\"li\", null, null, null),\n                  a = d.createDom(\"a\", null, r.name, s);\n              r.selected && (a.className = \"DVSL-bar-dropdown-active\"), r.disabled ? a.className = \"DVSL-bar-dropdown-disabled\" : !function (e, i) {\n                return d.listen(e, \"click\", function () {\n                  return t.userSelected(i);\n                });\n              }(a, r), e.push(s);\n            }\n\n            return e;\n          }, e.prototype.userSelected = function (t) {\n            this.hideDropdown(), this.setSelectedItem(t), this.onSelectionChange(t);\n          }, e.prototype.setSelectedItem = function (t) {\n            var e = t.name || \"\";\n            this.options.showLabel !== !1 && this._lastLabel !== e && (this.p.innerHTML = this._lastLabel = e);\n          }, e;\n        }(s);\n\n        t.Combobox = o;\n\n        var l = function (t) {\n          function e(e, i, n) {\n            var r = t.call(this, e, i) || this;\n            return r.additionalOptions = n, r.curState = null, r.onSceneChange({}), r;\n          }\n\n          return n(e, t), e.prototype.onSceneChange = function (t) {\n            var e = this.additionalOptions.getChartState();\n\n            if (e !== this.curState) {\n              var i = this.options,\n                  n = this.additionalOptions;\n              this.curState = e, i.cssClass = e && n.cssClassEnabled || n.cssClassDisabled, i.label = e && n.labelEnabled || n.labelDisabled, i.title = e && n.titleEnabled || n.titleDisabled, this.updateSettings();\n            }\n          }, e.prototype.onClick = function (e) {\n            this.options.enabled && (this.curState ? this.additionalOptions.onDisable() : this.additionalOptions.onEnable()), this.onSceneChange(null), t.prototype.onClick.call(this, e), d.stopPropagation(e);\n          }, e;\n        }(i);\n\n        t.ToggleButton = l, t.ToolbarItemNames = {};\n      }(o = r.Bar || (r.Bar = {}));\n\n      var Q = function () {\n        function t(t, e, i, n, r) {\n          void 0 === t && (t = !1), this.enabled = !1, this.location = \"auto\", this.side = \"top\", this.align = \"right\", this.showLabels = !0, this.cssClass = null, this.items = [], this.extraItems = [], this.back = !0, this.export = !0, this.fullscreen = !1, this.exportOptions = null, this.zoomOut = !1, this.enabled = t, void 0 !== e && (this.items = e), void 0 !== i && (this.side = i), void 0 !== n && (this.align = n), void 0 !== r && (this.showLabels = r);\n        }\n\n        return t;\n      }();\n\n      r.SettingsToolbar = Q;\n\n      var J = function () {\n        function t() {\n          this.label = null, this.title = null, this.image = null, this.enabled = !0, this.onClick = null, this.cssClass = null;\n        }\n\n        return t;\n      }();\n\n      r.SettingsToolbarItemBase = J;\n\n      var K = function (t) {\n        function e(e, i, n, r) {\n          var s = t.call(this) || this;\n          return s.location = void 0, s.side = void 0, s.align = void 0, s.showLabel = void 0, s.item = null, s.dropDownItems = null, void 0 !== e && (s.item = e), void 0 !== i && (s.align = i), void 0 !== n && (s.side = n), void 0 !== r && (s.location = r), s;\n        }\n\n        return n(e, t), e;\n      }(J);\n\n      r.SettingsToolbarItem = K;\n\n      var $ = function (t) {\n        function e(e, i) {\n          var n = t.call(this) || this;\n          return n.panels = {}, n.panelList = [], n.items = [], n.animationOrder = 2e3, n.options = i, n.chart = e, n.scene = n.chart.scene, n.addItems(), n.chart.events.addElement(n), n.chart.events.notifySceneChanges({\n            bounds: !0\n          }), n;\n        }\n\n        return n(e, t), e.prototype.rebuildItems = function () {\n          this.removeItems(), this.addItems();\n        }, e.prototype.addItems = function () {\n          if (this.options.enabled) {\n            for (var t = 0; t < this.options.items.length; t++) {\n              var e = this.options.items[t];\n              this.addItem(e);\n            }\n\n            for (var t = 0; t < this.options.extraItems.length; t++) {\n              var e = this.options.extraItems[t];\n              this.addItem(e);\n            }\n          }\n        }, e.prototype.removeItems = function () {\n          for (var t = 0; t < this.items.length; t++) {\n            var e = this.items[t];\n            e.remove();\n          }\n\n          for (var i = 0; i < this.panelList.length; i++) {\n            var n = this.panelList[i];\n            n.clear();\n          }\n\n          this.items = [];\n        }, e.prototype.remove = function () {\n          this.removeItems();\n\n          for (var t = 0; t < this.panelList.length; t++) {\n            var e = this.panelList[t];\n            e.remove();\n          }\n\n          this.chart.events.removeElement(this);\n        }, e.prototype.addItem = function (t) {\n          var e = this.generateToolbarOptions(),\n              i = this.createItemOptions(e, t),\n              n = this.findOrCreatePanel(i);\n          null != i.showLabel || !n.hideLabels && e.showLabels || (i.showLabel = !1);\n          var r;\n\n          if (null != i.item) {\n            var s = i.item;\n            if (e[s] === !1) return;\n            if (!o.ToolbarItemNames.hasOwnProperty(s)) return void this.chart.error(\"Toolbar item name '\" + s + \"' not recognized.\");\n            r = o.ToolbarItemNames[s](this.chart, i);\n          } else r = i.dropDownItems ? new o.Dropdown(this.chart, i) : new o.Button(this.chart, i);\n\n          n.addItem(r, i.align), this.items.push(r);\n        }, e.prototype.findOrCreatePanel = function (t) {\n          var e,\n              i = t.location + t.side;\n          return this.panels.hasOwnProperty(i) ? e = this.panels[i] : (e = new tt(this, t.location, t.side, this.chart), this.panelList.push(e), this.panels[i] = e), e;\n        }, e.prototype.createItemOptions = function (t, e) {\n          var i;\n          return d.isString(e) ? i = new K(e, t.align, t.side, t.location) : (i = d.clone(e), i.side = this.convertSideIfHorizontal(i.side), i.align = i.align || t.align, i.side = i.side || t.side, i.location = i.location || t.location), i;\n        }, e.prototype.generateToolbarOptions = function () {\n          var t = d.clone(this.options);\n          return t.side = this.convertSideIfHorizontal(t.side), t.location = this.determineLocationIfAuto(t), t;\n        }, e.prototype.determineLocationIfAuto = function (t) {\n          return \"auto\" !== t.location ? t.location : this.isChartHorizontal() ? \"outside\" : \"inside\";\n        }, e.prototype.convertSideIfHorizontal = function (t) {\n          return this.isChartHorizontal() ? \"top\" === t ? \"left\" : \"left\" === t ? \"top\" : \"right\" === t ? \"bottom\" : \"bottom\" === t ? \"right\" : t : t;\n        }, e.prototype.isChartHorizontal = function () {\n          var t = this.chart.settings;\n          return !!t.hasOwnProperty(\"horizontal\") && t.horizontal;\n        }, e.prototype.getPanels = function () {\n          return this.panelList;\n        }, e.prototype.onSceneChange = function (t) {\n          for (var e = 0; e < this.items.length; e++) {\n            var i = this.items[e];\n            i.onSceneChange(t.changes);\n          }\n        }, e.prototype.doAnimations = function (t) {\n          for (var e = 0; e < this.items.length; e++) {\n            var i = this.items[e];\n            i.doAnimations(t);\n          }\n        }, e.prototype.previewGlobalPointerDown = function (t) {\n          for (var e = 0; e < this.items.length; e++) {\n            this.items[e].previewPointerDown(t);\n          }\n        }, e;\n      }(k);\n\n      r.Toolbar = $;\n\n      var tt = function (t) {\n        function e(e, i, n, r) {\n          var s = t.call(this) || this;\n          s.hideLabels = !1, s.chart = r, s.side = n, s.location = i, s.toolbar = e, s.packingOrder = \"inside\" === i ? 1e3 : 15, s.container = s.toolbar.chart.shell.menuContainer, s.floating = !1, s.align = \"fill\";\n          var a = e.options.cssClass ? e.options.cssClass + \" \" : \"\";\n          return \"top\" === s.side ? (s.vertical = !1, s.leftPanel = d.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal\", null, s.container), s.rightPanel = d.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal\", null, s.container)) : \"bottom\" === s.side ? (s.vertical = !1, s.leftPanel = d.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal\", null, s.container), s.rightPanel = d.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal\", null, s.container)) : \"left\" === s.side ? (s.vertical = !0, s.leftPanel = d.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-top DVSL-bar-vertical\", null, s.container), s.rightPanel = d.createDom(\"ul\", a + \"DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical\", null, s.container)) : \"right\" === s.side ? (s.vertical = !0, s.leftPanel = d.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-top DVSL-bar-vertical\", null, s.container), s.rightPanel = d.createDom(\"ul\", a + \"DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical\", null, s.container)) : s.chart.error(\"Unrecognized side: '\" + s.side + \"'\"), s.leftPanel.style.visibility = \"hidden\", s.rightPanel.style.visibility = \"hidden\", s;\n        }\n\n        return n(e, t), e.prototype.addItem = function (t, e) {\n          \"left\" === e || \"top\" === e ? this.leftPanel.appendChild(t.domElement) : \"right\" === e || \"bottom\" === e ? this.rightPanel.appendChild(t.domElement) : this.chart.error(\"Unrecognized align: '\" + e + \"'\");\n        }, e.prototype.clear = function () {\n          this.leftPanel.innerHTML = \"\", this.rightPanel.innerHTML = \"\";\n        }, e.prototype.computeSize = function (t, e, i) {\n          var n = 0;\n\n          if (\"outside\" === this.location) {\n            var r = d.getRelativeClientRect(this.leftPanel),\n                s = d.getRelativeClientRect(this.rightPanel);\n            this.leftPanel && r && (n += r.left), this.rightPanel && s && (n += s.right);\n          }\n\n          if (!this.vertical) {\n            if (!this.hideLabels) {\n              this.contentWidthWithLabels = this.leftPanel.offsetWidth + this.rightPanel.offsetWidth;\n\n              for (var a = this.rightPanel.getElementsByTagName(\"li\"), o = this.leftPanel.getElementsByTagName(\"li\"), l = 0, h = 0; h < a.length; h++) {\n                l += a[h].offsetWidth;\n              }\n\n              for (var h = 0; h < o.length; h++) {\n                l += o[h].offsetWidth;\n              }\n\n              this.contentWidthWithLabels = l;\n            }\n\n            var u = t - this.contentWidthWithLabels - n,\n                c = this.contentWidthWithLabels > 0 && u < 0;\n            c !== this.hideLabels && (c === !0 ? this.container.className.indexOf(\"DVSL-menu-narrow\") === -1 && (this.container.className += \" DVSL-menu-narrow\") : this.container.className.indexOf(\"DVSL-menu-narrow\") > -1 && (this.container.className = this.container.className.replace(/ ?DVSL-menu-narrow/, \"\")), this.hideLabels = c);\n          }\n\n          var p = Math.max(this.leftPanel.offsetWidth, this.rightPanel.offsetWidth),\n              f = Math.max(this.leftPanel.offsetHeight, this.rightPanel.offsetHeight);\n          return this.vertical ? {\n            width: this.isChartHorizontal() ? f : p,\n            height: 0\n          } : {\n            width: 0,\n            height: this.isChartHorizontal() ? p : f\n          };\n        }, e.prototype.isChartHorizontal = function () {\n          return this.toolbar.isChartHorizontal();\n        }, e.prototype.placePanel = function (t, e, i, n) {\n          var r = this.leftPanel,\n              s = this.rightPanel,\n              a = r.style,\n              o = s.style,\n              l = \"px\",\n              h = this.toolbar.scene,\n              u = h.chartHeight,\n              c = h.chartWidth,\n              d = a,\n              p = o;\n          if (this.vertical) this.setPanelStyleTop(d, p, e + l), this.setPanelStyleBottom(p, d, u - n + l), \"left\" === this.side ? (this.setPanelStyleLeft(d, p, t + l), this.setPanelStyleLeft(p, d, t + l)) : (this.setPanelStyleRight(d, p, c - i + l), this.setPanelStyleRight(p, d, c - i + l));else {\n            this.setPanelStyleLeft(d, p, t + l), this.setPanelStyleRight(p, d, c - i + l);\n            var f = \"top\" === this.side;\n\n            if (f ? (this.setPanelStyleTop(d, p, e + l), this.setPanelStyleTop(p, d, e + l)) : (this.setPanelStyleBottom(d, p, u - n + l), this.setPanelStyleBottom(p, d, u - n + l)), this.hideLabels) {\n              var g = r.offsetLeft + r.offsetWidth;\n              o.marginLeft = g + \"px\", s.offsetLeft < g && (f ? o.top = e + r.offsetHeight + l : o.bottom = u - n + r.offsetHeight + l);\n            }\n          }\n          r.offsetWidth > 0 && (a.visibility = \"visible\"), s.offsetWidth > 0 && (o.visibility = \"visible\");\n        }, e.prototype.setPanelStyleLeft = function (t, e, i) {\n          this.setPanelStyleSide(t, e, i, !0, !0);\n        }, e.prototype.setPanelStyleRight = function (t, e, i) {\n          this.setPanelStyleSide(t, e, i, !0, !1);\n        }, e.prototype.setPanelStyleTop = function (t, e, i) {\n          this.setPanelStyleSide(t, e, i, !1, !0);\n        }, e.prototype.setPanelStyleBottom = function (t, e, i) {\n          this.setPanelStyleSide(t, e, i, !1, !1);\n        }, e.prototype.setPanelStyleSide = function (t, e, i, n, r) {\n          var s = this.isChartHorizontal();\n          s ? n ? r ? t.top = i : t.bottom = i : r ? e.right = i : e.left = i : n ? r ? t.left = i : t.right = i : r ? t.top = i : t.bottom = i;\n        }, e.prototype.remove = function () {\n          this.container.removeChild(this.leftPanel), this.container.removeChild(this.rightPanel);\n        }, e;\n      }(A);\n\n      r.ToolbarPanel = tt;\n\n      var et = function () {\n        function t() {\n          this.enabled = !0, this.fixedAspect = !1, this.visibilityDistance = 45, this.grabDistance = 10;\n        }\n\n        return t;\n      }();\n\n      r.SettingsResizer = et;\n\n      var it = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 300, i.oh = 0, i.sy = 0, i.barVisible = !1, i.resizing = !1, i.aspect = null, i.chart = e, i.scene = i.chart.scene, i.options = i.scene.settings.interaction.resizing, i.resizerBar = r.Helpers.createDom(\"div\", \"DVSL-resizer\", null, i.chart.shell.interactiveContainer), i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          this.options.enabled || this.hideUI();\n        }, e.prototype.doAnimations = function (t) {\n          t.changes.bounds && this.resizerBar && (this.resizerBar.style.width = this.scene.chartWidth + \"px\");\n        }, e.prototype.onPointerOut = function (t) {\n          this.options.enabled && this.hideUI();\n        }, e.prototype.onPointerMove = function (t) {\n          if (this.options.enabled) {\n            var e = this.scene.chartHeight - t.y;\n            e < this.options.visibilityDistance ? (this.barVisible || this.showUI(), e < this.options.grabDistance && (t.consumed = !0, t.cursor = \"ns-resize\")) : this.barVisible && this.hideUI();\n          }\n        }, e.prototype.onPointerDown = function (t) {\n          if (this.options.enabled) {\n            this.sy = t.y;\n            var e = this.scene.chartHeight - t.y;\n            this.resizing = e < this.options.grabDistance && t.y <= this.scene.chartHeight, this.resizing && (this.options.fixedAspect ? this.aspect = Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight) : this.aspect = 0, this.oh = this.scene.chartHeight, this.showUI(), t.cursor = \"ns-resize\", t.consumed = !0);\n          }\n        }, e.prototype.onDoubleClick = function (t) {\n          this.resizing && this.chart.setFullscreen(!this.chart.isFullscreen());\n        }, e.prototype.onPointerDrag = function (t) {\n          if (this.options.enabled) if (this.chart.isFullscreen()) this.chart.setFullscreen(!1), this.hideUI(), t.consumed = !0;else if (this.resizing) {\n            var e = this.scene.settings.area;\n            t.consumed = !0, this.wasMaximized = !1, e.height = Math.min(e.maxHeight, Math.max(e.minHeight, this.oh + (t.y - this.sy))), this.aspect && (e.width = e.height * this.aspect), this.chart.updateSize(!0);\n          }\n        }, e.prototype.showUI = function () {\n          this.barVisible || (this.barVisible = !0, this.resizerBar.style.display = \"block\");\n        }, e.prototype.hideUI = function () {\n          this.barVisible && (this.barVisible = !1, this.resizing = !1, this.resizerBar.style.display = \"none\");\n        }, e;\n      }(k);\n\n      r.Resizer = it;\n\n      var nt = function () {\n        function t() {}\n\n        return t;\n      }();\n\n      nt.BaseIChartErrorEventArguments = {}, nt.BaseIChartEventArguments = {}, nt.BaseIChartSettingsChangeEventArguments = {}, nt.BaseIDataErrorResponse = {\n        error: {\n          t: 0\n        }\n      }, nt.BaseIDataObjectBase = {\n        extra: {\n          t: 10\n        }\n      }, nt.BaseISettingsClassMap = {}, nt.BaseSettings = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsAdvanced;\n          },\n          x: function x() {\n            return i.Base.SettingsAdvanced;\n          }\n        },\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsArea;\n          },\n          x: function x() {\n            return i.Base.SettingsArea;\n          }\n        },\n        assetsUrlBase: {\n          t: 0\n        },\n        callbacks: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsCallbacks;\n          },\n          x: function x() {\n            return i.Base.SettingsCallbacks;\n          }\n        },\n        container: {\n          t: 3\n        },\n        credits: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsCredits;\n          },\n          x: function x() {\n            return i.Base.SettingsCredits;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.BaseSettingsData;\n            },\n            x: function x() {\n              return i.Base.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsEvents(nt.BaseIChartEventArguments, nt.BaseIChartEventArguments);\n          },\n          x: function x() {\n            return i.Base.SettingsEvents;\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsInteraction;\n          },\n          x: function x() {\n            return i.Base.SettingsInteraction;\n          }\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegend;\n          },\n          x: function x() {\n            return i.Base.SettingsLegend;\n          }\n        },\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLocalization;\n          },\n          x: function x() {\n            return i.Base.SettingsLocalization;\n          }\n        },\n        parentChart: {\n          t: 5\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.BaseSettings;\n          },\n          x: function x() {\n            return i.Base.Settings;\n          },\n          y: !0\n        },\n        title: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTitle;\n          },\n          x: function x() {\n            return i.Base.SettingsTitle;\n          }\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsToolbar;\n          },\n          x: function x() {\n            return i.Base.SettingsToolbar;\n          }\n        }\n      }, nt.BaseSettingsAdvanced = {\n        assets: {\n          t: 6,\n          u: 3,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return {\n                  url: {\n                    t: 0\n                  },\n                  required: {\n                    t: 4\n                  }\n                };\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        crossOriginHeader: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        dataExportFunction: {\n          t: 4\n        },\n        exportPdfSize: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        exportProxyURL: {\n          t: 0,\n          d: 5\n        },\n        highDPI: {\n          t: 7,\n          b: [{\n            t: 9\n          }, {\n            t: 1\n          }]\n        },\n        labelCache: {\n          t: 9\n        },\n        labelCacheRotated: {\n          t: 9\n        },\n        logging: {\n          t: 9\n        },\n        maxCanvasHeight: {\n          t: 1,\n          d: 0\n        },\n        maxCanvasWidth: {\n          t: 1,\n          d: 0\n        },\n        pointer: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsAdvancedPointer;\n          },\n          x: function x() {\n            return i.Base.SettingsAdvancedPointer;\n          }\n        },\n        showFPS: {\n          t: 9\n        },\n        showTimestamp: {\n          t: 9\n        },\n        showTouchTrail: {\n          t: 9\n        },\n        showTouches: {\n          t: 9\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsAdvancedStyle;\n          },\n          x: function x() {\n            return i.Base.SettingsAdvancedStyle;\n          }\n        },\n        themeCSSClass: {\n          t: 0\n        },\n        useAnimationFrame: {\n          t: 9\n        }\n      }, nt.BaseSettingsAdvancedPointer = {\n        clickSensitivity: {\n          t: 1\n        },\n        doubleClickSensitivity: {\n          t: 1\n        },\n        doubleClickTimeout: {\n          t: 1,\n          d: 0\n        },\n        longPressSensitivity: {\n          t: 1,\n          d: 0\n        },\n        longPressTimeout: {\n          t: 1,\n          d: 0\n        },\n        mouseWheelRequiresFocus: {\n          t: 9\n        },\n        noClickOnDoubleClick: {\n          t: 9\n        },\n        scrollIntoView: {\n          t: 9\n        },\n        speedAveragingPeriod: {\n          t: 1,\n          d: 0\n        }\n      }, nt.BaseSettingsAdvancedStyle = {\n        loadingArcStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              lineColor: {\n                t: 0\n              },\n              lineWidth: {\n                t: 1\n              },\n              location: {\n                t: 0,\n                d: 6\n              },\n              r: {\n                t: 1\n              }\n            };\n          }\n        },\n        messageBackgroundStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsAdvancedStyleMessageBackground;\n          }\n        },\n        messageTextStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTextStyle;\n          }\n        }\n      }, nt.BaseSettingsAdvancedStyleMessageBackground = {\n        padding: {\n          t: 1\n        }\n      }, nt.BaseSettingsArea = {\n        height: {\n          t: 1\n        },\n        left: {\n          t: 1\n        },\n        maxHeight: {\n          t: 1\n        },\n        maxWidth: {\n          t: 1\n        },\n        minHeight: {\n          t: 1\n        },\n        minWidth: {\n          t: 1\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsAreaStyle;\n          },\n          x: function x() {\n            return i.Base.SettingsAreaStyle;\n          }\n        },\n        top: {\n          t: 1\n        },\n        width: {\n          t: 1\n        }\n      }, nt.BaseSettingsAreaStyle = {\n        fillColor: {\n          t: 0,\n          d: 3\n        },\n        image: {\n          t: 0,\n          d: 4\n        },\n        overlayColor: {\n          t: 0,\n          d: 3\n        }\n      }, nt.BaseSettingsBackgroundStyle = {\n        fillColor: {\n          t: 7,\n          b: [{\n            t: 14\n          }, {\n            t: 0\n          }]\n        },\n        shadowBlur: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0\n        },\n        shadowOffsetX: {\n          t: 1\n        },\n        shadowOffsetY: {\n          t: 1\n        }\n      }, nt.BaseSettingsCallbacks = {\n        renderFinish: {\n          t: 4\n        },\n        renderStart: {\n          t: 4\n        }\n      }, nt.BaseSettingsChartPanel = {\n        align: {\n          t: 0,\n          d: 6\n        },\n        floating: {\n          t: 9\n        },\n        location: {\n          t: 0,\n          d: 6\n        },\n        margin: {\n          t: 1\n        },\n        side: {\n          t: 0,\n          d: 6\n        }\n      }, nt.BaseSettingsCredits = {\n        enabled: {\n          t: 9\n        },\n        enabledOnExport: {\n          t: 9\n        },\n        image: {\n          t: 0,\n          d: 4\n        },\n        imageExport: {\n          t: 0,\n          d: 4\n        },\n        imageScaling: {\n          t: 1\n        },\n        location: {\n          t: 0,\n          d: 6\n        },\n        url: {\n          t: 0,\n          d: 5\n        },\n        urlTarget: {\n          t: 0\n        }\n      }, nt.BaseSettingsData = {\n        format: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        id: {\n          t: 0\n        },\n        numberOfParallelRequests: {\n          t: 1,\n          d: 0\n        },\n        postprocessorFunction: {\n          t: 4\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.BaseIDataErrorResponse;\n          }\n        },\n        requestTimeout: {\n          t: 1,\n          d: 0\n        },\n        url: {\n          t: 0,\n          d: 5\n        },\n        urlParameters: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return {\n                name: {\n                  t: 0\n                },\n                value: {\n                  t: 0\n                }\n              };\n            }\n          }]\n        }\n      }, nt.BaseSettingsEvents = function (t, e) {\n        return {\n          chartUpdateDelay: {\n            t: 1,\n            d: 0\n          },\n          onChartUpdate: {\n            t: 4\n          },\n          onClick: {\n            t: 4\n          },\n          onDoubleClick: {\n            t: 4\n          },\n          onError: {\n            t: 4\n          },\n          onHoverChange: {\n            t: 4\n          },\n          onPositionChange: {\n            t: 4\n          },\n          onRightClick: {\n            t: 4\n          },\n          onSelectionChange: {\n            t: 4\n          },\n          onSettingsChange: {\n            t: 4\n          },\n          onTripleClick: {\n            t: 4\n          }\n        };\n      }, nt.BaseSettingsInteraction = {\n        resizing: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsResizer;\n          },\n          x: function x() {\n            return i.Base.SettingsResizer;\n          }\n        }\n      }, nt.BaseSettingsLabelStyle = {\n        align: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        angle: {\n          t: 1,\n          d: 0\n        },\n        aspectRatio: {\n          t: 1\n        },\n        backgroundStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsBackgroundStyle;\n          }\n        },\n        borderRadius: {\n          t: 1\n        },\n        extra: {\n          t: 10\n        },\n        image: {\n          t: 0,\n          d: 4\n        },\n        imageSlicing: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }, {\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        lineSpacing: {\n          t: 1\n        },\n        margin: {\n          t: 1\n        },\n        maxWidth: {\n          t: 1\n        },\n        padding: {\n          t: 1\n        },\n        text: {\n          t: 0\n        },\n        textStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTextStyle;\n          }\n        }\n      }, nt.BaseSettingsLegend = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendAdvanced;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendAdvanced;\n          }\n        },\n        enabled: {\n          t: 9\n        },\n        equalizeRowsColumns: {\n          t: 9\n        },\n        height: {\n          t: 1\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendInteraction;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendInteraction;\n          }\n        },\n        lineSpacing: {\n          t: 1\n        },\n        margin: {\n          t: 1\n        },\n        marker: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendMarker;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendMarker;\n          }\n        },\n        maxLineSymbols: {\n          t: 1,\n          d: 0\n        },\n        minHeight: {\n          t: 1\n        },\n        minWidth: {\n          t: 1\n        },\n        numberOfColumns: {\n          t: 1,\n          d: 0\n        },\n        numberOfRows: {\n          t: 1,\n          d: 0\n        },\n        padding: {\n          t: 1\n        },\n        panel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendPanel;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendPanel;\n          }\n        },\n        text: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTextStyle;\n          }\n        },\n        width: {\n          t: 1\n        }\n      }, nt.BaseSettingsLegendAdvanced = {\n        selectedBackground: {\n          t: 0,\n          d: 3\n        },\n        selectedBorder: {\n          t: 0,\n          d: 3\n        }\n      }, nt.BaseSettingsLegendInteraction = {\n        click: {\n          t: 9\n        }\n      }, nt.BaseSettingsLegendMarker = {\n        alignment: {\n          t: 0,\n          d: 6\n        },\n        lineColor: {\n          t: 0,\n          d: 3\n        },\n        size: {\n          t: 1\n        }\n      }, nt.BaseSettingsLegendPanel = {\n        padding: {\n          t: 1\n        }\n      }, nt.BaseSettingsLineStyle = {\n        lineColor: {\n          t: 0\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineWidth: {\n          t: 1\n        }\n      }, nt.BaseSettingsLocalization = {\n        closeButton: {\n          t: 0\n        },\n        dataRequestFailed: {\n          t: 0\n        },\n        exportNotAvailable: {\n          t: 0\n        },\n        loadingLabel: {\n          t: 0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLocalizationToolbar;\n          },\n          x: function x() {\n            return i.Base.SettingsLocalizationToolbar;\n          }\n        }\n      }, nt.BaseSettingsLocalizationToolbar = {\n        backButton: {\n          t: 0\n        },\n        backTitle: {\n          t: 0\n        },\n        exportButton: {\n          t: 0\n        },\n        exportCSV: {\n          t: 0\n        },\n        exportJpeg: {\n          t: 0\n        },\n        exportPDF: {\n          t: 0\n        },\n        exportPNG: {\n          t: 0\n        },\n        exportTitle: {\n          t: 0\n        },\n        exportXLS: {\n          t: 0\n        },\n        fullscreenButton: {\n          t: 0\n        },\n        fullscreenTitle: {\n          t: 0\n        },\n        zoomoutButton: {\n          t: 0\n        },\n        zoomoutTitle: {\n          t: 0\n        }\n      }, nt.BaseSettingsResizer = {\n        enabled: {\n          t: 9\n        },\n        fixedAspect: {\n          t: 9\n        },\n        grabDistance: {\n          t: 1\n        },\n        visibilityDistance: {\n          t: 1\n        }\n      }, nt.BaseSettingsTextStyle = {\n        fillColor: {\n          t: 0\n        },\n        font: {\n          t: 0\n        },\n        outlineColor: {\n          t: 0\n        },\n        outlineJoin: {\n          t: 0,\n          d: 6\n        },\n        outlineWidth: {\n          t: 1\n        },\n        shadowBlur: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0\n        },\n        shadowOffsetX: {\n          t: 1\n        },\n        shadowOffsetY: {\n          t: 1\n        }\n      }, nt.BaseSettingsTitle = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              addAfterToolbar: {\n                t: 9\n              }\n            };\n          }\n        },\n        align: {\n          t: 0,\n          d: 6\n        },\n        enabled: {\n          t: 9\n        },\n        enabledOnExport: {\n          t: 9\n        },\n        margin: {\n          t: 1\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              },\n              font: {\n                t: 0\n              }\n            };\n          }\n        },\n        text: {\n          t: 0\n        },\n        verticalAlign: {\n          t: 0,\n          d: 6\n        }\n      }, nt.BaseSettingsToolbar = {\n        align: {\n          t: 0,\n          d: 6\n        },\n        back: {\n          t: 9\n        },\n        cssClass: {\n          t: 0\n        },\n        enabled: {\n          t: 9\n        },\n        export: {\n          t: 9\n        },\n        exportOptions: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            b: [{\n              t: 0\n            }]\n          }]\n        },\n        extraItems: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return nt.BaseSettingsToolbarItem;\n              },\n              x: function x() {\n                return i.Base.SettingsToolbarItem;\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        fullscreen: {\n          t: 9\n        },\n        items: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return nt.BaseSettingsToolbarItem;\n              },\n              x: function x() {\n                return i.Base.SettingsToolbarItem;\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        location: {\n          t: 0,\n          d: 6\n        },\n        showLabels: {\n          t: 9\n        },\n        side: {\n          t: 0,\n          d: 6\n        },\n        zoomOut: {\n          t: 9\n        }\n      }, nt.BaseSettingsToolbarItem = {\n        align: {\n          t: 0,\n          d: 6\n        },\n        dropDownItems: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.BaseSettingsToolbarItemBase;\n            },\n            x: function x() {\n              return i.Base.SettingsToolbarItemBase;\n            }\n          }]\n        },\n        item: {\n          t: 0,\n          d: 6\n        },\n        location: {\n          t: 0,\n          d: 6\n        },\n        showLabel: {\n          t: 9\n        },\n        side: {\n          t: 0,\n          d: 6\n        }\n      }, nt.BaseSettingsToolbarItemBase = {\n        cssClass: {\n          t: 0\n        },\n        enabled: {\n          t: 9\n        },\n        image: {\n          t: 0,\n          d: 4\n        },\n        label: {\n          t: 0\n        },\n        onClick: {\n          t: 4\n        },\n        title: {\n          t: 0\n        }\n      }, nt.FacetChartIChartClickEventArguments = {}, nt.FacetChartIChartEventArguments = {}, nt.FacetChartIDataObject = {\n        id: {\n          t: 0\n        },\n        name: {\n          t: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsFacetStyle;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsFacetStyle;\n          }\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.FacetChartIDataObject;\n            }\n          }]\n        },\n        value: {\n          t: 1\n        }\n      }, nt.FacetChartIDataObjectCommon = {\n        id: {\n          t: 0\n        },\n        name: {\n          t: 0\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.FacetChartIDataObject;\n            }\n          }]\n        }\n      }, nt.FacetChartIDataObjectRoot = {\n        afterSum: {\n          t: 1\n        },\n        beforeSum: {\n          t: 1\n        },\n        id: {\n          t: 0\n        },\n        limit: {\n          t: 1\n        },\n        name: {\n          t: 0\n        },\n        offset: {\n          t: 1\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.FacetChartIDataObject;\n            }\n          }]\n        },\n        sum: {\n          t: 1\n        }\n      }, nt.FacetChartSettings = {\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsArea;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsArea;\n          }\n        },\n        chartTypes: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              columns: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.FacetChartSettingsSeriesColumns;\n                },\n                x: function x() {\n                  return i.FacetChart.SettingsSeriesColumns;\n                },\n                y: !0\n              },\n              line: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.FacetChartSettingsSeriesLines;\n                },\n                x: function x() {\n                  return i.FacetChart.SettingsSeriesLines;\n                },\n                y: !0\n              }\n            };\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.FacetChartSettingsData;\n            },\n            x: function x() {\n              return i.FacetChart.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsEvents(nt.FacetChartIChartEventArguments, nt.FacetChartIChartClickEventArguments);\n          },\n          x: function x() {\n            return i.LinearChart.SettingsEvents;\n          }\n        },\n        facetAxis: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsFacetAxis;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsFacetAxis;\n          }\n        },\n        filters: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              allowZeroValues: {\n                t: 9\n              },\n              sliceFilter: {\n                t: 4\n              }\n            };\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsInteraction;\n          }\n        },\n        items: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              style: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    expandable: {\n                      t: 9\n                    },\n                    label: {\n                      t: 0\n                    }\n                  };\n                }\n              },\n              styleFunction: {\n                t: 4\n              }\n            };\n          }\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLegend;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLegend;\n          }\n        },\n        navigation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              initialDrilldown: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              },\n              initialOffset: {\n                t: 1,\n                d: 0\n              }\n            };\n          }\n        },\n        scrollButtons: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsScrollButtons;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsScrollButtons;\n          }\n        },\n        series: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.FacetChartSettingsSeries;\n            },\n            x: function x() {\n              return i.FacetChart.SettingsSeries;\n            },\n            y: !0\n          }]\n        },\n        seriesDefault: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeries;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeries;\n          },\n          y: !0\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.FacetChartSettings;\n          },\n          x: function x() {\n            return i.FacetChart.Settings;\n          },\n          y: !0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsToolbar;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsToolbar;\n          }\n        }\n      }, nt.FacetChartSettingsArea = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsAreaStyle;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsAreaStyle;\n          }\n        }\n      }, nt.FacetChartSettingsAreaStyle = {\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsAreaStyleSelection;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsAreaStyleSelection;\n          }\n        }\n      }, nt.FacetChartSettingsAreaStyleSelection = {\n        behindSeries: {\n          t: 9\n        },\n        fillColor: {\n          t: 0\n        },\n        lineColor: {\n          t: 0\n        },\n        lineWidth: {\n          t: 1\n        }\n      }, nt.FacetChartSettingsData = {\n        dataFunction: {\n          t: 4\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.FacetChartIDataObjectRoot;\n          }\n        },\n        sortField: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 4\n          }, {\n            t: 6,\n            u: 0,\n            b: [{\n              t: 0\n            }]\n          }, {\n            t: 0\n          }]\n        }\n      }, nt.FacetChartSettingsFacetAxis = {\n        defaultUnitWidth: {\n          t: 1\n        },\n        enabled: {\n          t: 9\n        },\n        labels: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsFacetAxisLabels;\n          }\n        },\n        maxUnitWidth: {\n          t: 1\n        },\n        size: {\n          t: 1\n        },\n        title: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsFacetAxisTitleStyle;\n          }\n        },\n        zoomOutUnitWidth: {\n          t: 1\n        }\n      }, nt.FacetChartSettingsFacetAxisLabels = {\n        allowOverflow: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        interLabelSpacing: {\n          t: 1\n        },\n        text: {\n          t: 0\n        }\n      }, nt.FacetChartSettingsFacetAxisTitleStyle = {\n        enabled: {\n          t: 9\n        },\n        text: {\n          t: 0\n        },\n        useFacetName: {\n          t: 9\n        }\n      }, nt.FacetChartSettingsFacetStyle = {\n        expandable: {\n          t: 9\n        }\n      }, nt.FacetChartSettingsInteraction = {\n        animation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              scrollDuration: {\n                t: 1,\n                d: 0\n              }\n            };\n          }\n        },\n        mode: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsInteractionSelection;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsInteractionSelection;\n          }\n        }\n      }, nt.FacetChartSettingsInteractionSelection = {\n        enabled: {\n          t: 9\n        },\n        tolerance: {\n          t: 1\n        }\n      }, nt.FacetChartSettingsScrollButtons = {\n        enabled: {\n          t: 9\n        },\n        enabledOnExport: {\n          t: 9\n        },\n        size: {\n          t: 1\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              },\n              hoverFillColor: {\n                t: 0\n              },\n              hoverLineColor: {\n                t: 0\n              },\n              lineColor: {\n                t: 0\n              }\n            };\n          }\n        }\n      }, nt.FacetChartSettingsSeries = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeriesData;\n          }\n        },\n        type: {\n          t: 0,\n          d: 6\n        }\n      }, nt.FacetChartSettingsSeriesColumns = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeriesData;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeriesColumnsStyle;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeriesColumnsStyle;\n          }\n        }\n      }, nt.FacetChartSettingsSeriesColumnsStyle = {\n        previewContents: {\n          t: 9\n        },\n        previewLineColor: {\n          t: 0\n        }\n      }, nt.FacetChartSettingsSeriesData = {\n        field: {\n          t: 0\n        },\n        valueFunction: {\n          t: 4\n        }\n      }, nt.FacetChartSettingsSeriesLines = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeriesData;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.FacetChartSettingsSeriesLinesStyle;\n          },\n          x: function x() {\n            return i.FacetChart.SettingsSeriesLinesStyle;\n          }\n        }\n      }, nt.FacetChartSettingsSeriesLinesStyle = {\n        markerStyleFunction: {\n          t: 4\n        }\n      }, nt.FacetChartSettingsToolbar = {\n        enabled: {\n          t: 9\n        },\n        items: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.BaseSettingsToolbarItem;\n            },\n            x: function x() {\n              return i.Base.SettingsToolbarItem;\n            }\n          }]\n        },\n        logScale: {\n          t: 9\n        },\n        zoomOut: {\n          t: 9\n        }\n      }, nt.GeoChartIAggregationDataObjectNode = {\n        aggregatedNodes: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartIGeoDataObjectNode;\n            }\n          }]\n        },\n        aggregatedWeight: {\n          t: 1\n        }\n      }, nt.GeoChartIDataObject = {\n        clearCache: {\n          t: 9\n        },\n        east: {\n          t: 1\n        },\n        links: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartIGeoDataObjectLink;\n            }\n          }]\n        },\n        nodes: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartIGeoDataObjectNode;\n            }\n          }]\n        },\n        north: {\n          t: 1\n        },\n        south: {\n          t: 1\n        },\n        west: {\n          t: 1\n        }\n      }, nt.GeoChartIGeoDataObjectLink = {}, nt.GeoChartIGeoDataObjectNode = {\n        aggregate: {\n          t: 9\n        },\n        coordinates: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            }]\n          }, {\n            t: 12,\n            b: [{\n              t: 1\n            }, {\n              t: 1\n            }]\n          }]\n        },\n        count: {\n          t: 1\n        },\n        shapeFeature: {\n          t: 10\n        },\n        shapeGeometry: {\n          t: 10\n        },\n        type: {\n          t: 0\n        }\n      }, nt.GeoChartSettings = {\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsArea;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsArea;\n          }\n        },\n        background: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsBackground;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsBackground;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartSettingsData;\n            },\n            x: function x() {\n              return i.GeoChart.SettingsData;\n            }\n          }]\n        },\n        filters: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              nodeFilter: {\n                t: 4\n              }\n            };\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsInteraction;\n          }\n        },\n        layerTypes: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              aggregateOnShapes: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.GeoChartSettingsLayerAggregated;\n                },\n                x: function x() {\n                  return i.GeoChart.SettingsLayerAggregated;\n                },\n                y: !0\n              },\n              charts: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.GeoChartSettingsLayerCharts;\n                },\n                x: function x() {\n                  return i.GeoChart.SettingsLayerCharts;\n                },\n                y: !0\n              },\n              items: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.GeoChartSettingsLayerItems;\n                },\n                x: function x() {\n                  return i.GeoChart.SettingsLayerItems;\n                },\n                y: !0\n              },\n              shapes: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.GeoChartSettingsLayerShapes;\n                },\n                x: function x() {\n                  return i.GeoChart.SettingsLayerShapes;\n                },\n                y: !0\n              }\n            };\n          }\n        },\n        layers: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartSettingsLayerBase;\n            },\n            x: function x() {\n              return i.GeoChart.SettingsLayerBase;\n            },\n            y: !0\n          }]\n        },\n        layersDefault: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsLayerBase;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsLayerBase;\n          },\n          y: !0\n        },\n        navigation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              drilldownLayer: {\n                t: 0\n              },\n              initialDrilldown: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              },\n              initialLat: {\n                t: 1\n              },\n              initialLng: {\n                t: 1\n              },\n              initialZoom: {\n                t: 1\n              },\n              maxBounds: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    east: {\n                      t: 1\n                    },\n                    north: {\n                      t: 1\n                    },\n                    south: {\n                      t: 1\n                    },\n                    west: {\n                      t: 1\n                    }\n                  };\n                }\n              },\n              maxZoom: {\n                t: 1\n              },\n              minZoom: {\n                t: 1\n              }\n            };\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fadeTime: {\n                t: 1\n              },\n              selection: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    fillColor: {\n                      t: 0\n                    },\n                    sizeConstant: {\n                      t: 1\n                    },\n                    sizeProportional: {\n                      t: 1\n                    }\n                  };\n                }\n              }\n            };\n          }\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.GeoChartSettings;\n          },\n          x: function x() {\n            return i.GeoChart.Settings;\n          },\n          y: !0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsToolbar;\n          },\n          x: function x() {\n            return i.Base.SettingsToolbar;\n          }\n        }\n      }, nt.GeoChartSettingsAggregatedShapeStyle = {\n        mode: {\n          t: 2,\n          e: function e() {\n            return _e2.GeoChartSettingsAggregatedShapeStyleMode;\n          }\n        }\n      }, nt.GeoChartSettingsAggregation = {\n        distance: {\n          t: 1,\n          d: 0\n        },\n        enabled: {\n          t: 9\n        },\n        ignoreZeroWeight: {\n          t: 9\n        },\n        maxZoom: {\n          t: 1,\n          d: 0\n        },\n        postProcessAggregatedNodes: {\n          t: 4\n        },\n        weightFunction: {\n          t: 4\n        }\n      }, nt.GeoChartSettingsArea = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsAreaStyle;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsAreaStyle;\n          }\n        }\n      }, nt.GeoChartSettingsAreaStyle = {}, nt.GeoChartSettingsBackground = {\n        enabled: {\n          t: 9\n        },\n        params: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartSettingsBackgroundParams;\n            }\n          }, {\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.GeoChartSettingsWmsParams;\n            }\n          }]\n        },\n        type: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        url: {\n          t: 0\n        }\n      }, nt.GeoChartSettingsBackgroundParams = {\n        attribution: {\n          t: 0\n        },\n        continuousWorld: {\n          t: 9\n        },\n        detectRetina: {\n          t: 9\n        },\n        errorTileUrl: {\n          t: 0\n        },\n        maxNativeZoom: {\n          t: 1\n        },\n        maxZoom: {\n          t: 1\n        },\n        minZoom: {\n          t: 1\n        },\n        noWrap: {\n          t: 9\n        },\n        opacity: {\n          t: 1\n        },\n        reuseTiles: {\n          t: 9\n        },\n        subdomains: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 0\n            }]\n          }, {\n            t: 0\n          }]\n        },\n        tileSize: {\n          t: 1\n        },\n        tms: {\n          t: 9\n        },\n        unloadInvisibleTiles: {\n          t: 9\n        },\n        updateWhenIdle: {\n          t: 9\n        },\n        zIndex: {\n          t: 1\n        },\n        zoomOffset: {\n          t: 1\n        },\n        zoomReverse: {\n          t: 9\n        }\n      }, nt.GeoChartSettingsData = {\n        aggregationGridSize: {\n          t: 1\n        },\n        aggregationMinCount: {\n          t: 1\n        },\n        bounds: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }, {\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        dataFunction: {\n          t: 4\n        },\n        maxRequestRect: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        perBoundsData: {\n          t: 9\n        },\n        perDrilldownData: {\n          t: 9\n        },\n        perZoomData: {\n          t: 9\n        },\n        prefetchRatio: {\n          t: 1\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.GeoChartIDataObject;\n          }\n        },\n        useGridBasedAggregation: {\n          t: 9\n        },\n        wrapLng: {\n          t: 9\n        }\n      }, nt.GeoChartSettingsInteraction = {\n        mode: {\n          t: 0,\n          d: 6\n        },\n        zooming: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsInteractionZooming;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsInteractionZooming;\n          }\n        }\n      }, nt.GeoChartSettingsInteractionZooming = {\n        zoomInOnDoubleClick: {\n          t: 9\n        }\n      }, nt.GeoChartSettingsLayerAggregated = {\n        aggregation: {\n          t: 0,\n          d: 6\n        },\n        aggregationField: {\n          t: 0\n        },\n        aggregationFunction: {\n          t: 4\n        },\n        shapesLayer: {\n          t: 0\n        },\n        styleFunction: {\n          t: 4\n        }\n      }, nt.GeoChartSettingsLayerBase = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              id: {\n                t: 0\n              }\n            };\n          }\n        },\n        enabled: {\n          t: 9\n        },\n        id: {\n          t: 0\n        },\n        maxZoom: {\n          t: 1,\n          d: 0\n        },\n        minZoom: {\n          t: 1,\n          d: 0\n        },\n        name: {\n          t: 0\n        },\n        perZoomStyle: {\n          t: 9\n        },\n        type: {\n          t: 0,\n          d: 6\n        }\n      }, nt.GeoChartSettingsLayerCharts = {\n        chartType: {\n          t: 0,\n          d: 6\n        },\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              id: {\n                t: 0\n              }\n            };\n          }\n        },\n        settings: {\n          t: 7,\n          b: [{\n            t: 5,\n            c: function c() {\n              return nt.FacetChartSettings;\n            },\n            x: function x() {\n              return i.FacetChart.Settings;\n            },\n            y: !0\n          }, {\n            t: 5,\n            c: function c() {\n              return nt.PieChartSettings;\n            },\n            x: function x() {\n              return i.PieChart.Settings;\n            },\n            y: !0\n          }, {\n            t: 5,\n            c: function c() {\n              return nt.TimeChartSettings;\n            },\n            x: function x() {\n              return i.TimeChart.Settings;\n            },\n            y: !0\n          }]\n        },\n        settingsFunction: {\n          t: 4\n        },\n        shapesLayer: {\n          t: 0\n        }\n      }, nt.GeoChartSettingsLayerItems = {\n        aggregation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsAggregation;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsAggregation;\n          }\n        },\n        auras: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodesLayerAuras;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsNodesLayerAuras;\n          }\n        },\n        layout: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsNodesLayout;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsNodesLayout;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsNodesLayerStyle;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsNodesLayerStyle;\n          }\n        }\n      }, nt.GeoChartSettingsLayerOverlay = {\n        shapesLayer: {\n          t: 0\n        }\n      }, nt.GeoChartSettingsLayerShapes = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsShapesLayerStyle;\n          },\n          x: function x() {\n            return i.GeoChart.SettingsShapesLayerStyle;\n          }\n        }\n      }, nt.GeoChartSettingsNodesLayerStyle = {\n        aggregatedShape: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsAggregatedShapeStyle;\n          }\n        }\n      }, nt.GeoChartSettingsNodesLayout = {\n        anchorStrength: {\n          t: 1\n        },\n        mode: {\n          t: 0,\n          d: 6\n        },\n        nodeSpacing: {\n          t: 1,\n          d: 0\n        }\n      }, nt.GeoChartSettingsShapesLayerNodeStyle = {\n        expandable: {\n          t: 9\n        }\n      }, nt.GeoChartSettingsShapesLayerStyle = {\n        node: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.GeoChartSettingsShapesLayerNodeStyle;\n          }\n        },\n        shapeSimplificationPrecision: {\n          t: 1\n        }\n      }, nt.GeoChartSettingsWmsParams = {\n        format: {\n          t: 0\n        },\n        layers: {\n          t: 0\n        },\n        styles: {\n          t: 0\n        },\n        transparent: {\n          t: 9\n        },\n        version: {\n          t: 0\n        }\n      }, nt.ItemsChartIChartClickEventArguments = {}, nt.ItemsChartIChartEventArguments = {}, nt.ItemsChartIDataObjectBase = {}, nt.ItemsChartIDataObjectLink = {\n        className: {\n          t: 0\n        },\n        from: {\n          t: 0\n        },\n        id: {\n          t: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkStyle;\n          }\n        },\n        to: {\n          t: 0\n        }\n      }, nt.ItemsChartIDataObjectNode = {\n        className: {\n          t: 0\n        },\n        id: {\n          t: 0\n        },\n        loaded: {\n          t: 9\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        }\n      }, nt.ItemsChartSettings = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsAdvanced;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsAdvanced;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsData;\n            },\n            x: function x() {\n              return i.ItemsChart.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsEvents(nt.ItemsChartIChartEventArguments, nt.ItemsChartIChartClickEventArguments);\n          },\n          x: function x() {\n            return i.Base.SettingsEvents;\n          }\n        },\n        info: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              enabled: {\n                t: 9\n              },\n              linkContentsFunction: {\n                t: 4\n              },\n              nodeContentsFunction: {\n                t: 4\n              }\n            };\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsInteraction;\n          }\n        },\n        linkMenu: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkMenu;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsLinkMenu;\n          }\n        },\n        nodeMenu: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeMenu;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsNodeMenu;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {};\n          }\n        }\n      }, nt.ItemsChartSettingsAdvanced = {\n        perNodeLoadingIndicator: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsAuraStyle = {\n        enabled: {\n          t: 9\n        },\n        legendGroupId: {\n          t: 0\n        },\n        nameLegend: {\n          t: 0\n        },\n        showInLegend: {\n          t: 9\n        },\n        zIndex: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsCustomShape = {\n        distanceToEdge: {\n          t: 4\n        },\n        hitTest: {\n          t: 4\n        },\n        onUpdate: {\n          t: 4\n        },\n        paint: {\n          t: 4\n        },\n        paintSelection: {\n          t: 4\n        }\n      }, nt.ItemsChartSettingsData = {\n        cacheSize: {\n          t: 1,\n          d: 0\n        },\n        random: {\n          t: 0,\n          d: 6\n        },\n        randomGridLinkProbability: {\n          t: 1\n        },\n        randomLinks: {\n          t: 1,\n          d: 0\n        },\n        randomNodes: {\n          t: 1,\n          d: 0\n        },\n        randomTreeDensity: {\n          t: 1\n        },\n        requestMaxUnits: {\n          t: 1,\n          d: 0\n        }\n      }, nt.ItemsChartSettingsInteraction = {\n        nodesMovable: {\n          t: 9\n        },\n        panning: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              enabled: {\n                t: 9\n              }\n            };\n          }\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsInteractionSelection;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsInteractionSelection;\n          }\n        },\n        zooming: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsInteractionZooming;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsInteractionZooming;\n          }\n        }\n      }, nt.ItemsChartSettingsInteractionSelection = {\n        allowMoveNodesOffscreen: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        linksSelectable: {\n          t: 9\n        },\n        lockNodesOnMove: {\n          t: 9\n        },\n        nodesSelectable: {\n          t: 9\n        },\n        tolerance: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsInteractionZooming = {\n        autoZoomAfterClick: {\n          t: 9\n        },\n        doubleClickZoom: {\n          t: 1\n        },\n        fingers: {\n          t: 9\n        },\n        sensitivity: {\n          t: 1\n        },\n        wheel: {\n          t: 9\n        },\n        zoomInOnDoubleClick: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsItemClass = {\n        className: {\n          t: 0\n        },\n        legendGroupId: {\n          t: 0\n        },\n        nameLegend: {\n          t: 0\n        },\n        showInLegend: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsItemsLayerItemStyle = {\n        hoverEffect: {\n          t: 9\n        },\n        zIndex: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsItemsLayerLabelStyle = {\n        scaleWithSize: {\n          t: 9\n        },\n        scaleWithZoom: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsItemsLayerLinkLabelStyle = {\n        rotateWithLink: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsItemsLayerStyle = {\n        allObjectsStyleFunction: {\n          t: 4\n        },\n        item: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsItemsLayerItemStyle;\n          }\n        },\n        link: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkStyle;\n          }\n        },\n        linkClasses: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsLinkClass;\n            },\n            x: function x() {\n              return i.ItemsChart.SettingsLinkClass;\n            }\n          }]\n        },\n        linkDecorationMinSize: {\n          t: 1\n        },\n        linkDecorationScale: {\n          t: 1\n        },\n        linkDetailMinSize: {\n          t: 1\n        },\n        linkDetailMinZoom: {\n          t: 1\n        },\n        linkHovered: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkStyle;\n          }\n        },\n        linkLabel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsItemsLayerLinkLabelStyle;\n          }\n        },\n        linkLabelScaleBase: {\n          t: 1\n        },\n        linkRules: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 4\n          }]\n        },\n        linkSelected: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkStyle;\n          }\n        },\n        linkStyleFunction: {\n          t: 4\n        },\n        node: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeAnchor: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeAnchorStyle;\n          }\n        },\n        nodeBackground: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeClasses: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsNodeClass;\n            },\n            x: function x() {\n              return i.ItemsChart.SettingsNodeClass;\n            }\n          }]\n        },\n        nodeDetailMinSize: {\n          t: 1\n        },\n        nodeDetailMinZoom: {\n          t: 1\n        },\n        nodeExpanded: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeFocused: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeHovered: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeLabel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsItemsLayerLabelStyle;\n          }\n        },\n        nodeLabelScaleBase: {\n          t: 1\n        },\n        nodeLocked: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeNotLoaded: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeRules: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 4\n          }]\n        },\n        nodeSelected: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        },\n        nodeStyleFunction: {\n          t: 4\n        },\n        removedColor: {\n          t: 0,\n          d: 3\n        },\n        scaleLinksWithZoom: {\n          t: 9\n        },\n        scaleObjectsWithZoom: {\n          t: 9\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              enabled: {\n                t: 9\n              },\n              fillColor: {\n                t: 0\n              },\n              lineColor: {\n                t: 0\n              },\n              lineWidth: {\n                t: 1\n              },\n              shadowBlur: {\n                t: 1\n              },\n              shadowColor: {\n                t: 0\n              },\n              shadowOffsetX: {\n                t: 1\n              },\n              shadowOffsetY: {\n                t: 1\n              },\n              sizeConstant: {\n                t: 1\n              },\n              sizeProportional: {\n                t: 1\n              }\n            };\n          }\n        }\n      }, nt.ItemsChartSettingsLinkClass = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsLinkStyle;\n          }\n        }\n      }, nt.ItemsChartSettingsLinkItem = {\n        lx: {\n          t: 1\n        },\n        ly: {\n          t: 1\n        },\n        px: {\n          t: 1\n        },\n        py: {\n          t: 1\n        },\n        rotateWithLink: {\n          t: 9\n        },\n        x: {\n          t: 1\n        },\n        y: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsLinkMenu = {\n        buttons: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsMenuButton;\n            },\n            x: function x() {\n              return i.ItemsChart.SettingsMenuButton;\n            }\n          }]\n        },\n        contentsFunction: {\n          t: 4\n        }\n      }, nt.ItemsChartSettingsLinkStyle = {\n        cursor: {\n          t: 0\n        },\n        definesLayout: {\n          t: 9\n        },\n        direction: {\n          t: 0\n        },\n        fillColor: {\n          t: 0\n        },\n        fromDecoration: {\n          t: 0,\n          d: 6\n        },\n        invisible: {\n          t: 9\n        },\n        items: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsLinkItem;\n            }\n          }]\n        },\n        label: {\n          t: 0\n        },\n        length: {\n          t: 1\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineDashBackgroundFillColor: {\n          t: 0\n        },\n        lineDashShape: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        radius: {\n          t: 1\n        },\n        shadowBlur: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0\n        },\n        shadowOffsetX: {\n          t: 1\n        },\n        shadowOffsetY: {\n          t: 1\n        },\n        strength: {\n          t: 1\n        },\n        toDecoration: {\n          t: 0,\n          d: 6\n        },\n        toPieColor: {\n          t: 0\n        },\n        toPieValue: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsMenu = {\n        buttons: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return nt.ItemsChartSettingsMenuButton;\n              },\n              x: function x() {\n                return i.ItemsChart.SettingsMenuButton;\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        contentsFunction: {\n          t: 4\n        },\n        enabled: {\n          t: 9\n        },\n        showData: {\n          t: 9\n        }\n      }, nt.ItemsChartSettingsMenuButton = {\n        className: {\n          t: 0\n        },\n        onClick: {\n          t: 4\n        },\n        onInit: {\n          t: 4\n        },\n        onRefresh: {\n          t: 4\n        },\n        text: {\n          t: 0\n        },\n        title: {\n          t: 0\n        }\n      }, nt.ItemsChartSettingsNodeAnchorStyle = {\n        lineColor: {\n          t: 0\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineWidth: {\n          t: 1\n        },\n        shadowBlur: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0\n        },\n        shadowOffsetX: {\n          t: 1\n        },\n        shadowOffsetY: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsNodeClass = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeStyle;\n          }\n        }\n      }, nt.ItemsChartSettingsNodeItem = {\n        px: {\n          t: 1\n        },\n        py: {\n          t: 1\n        },\n        x: {\n          t: 1\n        },\n        y: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsNodeMenu = {\n        buttons: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return nt.ItemsChartSettingsMenuButton;\n              },\n              x: function x() {\n                return i.ItemsChart.SettingsMenuButton;\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        contentsFunction: {\n          t: 4\n        }\n      }, nt.ItemsChartSettingsNodeStyle = {\n        anchorMode: {\n          t: 2,\n          e: function e() {\n            return i.ItemsChart.NodeAnchorMode;\n          }\n        },\n        anchorStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodeAnchorStyle;\n          }\n        },\n        anchorX: {\n          t: 1\n        },\n        anchorY: {\n          t: 1\n        },\n        aspectRatio: {\n          t: 1\n        },\n        aura: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 0\n            }]\n          }, {\n            t: 0\n          }]\n        },\n        coordinates: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 6,\n              u: 0,\n              b: [{\n                t: 1\n              }]\n            }]\n          }, {\n            t: 6,\n            u: 0,\n            b: [{\n              t: 1\n            }]\n          }]\n        },\n        cursor: {\n          t: 0,\n          d: 7\n        },\n        customShape: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsCustomShape;\n          }\n        },\n        display: {\n          t: 0\n        },\n        draggable: {\n          t: 9\n        },\n        fillColor: {\n          t: 7,\n          b: [{\n            t: 14\n          }, {\n            t: 0\n          }]\n        },\n        fillGradient: {\n          t: 11\n        },\n        hierarchyLevel: {\n          t: 1\n        },\n        hierarchyOffset: {\n          t: 1\n        },\n        image: {\n          t: 0\n        },\n        imageCropping: {\n          t: 7,\n          b: [{\n            t: 0\n          }, {\n            t: 9\n          }]\n        },\n        invisible: {\n          t: 9\n        },\n        items: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsNodeItem;\n            }\n          }]\n        },\n        label: {\n          t: 0\n        },\n        labelStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsItemsLayerLabelStyle;\n          }\n        },\n        lineColor: {\n          t: 0\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineWidth: {\n          t: 1\n        },\n        opacity: {\n          t: 1\n        },\n        radius: {\n          t: 1\n        },\n        shadowBlur: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0\n        },\n        shadowOffsetX: {\n          t: 1\n        },\n        shadowOffsetY: {\n          t: 1\n        }\n      }, nt.ItemsChartSettingsNodesLayerAuras = {\n        cellSize: {\n          t: 1\n        },\n        defaultColors: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        defaultStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsAuraStyle;\n          }\n        },\n        drawLimit: {\n          t: 1\n        },\n        enabled: {\n          t: 9\n        },\n        intensity: {\n          t: 1\n        },\n        overlap: {\n          t: 9\n        },\n        style: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.ItemsChartSettingsAuraStyle;\n            }\n          }]\n        }\n      }, nt.ItemsChartSettingsNodesLayerStyle = {\n        fadeTime: {\n          t: 1,\n          d: 0\n        },\n        hiddenLinks: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              lineColor: {\n                t: 0\n              },\n              lineWidth: {\n                t: 1\n              },\n              size: {\n                t: 1\n              }\n            };\n          }\n        },\n        linkAutoScaling: {\n          t: 0,\n          d: 6\n        },\n        linkLengthAutoScaling: {\n          t: 0,\n          d: 6\n        },\n        linkLengthExtent: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        linkRadiusExtent: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        linkStrengthAutoScaling: {\n          t: 0,\n          d: 6\n        },\n        linkStrengthExtent: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        multilinkSpacing: {\n          t: 1\n        },\n        nodeAutoScaling: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        nodeRadiusExtent: {\n          t: 12,\n          b: [{\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }]\n        },\n        selfLinkAngle: {\n          t: 1\n        },\n        selfLinkHeightFactor: {\n          t: 1\n        },\n        selfLinkShape: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        selfLinkWidthFactor: {\n          t: 1\n        }\n      }, nt.LinearChartSettings = {\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsArea;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsArea;\n          }\n        },\n        chartTypes: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              candlestick: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsSeriesCandleStick;\n                },\n                x: function x() {\n                  return i.LinearChart.SettingsSeriesCandleStick;\n                },\n                y: !0\n              },\n              columns: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsSeriesColumns;\n                },\n                x: function x() {\n                  return i.LinearChart.SettingsSeriesColumns;\n                },\n                y: !0\n              },\n              line: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsSeriesLines;\n                },\n                x: function x() {\n                  return i.LinearChart.SettingsSeriesLines;\n                },\n                y: !0\n              }\n            };\n          }\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsEvents(nt.BaseIChartEventArguments, nt.BaseIChartEventArguments);\n          },\n          x: function x() {\n            return i.LinearChart.SettingsEvents;\n          }\n        },\n        horizontal: {\n          t: 9\n        },\n        info: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsInfoPopup;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsInfoPopup;\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsInteraction;\n          }\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLegend;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLegend;\n          }\n        },\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLocalization;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLocalization;\n          }\n        },\n        series: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.LinearChartSettingsSeries;\n            },\n            x: function x() {\n              return i.LinearChart.SettingsSeries;\n            },\n            y: !0\n          }]\n        },\n        seriesDefault: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeries;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeries;\n          },\n          y: !0\n        },\n        stacks: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.LinearChartSettingsStack;\n            },\n            x: function x() {\n              return i.LinearChart.SettingsStack;\n            }\n          }]\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              columnColors: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              },\n              lineColors: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              }\n            };\n          }\n        },\n        valueAxis: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.LinearChartSettingsValueAxis;\n            },\n            x: function x() {\n              return i.LinearChart.SettingsValueAxis;\n            },\n            y: !0\n          }]\n        },\n        valueAxisDefault: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsValueAxis;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsValueAxis;\n          }\n        }\n      }, nt.LinearChartSettingsArea = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsAreaStyle;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsAreaStyle;\n          }\n        }\n      }, nt.LinearChartSettingsAreaStyle = {\n        noData: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              },\n              image: {\n                t: 0,\n                d: 5\n              }\n            };\n          }\n        },\n        zoomHighlight: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsHighlightStyle;\n          }\n        },\n        zoomHighlightInactive: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              }\n            };\n          }\n        }\n      }, nt.LinearChartSettingsCandleStickMotionStyle = {\n        bar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              lineColor: {\n                t: 0\n              },\n              lineDash: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 1\n                }]\n              },\n              lineWidth: {\n                t: 1\n              },\n              shadowBlur: {\n                t: 1\n              },\n              shadowColor: {\n                t: 0\n              },\n              shadowOffsetX: {\n                t: 1\n              },\n              shadowOffsetY: {\n                t: 1\n              }\n            };\n          }\n        },\n        candlestick: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              },\n              lineColor: {\n                t: 0,\n                d: 3\n              },\n              lineDash: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 1\n                }]\n              },\n              lineWidth: {\n                t: 1\n              },\n              shadowBlur: {\n                t: 1\n              },\n              shadowColor: {\n                t: 0\n              },\n              shadowOffsetX: {\n                t: 1\n              },\n              shadowOffsetY: {\n                t: 1\n              }\n            };\n          }\n        }\n      }, nt.LinearChartSettingsEvents = function (t, e) {\n        return {\n          onAnimationDone: {\n            t: 4\n          }\n        };\n      }, nt.LinearChartSettingsHighlightStyle = {\n        fadeIn: {\n          t: 1,\n          d: 0\n        },\n        fadeOut: {\n          t: 1,\n          d: 0\n        },\n        fillColor: {\n          t: 0\n        }\n      }, nt.LinearChartSettingsInfoPopup = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              contentsFunction: {\n                t: 4\n              },\n              scope: {\n                t: 0,\n                d: 6\n              },\n              showHeader: {\n                t: 9\n              },\n              showOnlyHoveredSeries: {\n                t: 9\n              }\n            };\n          }\n        },\n        aggregations: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0,\n            d: 6\n          }]\n        },\n        enabled: {\n          t: 9\n        },\n        position: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        showNoData: {\n          t: 9\n        },\n        showNullData: {\n          t: 9\n        },\n        showZeroData: {\n          t: 9\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              highlight: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsHighlightStyle;\n                }\n              }\n            };\n          }\n        },\n        useStackedValue: {\n          t: 9\n        },\n        valueFormatterFunction: {\n          t: 4\n        }\n      }, nt.LinearChartSettingsInteraction = {\n        ignoreBottomAxis: {\n          t: 9\n        },\n        scrolling: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsInteractionScrolling;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsInteractionScrolling;\n          }\n        },\n        swipeSensitivity: {\n          t: 1\n        },\n        zooming: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsInteractionZooming;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsInteractionZooming;\n          }\n        }\n      }, nt.LinearChartSettingsInteractionScrolling = {\n        enabled: {\n          t: 9\n        },\n        kineticFriction: {\n          t: 1\n        },\n        maxAnimationLength: {\n          t: 1,\n          d: 0\n        },\n        swipePageFlipping: {\n          t: 9\n        }\n      }, nt.LinearChartSettingsInteractionZooming = {\n        enabled: {\n          t: 9\n        },\n        fingers: {\n          t: 9\n        },\n        fingersMaxZoom: {\n          t: 1\n        },\n        sensitivity: {\n          t: 1\n        },\n        swipe: {\n          t: 9\n        },\n        upDownTreshold: {\n          t: 1\n        },\n        wheel: {\n          t: 9\n        },\n        wheelSensitivity: {\n          t: 1\n        },\n        zoomHighlightThreshold: {\n          t: 1\n        }\n      }, nt.LinearChartSettingsLegend = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLegendAdvanced;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLegendAdvanced;\n          }\n        },\n        marker: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLegendMarker;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLegendMarker;\n          }\n        },\n        panel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendPanel;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendPanel;\n          }\n        }\n      }, nt.LinearChartSettingsLegendAdvanced = {\n        disabledSeries: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0\n              },\n              lineColor: {\n                t: 0\n              },\n              textColor: {\n                t: 0\n              }\n            };\n          }\n        }\n      }, nt.LinearChartSettingsLegendMarker = {\n        shape: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        }\n      }, nt.LinearChartSettingsLocalization = {\n        noDataLabel: {\n          t: 0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsLocalizationToolbar;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsLocalizationToolbar;\n          }\n        },\n        unnamedSeries: {\n          t: 0\n        },\n        valueUnits: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 1,\n            d: 0\n          }]\n        }\n      }, nt.LinearChartSettingsLocalizationToolbar = {\n        linButton: {\n          t: 0\n        },\n        linLogTitle: {\n          t: 0\n        },\n        logButton: {\n          t: 0\n        }\n      }, nt.LinearChartSettingsSeries = {\n        cluster: {\n          t: 0\n        },\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeriesData;\n          }\n        },\n        enabled: {\n          t: 9\n        },\n        extra: {\n          t: 10\n        },\n        id: {\n          t: 0\n        },\n        legendGroupId: {\n          t: 0\n        },\n        name: {\n          t: 0\n        },\n        nameLegend: {\n          t: 0\n        },\n        showInInfoPopup: {\n          t: 9\n        },\n        showInLegend: {\n          t: 9\n        },\n        stack: {\n          t: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesStyle;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeriesStyle;\n          }\n        },\n        type: {\n          t: 0,\n          d: 6\n        },\n        valueAxis: {\n          t: 0\n        }\n      }, nt.LinearChartSettingsSeriesCandleStick = {\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              close: {\n                t: 0\n              },\n              high: {\n                t: 0\n              },\n              low: {\n                t: 0\n              },\n              open: {\n                t: 0\n              }\n            };\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesCandleStickStyle;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeriesCandleStickStyle;\n          }\n        }\n      }, nt.LinearChartSettingsSeriesCandleStickStyle = {\n        decrease: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsCandleStickMotionStyle;\n          }\n        },\n        increase: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsCandleStickMotionStyle;\n          }\n        },\n        padding: {\n          t: 12,\n          b: [{\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }]\n        },\n        pattern: {\n          t: 0,\n          d: 6\n        }\n      }, nt.LinearChartSettingsSeriesColumns = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesColumnsStyle;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeriesColumnsStyle;\n          }\n        },\n        valueLabels: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsValueLabels;\n          }\n        }\n      }, nt.LinearChartSettingsSeriesColumnsStyle = {\n        clusterPadding: {\n          t: 12,\n          b: [{\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }]\n        },\n        connectorLineID: {\n          t: 0\n        },\n        connectorLinePositionX: {\n          t: 0,\n          d: 6\n        },\n        depth: {\n          t: 1\n        },\n        depthBrightness: {\n          t: 1\n        },\n        enableOutlineLines: {\n          t: 9\n        },\n        fillGradientMode: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        fillGradientType: {\n          t: 0\n        },\n        gradient: {\n          t: 1\n        },\n        lineColor: {\n          t: 0,\n          d: 3\n        },\n        minHeight: {\n          t: 1,\n          d: 0\n        },\n        padding: {\n          t: 12,\n          b: [{\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }]\n        },\n        radius: {\n          t: 12,\n          b: [{\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }, {\n            t: 1,\n            d: 0\n          }]\n        },\n        shadowBlur: {\n          t: 1,\n          d: 0\n        },\n        widthScale: {\n          t: 1\n        }\n      }, nt.LinearChartSettingsSeriesData = {\n        aggregatedValueFunction: {\n          t: 4\n        },\n        aggregation: {\n          t: 0,\n          d: 6\n        },\n        noDataPolicy: {\n          t: 0,\n          d: 6\n        },\n        source: {\n          t: 0\n        },\n        valueFunction: {\n          t: 4\n        }\n      }, nt.LinearChartSettingsSeriesLines = {\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesLinesStyle;\n          },\n          x: function x() {\n            return i.LinearChart.SettingsSeriesLinesStyle;\n          }\n        },\n        valueLabels: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsValueLabels;\n          }\n        }\n      }, nt.LinearChartSettingsSeriesLinesStyle = {\n        marker: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.LinearChartSettingsSeriesStyleMarker;\n          }\n        },\n        markerStyleFunction: {\n          t: 4\n        },\n        shadowBlur: {\n          t: 1,\n          d: 0\n        },\n        smoothing: {\n          t: 9\n        },\n        steps: {\n          t: 9\n        }\n      }, nt.LinearChartSettingsSeriesStyle = {\n        depth: {\n          t: 1\n        },\n        fillColor: {\n          t: 0,\n          d: 3\n        },\n        fillGradient: {\n          t: 11\n        },\n        fillGradientMode: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        fillPattern: {\n          t: 0\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              marker: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsSeriesStyleMarker;\n                }\n              },\n              textColor: {\n                t: 0,\n                d: 3\n              }\n            };\n          }\n        },\n        lineColor: {\n          t: 0\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineWidth: {\n          t: 1\n        },\n        shadowColor: {\n          t: 0,\n          d: 3\n        },\n        shadowOffsetX: {\n          t: 1,\n          d: 0\n        },\n        shadowOffsetY: {\n          t: 1,\n          d: 0\n        }\n      }, nt.LinearChartSettingsSeriesStyleMarker = {\n        fillColor: {\n          t: 0,\n          d: 3\n        },\n        lineColor: {\n          t: 0,\n          d: 3\n        },\n        lineWidth: {\n          t: 1\n        },\n        shape: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        width: {\n          t: 1,\n          d: 0\n        }\n      }, nt.LinearChartSettingsStack = {\n        drawFullArea: {\n          t: 9\n        },\n        name: {\n          t: 0\n        },\n        separateNegativeValues: {\n          t: 9\n        },\n        type: {\n          t: 0,\n          d: 6\n        }\n      }, nt.LinearChartSettingsValueAxis = {\n        alignZero: {\n          t: 9\n        },\n        animate: {\n          t: 0,\n          d: 6\n        },\n        axisLine: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        forceTopAndBottomValues: {\n          t: 9\n        },\n        gridPosition: {\n          t: 0,\n          d: 6\n        },\n        hgrid: {\n          t: 9\n        },\n        initialAnimationValue: {\n          t: 1\n        },\n        initialAnimationValueMultiplier: {\n          t: 1\n        },\n        logScale: {\n          t: 9\n        },\n        maxValue: {\n          t: 1\n        },\n        minValue: {\n          t: 1\n        },\n        position: {\n          t: 0,\n          d: 6\n        },\n        scaleAdjustmentAnimation: {\n          t: 0,\n          d: 6\n        },\n        scaleAdjustmentAnimationDelay: {\n          t: 1,\n          d: 0\n        },\n        scaleAdjustmentTolerance: {\n          t: 1\n        },\n        scaleMinStep: {\n          t: 1\n        },\n        scaleStep: {\n          t: 1\n        },\n        side: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        size: {\n          t: 1,\n          d: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              axisLine: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              },\n              baseLine: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsValueAxisBaseLineStyle;\n                }\n              },\n              hgrid: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              },\n              labelSpacing: {\n                t: 1\n              },\n              tick: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              },\n              title: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.LinearChartSettingsValueAxisTitleStyle;\n                }\n              },\n              valueLabel: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLabelStyle;\n                }\n              }\n            };\n          }\n        },\n        thresholds: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.LinearChartSettingsValueAxisThreshold;\n            },\n            x: function x() {\n              return i.LinearChart.SettingsValueAxisThreshold;\n            }\n          }]\n        },\n        title: {\n          t: 0\n        },\n        valueFormat: {\n          t: 0\n        },\n        valueFormatterFunction: {\n          t: 4\n        },\n        zeroLine: {\n          t: 0,\n          d: 6\n        }\n      }, nt.LinearChartSettingsValueAxisBaseLineStyle = {\n        depthColor: {\n          t: 0,\n          d: 3\n        },\n        lineDepth: {\n          t: 1,\n          d: 0\n        },\n        showLabel: {\n          t: 2,\n          e: function e() {\n            return _e2.BaseSettingsValueAxisBaseLineLabelMode;\n          }\n        }\n      }, nt.LinearChartSettingsValueAxisThreshold = {\n        from: {\n          t: 1\n        },\n        fromType: {\n          t: 0,\n          d: 6\n        },\n        label: {\n          t: 0\n        },\n        labelDecimals: {\n          t: 1\n        },\n        labelDisplayUnits: {\n          t: 0\n        },\n        labelHorizontalPadding: {\n          t: 1\n        },\n        labelHorizontalPosition: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        labelStyle: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        labelType: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        labelVerticalPadding: {\n          t: 1\n        },\n        labelVerticalPosition: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        percentileFrom: {\n          t: 1\n        },\n        percentileTo: {\n          t: 1\n        },\n        position: {\n          t: 0,\n          d: 6\n        },\n        seriesID: {\n          t: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fillColor: {\n                t: 0,\n                d: 3\n              },\n              lineColor: {\n                t: 0,\n                d: 3\n              },\n              lineDash: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 1\n                }]\n              },\n              lineWidth: {\n                t: 1\n              }\n            };\n          }\n        },\n        to: {\n          t: 1\n        },\n        toType: {\n          t: 0,\n          d: 6\n        }\n      }, nt.LinearChartSettingsValueAxisTitleStyle = {\n        reverseDirection: {\n          t: 9\n        }\n      }, nt.LinearChartSettingsValueLabels = {\n        allowOverlap: {\n          t: 9\n        },\n        contentsFunction: {\n          t: 4\n        },\n        enabled: {\n          t: 9\n        },\n        minFontSize: {\n          t: 1\n        },\n        position: {\n          t: 0,\n          d: 6\n        },\n        showNullData: {\n          t: 9\n        },\n        showZeroData: {\n          t: 9\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        useStackedValue: {\n          t: 9\n        },\n        xPosition: {\n          t: 0,\n          d: 6\n        }\n      }, nt.NetChartBarSettingsLocalizationToolbar = {\n        fitButton: {\n          t: 0\n        },\n        fitTitle: {\n          t: 0\n        },\n        freezeButton: {\n          t: 0\n        },\n        freezeTitle: {\n          t: 0\n        },\n        rearrangeButton: {\n          t: 0\n        },\n        rearrangeTitle: {\n          t: 0\n        },\n        unfreezeTitle: {\n          t: 0\n        }\n      }, nt.NetChartBarSettingsToolbar = {\n        zoomControl: {\n          t: 9\n        }\n      }, nt.NetChartGravitySettings = {\n        from: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        fromCenter: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        strength: {\n          t: 1\n        },\n        to: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        toCenter: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        }\n      }, nt.NetChartIChartClickEventArguments = {}, nt.NetChartIChartEventArguments = {}, nt.NetChartIDataObject = {\n        links: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.NetChartIDataObjectLink;\n            }\n          }]\n        },\n        nodes: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.NetChartIDataObjectNode;\n            }\n          }]\n        }\n      }, nt.NetChartIDataObjectLink = {}, nt.NetChartIDataObjectNode = {\n        locked: {\n          t: 9\n        },\n        x: {\n          t: 1\n        },\n        y: {\n          t: 1\n        }\n      }, nt.NetChartSettings = {\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsArea;\n          },\n          x: function x() {\n            return i.NetChart.SettingsArea;\n          }\n        },\n        auras: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.ItemsChartSettingsNodesLayerAuras;\n          },\n          x: function x() {\n            return i.ItemsChart.SettingsNodesLayerAuras;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.NetChartSettingsData;\n            },\n            x: function x() {\n              return i.NetChart.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsEvents;\n          },\n          x: function x() {\n            return i.NetChart.SettingsEvents;\n          }\n        },\n        filters: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              linkFilter: {\n                t: 4\n              },\n              multilinkProcessor: {\n                t: 4\n              },\n              nodeFilter: {\n                t: 4\n              },\n              nodeLinksProcessor: {\n                t: 4\n              }\n            };\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.NetChart.SettingsInteraction;\n          }\n        },\n        layout: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsLayout;\n          },\n          x: function x() {\n            return i.NetChart.SettingsLayout;\n          }\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsLegend;\n          },\n          x: function x() {\n            return i.NetChart.SettingsLegend;\n          }\n        },\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsLocalization;\n          },\n          x: function x() {\n            return i.NetChart.SettingsLocalization;\n          }\n        },\n        navigation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsNavigation;\n          },\n          x: function x() {\n            return i.NetChart.SettingsNavigation;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsStyle;\n          },\n          x: function x() {\n            return i.NetChart.SettingsStyle;\n          }\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.NetChartSettings;\n          },\n          x: function x() {\n            return i.NetChart.Settings;\n          },\n          y: !0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartBarSettingsToolbar;\n          },\n          x: function x() {\n            return i.NetChart.Bar.SettingsToolbar;\n          }\n        }\n      }, nt.NetChartSettingsArea = {\n        centerX: {\n          t: 1\n        },\n        centerY: {\n          t: 1\n        },\n        paddingBottom: {\n          t: 1\n        },\n        paddingLeft: {\n          t: 1\n        },\n        paddingRight: {\n          t: 1\n        },\n        paddingTop: {\n          t: 1\n        }\n      }, nt.NetChartSettingsData = {\n        dataFunction: {\n          t: 4\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.NetChartIDataObject;\n          }\n        }\n      }, nt.NetChartSettingsEvents = {\n        onDataUpdated: {\n          t: 4\n        },\n        onPointerDown: {\n          t: 4\n        },\n        onPointerDrag: {\n          t: 4\n        },\n        onPointerMove: {\n          t: 4\n        },\n        onPointerUp: {\n          t: 4\n        }\n      }, nt.NetChartSettingsInteraction = {\n        rotation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fingers: {\n                t: 9\n              }\n            };\n          }\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsInteractionSelection;\n          },\n          x: function x() {\n            return i.NetChart.SettingsInteractionSelection;\n          }\n        },\n        zooming: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsInteractionZooming;\n          },\n          x: function x() {\n            return i.NetChart.SettingsInteractionZooming;\n          }\n        }\n      }, nt.NetChartSettingsInteractionSelection = {\n        dragSelect: {\n          t: 9\n        }\n      }, nt.NetChartSettingsInteractionZooming = {\n        autoZoomExtent: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        },\n        autoZoomPositionElasticity: {\n          t: 1\n        },\n        autoZoomSize: {\n          t: 1\n        },\n        initialAutoZoom: {\n          t: 7,\n          b: [{\n            t: 9\n          }, {\n            t: 0\n          }]\n        },\n        zoomExtent: {\n          t: 12,\n          b: [{\n            t: 1\n          }, {\n            t: 1\n          }]\n        }\n      }, nt.NetChartSettingsLayout = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              adaptiveFreezeTreshold: {\n                t: 1\n              }\n            };\n          }\n        },\n        aspectRatio: {\n          t: 9\n        },\n        globalLayoutOnChanges: {\n          t: 9\n        },\n        gravity: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartGravitySettings;\n          },\n          x: function x() {\n            return i.NetChart.GravitySettings;\n          }\n        },\n        groupSpacing: {\n          t: 1,\n          d: 0\n        },\n        incrementalLayoutMaxTime: {\n          t: 1,\n          d: 0\n        },\n        initialLayoutMaxTime: {\n          t: 1,\n          d: 0\n        },\n        layoutFreezeMinTimeout: {\n          t: 1,\n          d: 0\n        },\n        layoutFreezeTimeout: {\n          t: 1,\n          d: 0\n        },\n        mode: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        nodeSpacing: {\n          t: 1,\n          d: 0\n        },\n        rotation: {\n          t: 1\n        },\n        rowSpacing: {\n          t: 1,\n          d: 0\n        },\n        twoRingRadialLayout: {\n          t: 9\n        }\n      }, nt.NetChartSettingsLegend = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartSettingsLegendAdvanced;\n          },\n          x: function x() {\n            return i.NetChart.SettingsLegendAdvanced;\n          }\n        },\n        mode: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        panel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLegendPanel;\n          },\n          x: function x() {\n            return i.Base.SettingsLegendPanel;\n          }\n        }\n      }, nt.NetChartSettingsLegendAdvanced = {\n        showItemsWithClasses: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        textColorDisabled: {\n          t: 0\n        }\n      }, nt.NetChartSettingsLocalization = {\n        menu: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              close: {\n                t: 0\n              },\n              collapse: {\n                t: 0\n              },\n              dynamic: {\n                t: 0\n              },\n              expand: {\n                t: 0\n              },\n              fixed: {\n                t: 0\n              },\n              focus: {\n                t: 0\n              },\n              hide: {\n                t: 0\n              },\n              unfocus: {\n                t: 0\n              }\n            };\n          }\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.NetChartBarSettingsLocalizationToolbar;\n          },\n          x: function x() {\n            return i.NetChart.Bar.SettingsLocalizationToolbar;\n          }\n        }\n      }, nt.NetChartSettingsNavigation = {\n        autoUnfocus: {\n          t: 9\n        },\n        autoZoomOnFocus: {\n          t: 9\n        },\n        expandDelay: {\n          t: 1,\n          d: 0\n        },\n        expandOnClick: {\n          t: 9\n        },\n        focusAutoFadeout: {\n          t: 9\n        },\n        focusNodeExpansionRadius: {\n          t: 1\n        },\n        focusNodeTailExpansionRadius: {\n          t: 1\n        },\n        initialNodes: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        minNumberOfFocusNodes: {\n          t: 1,\n          d: 0\n        },\n        mode: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        },\n        numberOfFocusNodes: {\n          t: 1,\n          d: 0\n        }\n      }, nt.NetChartSettingsStyle = {\n        dragSelection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsBackgroundStyle;\n          }\n        }\n      }, nt.PieChartIChartClickEventArguments = {}, nt.PieChartIChartEventArguments = {}, nt.PieChartIDataObject = {\n        id: {\n          t: 0\n        },\n        name: {\n          t: 0\n        },\n        nameLegend: {\n          t: 0\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsSliceStyle;\n          }\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.PieChartIDataObject;\n            }\n          }]\n        },\n        value: {\n          t: 1\n        }\n      }, nt.PieChartIDataObjectCommon = {\n        id: {\n          t: 0\n        },\n        name: {\n          t: 0\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.PieChartIDataObject;\n            }\n          }]\n        }\n      }, nt.PieChartIDataObjectRoot = {\n        afterSum: {\n          t: 1\n        },\n        beforeSum: {\n          t: 1\n        },\n        id: {\n          t: 0\n        },\n        limit: {\n          t: 1\n        },\n        name: {\n          t: 0\n        },\n        offset: {\n          t: 1\n        },\n        subvalues: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.PieChartIDataObject;\n            }\n          }]\n        },\n        sum: {\n          t: 1\n        }\n      }, nt.PieChartSettings = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsAdvanced;\n          },\n          x: function x() {\n            return i.PieChart.SettingsAdvanced;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.PieChartSettingsData;\n            },\n            x: function x() {\n              return i.PieChart.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsEvents;\n          },\n          x: function x() {\n            return i.PieChart.SettingsEvents;\n          }\n        },\n        filters: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              allowZeroValues: {\n                t: 9\n              },\n              sliceFilter: {\n                t: 4\n              }\n            };\n          }\n        },\n        icons: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              autohideWhenTooSmall: {\n                t: 9\n              },\n              placement: {\n                t: 0,\n                d: 6\n              },\n              sizeExtent: {\n                t: 12,\n                b: [{\n                  t: 1\n                }, {\n                  t: 1\n                }]\n              }\n            };\n          }\n        },\n        info: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              contentsFunction: {\n                t: 4\n              },\n              enabled: {\n                t: 9\n              }\n            };\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.PieChart.SettingsInteraction;\n          }\n        },\n        labels: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsLabels;\n          },\n          x: function x() {\n            return i.PieChart.SettingsLabels;\n          }\n        },\n        legend: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsLegend;\n          },\n          x: function x() {\n            return i.PieChart.SettingsLegend;\n          }\n        },\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsLocalization;\n          },\n          x: function x() {\n            return i.PieChart.SettingsLocalization;\n          }\n        },\n        navigation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              initialDrilldown: {\n                t: 6,\n                u: 0,\n                b: [{\n                  t: 0\n                }]\n              },\n              initialOffset: {\n                t: 1,\n                d: 0\n              }\n            };\n          }\n        },\n        pie: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              adaptiveRadius: {\n                t: 9\n              },\n              backgroundHoveredStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsPieStyle;\n                }\n              },\n              backgroundStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsPieStyle;\n                }\n              },\n              centerMargin: {\n                t: 1,\n                d: 0\n              },\n              depth: {\n                t: 1,\n                d: 0\n              },\n              endAngle: {\n                t: 1\n              },\n              innerRadius: {\n                t: 1\n              },\n              innerRadiusWhenDrilldown: {\n                t: 1\n              },\n              margin: {\n                t: 1\n              },\n              noDataStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsPieStyle;\n                }\n              },\n              outerMargin: {\n                t: 1\n              },\n              radius: {\n                t: 1\n              },\n              rotationSpeed: {\n                t: 1\n              },\n              showInnerPies: {\n                t: 9\n              },\n              showInnerPiesExport: {\n                t: 9\n              },\n              startAngle: {\n                t: 1\n              },\n              style: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsPieStyle;\n                }\n              },\n              styleFunction: {\n                t: 4\n              },\n              theme: {\n                t: 0,\n                d: 6\n              },\n              x: {\n                t: 1\n              },\n              y: {\n                t: 1\n              }\n            };\n          }\n        },\n        slice: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              backgroundActiveStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    brightness: {\n                      t: 1\n                    }\n                  };\n                }\n              },\n              backgroundStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    fillColor: {\n                      t: 0\n                    },\n                    fillColor2: {\n                      t: 0,\n                      d: 3\n                    },\n                    fillGradient: {\n                      t: 11\n                    }\n                  };\n                }\n              },\n              connectorStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              },\n              expandableMarkStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    distance: {\n                      t: 1\n                    },\n                    lineColor: {\n                      t: 0\n                    },\n                    lineDash: {\n                      t: 6,\n                      u: 0,\n                      b: [{\n                        t: 1\n                      }]\n                    },\n                    lineWidth: {\n                      t: 1\n                    }\n                  };\n                }\n              },\n              hoverStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsSliceStyle;\n                }\n              },\n              margin: {\n                t: 1\n              },\n              minFraction: {\n                t: 1\n              },\n              othersStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    fillColor: {\n                      t: 0\n                    },\n                    lineDecoration: {\n                      t: 0,\n                      d: 6\n                    }\n                  };\n                }\n              },\n              previousStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    fillColor: {\n                      t: 0\n                    },\n                    lineDecoration: {\n                      t: 0,\n                      d: 6\n                    }\n                  };\n                }\n              },\n              selectedStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsSliceStyle;\n                }\n              },\n              style: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.PieChartSettingsSliceStyle;\n                }\n              },\n              styleFunction: {\n                t: 4\n              }\n            };\n          }\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.PieChartSettings;\n          },\n          x: function x() {\n            return i.PieChart.Settings;\n          },\n          y: !0\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsToolbar;\n          },\n          x: function x() {\n            return i.Base.SettingsToolbar;\n          }\n        }\n      }, nt.PieChartSettingsAdvanced = {\n        backAlwaysVisible: {\n          t: 9\n        },\n        backImage: {\n          t: 0,\n          d: 4\n        },\n        backImageBackground: {\n          t: 0\n        },\n        iconMinSize: {\n          t: 1\n        },\n        initialAnimation: {\n          t: 9\n        },\n        labelInsideTreshold: {\n          t: 1,\n          d: 0\n        },\n        renderQuality: {\n          t: 1,\n          d: 0\n        }\n      }, nt.PieChartSettingsData = {\n        autoCategories: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            b: [{\n              t: 4\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        dataFunction: {\n          t: 4\n        },\n        itemsToLoad: {\n          t: 1,\n          d: 0\n        },\n        partialLoad: {\n          t: 9\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.PieChartIDataObjectRoot;\n          }\n        },\n        sortField: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 4\n          }, {\n            t: 6,\n            u: 0,\n            b: [{\n              t: 0\n            }]\n          }, {\n            t: 0\n          }]\n        }\n      }, nt.PieChartSettingsEvents = {\n        onPieChange: {\n          t: 4\n        },\n        onPieReadyStateChanged: {\n          t: 4\n        }\n      }, nt.PieChartSettingsInteraction = {\n        animation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              hoverDuration: {\n                t: 1,\n                d: 0\n              },\n              scrollDuration: {\n                t: 1,\n                d: 0\n              }\n            };\n          }\n        },\n        coverCenter: {\n          t: 9\n        },\n        mode: {\n          t: 0,\n          d: 6\n        },\n        others: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              centerGoesToPrevious: {\n                t: 9\n              },\n              enabled: {\n                t: 9\n              },\n              maxOthersFraction: {\n                t: 1\n              },\n              maxSlicesVisible: {\n                t: 1,\n                d: 0\n              },\n              minSliceFraction: {\n                t: 1\n              },\n              minSlices: {\n                t: 1\n              },\n              navigationFraction: {\n                t: 1\n              }\n            };\n          }\n        },\n        scrolling: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              enabled: {\n                t: 9\n              }\n            };\n          }\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              enabled: {\n                t: 9\n              },\n              maxSwipeDistance: {\n                t: 1\n              },\n              partialSwipe: {\n                t: 9\n              },\n              swipe: {\n                t: 9\n              },\n              swipeSensitivity: {\n                t: 1\n              },\n              tolerance: {\n                t: 1\n              }\n            };\n          }\n        }\n      }, nt.PieChartSettingsLabels = {\n        angle: {\n          t: 1,\n          d: 0\n        },\n        connectorLength: {\n          t: 1,\n          d: 0\n        },\n        connectors: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        insideLabel: {\n          t: 0,\n          d: 6\n        },\n        insideLabelVisibilityFraction: {\n          t: 1\n        },\n        interLabelSpacing: {\n          t: 1\n        },\n        placement: {\n          t: 0,\n          d: 6\n        }\n      }, nt.PieChartSettingsLegend = {\n        marker: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.PieChartSettingsLegendMarker;\n          },\n          x: function x() {\n            return i.PieChart.SettingsLegendMarker;\n          }\n        },\n        showOthers: {\n          t: 9\n        }\n      }, nt.PieChartSettingsLegendMarker = {\n        shape: {\n          t: 7,\n          d: 6,\n          b: [{\n            t: 0\n          }]\n        }\n      }, nt.PieChartSettingsLocalization = {\n        othersLabel: {\n          t: 0\n        },\n        previousLabel: {\n          t: 0\n        }\n      }, nt.PieChartSettingsPieStyle = {\n        background: {\n          t: 9\n        },\n        brightness: {\n          t: 1\n        },\n        colorDistribution: {\n          t: 0,\n          d: 6\n        },\n        fillColor: {\n          t: 0,\n          d: 3\n        },\n        sliceColors: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0,\n            d: 3\n          }]\n        }\n      }, nt.PieChartSettingsSliceStyle = {\n        brightness: {\n          t: 1\n        },\n        cutoutDistance: {\n          t: 1\n        },\n        expandable: {\n          t: 9\n        },\n        fillColor: {\n          t: 0,\n          d: 3\n        },\n        icon: {\n          t: 0,\n          d: 4\n        },\n        insideLabel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        label: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        lineBrightness: {\n          t: 1,\n          d: 0\n        },\n        lineColor: {\n          t: 0,\n          d: 3\n        },\n        lineDash: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1\n          }]\n        },\n        lineWidth: {\n          t: 1,\n          d: 0\n        },\n        url: {\n          t: 0,\n          d: 5\n        }\n      }, nt.TimeChartIChartEventArguments = {}, nt.TimeChartIDataObject = {\n        data: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 7,\n              b: [{\n                t: 1\n              }, {\n                t: 0\n              }]\n            }]\n          }]\n        },\n        dataLimitFrom: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        dataLimitTo: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        from: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        timeZone: {\n          t: 0\n        },\n        to: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        unit: {\n          t: 0\n        },\n        values: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 18\n            }, {\n              t: 17\n            }, {\n              t: 16\n            }, {\n              t: 15\n            }, {\n              t: 6,\n              u: 0,\n              b: [{\n                t: 7,\n                b: [{\n                  t: 1\n                }, {\n                  t: 0\n                }]\n              }]\n            }]\n          }]\n        }\n      }, nt.TimeChartSettings = {\n        advanced: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsAdvanced;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsAdvanced;\n          }\n        },\n        area: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsArea;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsArea;\n          }\n        },\n        chartTypes: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              candlestick: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsSeriesCandleStick;\n                },\n                x: function x() {\n                  return i.TimeChart.SettingsSeriesCandleStick;\n                },\n                y: !0\n              },\n              columns: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsSeriesColumns;\n                },\n                x: function x() {\n                  return i.TimeChart.SettingsSeriesColumns;\n                },\n                y: !0\n              },\n              line: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsSeriesLines;\n                },\n                x: function x() {\n                  return i.TimeChart.SettingsSeriesLines;\n                },\n                y: !0\n              }\n            };\n          }\n        },\n        currentTime: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsCurrentTime;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsCurrentTime;\n          }\n        },\n        data: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.TimeChartSettingsData;\n            },\n            x: function x() {\n              return i.TimeChart.SettingsData;\n            }\n          }]\n        },\n        events: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsEvents;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsEvents;\n          }\n        },\n        interaction: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsInteraction;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsInteraction;\n          }\n        },\n        localization: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsLocalization;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsLocalization;\n          }\n        },\n        milestones: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.TimeChartSettingsMarker;\n            },\n            x: function x() {\n              return i.TimeChart.SettingsMarker;\n            }\n          }]\n        },\n        navigation: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              followAnchor: {\n                t: 9\n              },\n              initialDisplayAnchor: {\n                t: 7,\n                b: [{\n                  t: 0\n                }, {\n                  t: 1\n                }]\n              },\n              initialDisplayPeriod: {\n                t: 0\n              },\n              initialDisplayUnit: {\n                t: 0\n              }\n            };\n          }\n        },\n        series: {\n          t: 6,\n          u: 4,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.TimeChartSettingsSeries;\n            },\n            x: function x() {\n              return i.TimeChart.SettingsSeries;\n            },\n            y: !0\n          }]\n        },\n        seriesDefault: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeries;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeries;\n          },\n          y: !0\n        },\n        theme: {\n          t: 5,\n          c: function c() {\n            return nt.TimeChartSettings;\n          },\n          x: function x() {\n            return i.TimeChart.Settings;\n          },\n          y: !0\n        },\n        timeAxis: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsTimeAxis;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsTimeAxis;\n          }\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsToolbar;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsToolbar;\n          }\n        }\n      }, nt.TimeChartSettingsAdvanced = {\n        dataUpdateInterval: {\n          t: 1,\n          d: 0\n        },\n        maxUnitsToDisplay: {\n          t: 1\n        },\n        timeUpdateInterval: {\n          t: 1,\n          d: 0\n        }\n      }, nt.TimeChartSettingsArea = {\n        displayPeriods: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return {\n                unit: {\n                  t: 0\n                }\n              };\n            }\n          }]\n        },\n        displayUnits: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return {\n                unit: {\n                  t: 0\n                },\n                name: {\n                  t: 0\n                }\n              };\n            }\n          }]\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsAreaStyle;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsAreaStyle;\n          }\n        }\n      }, nt.TimeChartSettingsAreaDisplayPeriod = {\n        displayAnchor: {\n          t: 7,\n          b: [{\n            t: 0\n          }, {\n            t: 1\n          }]\n        },\n        displayPeriod: {\n          t: 0\n        },\n        displayUnit: {\n          t: 0\n        },\n        name: {\n          t: 0\n        }\n      }, nt.TimeChartSettingsAreaStyle = {\n        markerText: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTextStyle;\n          }\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsAreaStyleSelection;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsAreaStyleSelection;\n          }\n        },\n        selectionLabel: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsTextStyle;\n          }\n        }\n      }, nt.TimeChartSettingsAreaStyleSelection = {\n        behindSeries: {\n          t: 9\n        },\n        fillColor: {\n          t: 0\n        },\n        lineColor: {\n          t: 0\n        },\n        lineWidth: {\n          t: 1\n        },\n        roundToNearestTime: {\n          t: 9\n        }\n      }, nt.TimeChartSettingsCurrentTime = {\n        align: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        label: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        showTime: {\n          t: 9\n        },\n        side: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLineStyle;\n          }\n        }\n      }, nt.TimeChartSettingsData = {\n        cacheSize: {\n          t: 1,\n          d: 0\n        },\n        dataFunction: {\n          t: 4\n        },\n        minimizeRequests: {\n          t: 9\n        },\n        prefetchRatio: {\n          t: 1\n        },\n        preloaded: {\n          t: 5,\n          c: function c() {\n            return nt.TimeChartIDataObject;\n          }\n        },\n        requestMaxUnits: {\n          t: 1,\n          d: 0\n        },\n        stringTimestampFormat: {\n          t: 7,\n          u: 0,\n          b: [{\n            t: 6,\n            u: 0,\n            b: [{\n              t: 0\n            }]\n          }, {\n            t: 0\n          }]\n        },\n        suppressWarnings: {\n          t: 9\n        },\n        timeZoneOffset: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        timestampInSeconds: {\n          t: 9\n        },\n        units: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        url: {\n          t: 0,\n          d: 5\n        },\n        urlByUnit: {\n          t: 8,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        useSmallerUnitCache: {\n          t: 9\n        }\n      }, nt.TimeChartSettingsEvents = {\n        onTimeChange: {\n          t: 4\n        },\n        selectionChangeDuringInteraction: {\n          t: 9\n        }\n      }, nt.TimeChartSettingsInteraction = {\n        scrolling: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsInteractionScrolling;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsInteractionScrolling;\n          }\n        },\n        selection: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsInteractionSelection;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsInteractionSelection;\n          }\n        },\n        snapMode: {\n          t: 0,\n          d: 6\n        },\n        zooming: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsInteractionZooming;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsInteractionZooming;\n          }\n        }\n      }, nt.TimeChartSettingsInteractionScrolling = {\n        limitFrom: {\n          t: 7,\n          b: [{\n            t: 0\n          }, {\n            t: 1\n          }]\n        },\n        limitMode: {\n          t: 0,\n          d: 6\n        },\n        limitTo: {\n          t: 7,\n          b: [{\n            t: 0\n          }, {\n            t: 1\n          }]\n        },\n        overscrollProportion: {\n          t: 1\n        }\n      }, nt.TimeChartSettingsInteractionSelection = {\n        clearOnRightClick: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        moveByDragging: {\n          t: 9\n        },\n        resizeSensitivity: {\n          t: 1\n        },\n        resizeTolerance: {\n          t: 1\n        },\n        tolerance: {\n          t: 1\n        }\n      }, nt.TimeChartSettingsInteractionZooming = {\n        click: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        }\n      }, nt.TimeChartSettingsLocalization = {\n        calendar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsLocalizationCalendar;\n          }\n        },\n        determiningDataBounds: {\n          t: 0\n        },\n        holidayWeekdays: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 1,\n            d: 0\n          }]\n        },\n        infoDates: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              fullTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              },\n              majorTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              },\n              minorTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              }\n            };\n          }\n        },\n        loadingLabel: {\n          t: 0\n        },\n        markerDates: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              timeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              }\n            };\n          }\n        },\n        timeAxisDates: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              majorLabelFullTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              },\n              majorLabelTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              },\n              minorLabelTimeFormats: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.TimeChartSettingsLocalizationTimeUnits;\n                }\n              }\n            };\n          }\n        },\n        timeUnitsNames: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsLocalizationTimeUnits;\n          }\n        },\n        timeUnitsNamesPlural: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsLocalizationTimeUnits;\n          }\n        },\n        toolbar: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsLocalizationToolbar;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsLocalizationToolbar;\n          }\n        }\n      }, nt.TimeChartSettingsLocalizationCalendar = {\n        months: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        monthsShort: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        parentLocale: {\n          t: 0\n        },\n        week: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              dow: {\n                t: 1,\n                d: 0\n              },\n              doy: {\n                t: 1\n              }\n            };\n          }\n        },\n        weekdays: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        weekdaysMin: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        },\n        weekdaysShort: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 0\n          }]\n        }\n      };\n      nt.TimeChartSettingsLocalizationTimeUnits = {\n        M: {\n          t: 0\n        },\n        d: {\n          t: 0\n        },\n        h: {\n          t: 0\n        },\n        m: {\n          t: 0\n        },\n        ms: {\n          t: 0\n        },\n        s: {\n          t: 0\n        },\n        w: {\n          t: 0\n        },\n        y: {\n          t: 0\n        }\n      };\n      nt.TimeChartSettingsLocalizationToolbar = {\n        customPeriod: {\n          t: 0\n        },\n        periodDropdownTitle: {\n          t: 0\n        },\n        unavailableUnitTitle: {\n          t: 0\n        },\n        unitDropdownTitle: {\n          t: 0\n        },\n        zoomoutButton: {\n          t: 0\n        },\n        zoomoutTitle: {\n          t: 0\n        }\n      }, nt.TimeChartSettingsMarker = {\n        align: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        enabled: {\n          t: 9\n        },\n        label: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLabelStyle;\n          }\n        },\n        overrideLimits: {\n          t: 9\n        },\n        showTime: {\n          t: 9\n        },\n        side: {\n          t: 7,\n          b: [{\n            t: 0\n          }]\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.BaseSettingsLineStyle;\n          }\n        },\n        time: {\n          t: 1,\n          d: 0\n        }\n      }, nt.TimeChartSettingsSeries = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeriesData;\n          }\n        }\n      }, nt.TimeChartSettingsSeriesCandleStick = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeriesCandleStickData;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeriesCandleStickData;\n          }\n        }\n      }, nt.TimeChartSettingsSeriesCandleStickData = {\n        close: {\n          t: 1\n        },\n        high: {\n          t: 1\n        },\n        low: {\n          t: 1\n        },\n        open: {\n          t: 1\n        }\n      }, nt.TimeChartSettingsSeriesColumns = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeriesData;\n          }\n        }\n      }, nt.TimeChartSettingsSeriesData = {\n        countIndex: {\n          t: 1\n        },\n        index: {\n          t: 1,\n          d: 0\n        }\n      }, nt.TimeChartSettingsSeriesLines = {\n        data: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeriesData;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeriesData;\n          }\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return nt.TimeChartSettingsSeriesLinesStyle;\n          },\n          x: function x() {\n            return i.TimeChart.SettingsSeriesLinesStyle;\n          }\n        }\n      }, nt.TimeChartSettingsSeriesLinesStyle = {\n        markerStyleFunction: {\n          t: 4\n        }\n      }, nt.TimeChartSettingsTimeAxis = {\n        enabled: {\n          t: 9\n        },\n        maxUnitWidth: {\n          t: 1\n        },\n        minUnitWidth: {\n          t: 1\n        },\n        miniTimeRuler: {\n          t: 9\n        },\n        padding: {\n          t: 1\n        },\n        showHolidays: {\n          t: 9\n        },\n        style: {\n          t: 5,\n          u: 0,\n          c: function c() {\n            return {\n              dateHolidays: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsBackgroundStyle;\n                }\n              },\n              dateLighten: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return {\n                    fillColor: {\n                      t: 0\n                    }\n                  };\n                }\n              },\n              majorTimeBalloonStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsBackgroundStyle;\n                }\n              },\n              majorTimeLabel: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsTextStyle;\n                }\n              },\n              minorTimeBalloonStyle: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsBackgroundStyle;\n                }\n              },\n              minorTimeLabel: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsTextStyle;\n                }\n              },\n              minorTimeRuler: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              },\n              showMajorTimeBalloons: {\n                t: 9\n              },\n              showMinorTimeBalloons: {\n                t: 9\n              },\n              vgrid: {\n                t: 5,\n                u: 0,\n                c: function c() {\n                  return nt.BaseSettingsLineStyle;\n                }\n              }\n            };\n          }\n        },\n        timeZone: {\n          t: 0\n        },\n        timeZoneOffset: {\n          t: 7,\n          b: [{\n            t: 1\n          }, {\n            t: 0\n          }]\n        },\n        unitSizePolicy: {\n          t: 0,\n          d: 6\n        },\n        vgrid: {\n          t: 9\n        }\n      }, nt.TimeChartSettingsToolbar = {\n        displayPeriod: {\n          t: 9\n        },\n        displayUnit: {\n          t: 9\n        },\n        enabled: {\n          t: 9\n        },\n        items: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 7,\n            u: 0,\n            b: [{\n              t: 5,\n              u: 0,\n              c: function c() {\n                return nt.BaseSettingsToolbarItem;\n              },\n              x: function x() {\n                return i.Base.SettingsToolbarItem;\n              }\n            }, {\n              t: 0\n            }]\n          }]\n        },\n        logScale: {\n          t: 9\n        },\n        periods: {\n          t: 6,\n          u: 0,\n          b: [{\n            t: 5,\n            u: 0,\n            c: function c() {\n              return nt.TimeChartSettingsAreaDisplayPeriod;\n            },\n            x: function x() {\n              return i.TimeChart.SettingsAreaDisplayPeriod;\n            }\n          }]\n        },\n        zoomOut: {\n          t: 9\n        },\n        zoomOutFunction: {\n          t: 4\n        }\n      }, r.SettingsMapping = nt, a(nt.BaseIChartErrorEventArguments, nt.BaseIChartEventArguments), a(nt.BaseIChartSettingsChangeEventArguments, nt.BaseIChartEventArguments), a(nt.BaseIDataErrorResponse, nt.BaseIDataObjectBase), a(nt.BaseSettingsBackgroundStyle, nt.BaseSettingsLineStyle), a(nt.BaseSettingsAdvancedStyleMessageBackground, nt.BaseSettingsBackgroundStyle), a(nt.BaseSettingsLegendPanel, nt.BaseSettingsChartPanel), a(nt.BaseSettingsToolbarItem, nt.BaseSettingsToolbarItemBase), a(nt.FacetChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.FacetChartIChartClickEventArguments, nt.FacetChartIChartEventArguments), a(nt.FacetChartIDataObjectCommon, nt.BaseIDataObjectBase), a(nt.FacetChartIDataObject, nt.FacetChartIDataObjectCommon), a(nt.FacetChartIDataObjectRoot, nt.FacetChartIDataObjectCommon), a(nt.FacetChartIDataObjectRoot, nt.BaseIDataErrorResponse), a(nt.LinearChartSettings, nt.BaseSettings), a(nt.FacetChartSettings, nt.LinearChartSettings), a(nt.LinearChartSettingsArea, nt.BaseSettingsArea), a(nt.FacetChartSettingsArea, nt.LinearChartSettingsArea), a(nt.LinearChartSettingsAreaStyle, nt.BaseSettingsAreaStyle), a(nt.FacetChartSettingsAreaStyle, nt.LinearChartSettingsAreaStyle), a(nt.PieChartSettingsData, nt.BaseSettingsData), a(nt.FacetChartSettingsData, nt.PieChartSettingsData), a(nt.FacetChartSettingsFacetAxisLabels, nt.BaseSettingsLabelStyle), a(nt.FacetChartSettingsFacetAxisTitleStyle, nt.BaseSettingsLabelStyle), a(nt.LinearChartSettingsSeriesColumnsStyle, nt.LinearChartSettingsSeriesStyle), a(nt.FacetChartSettingsSeriesColumnsStyle, nt.LinearChartSettingsSeriesColumnsStyle), a(nt.FacetChartSettingsFacetStyle, nt.FacetChartSettingsSeriesColumnsStyle), a(nt.LinearChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.FacetChartSettingsInteraction, nt.LinearChartSettingsInteraction), a(nt.FacetChartSettingsSeries, nt.LinearChartSettingsSeries), a(nt.LinearChartSettingsSeriesColumns, nt.LinearChartSettingsSeries), a(nt.FacetChartSettingsSeriesColumns, nt.LinearChartSettingsSeriesColumns), a(nt.FacetChartSettingsSeriesData, nt.LinearChartSettingsSeriesData), a(nt.LinearChartSettingsSeriesLines, nt.LinearChartSettingsSeries), a(nt.FacetChartSettingsSeriesLines, nt.LinearChartSettingsSeriesLines), a(nt.LinearChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesStyle), a(nt.FacetChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesLinesStyle), a(nt.FacetChartSettingsToolbar, nt.BaseSettingsToolbar), a(nt.ItemsChartIDataObjectBase, nt.BaseIDataErrorResponse), a(nt.ItemsChartIDataObjectNode, nt.ItemsChartIDataObjectBase), a(nt.GeoChartIGeoDataObjectNode, nt.ItemsChartIDataObjectNode), a(nt.GeoChartIAggregationDataObjectNode, nt.GeoChartIGeoDataObjectNode), a(nt.GeoChartIDataObject, nt.BaseIDataErrorResponse), a(nt.ItemsChartIDataObjectLink, nt.ItemsChartIDataObjectBase), a(nt.GeoChartIGeoDataObjectLink, nt.ItemsChartIDataObjectLink), a(nt.ItemsChartSettings, nt.BaseSettings), a(nt.GeoChartSettings, nt.ItemsChartSettings), a(nt.GeoChartSettingsAggregatedShapeStyle, nt.BaseSettingsBackgroundStyle), a(nt.GeoChartSettingsArea, nt.BaseSettingsArea), a(nt.GeoChartSettingsAreaStyle, nt.BaseSettingsAreaStyle), a(nt.ItemsChartSettingsData, nt.BaseSettingsData), a(nt.GeoChartSettingsData, nt.ItemsChartSettingsData), a(nt.ItemsChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.GeoChartSettingsInteraction, nt.ItemsChartSettingsInteraction), a(nt.GeoChartSettingsInteractionZooming, nt.ItemsChartSettingsInteractionZooming), a(nt.GeoChartSettingsLayerOverlay, nt.GeoChartSettingsLayerBase), a(nt.GeoChartSettingsLayerAggregated, nt.GeoChartSettingsLayerOverlay), a(nt.GeoChartSettingsLayerCharts, nt.GeoChartSettingsLayerOverlay), a(nt.GeoChartSettingsLayerItems, nt.GeoChartSettingsLayerBase), a(nt.GeoChartSettingsLayerShapes, nt.GeoChartSettingsLayerBase), a(nt.ItemsChartSettingsNodesLayerStyle, nt.ItemsChartSettingsItemsLayerStyle), a(nt.GeoChartSettingsNodesLayerStyle, nt.ItemsChartSettingsNodesLayerStyle), a(nt.GeoChartSettingsShapesLayerNodeStyle, nt.ItemsChartSettingsNodeStyle), a(nt.GeoChartSettingsShapesLayerStyle, nt.GeoChartSettingsNodesLayerStyle), a(nt.ItemsChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.ItemsChartIChartClickEventArguments, nt.ItemsChartIChartEventArguments), a(nt.ItemsChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.ItemsChartSettingsAuraStyle, nt.BaseSettingsBackgroundStyle), a(nt.ItemsChartSettingsItemsLayerLabelStyle, nt.BaseSettingsLabelStyle), a(nt.ItemsChartSettingsItemsLayerItemStyle, nt.ItemsChartSettingsItemsLayerLabelStyle), a(nt.ItemsChartSettingsItemsLayerLinkLabelStyle, nt.ItemsChartSettingsItemsLayerLabelStyle), a(nt.ItemsChartSettingsLinkClass, nt.ItemsChartSettingsItemClass), a(nt.ItemsChartSettingsLinkItem, nt.ItemsChartSettingsItemsLayerItemStyle), a(nt.ItemsChartSettingsLinkMenu, nt.ItemsChartSettingsMenu), a(nt.ItemsChartSettingsNodeClass, nt.ItemsChartSettingsItemClass), a(nt.ItemsChartSettingsNodeItem, nt.ItemsChartSettingsItemsLayerItemStyle), a(nt.ItemsChartSettingsNodeMenu, nt.ItemsChartSettingsMenu);\n      var rt = nt.LinearChartSettingsEvents;\n      nt.LinearChartSettingsEvents = function (t, e) {\n        var i = rt(t, e);\n        return a(i, nt.BaseSettingsEvents(t, e)), i;\n      }, a(nt.LinearChartSettingsLegend, nt.BaseSettingsLegend), a(nt.LinearChartSettingsLegendAdvanced, nt.BaseSettingsLegendAdvanced), a(nt.LinearChartSettingsLegendMarker, nt.BaseSettingsLegendMarker), a(nt.LinearChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.LinearChartSettingsLocalizationToolbar, nt.BaseSettingsLocalizationToolbar), a(nt.LinearChartSettingsSeriesCandleStick, nt.LinearChartSettingsSeries), a(nt.LinearChartSettingsSeriesCandleStickStyle, nt.LinearChartSettingsSeriesStyle), a(nt.LinearChartSettingsValueAxisBaseLineStyle, nt.BaseSettingsLineStyle), a(nt.LinearChartSettingsValueAxisTitleStyle, nt.BaseSettingsLabelStyle), a(nt.NetChartBarSettingsLocalizationToolbar, nt.BaseSettingsLocalizationToolbar), a(nt.NetChartBarSettingsToolbar, nt.BaseSettingsToolbar), a(nt.NetChartIChartEventArguments, nt.ItemsChartIChartEventArguments), a(nt.NetChartIChartClickEventArguments, nt.NetChartIChartEventArguments), a(nt.NetChartIDataObject, nt.BaseIDataErrorResponse), a(nt.NetChartIDataObjectLink, nt.ItemsChartIDataObjectLink), a(nt.NetChartIDataObjectNode, nt.ItemsChartIDataObjectNode), a(nt.NetChartSettings, nt.ItemsChartSettings), a(nt.NetChartSettingsArea, nt.BaseSettingsArea), a(nt.NetChartSettingsData, nt.ItemsChartSettingsData), a(nt.NetChartSettingsEvents, nt.BaseSettingsEvents(nt.NetChartIChartEventArguments, nt.NetChartIChartClickEventArguments)), a(nt.NetChartSettingsInteraction, nt.ItemsChartSettingsInteraction), a(nt.NetChartSettingsInteractionSelection, nt.ItemsChartSettingsInteractionSelection), a(nt.NetChartSettingsInteractionZooming, nt.ItemsChartSettingsInteractionZooming), a(nt.NetChartSettingsLegend, nt.BaseSettingsLegend), a(nt.NetChartSettingsLegendAdvanced, nt.BaseSettingsLegendAdvanced), a(nt.NetChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.NetChartSettingsStyle, nt.ItemsChartSettingsNodesLayerStyle), a(nt.PieChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.PieChartIChartClickEventArguments, nt.PieChartIChartEventArguments), a(nt.PieChartIDataObjectCommon, nt.BaseIDataObjectBase), a(nt.PieChartIDataObject, nt.PieChartIDataObjectCommon), a(nt.PieChartIDataObjectRoot, nt.PieChartIDataObjectCommon), a(nt.PieChartIDataObjectRoot, nt.BaseIDataErrorResponse), a(nt.PieChartSettings, nt.BaseSettings), a(nt.PieChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.PieChartSettingsEvents, nt.BaseSettingsEvents(nt.PieChartIChartEventArguments, nt.PieChartIChartClickEventArguments)), a(nt.PieChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.PieChartSettingsLegend, nt.BaseSettingsLegend), a(nt.PieChartSettingsLegendMarker, nt.BaseSettingsLegendMarker), a(nt.PieChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.TimeChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.TimeChartIDataObject, nt.BaseIDataErrorResponse), a(nt.TimeChartSettings, nt.LinearChartSettings), a(nt.TimeChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.TimeChartSettingsArea, nt.LinearChartSettingsArea), a(nt.TimeChartSettingsAreaStyle, nt.LinearChartSettingsAreaStyle), a(nt.TimeChartSettingsCurrentTime, nt.TimeChartSettingsMarker), a(nt.TimeChartSettingsData, nt.BaseSettingsData), a(nt.TimeChartSettingsEvents, nt.LinearChartSettingsEvents(nt.TimeChartIChartEventArguments, nt.TimeChartIChartEventArguments)), a(nt.TimeChartSettingsInteraction, nt.LinearChartSettingsInteraction), a(nt.TimeChartSettingsInteractionScrolling, nt.LinearChartSettingsInteractionScrolling), a(nt.TimeChartSettingsInteractionZooming, nt.LinearChartSettingsInteractionZooming), a(nt.TimeChartSettingsLocalization, nt.LinearChartSettingsLocalization), a(nt.TimeChartSettingsLocalizationToolbar, nt.LinearChartSettingsLocalizationToolbar), a(nt.TimeChartSettingsSeries, nt.LinearChartSettingsSeries), a(nt.TimeChartSettingsSeriesCandleStick, nt.LinearChartSettingsSeriesCandleStick), a(nt.TimeChartSettingsSeriesData, nt.LinearChartSettingsSeriesData), a(nt.TimeChartSettingsSeriesCandleStickData, nt.TimeChartSettingsSeriesData), a(nt.TimeChartSettingsSeriesColumns, nt.LinearChartSettingsSeriesColumns), a(nt.TimeChartSettingsSeriesLines, nt.LinearChartSettingsSeriesLines), a(nt.TimeChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesLinesStyle), a(nt.TimeChartSettingsToolbar, nt.BaseSettingsToolbar);\n\n      var st = function () {\n        function t() {}\n\n        return t.mergeDefaultValues = function (e, i, n, r, s, a) {\n          var o = i ? i.type : null;\n\n          if (!e || 0 === e.length) {\n            if (!o) return [];\n            e = [{\n              type: o\n            }];\n          }\n\n          for (var l = [], h = 0; h < e.length; h++) {\n            var u = e[h],\n                c = a + \"[\" + h + \"]\";\n\n            if (d.isObjectOrArray(u)) {\n              var p = u.type || o;\n              if (!p) throw new Error(\"`type` property must be specified in the settings for value: \" + c);\n              var f = r(u, p),\n                  g = n[p];\n              i && (delete i.type, t.updateRecursive(f, i, s(f, i), {}, c), i.type = o), g && t.updateRecursive(f, g, s(f, g), {}, c), t.updateRecursive(f, u, s(f, u), {}, c), l.push(f);\n            }\n          }\n\n          return l;\n        }, t.updateRecursive = function (t, e, i, n, r) {\n          if (void 0 === r && (r = \"\"), !t) throw new Error(\"Cannot update settings path '\" + r + \"' because the target object is not defined.\");\n          if (e) for (var s in e) {\n            if (e.hasOwnProperty(s)) {\n              var a = e[s],\n                  o = (r.length ? r + \".\" : \"\") + s,\n                  l = this.findPropertyConfiguration(s, i, o);\n              null !== l && void 0 !== a && this.copyValue(t, s, a, l, n, o);\n            }\n          }\n        }, t.copyValueMergeByID = function (t, e, i, n, r, s) {\n          if (null != i) {\n            if (6 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use merge-by-ID update mode which is only supported on arrays.\");\n            if (this.replacingSettings) return this.copyValueRecursive(t, e, i, n, r, s);\n            var a = t[e];\n            null == a && (t[e] = a = []);\n\n            for (var o = {}, l = 0; l < a.length; l++) {\n              o[a[l].id] = a[l];\n            }\n\n            for (var h = 0; h < i.length; h++) {\n              var u = i[h];\n\n              if (null != u) {\n                u.id || (u.id = d.getIdentifierStr());\n                var c = o[u.id];\n                r[e] || (r[e] = {}), this.copyValue(o, u.id, u, n.b[0], r[e], s + \"[\" + u.id + \"]\"), c || a.push(o[u.id]);\n              }\n            }\n          }\n        }, t.retrieveOwnMethod = function (t, e) {\n          if (!t) return null;\n          var i = t[e],\n              n = t.__baseType;\n          return n && n[e] === i ? null : i;\n        }, t.copyValueRecursive = function (t, e, i, n, r, s) {\n          if (null != i) {\n            var a = t[e];\n\n            if (n.c) {\n              var o = n.x ? n.x() : null,\n                  l = this.retrieveOwnMethod(o, \"getMapping\"),\n                  h = l ? l(a, i) : n.c();\n\n              if (null == a) {\n                if (!o || n.y || this._ignoringCtor) a = {};else {\n                  var u = this.retrieveOwnMethod(o, \"createInstance\");\n                  a = u ? u(i) : new o();\n                }\n                t[e] = a;\n              }\n\n              if (n.y) try {\n                this._ignoringCtor++, this.updateRecursive(a, i, h, r[e] = {}, s);\n              } finally {\n                this._ignoringCtor--;\n              } else this.updateRecursive(a, i, h, r[e] = {}, s);\n            } else if (6 === n.t) t[e] = a = [], this.copyArray(a, i, n.b[0], r[e] = [], s);else {\n              if (8 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use recursive update but does not define target object mapping.\");\n              (null == a || this.replacingSettings) && (t[e] = a = {}), this.copyDictionary(a, i, n.b[0], r[e] = {}, s);\n            }\n          }\n        }, t.copyValue = function (t, e, i, n, r, s) {\n          if (void 0 === i) return delete t[e], void (r[e] = !0);\n          var a = this.ensurePropertyType(i, n, s);\n\n          if (a) {\n            i = a.value, n = a.configuration || n;\n            var o = t[e];\n            if (1 === n.u || void 0 === n.u) o !== i && (r[e] = i, t[e] = i);else if (2 === n.u) i = JSON.parse(JSON.stringify(i)), r[e] = i, t[e] = i;else if (4 === n.u) this.copyValueMergeByID(t, e, i, n, r, s);else if (3 === n.u) {\n              if (null != i) {\n                if (6 !== n.t) throw new Error(\"Property '\" + s + \"' is set to use concat update which is only supported for arrays.\");\n                o && !this.replacingSettings || (t[e] = o = []), this.copyArray(o, i, n.b[0], r[e] = [], s);\n              }\n            } else {\n              if (0 !== n.u) throw new Error(\"Property '\" + s + \"' does not have an update mode defined in the settings mapping or it is not implemented.\");\n              this.copyValueRecursive(t, e, i, n, r, s);\n            }\n          }\n        }, t.copyDictionary = function (t, e, i, n, r) {\n          for (var s = Object.keys(e), a = 0; a < s.length; a++) {\n            var o = s[a],\n                l = {};\n            this.copyValue(t, o, e[o], i, l, r + \".\" + o), d.hasProperties(l) && (n[o] = l);\n          }\n        }, t.copyArray = function (t, e, i, n, r) {\n          for (var s = 0; s < e.length; s++) {\n            this.copyValue(t, t.length, e[s], i, n, r + \"[\" + s + \"]\");\n          }\n        }, t.ensurePropertyType = function (t, e, i, n) {\n          if (void 0 === n && (n = !1), null == t) return {\n            value: t\n          };\n          var r = null,\n              s = null,\n              a = void 0,\n              o = null;\n\n          switch (e.t) {\n            case 0:\n              t instanceof String && (t = t.valueOf()), d.isString(t) || (r = \"String\");\n              break;\n\n            case 1:\n              if (t instanceof Number && (t = t.valueOf()), 0 === e.d) {\n                a = parseFloat(t);\n                var l = Math.round(a);\n                if (isNaN(a)) r = \"Integer\";else if (l !== a) {\n                  var h = Math.abs(l - a);\n                  n || d.warn(\"Settings value '\" + i + \"' expected to be an Integer but contains a decimal point: \" + a + \".\"), h < 1e-8 && (a = l);\n                }\n              } else a = parseFloat(t), isNaN(a) && (r = \"Float\");\n\n              break;\n\n            case 3:\n              d.isString(t) ? (a = document.getElementById(t), a || (s = \"the property expects either a reference to a DOM element or a string containing the ID of the element. There is no element with the given ID '\" + t + \"'.\")) : d.isDomObject(t) || (s = \"the property expects either a reference to a DOM element or a string containing the ID of the element.\");\n              break;\n\n            case 4:\n              d.isFunction(t) || (r = \"Function\");\n              break;\n\n            case 6:\n              Array.isArray(t) || (n ? r = \"Array\" : (d.warn(\"Settings value '\" + i + \"' expected to be an array but found \" + typeof t + \". The value will be wrapped in an array.\"), a = [t]));\n              break;\n\n            case 16:\n              \"undefined\" != typeof Float32Array && t instanceof Float32Array || (r = \"Float32Array\");\n              break;\n\n            case 16:\n              \"undefined\" != typeof Float32Array && t instanceof Float32Array || (r = \"Float32Array\");\n              break;\n\n            case 17:\n              \"undefined\" != typeof Int32Array && t instanceof Int32Array || (r = \"Int32Array\");\n              break;\n\n            case 18:\n              \"undefined\" != typeof Uint32Array && t instanceof Uint32Array || (r = \"UInt32Array\");\n              break;\n\n            case 11:\n              if (Array.isArray(t)) for (var u = 0; u < t.length; u++) {\n                var c = t[u];\n\n                if (!Array.isArray(c) || 2 !== c.length || !d.isNumber(c[0]) || !d.isString(c[1])) {\n                  s = \"the property at index \" + u + \" has to be an array with two elements - a number and a string.\";\n                  break;\n                }\n              } else s = \"the property has to be an array where each item is an array with two elements - a number and a string.\";\n              break;\n\n            case 2:\n              var p = e.e(),\n                  f = d.isNumber(t);\n              f || d.isString(t) ? (a = p[t], void 0 === a && (s = \"'\" + t + \"' is not a valid enumeration value. Please review the documentation for valid values.\", t = p), f && (a = t)) : (s = \"the value must be a number or a string (the preferred way is to use the enumeration from 'ZoomCharts.Configuration' namespace).\", t = p);\n              break;\n\n            case 14:\n              t instanceof CanvasGradient || (r = \"CanvasGradient\");\n              break;\n\n            case 12:\n              if (Array.isArray(t) && t.length === e.b.length) for (var g = 0; g < t.length; g++) {\n                var v = this.ensurePropertyType(t[g], e.b[g], i + \"[\" + g + \"]\", n);\n                if (!v) return null;\n                t[g] = v.value;\n              } else s = \"the property expects an array with exactly \" + e.b.length + \" elements.\";\n              break;\n\n            case 7:\n              for (var m = !1, y = 0; y < e.b.length; y++) {\n                var S = this.ensurePropertyType(t, e.b[y], i, !0);\n\n                if (S) {\n                  a = S.value, o = S.configuration || e.b[y], m = !0;\n                  break;\n                }\n              }\n\n              m || (s = \"the the given value does not match any constituent of the union type. Please review the documentation on the correct type.\");\n              break;\n\n            case 5:\n            case 8:\n              d.isObjectOrArray(t) || (r = \"Object\");\n              break;\n\n            case 9:\n              t instanceof Boolean && (t = t.valueOf()), null !== t && t !== !0 && t !== !1 && (r = \"Boolean\");\n              break;\n\n            case 10:\n              break;\n\n            default:\n              throw new Error(\"Unsupported data type: \" + e.t);\n          }\n\n          return null !== r && null === s && (s = \"the given value '\" + t + \"' is not of type '\" + r + \"'.\"), null !== s ? (n || d.error(\"Cannot update settings value '\" + i + \"' because \" + s, t), null) : (void 0 !== a && (t = a), {\n            value: t,\n            configuration: o\n          });\n        }, t.findPropertyConfiguration = function (t, e, i) {\n          var n = e[t];\n          return void 0 !== n ? n : (d.warn(\"Cannot update settings value '\" + i + \"' because such property does not exist.\", null, !0), null);\n        }, t;\n      }();\n\n      st._ignoringCtor = 0, st.replacingSettings = !1, r.SettingsHelper = st;\n\n      var at = function () {\n        function t(t) {\n          this._mapping = null, this._computedDataMap = {}, this._initializing = !0, this.container = null, this.theme = null, this.assetsUrlBase = \"\", this.area = new ct(), this.data = [], this.advanced = new ft(), this.events = new ot(), this.interaction = new pt(), this.localization = new lt(), this.toolbar = new Q(), this.title = new z(), this.credits = new N(), this.legend = new W(), this.callbacks = new ht(), this._mapping = t;\n        }\n\n        return t.prototype.applyGlobalCustomizations = function () {\n          this.theme && st.updateRecursive(this, this.theme, this._mapping, {});\n        }, t.prototype.applyCompatibility = function (t, e, i) {\n          i = null == i ? \"\" : i + \".\";\n\n          for (var n = 0; n < e.length; n++) {\n            var r = e[n],\n                s = r.from,\n                a = d.getProp(t, s, !!r.to && !r.filter);\n            if (void 0 !== a && (!r.filter || r.filter(a))) if (r.to) r.transform && (a = r.transform(a)), d.extendDeep(t, d.wrapValue(a, r.to)), d.warn(\"Setting `\" + i + s + \"` is being deprecated. Compatibility layer moved the value automatically to `\" + i + r.to + \"`. Please update the configuration to avoid using the obsolete property.\", null, !0);else {\n              var o = r.alternativeAsWarning,\n                  l = \"Setting `\" + i + s + \"` \" + (o ? \"is being deprecated\" : \"is no longer supported\") + \". Consider using `\" + r.alternative + \"` instead.\";\n              o ? d.warn(l, null, !0) : d.error(l);\n            }\n          }\n        }, t.prototype.apply = function (t) {\n          this.applyCompatibility(t, [{\n            from: \"width\",\n            to: \"area.width\"\n          }, {\n            from: \"height\",\n            to: \"area.height\"\n          }, {\n            from: \"minHeight\",\n            to: \"area.minHeight\"\n          }, {\n            from: \"maxHeight\",\n            to: \"area.maxHeight\"\n          }, {\n            from: \"minWidth\",\n            to: \"area.minWidth\"\n          }, {\n            from: \"maxWidth\",\n            to: \"area.maxWidth\"\n          }]);\n          var e = {},\n              i = !1;\n          if (this._initializing) this.applyGlobalCustomizations(), t || (t = {}), t.data || (t.data = [{}]);else if (!t) return e;\n\n          if (t.data) {\n            Array.isArray(t.data) || (t.data = [t.data], i = !0);\n\n            for (var n = 0; n < t.data.length; n++) {\n              var r = t.data[n];\n              r.id || (r.name ? (d.warn(\"The property `name` in the data object configuration is deprecated in favor of `id` property. Please update the configuration to avoid using the obsolete property.\", null, !0), r.id = r.name, delete r.name) : 0 === n ? r.id = \"default\" : r.id = \"default-\" + n.toString(10));\n            }\n          }\n\n          if (st.updateRecursive(this, t.theme, this._mapping, e), st.updateRecursive(this, t, this._mapping, e), i && (t.data = t.data[0]), e.data || this._initializing) {\n            this._computedDataMap = {};\n\n            for (var n = 0; n < this.data.length; n++) {\n              var s = this.data[n];\n              this._computedDataMap[s.id] = s;\n            }\n          }\n\n          return e;\n        }, t;\n      }();\n\n      r.Settings = at;\n\n      var ot = function () {\n        function t() {\n          this.onError = null, this.onSettingsChange = null, this.onClick = null, this.onDoubleClick = null, this.onTripleClick = null, this.onRightClick = null, this.onHoverChange = null, this.onSelectionChange = null, this.onChartUpdate = null, this.onPositionChange = null, this.chartUpdateDelay = 0;\n        }\n\n        return t;\n      }();\n\n      r.SettingsEvents = ot;\n\n      var lt = function () {\n        function t() {\n          this.toolbar = new ut(), this.loadingLabel = \"Loading...\", this.closeButton = \"Close\", this.dataRequestFailed = \"Data request failed\", this.exportNotAvailable = \"Your browser does not support exporting the chart.\";\n        }\n\n        return t;\n      }();\n\n      r.SettingsLocalization = lt;\n\n      var ht = function () {\n        function t() {\n          this.renderStart = null, this.renderFinish = null;\n        }\n\n        return t;\n      }();\n\n      r.SettingsCallbacks = ht;\n\n      var ut = function () {\n        function t() {\n          this.backButton = \"Back\", this.backTitle = \"Move one step back in navigation\", this.fullscreenButton = \"Fullscreen\", this.fullscreenTitle = \"Toggle fullscreen mode\", this.zoomoutButton = \"Zoom-out\", this.zoomoutTitle = \"Zoom out\", this.exportButton = \"Export\", this.exportTitle = \"Export Data\", this.exportJpeg = \"For Office and Web (jpeg)\", this.exportPNG = \"For Photoshop (png)\", this.exportPDF = \"For Printer (pdf)\", this.exportCSV = \"Spreadsheet (csv)\", this.exportXLS = \"Spreadsheet (xls)\";\n        }\n\n        return t;\n      }();\n\n      r.SettingsLocalizationToolbar = ut;\n\n      var ct = function () {\n        function t() {\n          this.defaultHeight = 300, this.width = null, this.height = null, this.top = null, this.left = null, this.minHeight = 50, this.maxHeight = 2e4, this.minWidth = 50, this.maxWidth = 2e4, this.style = new dt();\n        }\n\n        return t;\n      }();\n\n      r.SettingsArea = ct;\n\n      var dt = function () {\n        function t() {\n          this.fillColor = \"transparent\", this.image = null, this.overlayColor = null;\n        }\n\n        return t;\n      }();\n\n      r.SettingsAreaStyle = dt;\n\n      var pt = function () {\n        function t() {\n          this.resizing = new et();\n        }\n\n        return t;\n      }();\n\n      r.SettingsInteraction = pt;\n\n      var ft = function () {\n        function t() {\n          this.labelCache = !0, this.labelCacheRotated = !0, this.highDPI = !0, this.pointer = new gt(), this.useAnimationFrame = !0, this.showTouches = !1, this.showTouchTrail = !0, this.showFPS = !1, this.showTimestamp = !1, this.logging = !1, this.style = new vt(), this.maxCanvasWidth = 4096, this.maxCanvasHeight = 4096, this.themeCSSClass = \"DVSL-round\", this.assets = [{\n            url: \"assets://zc.css\",\n            required: function required() {\n              return !d.isStyleSheetDefined(\"DVSL-suppress-default-styles\", \"color\");\n            }\n          }], this.builtinAssets = {\n            \"logo-blank\": c.LicenseBannerBlank,\n            \"logo-supported-by\": c.LicenseBannerSupportedBy,\n            \"logo-development\": c.LicenseBannerDevelopment,\n            \"logo-license-expired\": c.LicenseBannerExpired,\n            \"logo-unlicensed\": c.LicenseBannerUnlicensed\n          }, this.exportProxyURL = \"https://echo.zoomcharts-cloud.com/download\", this.exportPdfSize = [210, 297], this.crossOriginHeader = null, this.dataExportFunction = null;\n        }\n\n        return t;\n      }();\n\n      r.SettingsAdvanced = ft;\n\n      var gt = function () {\n        function t() {\n          this.noClickOnDoubleClick = !0, this.clickSensitivity = 10, this.doubleClickSensitivity = 20, this.doubleClickTimeout = 300, this.longPressTimeout = 500, this.longPressSensitivity = 10, this.speedAveragingPeriod = 200, this.scrollIntoView = !1, this.mouseWheelRequiresFocus = !1;\n        }\n\n        return t;\n      }();\n\n      r.SettingsAdvancedPointer = gt;\n\n      var vt = function () {\n        function t() {\n          this.messageTextStyle = {\n            fillColor: \"#000\",\n            font: \"15px Arial\"\n          }, this.messageBackgroundStyle = {\n            padding: 5\n          }, this.loadingArcStyle = {\n            r: 10,\n            lineColor: \"#444\",\n            lineWidth: 1,\n            location: \"center\"\n          };\n        }\n\n        return t;\n      }();\n\n      r.SettingsAdvancedStyle = vt;\n\n      var mt = function () {\n        function t(t, e, i, n) {\n          t !== 1 / 0 && t > i ? (this.x1 = t, this.x0 = i) : (this.x1 = i, this.x0 = t), e !== 1 / 0 && e > n ? (this.y1 = e, this.y0 = n) : (this.y1 = n, this.y0 = e);\n        }\n\n        return t.createEmpty = function () {\n          return new t(1 / 0, 1 / 0, -(1 / 0), -(1 / 0));\n        }, t.prototype.isEmpty = function () {\n          return this.x0 >= this.x1 || this.y0 >= this.y1;\n        }, t.prototype.clone = function () {\n          return new t(this.x0, this.y0, this.x1, this.y1);\n        }, t.prototype.w = function () {\n          return this.x1 - this.x0;\n        }, t.prototype.h = function () {\n          return this.y1 - this.y0;\n        }, t.prototype.equals = function (t) {\n          return this.x0 === t.x0 && this.x1 === t.x1 && this.y0 === t.y0 && this.y1 === t.y1;\n        }, t.prototype.inflate = function (t) {\n          var e = (this.x0 + this.x1) / 2,\n              i = (this.y0 + this.y1) / 2;\n          return this.x0 = (this.x0 - e) * t + e, this.x1 = (this.x1 - e) * t + e, this.y0 = (this.y0 - i) * t + i, this.y1 = (this.y1 - i) * t + i, this;\n        }, t.prototype.clip = function (t) {\n          return this.x0 = Math.max(this.x0, t.x0), this.x1 = Math.min(this.x1, t.x1), this.y0 = Math.max(this.y0, t.y0), this.y1 = Math.min(this.y1, t.y1), this;\n        }, t.prototype.isInside = function (t) {\n          return this.x0 >= t.x0 && this.x1 <= t.x1 && this.y0 >= t.y0 && this.y1 <= t.y1;\n        }, t.prototype.isOutside = function (t) {\n          return this.x0 > t.x1 || this.x1 < t.x0 || this.y0 > t.y1 || this.y1 < t.y0;\n        }, t.prototype.overlapsRect = function (t, e, i, n) {\n          return t < this.x1 && i > this.x0 && e < this.y1 && n > this.y0;\n        }, t.prototype.intersectsSegment = function (t, e, i, n) {\n          return null != r.Geometry.clipSegmentToRect(t, e, i - t, n - e, this.x0, this.y0, this.x1, this.y1);\n        }, t.prototype.area = function () {\n          return (this.x1 - this.x0) * (this.y1 - this.y0);\n        }, t.prototype.toString = function () {\n          return this.x0 + \",\" + this.y0 + \", \" + this.x1 + \", \" + this.y1;\n        }, t.prototype.addPoint = function (t, e) {\n          return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, t), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, e), this;\n        }, t.prototype.addBounds = function (t, e, i, n) {\n          return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, i), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, n), this;\n        }, t.prototype.addRect = function (t) {\n          return this.x0 = Math.min(this.x0, t.x0), this.x1 = Math.max(this.x1, t.x1), this.y0 = Math.min(this.y0, t.y0), this.y1 = Math.max(this.y1, t.y1), this;\n        }, t.prototype.moveBy = function (t, e) {\n          return this.x0 += t, this.x1 += t, this.y0 += e, this.y1 += e, this;\n        }, t.prototype.containsPoint = function (t, e) {\n          return t >= this.x0 && t < this.x1 && e >= this.y0 && e < this.y1;\n        }, t.prototype.addLine = function (t) {\n          for (var e = 0; e <= t.length - 2; e += 2) {\n            this.addPoint(t[e], t[e + 1]);\n          }\n\n          return this;\n        }, t.prototype.translate = function (t, e, i, n) {\n          return this.x0 = this.x0 * t + e, this.x1 = this.x1 * t + e, this.y0 = this.y0 * i + n, this.y1 = this.y1 * i + n, this;\n        }, t.prototype.overlaps = function (t) {\n          return this.x0 < t.x1 && this.x1 > t.x0 && this.y0 < t.y1 && this.y1 > t.y0;\n        }, t;\n      }();\n\n      r.Rect = mt;\n\n      var yt = function () {\n        function t(t, e) {\n          this.msg = t, this.pri = e;\n        }\n\n        return t;\n      }(),\n          St = function () {\n        function t() {\n          this.settings = null, this.assetsLoader = null, this.mainData = null, this.mainDataEnabled = !0, this.chartLeft = 0, this.chartTop = 0, this.chartWidth = 1, this.chartHeight = 1, this.x0 = 0, this.y0 = 0, this.height = 0, this.width = 0, this.leftMargin = 0, this.rightMargin = 0, this.topMargin = 0, this.bottomMargin = 0, this.loading = !0, this.messages = {}, this.backStack = [];\n        }\n\n        return t.prototype.setMessage = function (t, e, i) {\n          void 0 === i && (i = 0);\n          var n;\n          return e ? (n = !this.messages[t] || this.messages[t].msg !== e || this.messages[t].pri !== i, this.messages[t] = new yt(e, i)) : (n = this.messages.hasOwnProperty(t), delete this.messages[t]), n;\n        }, t.prototype.getMessage = function () {\n          var t = null,\n              e = 0;\n\n          for (var i in this.messages) {\n            var n = this.messages[i];\n            n.pri > e && (t = n.msg, e = n.pri);\n          }\n\n          return t;\n        }, t.prototype.pushBack = function (t) {\n          this.backStack.push(t), this.backStack.length > 1e3 && (this.backStack = this.backStack.slice(200));\n        }, t.prototype.prepareRotationMatrix = function (t) {}, t;\n      }();\n\n      r.Scene = St;\n\n      var bt = 2 * Math.PI,\n          xt = function () {\n        function t() {}\n\n        return t.cuberoot = function (t) {\n          var e = Math.pow(Math.abs(t), 1 / 3);\n          return t < 0 ? -e : e;\n        }, t.solveCubic = function (e, i, n, r) {\n          if (Math.abs(e) < 1e-8) {\n            if (e = i, i = n, n = r, Math.abs(e) < 1e-8) return e = i, i = n, Math.abs(e) < 1e-8 ? [] : [-i / e];\n            var s = i * i - 4 * e * n;\n            return Math.abs(s) < 1e-8 ? [-i / (2 * e)] : s > 0 ? [(-i + Math.sqrt(s)) / (2 * e), (-i - Math.sqrt(s)) / (2 * e)] : [];\n          }\n\n          var a,\n              o = (3 * e * n - i * i) / (3 * e * e),\n              l = (2 * i * i * i - 9 * e * i * n + 27 * e * e * r) / (27 * e * e * e);\n          if (Math.abs(o) < 1e-8) a = [t.cuberoot(-l)];else if (Math.abs(l) < 1e-8) a = [0].concat(o < 0 ? [Math.sqrt(-o), -Math.sqrt(-o)] : []);else {\n            var s = l * l / 4 + o * o * o / 27;\n            if (Math.abs(s) < 1e-8) a = [-1.5 * l / o, 3 * l / o];else if (s > 0) {\n              var h = t.cuberoot(-l / 2 - Math.sqrt(s));\n              a = [h - o / (3 * h)];\n            } else {\n              var h = 2 * Math.sqrt(-o / 3),\n                  u = Math.acos(3 * l / o / h) / 3,\n                  c = 2 * Math.PI / 3;\n              a = [h * Math.cos(u), h * Math.cos(u - c), h * Math.cos(u - 2 * c)];\n            }\n          }\n\n          for (var d = 0; d < a.length; d++) {\n            a[d] -= i / (3 * e);\n          }\n\n          return a;\n        }, t.quadraticCurve = function (t, e, i, n) {\n          var r = 1 - n,\n              s = r * r,\n              a = n * n,\n              o = s * t + 2 * n * r * e + a * i;\n          return o;\n        }, t.derivativeQuadraticCurve = function (t, e, i, n) {\n          return 2 * (-t * (1 - n) - 2 * e * n + e + i * n);\n        }, t.distSq = function (t, e, i, n) {\n          var r = i - t,\n              s = n - e,\n              a = r * r + s * s;\n          return a;\n        }, t.distanceToQuadraticCurveSq = function (e, i, n, r, s, a, o, l) {\n          for (var h = e - o, u = i - l, c = n - e, d = r - i, p = s - n - c, f = a - r - d, g = p * p + f * f, v = 3 * (c * p + d * f), m = 2 * (c * c + d * d) + (h * p + u * f), y = h * c + u * d, S = t.solveCubic(g, v, m, y), b = Math.min(t.distSq(o, l, e, i), t.distSq(o, l, s, a)), x = 0; x < S.length; x++) {\n            var C = S[x],\n                w = t.quadraticCurve(e, n, s, C),\n                L = t.quadraticCurve(i, r, a, C),\n                T = t.distSq(o, l, w, L);\n            T < b && (b = T);\n          }\n\n          return b;\n        }, t.distanceToSegmentSq = function (t, e, i, n, r, s) {\n          var a = r - t,\n              o = s - e,\n              l = i - t,\n              h = n - e,\n              u = a * l + o * h,\n              c = l * l + h * h,\n              d = -1;\n          0 !== c && (d = u / c);\n          var p, f;\n          d < 0 ? (p = t, f = e) : d > 1 ? (p = i, f = n) : (p = t + d * l, f = e + d * h);\n          var g = r - p,\n              v = s - f;\n          return g * g + v * v;\n        }, t.rayIntersectsSegment = function (t, e, i, n, r, s, a, o) {\n          var l = 1 / 0,\n              h = a - r,\n              u = o - s,\n              c = i * u - n * h;\n\n          if (0 !== c) {\n            var d = (e * h - t * u + r * u - s * h) / c,\n                p = void 0;\n            p = Math.abs(h) > Math.abs(u) ? (t + i * d - r) / h : (e + n * d - s) / u, p >= 0 && p <= 1 && d >= 0 && (l = d);\n          }\n\n          return l;\n        }, t.lineIntersectsSegment = function (t, e, i, n, r, s, a, o) {\n          var l = 1 / 0,\n              h = a - r,\n              u = o - s,\n              c = i * u - n * h;\n\n          if (0 !== c) {\n            var d = (e * h - t * u + r * u - s * h) / c,\n                p = void 0;\n            p = Math.abs(h) > Math.abs(u) ? (t + i * d - r) / h : (e + n * d - s) / u, p >= 0 && p <= 1 && (l = d);\n          }\n\n          return l;\n        }, t.lineIntersectsLine = function (t, e, i, n, r, s, a, o) {\n          var l = 1 / 0,\n              h = i - t,\n              u = n - e,\n              c = a - r,\n              d = o - s,\n              p = h * d - u * c;\n\n          if (0 !== p) {\n            var f = (e * c - t * d + r * d - s * c) / p,\n                g = void 0;\n            g = Math.abs(c) > Math.abs(d) ? (t + h * f - r) / c : (e + u * f - s) / d, l = f;\n          }\n\n          return l;\n        }, t.rayIntersectsCircle = function (t, e, i, n, r) {\n          var s = i * i + n * n,\n              a = t * i + e * n,\n              o = t * t + e * e - r * r,\n              l = a * a - s * o,\n              h = 1 / 0;\n\n          if (l > 0) {\n            l = Math.sqrt(l);\n            var u = (-a - l) / s,\n                c = (-a + l) / s;\n            u >= 0 && (h = u), c >= 0 && (h = Math.min(h, c));\n          }\n\n          return h;\n        }, t.clipSegmentToRect = function (t, e, i, n, r, s, a, o) {\n          var l = 0,\n              h = 1;\n\n          if (0 !== n) {\n            var u = 1 / n,\n                c = (s - e) * u,\n                d = (o - e) * u;\n            if (l = Math.min(c, d), h = Math.max(c, d), l > 1 || h < 0) return null;\n          } else if (e < s || e > o) return null;\n\n          if (0 !== i) {\n            var p = 1 / i,\n                f = (r - t) * p,\n                g = (a - t) * p,\n                v = Math.min(f, g),\n                m = Math.max(f, g);\n            if (l = Math.max(l, v), h = Math.min(h, m), l > 1 || h < 0 || l > h) return null;\n          } else if (t < r || t > a) return null;\n\n          return [l, h];\n        }, t.rayIntersectsCircleOuter = function (t, e, i, n, r) {\n          var s = i * i + n * n,\n              a = t * i + e * n,\n              o = t * t + e * e - r * r,\n              l = a * a - s * o;\n          return l = Math.sqrt(l), Math.max((-a + l) / s, (-a - l) / s);\n        }, t.lineTouchingCircle = function (t, e, i, n, r) {\n          var s = Math.sqrt(t * t + e * e);\n          if (!(s > r)) return null;\n          var a = Math.sqrt(s * s - r * r),\n              o = r * a / s,\n              l = r * r / s,\n              h = t / s,\n              u = e / s,\n              c = t * n - e * i;\n          return c < 0 && (o = -o), {\n            x: h * l - u * o,\n            y: u * l + h * o\n          };\n        }, t.distanceToPolygonSq = function (e, i, n) {\n          if (t.isInsidePolygon(e, i, n)) return 0;\n\n          for (var r = 1 / 0, s = 0; s < n.length; s++) {\n            for (var a = n[s], o = a.length, l = a[o - 2], h = a[o - 1], u = 0; u <= o - 2; u += 2) {\n              var c = a[u],\n                  d = a[u + 1];\n              r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d;\n            }\n          }\n\n          return r;\n        }, t.distanceToLinesSq = function (e, i, n) {\n          for (var r = 1 / 0, s = 0; s < n.length; s++) {\n            var a = n[s],\n                o = a.length;\n            if (2 === o) r = Math.min(r, (e - a[0]) * (e - a[0]) + (i - a[1]) * (i - a[1]));else if (o > 2) for (var l = a[0], h = a[1], u = 2; u <= o - 2; u += 2) {\n              var c = a[u],\n                  d = a[u + 1];\n              r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d;\n            }\n          }\n\n          return r;\n        }, t.isInsidePolygon = function (t, e, i) {\n          for (var n = !1, r = 0; r < i.length; r++) {\n            for (var s = i[r], a = s.length, o = s[a - 2], l = s[a - 1], h = 0; h <= a - 2; h += 2) {\n              var u = s[h],\n                  c = s[h + 1];\n              c > e != l > e && t < (u - o) * (e - l) / (c - l) + o && (n = !n), o = u, l = c;\n            }\n          }\n\n          return n;\n        }, t.distanceToBalloon = function (e, i, n, r) {\n          var s;\n          if (e >= i) s = e;else if (0 === r) s = i;else {\n            var a = d.sign(r);\n            s = e / r * a, Math.abs(n * s) > i - e && (s = t.rayIntersectsCircleOuter(-(i - e), 0, Math.abs(n), r, e));\n          }\n          return s;\n        }, t.distanceToRect = function (t, e, i, n, s, a, o) {\n          void 0 === o && (o = !1);\n          var l, h;\n          i instanceof r.Rect ? (o = n, l = i.x0, h = i.y0, s = i.x1, a = i.y1) : (l = i, h = n);\n          var u, c;\n          return u = t < l ? l - t : t > s ? t - s : 0, c = e < h ? h - e : e > a ? e - a : 0, o ? u * u + c * c : Math.sqrt(u * u + c * c);\n        }, t.clipSegmentToBounds = function (e, i, n, r, s, a, o, l, h, u) {\n          var c = Math.max(s, a),\n              d = n - e,\n              p = r - i,\n              f = t.clipSegmentToRect(e, i, d, p, o - c, l - c, h + c, u + c);\n          if (null === f) return null;\n          var g = Math.max(0, f[0]),\n              v = Math.min(1, f[1]);\n          return [e + d * g, i + p * g, e + d * v, i + p * v];\n        }, t.computeBoundsSize = function (t) {\n          for (var e = 1 / 0, i = -(1 / 0), n = 1 / 0, r = -(1 / 0), s = t.length, a = 0; a < s; a += 2) {\n            var o = t[a],\n                l = t[a + 1];\n            e = Math.min(o, e), i = Math.max(o, i), n = Math.min(l, n), r = Math.max(l, r);\n          }\n\n          return Math.max(i - e, r - n);\n        }, t.simplify = function (e, i) {\n          if (!i || !e.length) return e;\n          var n = i * i;\n          return e = t.reducePoints(e, n), e = t.simplifyDP(e, n);\n        }, t.simplifyDP = function (e, i) {\n          var n,\n              r = e.length;\n          n = \"undefined\" != typeof Uint8Array ? new Uint8Array(r) : new Array(r), n[0] = n[r - 2] = 1, t.simplifyDPStep(e, n, i, 0, r - 2);\n\n          for (var s = [], a = 0; a < r; a += 2) {\n            n[a] && (s.push(e[a]), s.push(e[a + 1]));\n          }\n\n          return s;\n        }, t.simplifyDPStep = function (e, i, n, r, s) {\n          for (var a = 0, o = 0, l = e[r], h = e[r + 1], u = e[s], c = e[s + 1], d = r + 2; d <= s - 2; d += 2) {\n            var p = t.distanceToSegmentSq(l, h, u, c, e[d], e[d + 1]);\n            p > a && (o = d, a = p);\n          }\n\n          a > n && (i[o] = 1, t.simplifyDPStep(e, i, n, r, o), t.simplifyDPStep(e, i, n, o, s));\n        }, t.reducePoints = function (t, e) {\n          for (var i, n, r = t[0], s = t[1], a = [r, s], o = t.length, l = 2; l < o; l += 2) {\n            i = t[l], n = t[l + 1], (r - i) * (r - i) + (s - n) * (s - n) > e && (a.push(i), a.push(n), r = i, s = n);\n          }\n\n          return r !== i && s !== n && a.push(i, n), a;\n        }, t.transformPolyline = function (t, e, i, n, r) {\n          for (var s = [], a = 0; a < t.length; a += 2) {\n            s.push(t[a] * e + i, t[a + 1] * n + r);\n          }\n\n          return s;\n        }, t.outlinePolylineByVectors = function (t, e, i) {\n          for (var n = [], s = [], a = t.length - 2, o = 0; o < a; o += 2) {\n            var l = e[o] * i,\n                h = e[o + 1] * i,\n                u = t[o] + l,\n                c = t[o + 1] + h,\n                d = t[o + 2] + l,\n                p = t[o + 3] + h;\n            n.push(u, c, d, p);\n          }\n\n          s = n.slice(0, 2), a = n.length - 4;\n\n          for (var o = 0; o < a; o += 4) {\n            var f = r.Geometry.lineIntersectsLine(n[o], n[o + 1], n[o + 2], n[o + 3], n[o + 4], n[o + 5], n[o + 6], n[o + 7]);\n            f === 1 / 0 ? s.push(n[o + 2], n[o + 3]) : s.push(n[o] + (n[o + 2] - n[o]) * f, n[o + 1] + (n[o + 3] - n[o + 1]) * f);\n          }\n\n          return s.push.apply(s, n.slice(-2)), s;\n        }, t.calculatePolyArea = function (t) {\n          for (var e = 0, i = t, n = t.length - 2, r = 0; r < n; r += 2) {\n            e += i[r] * i[r + 3] - i[r + 2] * i[r + 1];\n          }\n\n          return e / 2;\n        }, t.calculatePolyCentroid = function (t, e) {\n          var i,\n              n = 0,\n              r = 0,\n              s = t.length - 2;\n          e *= 6;\n\n          for (var a = 0; a < s; a += 2) {\n            i = t[a] * t[a + 3] - t[a + 2] * t[a + 1], n += (t[a] + t[a + 2]) * i, r += (t[a + 1] + t[a + 3]) * i;\n          }\n\n          return {\n            x: n / e,\n            y: r / e\n          };\n        }, t.normalizeAngle = function (t) {\n          return t < 0 ? (t %= bt, t += bt) : t >= bt && (t %= bt), t;\n        }, t.sectorBetweenAngles = function (t, e) {\n          for (; e < t;) {\n            e += bt;\n          }\n\n          return e - t;\n        }, t.subtractAngle = function (t, e) {\n          var i = t - e;\n          return i > Math.PI ? i -= bt : i < -Math.PI && (i += bt), i;\n        }, t.rotateVector = function (t, e, i, n) {\n          return {\n            x: t * n - e * i,\n            y: t * i + e * n\n          };\n        }, t.circle2 = function (t, e, i) {\n          i.x = (t[0] + e[0]) / 2, i.y = (t[1] + e[1]) / 2, i.r = ((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) / 4;\n        }, t.circle3 = function (t, e, i, n) {\n          var r = t[0],\n              s = t[1],\n              a = e[0],\n              o = e[1],\n              l = i[0],\n              h = i[1],\n              u = 2 * (r * (o - h) + a * (h - s) + l * (s - o));\n\n          if (0 === u) {\n            var c = Math.min(r, a, l),\n                d = Math.min(s, o, h);\n            n.x = (c + Math.max(r, a, l)) / 2, n.y = (d + Math.max(s, o, h)) / 2, n.r = (n.x - c) * (n.x - c) + (n.y - d) * (n.y - d);\n          } else n.x = ((r * r + s * s) * (o - h) + (a * a + o * o) * (h - s) + (l * l + h * h) * (s - o)) / u, n.y = ((r * r + s * s) * (l - a) + (a * a + o * o) * (r - l) + (l * l + h * h) * (a - r)) / u, n.r = (r - n.x) * (r - n.x) + (s - n.y) * (s - n.y);\n        }, t.pointDistance = function (t, e) {\n          return (e[0] - t.x) * (e[0] - t.x) + (e[1] - t.y) * (e[1] - t.y);\n        }, t.pointsInCircle = function (e, i, n) {\n          return t.pointDistance(e, i) - e.r <= 1e-5 && (!n || t.pointDistance(e, n) - e.r <= 1e-5);\n        }, t.circumscribeCircle = function (e) {\n          function i(e, i, n, l, h) {\n            if (n ? t.circle3(e, i, n, s) : t.circle2(e, i, s), (!l || t.pointsInCircle(s, l, h)) && !(o && r.r <= s.r)) {\n              var u = r;\n              r = s, s = u, a[0] = e, a[1] = i, a[2] = n, o = !0;\n            }\n          }\n\n          if (null == e || e.length < 1) return null;\n          if (1 === e.length) return {\n            x: e[0].x,\n            y: e[0].y,\n            r: e[0].r\n          };\n          var n = [[e[0].x - e[0].r, e[0].y], [e[0].x + e[0].r, e[0].y], null],\n              r = {\n            x: 0,\n            y: 0,\n            r: 0\n          };\n          t.circle2(n[0], n[1], r);\n\n          for (var s = {\n            x: 0,\n            y: 0,\n            r: 0\n          }, a = [[0, 0], [0, 0], [0, 0]], o = !1, l = t.pointKoef, h = [0, 0], u = 0; u < e.length; u++) {\n            for (var c = 0; c < 8; c++) {\n              if (h[0] = e[u].x + e[u].r * l[c][0], h[1] = e[u].y + e[u].r * l[c][1], !(n[0][0] === h[0] && n[0][1] === h[1] || n[1][0] === h[0] && n[1][1] === h[1] || n[2] && n[2][0] === h[0] && n[2][1] === h[1] || t.pointsInCircle(r, h))) {\n                var d = [h[0], h[1]];\n                o = !1, i(n[0], d, null, n[1], n[2]), i(n[1], d, null, n[0], n[2]), i(n[0], n[1], d, n[2], null), n[2] && (i(n[2], d, null, n[0], n[1]), i(n[0], n[1], d, n[2], null), i(n[1], n[2], d, n[0], null), i(n[0], n[2], d, n[1], null));\n                var p = n;\n                n = a, a = p, u = -1;\n                break;\n              }\n            }\n          }\n\n          return r.r = Math.sqrt(r.r), r;\n        }, t.findWeightedCenter = function (t) {\n          for (var e = 0, i = 0, n = 0, r = 0; r < t.length; r++) {\n            var s = t[r];\n            e += s.x * s.r, i += s.y * s.r, n += s.r;\n          }\n\n          return {\n            x: e / n,\n            y: i / n,\n            r: n / t.length\n          };\n        }, t.mat3ToMat2d = function (t) {\n          var e = t.all();\n          return [e[0], e[3], e[1], e[4], e[2], e[5]];\n        }, t.transformVec2d = function (t, e, i) {\n          return {\n            x: i[0] * t + i[2] * e + i[4],\n            y: i[1] * t + i[3] * e + i[5]\n          };\n        }, t;\n      }();\n\n      xt.pointKoef = [[-1, 0], [0, -1], [1, 0], [0, 1], [Math.SQRT1_2, Math.SQRT1_2], [-Math.SQRT1_2, Math.SQRT1_2], [Math.SQRT1_2, -Math.SQRT1_2], [-Math.SQRT1_2, -Math.SQRT1_2]], r.Geometry = xt;\n\n      var Ct = function () {\n        function t(t) {\n          this.scene = t, this.bounds = null;\n        }\n\n        return t.prototype.setBounds = function (t, e, i, n) {\n          this.bounds = new mt(t, e, i, n);\n        }, t.prototype.findObjectAt = function (t, e, i) {\n          return null;\n        }, t.prototype.remove = function () {}, t;\n      }();\n\n      r.Layer = Ct, function (t) {\n        t.ToolbarItemNames.fullscreen = function (t, e) {\n          var i = t.settings.localization.toolbar;\n          return new r.Bar.ToggleButton(t, e, {\n            labelDisabled: e.label || i.fullscreenButton,\n            titleDisabled: e.title || i.fullscreenTitle,\n            cssClassEnabled: \"DVSL-bar-btn-fullscreen-active\",\n            cssClassDisabled: e.cssClass || \"DVSL-bar-btn-fullscreen\",\n            onEnable: function onEnable() {\n              return t.setFullscreen(!0);\n            },\n            onDisable: function onDisable() {\n              return t.setFullscreen(!1);\n            },\n            getChartState: function getChartState() {\n              return t.isFullscreen();\n            }\n          });\n        };\n\n        var e = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.onSceneChange = function (e) {\n            t.prototype.onSceneChange.call(this, e);\n            var i = this.chart.scene.backStack.length > 0,\n                n = this.options;\n            n.enabled !== i && (n.enabled = i, this.updateSettings());\n          }, e;\n        }(t.Button);\n\n        t.ToolbarItemNames.back = function (t, i) {\n          var n = t.settings.localization.toolbar;\n          i.label = i.label || n.backButton, i.title = i.title || n.backTitle, i.cssClass = i.cssClass || \"DVSL-bar-btn-back\";\n          var r = i.onClick;\n          return i.onClick = function (e, i) {\n            t.back(!0, \"user\"), r && r(e, i);\n          }, new e(t, i);\n        };\n      }(o = r.Bar || (r.Bar = {}));\n\n      var wt = function () {\n        function t(t) {\n          this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.oneOverM = 1 / this.M;\n        }\n\n        return t.prototype.get = function () {\n          var t = this.seed / this.Q,\n              e = this.seed % this.Q,\n              i = this.A * e - this.R * t;\n          return i > 0 ? this.seed = i : this.seed = i + this.M, this.seed * this.oneOverM;\n        }, t.prototype.getArrayElement = function (t) {\n          return t[Math.floor(t.length * this.get())];\n        }, t;\n      }();\n\n      r.Random = wt;\n\n      var Lt = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 600, i.container = null, i.backgroundContainer = null, i.background = null, i.canvas = null, i.interactionContainer = null, i.menuContainer = null, i.outerBorder = null, i.scene = null, i.curThemeClass = null, i.chart = e, i.scene = e.scene, i;\n        }\n\n        return n(e, t), e.setContainerStyle = function (t) {\n          t.style.position = \"absolute\", t.style.left = \"0px\", t.style.right = \"0px\", t.style.top = \"0px\", t.style.bottom = \"0px\";\n        }, e.prototype.createDom = function (t) {\n          this.shell = t, this.container = r.Helpers.createDom(\"div\", \"DVSL-container DVSL-\" + t.chart.api.typeName), this.container.style.position = \"relative\", this.container.style.width = \"100%\", this.backgroundContainer = r.Helpers.createDom(\"div\", \"DVSL-background-container\", null, this.container), e.setContainerStyle(this.backgroundContainer), this.background = r.Helpers.createDom(\"div\", \"DVSL-background\", null, this.backgroundContainer), e.setContainerStyle(this.background), this.backgroundImage = r.Helpers.createDom(\"div\", \"DVSL-background-image\", null, this.background), this.canvas = r.Helpers.createDom(\"canvas\", \"DVSL-canvas\", null, this.container), e.setContainerStyle(this.canvas), this.outerBorder = r.Helpers.createDom(\"div\", \"DVSL-border\", null, this.container), e.setContainerStyle(this.outerBorder), this.interactionContainer = r.Helpers.createDom(\"div\", \"DVSL-interaction\", null, this.container), e.setContainerStyle(this.interactionContainer), this.menuContainer = r.Helpers.createDom(\"div\", \"DVSL-menu-container DVSL-menu-workaround\", null, this.container), e.setContainerStyle(this.menuContainer), r.Helpers.createDom(\"span\", \"DVSL-empty\", \" \", this.menuContainer), this.updateSettings(this.scene.settings), this.interactionContainer.tabIndex = 0;\n        }, e.prototype.updateSettings = function (t) {\n          if (r.Helpers.hasProp(t, \"area.style.image\")) {\n            var e = t.area.style.image;\n            this.backgroundImage.style.backgroundImage = e ? \"url(\" + e + \")\" : \"\";\n          }\n\n          var i = this.curThemeClass,\n              n = this.scene.settings.advanced.themeCSSClass;\n          n !== i && (i && r.Helpers.removeClass(this.container, i), this.curThemeClass = n, r.Helpers.addClass(this.container, n));\n        }, e.prototype.doAnimations = function (t) {\n          t.changes.bounds && (this.backgroundImage.style.bottom = this.scene.bottomMargin + \"px\", this.backgroundImage.style.top = this.scene.topMargin + \"px\");\n        }, e;\n      }(k);\n\n      r.DomLayer = Lt;\n\n      var Tt = function () {\n        function t(t, e, i) {\n          void 0 === i && (i = []), this.x = i, this.y1 = e, this.y0 = t;\n        }\n\n        return t.prototype.isEmpty = function () {\n          return 0 === this.x.length;\n        }, t.prototype.makeCopy = function () {\n          return new t(this.y0, this.y1, this.x.slice(0));\n        }, t.prototype.split = function (e) {\n          var i = new t(e, this.y1);\n          return this.y1 = e, i.x = this.x.slice(0), i;\n        }, t.prototype.add = function (t, e) {\n          for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] < t;) {\n            i.push(this.x[r], this.x[r + 1]), r += 2;\n          }\n\n          for (r < n && (t = Math.min(this.x[r], t)); r < n && this.x[r] <= e;) {\n            e = Math.max(e, this.x[r + 1]), r += 2;\n          }\n\n          for (i.push(t, e); r < n;) {\n            i.push(this.x[r], this.x[r + 1]), r += 2;\n          }\n\n          return this.x = i, this;\n        }, t.prototype.subtract = function (t, e) {\n          for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] <= t;) {\n            i.push(this.x[r], this.x[r + 1]), r += 2;\n          }\n\n          for (r < n && this.x[r] < t && i.push(this.x[r], t); r < n && this.x[r + 1] <= e;) {\n            r += 2;\n          }\n\n          for (r < n && this.x[r] < e && (i.push(e, this.x[r + 1]), r += 2); r < n;) {\n            i.push(this.x[r], this.x[r + 1]), r += 2;\n          }\n\n          return this.x = i, this;\n        }, t.prototype.subtractSlice = function (t) {\n          if (this.isEmpty() || t.isEmpty()) return this;\n\n          for (var e = [], i = this.x, n = t.x, r = i.length, s = n.length, a = 0, o = 0, l = i[a], h = i[a + 1]; o < s;) {\n            var u = n[o],\n                c = n[o + 1];\n            if (l >= c) o += 2;else if (u >= h) {\n              if (e.push(l, h), a += 2, a === r) break;\n              l = i[a], h = i[a + 1];\n            } else if (u > l && e.push(l, u), c < h) l = c, o += 2;else {\n              if (a += 2, a === r) break;\n              l = i[a], h = i[a + 1];\n            }\n          }\n\n          for (; a < r && (e.push(l, h), a += 2, a !== r);) {\n            l = i[a], h = i[a + 1];\n          }\n\n          return this.x = e, this;\n        }, t.prototype.intersectsSlice = function (t) {\n          if (this.isEmpty() || t.isEmpty()) return !1;\n\n          for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n            var o = e[s],\n                l = e[s + 1],\n                h = i[a],\n                u = i[a + 1];\n            if (o >= u) a += 2;else {\n              if (!(h >= l)) return !0;\n              s += 2;\n            }\n          }\n\n          return !1;\n        }, t.prototype.coversSlice = function (t) {\n          if (t.isEmpty()) return !0;\n\n          for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n            var o = e[s],\n                l = e[s + 1],\n                h = i[a],\n                u = i[a + 1];\n            if (h >= l) s += 2;else {\n              if (!(h >= o && u <= l)) return !1;\n              a += 2;\n            }\n          }\n\n          return a === r;\n        }, t.prototype.clip = function (t, e) {\n          for (var i = [], n = 0; n <= this.x.length - 2; n += 2) {\n            var r = this.x[n],\n                s = this.x[n + 1];\n            s > t && r < e && (i.push(Math.max(r, t)), i.push(Math.min(s, e)));\n          }\n\n          return this.x = i, this;\n        }, t.prototype.tryMerge = function (t) {\n          if (this.x.length !== t.x.length || this.y1 !== t.y0) return !1;\n\n          for (var e = 0; e <= this.x.length - 1; e++) {\n            if (this.x[e] !== t.x[e]) return !1;\n          }\n\n          return this.y1 = t.y1, !0;\n        }, t.prototype.intersects = function (t, e) {\n          for (var i = 0; i <= this.x.length - 2; i += 2) {\n            var n = this.x[i],\n                r = this.x[i + 1];\n            if (n < e && r > t) return !0;\n          }\n\n          return !1;\n        }, t.prototype.covers = function (t, e) {\n          for (var i = 0; i <= this.x.length - 2; i += 2) {\n            var n = this.x[i],\n                r = this.x[i + 1];\n            if (n <= t && r >= e) return !0;\n          }\n\n          return !1;\n        }, t.prototype.findOverlappingRect = function (t, e, i) {\n          for (var n = !1, r = 0; r <= this.x.length - 2; r += 2) {\n            var s = this.x[r],\n                a = this.x[r + 1];\n            s < e && e - i < a && (t = Math.min(t, Math.max(s, e - i)), n = !0), a > t && t + i > s && (e = Math.max(e, Math.min(a, t + i)), n = !0);\n          }\n\n          return {\n            x0: t,\n            x1: e,\n            overlaps: n\n          };\n        }, t.prototype.toRects = function (t) {\n          for (var e = 0; e <= this.x.length - 2; e += 2) {\n            var i = this.x[e],\n                n = this.x[e + 1];\n            t.push(new r.Rect(i, this.y0, n, this.y1));\n          }\n        }, t;\n      }();\n\n      r.AreaSlice = Tt;\n\n      var kt = function () {\n        function t() {\n          this.slices = [new Tt(-1e30, 1e30)];\n        }\n\n        return t.prototype.makeCopy = function () {\n          var e = new t();\n          e.slices = [];\n\n          for (var i = 0; i < this.slices.length; i++) {\n            var n = this.slices[i];\n            e.slices.push(n.makeCopy());\n          }\n\n          return e;\n        }, t.prototype.getBounds = function () {\n          var t = 1 / 0,\n              e = -(1 / 0),\n              i = 1 / 0,\n              n = -(1 / 0);\n\n          if (this.slices.length > 1) {\n            i = this.slices[1].y0, n = this.slices[this.slices.length - 1].y1;\n\n            for (var s = 0; s < this.slices.length; s++) {\n              var a = this.slices[s];\n              a.x.length > 0 && (t = Math.min(t, a.x[0]), e = Math.max(e, a.x[a.x.length - 1]));\n            }\n          }\n\n          return new r.Rect(t, i, e, n);\n        }, t.prototype.addRect = function (t) {\n          if (t.isEmpty()) return this;\n\n          for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {\n            var l = this.slices[o];\n            if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);else {\n              if (n > l.y0) {\n                var h = l.split(n);\n                a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n              }\n\n              if (r < l.y1) {\n                var h = l.split(r);\n                l.add(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n              } else l.add(e, i);\n\n              a && a.tryMerge(l) || (s.push(l), a = l);\n            }\n          }\n\n          return this.slices = s, this;\n        }, t.prototype.subtractRect = function (t) {\n          if (t.isEmpty()) return this;\n\n          for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {\n            var l = this.slices[o];\n            if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);else {\n              if (n > l.y0) {\n                var h = l.split(n);\n                a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n              }\n\n              if (r < l.y1) {\n                var h = l.split(r);\n                l.subtract(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h;\n              } else l.subtract(e, i);\n\n              a && a.tryMerge(l) || (s.push(l), a = l);\n            }\n          }\n\n          return this.slices = s, this;\n        }, t.prototype.clip = function (t) {\n          return 1;\n        }, t.prototype.subtractArea = function (t) {\n          if (t.isEmpty()) return this;\n\n          for (var e = [], i = null, n = this.slices, r = t.slices, s = n.length, a = r.length, o = 0, l = 0, h = n[o]; l < a;) {\n            var u = r[l];\n\n            if (h.y1 <= u.y0) {\n              if (i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o === s) break;\n              h = n[o];\n            } else if (u.y1 <= h.y0 || u.isEmpty()) l += 1;else {\n              if (h.y0 < u.y0) {\n                var c = h.split(u.y0);\n                i && i.tryMerge(h) || (e.push(h), i = h), h = c;\n              }\n\n              if (h.y1 > u.y1) {\n                var c = h.split(u.y1);\n                h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), h = c, l += 1;\n              } else {\n                if (h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o === s) break;\n                h = n[o];\n              }\n            }\n          }\n\n          for (; o < s && (i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o !== s);) {\n            h = n[o];\n          }\n\n          return this.slices = e, this;\n        }, t.prototype.intersectsArea = function (t) {\n          if (t.isEmpty() || this.isEmpty()) return !1;\n\n          for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n            var o = i[a],\n                l = e[s];\n            if (l.intersectsSlice(o)) return !0;\n            l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1);\n          }\n\n          return !1;\n        }, t.prototype.coversArea = function (t) {\n          if (t.isEmpty()) return !0;\n\n          for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {\n            var o = i[a],\n                l = e[s];\n            if (!l.coversSlice(o)) return !1;\n            l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1);\n          }\n\n          return !0;\n        }, t.prototype.findOverlappingRect = function (t, e) {\n          if (this.isEmpty()) return null;\n\n          for (var i = this.slices[1].x[0], n = Math.min(this.slices[1].x[1], i + t), s = this.slices[1].y0, a = Math.min(this.slices[1].y1, s + e), o = 0; o < this.slices.length; o++) {\n            var l = this.slices[o];\n            if (l.y0 >= s + e) break;\n            var h = l.findOverlappingRect(i, n, t);\n            i = h.x0, n = h.x1;\n            var u = h.overlaps;\n            u && (a = Math.min(l.y1, s + e));\n          }\n\n          return new r.Rect(i, s, n, a);\n        }, t.prototype.findTopPosition = function (t, e) {\n          for (var i = 1 / 0, n = 0; n < this.slices.length; n++) {\n            var r = this.slices[n];\n            r.covers(t, e) && (i = Math.min(i, r.y0));\n          }\n\n          return i === 1 / 0 ? 0 : i;\n        }, t.prototype.intersects = function (t) {\n          for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {\n            var a = this.slices[s];\n            if (a.y0 < r && a.y1 > n && a.intersects(e, i)) return !0;\n          }\n\n          return !1;\n        }, t.prototype.isEmpty = function () {\n          return 1 === this.slices.length && this.slices[0].isEmpty();\n        }, t.prototype.coversRect = function (t) {\n          for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {\n            var a = this.slices[s];\n            if (n < a.y1 && r > a.y0 && !a.covers(e, i)) return !1;\n          }\n\n          return !0;\n        }, t.prototype.toRects = function () {\n          for (var t = [], e = 0; e < this.slices.length; e++) {\n            var i = this.slices[e];\n            i.toRects(t);\n          }\n\n          return t;\n        }, t;\n      }();\n\n      r.AreaCollection = kt;\n\n      var Mt = navigator.userAgent.match(/AppleWebKit\\/(\\d+)/),\n          At = Mt ? parseInt(Mt[1], 10) : 1e6,\n          It = function () {\n        function e(t, i) {\n          var n = this;\n          this.chart = null, this.settings = null, this.scene = null, this.events = null, this.profiler = null, this.container = null, this.canvas = null, this.scaleX = 1, this.scaleY = 1, this.paintRequested = null, this.labelRenderer = null, this.prevTime = null, this.paintNowInProgreess = !1, this.animationInProgress = !1, this.mouseEvents = null, this.innerAreaCache = null, this.chartWidth = 0, this.chartHeight = 0, this.sizeChanged = !0, this.fullScreenMode = !1, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0, this.lastCursor = null, this.chart = t, this.settings = t.settings, this.scene = t.scene, this.domLayer = i, this.buildDom(), this.labelRenderer = new G(this.settings, this.chart.assetsLoader, this.container), this.mouseEvents = new w(this.domLayer.interactionContainer, this.settings.advanced.pointer, [this.domLayer.menuContainer], t.scene.invertedTransform), this.profiler = new I(this);\n\n          for (var r = 0; r < e.MouseEventConfig.length; r++) {\n            var s = e.MouseEventConfig[r];\n            !function (t) {\n              n.mouseEvents.listen(t.ev, function (e) {\n                return n.notifyMouseEvent(e, t);\n              });\n            }(s);\n          }\n\n          this.events = new D(t, this), this.events.addElement(this.domLayer), this.containerResizeFunc = function () {\n            return n.updateSize(!1);\n          }, d.listenResize(this.container, this.containerResizeFunc), d.listen(window, \"resize\", this.containerResizeFunc);\n        }\n\n        return e.prototype.forceChromeRedraw = function () {\n          var t = this.menuContainer.style,\n              e = t.transform;\n          t.transform = \"translateZ(0)\", window.setTimeout(function () {\n            t.transform = e;\n          }, 1);\n        }, e.prototype.updateSize = function (t) {\n          var e,\n              i,\n              n = this.settings.area;\n          this.fullScreenMode ? (e = window.innerWidth, i = window.innerHeight) : this.fullscreenBeforeW > 0 ? (e = this.fullscreenBeforeW, i = this.fullscreenBeforeH, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0) : (e = n.width || Math.min(n.maxWidth, this.container.clientWidth), i = n.height || Math.min(n.maxHeight, this.container.clientHeight), e > 0 && i < 2 && (i = this.settings.area.height || this.settings.area.defaultHeight), e = Math.max(n.minWidth, e), i = Math.max(n.minHeight, i)), (t || e >= 2 && e !== this.chartWidth || i >= 2 && i !== this.chartHeight) && this.setSize(e, i, t), d.updateResize(this.container);\n        }, e.prototype.setSize = function (t, e, i) {\n          this.chart.log(\"Update size: \" + e + \", \" + t);\n          var n = this.domLayer.container.style;\n          n.height = e + \"px\", n.width = t + \"px\", this.chartHeight = e, this.chartWidth = t, this.sizeChanged = !0, this.events.setNewSize(new mt(0, 0, t, e), !0, i);\n        }, e.prototype.setFullscreen = function (t) {\n          t !== this.fullScreenMode && (this.fullScreenMode = t, t ? (this.fullscreenBeforeW = this.scene.chartWidth, this.fullscreenBeforeH = this.scene.chartHeight, d.addClass(this.domLayer.container, \"DVSL-fullscreen\")) : d.removeClass(this.domLayer.container, \"DVSL-fullscreen\"), this.updateSize(!0));\n        }, e.prototype.buildDom = function () {\n          if (!this.settings.container) throw new Error(\"Chart container is not defined in the settings.\");\n          if (!d.isDomObject(this.settings.container)) throw new Error(\"Chart container is not a DOM object.\");\n          this.container = this.settings.container, null != this.container._DVSL_ChartInstance && this.container._DVSL_ChartInstance.remove(), this.container.innerHTML = \"<!--ZoomCharts \" + t.PackageInfo.Version + \"-->\", this.container._DVSL_ChartInstance = this.chart, this.domLayer.createDom(this), this.container.appendChild(this.domLayer.container), this.backgroundContainer = this.domLayer.backgroundContainer, this.interactiveContainer = this.domLayer.interactionContainer, this.menuContainer = this.domLayer.menuContainer, this.canvas = this.domLayer.canvas;\n        }, e.prototype.remove = function () {\n          this.mouseEvents.remove(), this.domLayer.remove(), d.unlistenResize(this.container), delete this.container._DVSL_ChartInstance, d.unlisten(window, \"resize\", this.containerResizeFunc), this.container.innerHTML = \"\";\n        }, e.prototype.updateSettings = function (t) {\n          t.area && this.updateSize(!0), this.domLayer.updateSettings(t);\n        }, e.prototype.notifyMouseEvent = function (t, e) {\n          this.chart.removed || (t.consumed = !1, this.events.onMouseEvent(t, e), t.cursor || (t.cursor = \"default\"), this.lastCursor !== t.cursor && (this.interactiveContainer.style.cursor = t.cursor, this.menuContainer.style.cursor = t.cursor, this.lastCursor = t.cursor));\n        }, e.prototype.requestPaint = function () {\n          var t = this;\n          null === this.paintRequested && (this.settings.advanced.useAnimationFrame ? this.paintRequested = r.Helpers.requestAnimationFrame(function (e, i) {\n            return t.paintScene(i ? e : null);\n          }) : this.paintRequested = window.setTimeout(function () {\n            return t.paintScene(null);\n          }, 5));\n        }, e.prototype.paintNow = function (t) {\n          return void 0 === t && (t = !1), this.paintNowInProgreess ? void this.chart.error(\"paintNow called from within paintNow call\") : (this.paintNowInProgreess = !0, (null !== this.paintRequested || t) && (this.settings.advanced.useAnimationFrame ? r.Helpers.cancelAnimationFrame(this.paintRequested) : window.clearTimeout(this.paintRequested), this.paintScene(null)), void (this.paintNowInProgreess = !1));\n        }, e.prototype.paintScene = function (t) {\n          if (!this.chart.removed) {\n            this.paintRequested = null;\n            var e = null !== t ? t : d.performanceNow(),\n                i = new L();\n            i.timeStamp = e, i.isExport = !1, this.prevTime && this.animationInProgress ? (i.dtime = i.timeStamp - this.prevTime, i.dtime > 1e3 && (i.dtime = 1e3), i.dtime < 1 && (i.dtime = 1)) : i.dtime = 30, this.prevTime = e, this.chartWidth > 0 && this.chartHeight > 0 && (this.sizeChanged && (this.resizeCanvas(), this.sizeChanged = !1), this.innerAreaCache = null, this.events.animateFrame(i), i.animating ? (this.animationInProgress = !0, this.events.requestPaint()) : this.animationInProgress = !1, this.profiler.paintDone());\n          }\n        }, e.prototype.resizeCanvas = function () {\n          var t = this.chart.settings.advanced,\n              e = 1,\n              i = 1;\n\n          if (t.highDPI === !0) {\n            var n = d.canvasScaling();\n            e = n.x, i = n.y;\n          } else t.highDPI > 0 && (e = i = t.highDPI);\n\n          var r,\n              s,\n              a = this.chartWidth,\n              o = this.chartHeight,\n              l = Math.max(100, t.maxCanvasWidth),\n              h = Math.max(100, t.maxCanvasHeight),\n              u = 0,\n              c = 0;\n\n          do {\n            u++, r = Math.ceil(a * e / u);\n          } while (r > l);\n\n          do {\n            c++, s = Math.ceil(o * i / c);\n          } while (s > h);\n\n          e /= u, i /= c, a = r / e, o = s / i, this.scaleX = e, this.scaleY = i, this.canvas.width = r, this.canvas.height = s, this.canvas.style.width = a + \"px\", this.canvas.style.height = o + \"px\";\n        }, e.prototype.prepareContext = function (t) {\n          var e = this.scene,\n              i = this.canvas,\n              n = i.getContext(\"2d\");\n          n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, i.width, i.height), 534 === At && (i.style.display = \"none\", i.offsetHeight, i.style.display = \"inherit\"), this.areaStylesBefore(n, this.canvas);\n          var r = this.scaleX,\n              s = this.scaleY;\n          n.setTransform(r, 0, 0, s, 0, 0), n.__scaleX = r, n.__scaleY = s, t.context = n, t.scaleX = r, t.scaleY = s, t.labelRenderer = this.labelRenderer, this.labelRenderer.startFrame(e.chartWidth, e.chartHeight, r, s);\n        }, e.prototype.areaStylesBefore = function (t, e) {\n          var i = this.settings.area.style.fillColor;\n          i && (t.fillStyle = i, t.fillRect(0, 0, e.width, e.height));\n        }, e.prototype.areaStylesAfter = function (t, e) {\n          var i = this.settings.area.style.overlayColor;\n          i && (t.fillStyle = i, t.setTransform(1, 0, 0, 1, 0, 0), t.fillRect(0, 0, e.width, e.height));\n        }, e.prototype.finalizeContext = function (t) {\n          this.areaStylesAfter(t.context, this.canvas), this.labelRenderer.finishFrame();\n        }, e.prototype.exportToImageGetDimensions = function () {\n          var t = new L();\n          t.isExport = !0, t.context = this.canvas.getContext(\"2d\"), t.labelRenderer = this.labelRenderer;\n          var e = this.events.updateLayout(t);\n          return t.isExport = !1, this.events.updateLayout(t), {\n            width: e.w(),\n            height: e.h()\n          };\n        }, e.prototype.exportToContext = function (t, e, i) {\n          var n = new G(this.settings, this.chart.assetsLoader, this.container);\n          n.allowCache = !1, n.startFrame(1, 1, i, i);\n          var r = new L();\n          r.isExport = !0, r.timeStamp = this.prevTime, r.dtime = 0, r.context = t, r.scaleX = i, r.scaleY = i, r.labelRenderer = n;\n          var s = this.events.updateLayout(r);\n          this.areaStylesBefore(t, e), t.save(), t.setTransform(i, 0, 0, i, -s.x0 * i, -s.y0 * i), this.events.doPaint(r), this.areaStylesAfter(t, e), r.isExport = !1, this.events.updateLayout(r), H.restore(t);\n        }, e.prototype.getChartInnerArea = function () {\n          if (this.innerAreaCache) return this.innerAreaCache;\n          var t = new r.AreaCollection();\n          t.addRect(new r.Rect(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height));\n\n          for (var e = this.menuContainer.getBoundingClientRect(), i = e.left, n = e.top, s = this.menuContainer.children, a = 0; a < s.length; a += 1) {\n            var o = s[a];\n\n            if (o.offsetHeight > 0 || o.offsetWidth > 0) {\n              var l = o.getBoundingClientRect();\n              t.subtractRect(new mt(l.left - i, l.top - n, l.right - i, l.bottom - n));\n            }\n          }\n\n          return this.innerAreaCache = t, t;\n        }, e;\n      }();\n\n      It.MouseEventConfig = [{\n        ev: w.EVENT_GLOBAL_DOWN,\n        name: \"GlobalPointerDown\"\n      }, {\n        ev: w.EVENT_DOWN,\n        name: \"PointerDown\",\n        captures: !0\n      }, {\n        ev: w.EVENT_UP,\n        name: \"PointerUp\",\n        needsCapture: !0,\n        releasesCapture: !0\n      }, {\n        ev: w.EVENT_DRAG,\n        name: \"PointerDrag\",\n        needsCapture: !0,\n        captures: !0\n      }, {\n        ev: w.EVENT_MOVE,\n        name: \"PointerMove\",\n        captures: !0\n      }, {\n        ev: w.EVENT_LEAVE,\n        name: \"PointerOut\"\n      }, {\n        ev: w.EVENT_CANCEL,\n        name: \"PointerCancel\",\n        needsCapture: !0,\n        releasesCapture: !0\n      }, {\n        ev: w.EVENT_CLICK,\n        name: \"Click\"\n      }, {\n        ev: w.EVENT_INSTACLICK,\n        name: \"InstantClick\"\n      }, {\n        ev: w.EVENT_LONGPRESS,\n        name: \"LongPress\"\n      }, {\n        ev: w.EVENT_RCLICK,\n        name: \"RightClick\"\n      }, {\n        ev: w.EVENT_DBLCLICK,\n        name: \"DoubleClick\"\n      }, {\n        ev: w.EVENT_TPLCLICK,\n        name: \"TripleClick\"\n      }, {\n        ev: w.EVENT_WHEEL,\n        name: \"Wheel\"\n      }], r.ChartOuterShell = It;\n\n      var Pt = function () {\n        function t(t, e) {\n          this.fullScreenMode = !1, this.chart = t, this.settings = t.settings, this.scene = t.scene, this.parentShell = e, this.buildDom(), this.events = new D(t, this), this.parentShell.events.addSubchart(this.chart), this.updateSize();\n        }\n\n        return t.prototype.getChartInnerArea = function () {\n          return this.parentShell.getChartInnerArea();\n        }, t.prototype.requestPaint = function () {\n          this.parentShell.requestPaint();\n        }, t.prototype.paintNow = function (t) {\n          this.parentShell.paintNow(t);\n        }, t.prototype.buildDom = function () {\n          this.container = this.parentShell.container, this.interactiveContainer = this.parentShell.interactiveContainer, this.backgroundContainer = this.parentShell.backgroundContainer, this.menuContainer = this.parentShell.menuContainer;\n        }, t.prototype.remove = function () {\n          this.parentShell.events.removeSubchart(this.chart);\n        }, t.prototype.updateSettings = function (t) {\n          t.area && this.updateSize();\n        }, t.prototype.updateSize = function (t) {\n          void 0 === t && (t = !1);\n          var e = this.settings.area;\n          this.events.setNewSize(new mt(e.left, e.top, e.left + e.width, e.top + e.height), !1, t);\n        }, t.prototype.prepareContext = function (t) {\n          var e = this.settings.area.style;\n\n          if (e.fillColor) {\n            var i = t.context,\n                n = this.scene;\n            i.fillStyle = e.fillColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight);\n          }\n        }, t.prototype.finalizeContext = function (t) {\n          var e = this.settings.area.style;\n\n          if (e.overlayColor) {\n            var i = t.context,\n                n = this.scene;\n            i.fillStyle = e.overlayColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight);\n          }\n        }, t.prototype.forceChromeRedraw = function () {\n          this.parentShell.forceChromeRedraw();\n        }, t.prototype.setFullscreen = function (t) {}, t;\n      }();\n\n      r.ChartInnerShell = Pt;\n\n      var Dt = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 70, i.updateOrder = 200, i.scene = null, i.loadingTime = null, i.chart = e, i.scene = e.scene, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          this.scene.loading && (t.animating = !0);\n        }, e.prototype.paintScene = function (t) {\n          var e = this.scene,\n              i = e.getMessage(),\n              n = e.settings.advanced.style,\n              r = n.loadingArcStyle,\n              s = e.loading && \"hidden\" !== r.location;\n\n          if (s || (this.loadingTime = null), i || s) {\n            null === this.loadingTime && (this.loadingTime = t.timeStamp);\n            var a,\n                o,\n                l = t.context,\n                h = \"corner\" === r.location,\n                u = r.r,\n                c = r.lineWidth;\n\n            if (h) {\n              a = e.x0 + e.width - 1.2 * (u + c), o = e.y0 + 1.2 * (u + c);\n              var d = this.chart.shell.getChartInnerArea();\n              o += d.findTopPosition(a, a);\n            } else a = e.x0 + e.width / 2, o = e.y0 + e.height / 2 + u;\n\n            if (i) {\n              var p = n.messageTextStyle;\n              l.textBaseline = \"top\", l.textAlign = \"left\";\n              var f = H.getTextHeight(l, p.font),\n                  g = H.getTextWidth(l, p, i),\n                  v = void 0,\n                  m = void 0,\n                  y = void 0,\n                  S = n.messageBackgroundStyle,\n                  b = S.padding || 0;\n              s && (h ? (a -= b, v = a - 1.2 * u - g, m = f > 2 * u ? 4 : o - f / 2, y = g + 2.2 * u) : (o -= f / 2, v = a - g / 2, m = o + 1.3 * f, y = g));\n              var x = H.beginStrokeAndFill(l, S);\n              x.rect(v - b, o - u - b, y + 2 * b, m - o + u + 2 * b + f), H.endStrokeAndFill(l, x, S), H.drawText(l, p, i, v, m), H.resetTextStyle(l);\n            }\n\n            if (s) {\n              l.save(), l.lineCap = \"round\", l.lineWidth = c;\n              var C = (t.timeStamp - this.loadingTime) / 700 * Math.PI,\n                  w = l.createLinearGradient(a + u * Math.cos(C + Math.PI), o + u * Math.sin(C + Math.PI), a + u * Math.cos(C), o + u * Math.sin(C));\n              w.addColorStop(0, r.lineColor), w.addColorStop(1, \"transparent\"), l.strokeStyle = w, l.beginPath(), l.arc(a, o, u, C, C + Math.PI), l.stroke(), H.restore(l);\n            }\n          }\n        }, e;\n      }(k);\n\n      r.MessagesOverlay = Dt;\n\n      var Nt = \"undefined\" != typeof document ? document.currentScript : null,\n          Ft = null,\n          Ot = function Ot() {\n        if (Ft) return Ft;\n        if (\"undefined\" == typeof document) return \"\";\n        var e = t.PackageInfo.LibraryName;\n        \"<?\" === e.substr(0, 2) && (e = \"everything\");\n        var i = e.indexOf(\"-\");\n        i > -1 && (e = e.substr(0, i));\n\n        for (var n = new RegExp(\"^(.*?/\" + e + \"(-dev|.min|).js)\"), s = document.getElementsByTagName(\"script\"), a = 0; a < s.length; a++) {\n          var o = s[a].src;\n\n          if (o) {\n            var l = o.match(n);\n            if (l) return Ft = l[1] + \"/../assets/\";\n          }\n        }\n\n        return Nt && Nt.src ? (r.Helpers.warn(\"Cannot locate the ZoomCharts script path based on file name '\" + e + \".js'. The script path was detected using `document.currentScript` which is not supported on all browsers. Please specify 'assetsUrlBase' in settings when creating the chart for full browser compatibility.\"), Ft = Nt.src.match(/^([^?#]*)/)[1] + \"/../assets/\") : Ft = \"\";\n      },\n          Et = function () {\n        function t() {}\n\n        return t.hasPendingRequests = function () {\n          return d.hasProperties(this._imageLoading) || d.hasProperties(this.pendingHTMLAssets);\n        }, t.getAssetImage = function (t, e, i) {\n          var n = this;\n          if (this._imageCache.hasOwnProperty(t)) return this._imageCache[t];\n          if (this._imageLoading.hasOwnProperty(t)) return null;\n          if (!t) return null;\n\n          var r = function r(e) {\n            if (delete n._imageLoading[t], n._imageCache[t] = e, i) return i(e);\n          },\n              s = function s() {\n            var t = c.ErrorImage,\n                i = n._imageCache[t];\n            if (i) r(i);else if (n._imagesPendingForErrors.push(r), !n._imageLoading.hasOwnProperty(t)) {\n              var s = function s(e) {\n                delete n._imageLoading[t], n._imageCache[t] = e;\n\n                for (var i = 0; i < n._imagesPendingForErrors.length; i++) {\n                  var r = n._imagesPendingForErrors[i];\n                  r(e);\n                }\n\n                n._imagesPendingForErrors = null;\n              };\n\n              d.buildImage(t, e, s, function () {\n                d.error(\"Could not load '\" + t + \"'\");\n              }), n._imageCache.hasOwnProperty(t) || (n._imageLoading[t] = !0);\n            }\n          };\n\n          return this._imageLoading[t] = !0, d.buildImage(t, e, r, s), this._imageCache.hasOwnProperty(t) ? this._imageCache[t] : null;\n        }, t.loadHtmlAssets = function (t, e) {\n          for (var i = this, n = !1, r = 0; r < t.length; r++) {\n            var s = t[r];\n            this.loadedHTMLAssets[s.url] || (this.pendingHTMLAssets[s.url] ? n = !0 : this.loadHTMLAsset(s, function (t) {\n              return i.htmlAssetLoaded(t);\n            }) && (this.pendingHTMLAssets[s.url] = !0, n = !0));\n          }\n\n          return !!n && (this.callbacks.push(e), !0);\n        }, t.htmlAssetLoaded = function (t) {\n          if (delete this.pendingHTMLAssets[t], this.loadedHTMLAssets[t] = !0, !d.hasProperties(this.pendingHTMLAssets)) {\n            for (var e = 0; e < this.callbacks.length; e += 1) {\n              this.callbacks[e](this.errors);\n            }\n\n            this.callbacks = [], this.errors = [];\n          }\n        }, t.loadHTMLAsset = function (t, e) {\n          var i,\n              n = this,\n              s = t.url,\n              a = s.toUpperCase(),\n              o = a.indexOf(\".CSS\"),\n              l = a.indexOf(\".JS\"),\n              h = !1,\n              u = null,\n              c = !1,\n              p = function p() {\n            u && window.clearInterval(u), c || (c = !0, !h && t.required && t.required() && n.errors.push(\"The `required` delegate did not return `false` after loading \" + s), e(s));\n          },\n              f = function f() {\n            u && window.clearInterval(u), c || (c = !0, n.errors.push(\"Failed to load asset: \" + s), e(s));\n          };\n\n          if (o > l) {\n            var g = document.createElement(\"link\");\n\n            if (g.rel = \"stylesheet\", g.href = s, g.type = \"text/css\", !t.required) {\n              r.Helpers.warn(\"Asset url \" + s + \" does not define the `required` delegate which prevents the detection of asset load in older browsers.\");\n              var v = 5;\n              t.required = function () {\n                return v-- > 0;\n              }, h = !0;\n            }\n\n            var m = 100;\n            u = window.setInterval(function () {\n              m-- < 0 ? f() : t.required() || p();\n            }, 100), i = g;\n          } else {\n            if (!(l > -1)) return this.errors.push(\"Assets: Do not know how to load \" + s + '. The URL should contain either \".css\" or \".js\" - it can be either in the path, the file name or the query string.'), !1;\n            var y = document.createElement(\"script\");\n            y.src = s, y.type = \"text/javascript\", y.async = !1, i = y;\n          }\n\n          return d.listen(i, \"load\", p), d.listen(i, \"error\", f), document.getElementsByTagName(\"head\")[0].appendChild(i), !0;\n        }, t;\n      }();\n\n      Et._imageCache = {}, Et._imageLoading = {}, Et._imagesPendingForErrors = [], Et.loadedHTMLAssets = {}, Et.pendingHTMLAssets = {}, Et.callbacks = [], Et.errors = [];\n\n      var Rt = function () {\n        function e(t) {\n          this.chart = t, this.settings = t.settings;\n          var e = this.settings.assetsUrlBase || Ot();\n          e.length > 0 && \"/\" !== e[e.length - 1] && (e += \"/\"), this.assetsUrlBase = e;\n        }\n\n        return e.prototype.getAssetUrl = function (e) {\n          return 0 === e.indexOf(\"builtin://\") ? this.settings.advanced.builtinAssets[e.slice(10)] : 0 === e.indexOf(\"assets://\") ? (this.assetsUrlBase || this.chart.error(\"Cannot locate the ZoomCharts script path based on file name '\" + t.PackageInfo.LibraryName + \".js'. Please specify 'assetsUrlBase' in settings when creating the chart.\"), this.assetsUrlBase + e.slice(9)) : e;\n        }, e.prototype.hasPendingRequests = function () {\n          return Et.hasPendingRequests();\n        }, e.prototype.getAssetImage = function (t, e) {\n          var i = this;\n          return Et.getAssetImage(this.getAssetUrl(t), this.settings.advanced.crossOriginHeader, function (t) {\n            i.chart.events.requestPaint(), e && e(t);\n          });\n        }, e.prototype.ensureAssetsList = function (t, e) {\n          for (var i = [], n = 0; n < t.length; n++) {\n            var r = t[n];\n            d.isString(r) ? i.push({\n              url: r,\n              required: null\n            }) : r.required && !r.required() || i.push(r);\n          }\n\n          var s = this.loadAssetsList(i, function () {\n            e(!0);\n          });\n          s || e(!1);\n        }, e.prototype.loadAssetsList = function (t, e) {\n          for (var i = this, n = 0; n < t.length; n++) {\n            var r = t[n];\n            r.url = this.getAssetUrl(r.url);\n          }\n\n          var s = function s(t) {\n            for (var n = 0; n < t.length; n += 1) {\n              i.chart.error(t[n]);\n            }\n\n            i.chart.log(\"Assets loaded\"), e();\n          },\n              a = Et.loadHtmlAssets(t, s);\n\n          return a && this.chart.log(\"Loading assets\"), a;\n        }, e;\n      }();\n\n      r.AssetsLoader = Rt;\n\n      var Ht = function () {\n        function t(e, i, n, r, s) {\n          if (void 0 === r && (r = \"<>\"), void 0 === s && (s = null), this.t = 0, this.startSpeed = 0, this.duration = n, this.from = e, this.to = i, null == this.from && (this.from = this.to), this.startTime = s, this.x = this.from, this.t = this.startTime, this.formula = t.easingFormulas[r], !this.formula) throw new Error(\"Easing formula not defined: \" + r);\n        }\n\n        return t.prototype.jump = function (t) {\n          this.to = t, this.from = t, this.x = t, this.t = this.startTime = null;\n        }, t.prototype.reset = function (t, e, i) {\n          void 0 === i && (i = null), this.from = t, this.to = e, this.startTime = i, this.x = this.from, this.t = this.startTime;\n        }, t.prototype.retarget = function (t, e) {\n          return this.finished(this.t) ? this.startSpeed = 0 : (this.startSpeed = this._getSpeed(), e || (e = this.t)), e ? (this.from = this.get(e), this.startTime = e) : (this.startTime = null, this.from = this.x), this.to = t, this;\n        }, t.prototype.switchCoordinates = function (t, e) {\n          this.from = this.from * e + t, this.x = this.x * e + t, this.to = this.to * e + t, this.startSpeed = this.startSpeed * e;\n        }, t.prototype.updateAndGet = function (t, e) {\n          var i = this.x !== t;\n          return t !== this.to && this.retarget(t, e), {\n            value: this.get(e),\n            changes: i\n          };\n        }, t.prototype.updateAndGetFixed = function (t, e) {\n          var i = this.x !== t;\n          return t !== this.to && (this.startSpeed = 0, this.startTime = e, this.from = this.x, this.to = t), {\n            value: this.get(e),\n            changes: i\n          };\n        }, t.prototype.getClean = function (t) {\n          return this.duration <= 0 ? this.to : this.startTime ? this._calculate(t) : this.from;\n        }, t.prototype._calculate = function (t) {\n          var e = Math.min(1, Math.max(t - this.startTime, 0) / this.duration);\n          if (e >= 1) return this.to;\n          var i = this.formula(e),\n              n = i * (this.to - this.from);\n\n          if (this.startSpeed && e < 1) {\n            var r = this.startSpeed * e * this.duration;\n            n = n * i + r * (1 - i);\n          }\n\n          return n = this.from + n;\n        }, t.prototype.get = function (t) {\n          if (this.duration <= 0) return this.t = t, this.x = this.to, this.to;\n          this.startTime || (this.startTime = t);\n\n          var e = this._calculate(t);\n\n          return this.t = t, this.x = e, e;\n        }, t.prototype.finished = function (t) {\n          return this.startTime || (this.startTime = t), t >= this.startTime + this.duration;\n        }, t.prototype._getSpeed = function () {\n          var t = this.t,\n              e = this.duration / 1e3,\n              i = this.getClean(t - e / 2),\n              n = this.getClean(t + e / 2);\n          return this.t = t, (n - i) / e;\n        }, t;\n      }();\n\n      Ht.easingFormulas = {\n        \"=\": function _(t) {\n          return t;\n        },\n        \"<>\": function _(t) {\n          return t < .5 ? 2 * t * t : -.5 * ((2 * t - 1) * (2 * t - 3) - 1);\n        },\n        scroll: function scroll(t) {\n          return 1 - (1 - t) * (1 - t);\n        }\n      }, r.Animator = Ht;\n\n      var zt = function () {\n        function t(t, e, i, n, r) {\n          void 0 === n && (n = \"<>\"), void 0 === r && (r = null), this._animator = new Ht(0, 1, i, n, r), this.reset(t, e, r);\n        }\n\n        return t.prototype.reset = function (t, e, i) {\n          return d.isString(t) || null == t ? this._fromColor = O.parse(t) : this._fromColor = t, d.isString(e) || null == e ? this._toColor = O.parse(e) : this._toColor = e, this._animator.reset(0, 1, i), this;\n        }, t.prototype.getColor = function (t) {\n          var e = Math.min(1, this._animator.get(t));\n          return this._lastValue = O.blend(this._fromColor, this._toColor, e);\n        }, t.prototype.get = function (t) {\n          return O.format(this.getColor(t));\n        }, t.prototype.updateAndGet = function (t, e) {\n          (d.isString(t) || null == t) && (t = O.parse(t));\n          var i = !O.areEqual(this._lastValue, t);\n          return O.areEqual(this._toColor, t) || this.reset(this._lastValue, t, e), {\n            value: this.get(e),\n            changes: i\n          };\n        }, t.prototype.finished = function (t) {\n          return this._animator.finished(t);\n        }, t;\n      }();\n\n      r.ColorAnimator = zt;\n\n      var Bt = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 0, i.paintOrder = 1e4, i.touches = {}, i.fps = 0, i.prevFrame = null, i.frameCount = 0, i.chart = e, i.settings = e.settings.advanced, i.captureTouches = i.settings.showTouches, i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          this.captureTouches = this.settings.showTouches;\n        }, e.prototype.paintScene = function (t) {\n          var e = \"\";\n\n          if (this.settings.showTimestamp && (e += Math.round(t.timeStamp)), this.settings.showFPS) {\n            if (this.frameCount += 1, this.prevFrame) {\n              var i = Math.max(t.timeStamp - this.prevFrame, 1) / 1e3,\n                  n = 1 / i,\n                  r = Math.min(1, 3 * i);\n              this.fps = this.fps * (1 - r) + n * r;\n            }\n\n            this.prevFrame = t.timeStamp, e += \"FPS:\" + Math.round(this.fps);\n          }\n\n          var s = t.context;\n\n          if (this.captureTouches) {\n            var a = this.settings.showTouchTrail,\n                o = 0;\n\n            for (var l in this.touches) {\n              var h = this.touches[l];\n\n              if (this.touches.hasOwnProperty(l)) {\n                s.beginPath(), s.moveTo(h.dx, h.dy);\n\n                for (var u = 0; u < h.trace.length; u++) {\n                  var c = h.trace[u];\n                  s.lineTo(c.x, c.y);\n                }\n\n                a && h.cancelled ? (s.strokeStyle = \"red\", s.fillStyle = \"red\", s.lineWidth = 1) : a && h.up ? (s.strokeStyle = \"gray\", s.fillStyle = \"gray\", s.lineWidth = 3) : (s.strokeStyle = \"rgba(180,180,180,0.4)\", s.fillStyle = \"rgba(180,180,180,0.3)\", s.lineWidth = 3), s.moveTo(h.x + 30, h.y), s.stroke(), s.lineWidth = 1.5, s.beginPath(), s.arc(h.x, h.y, h.animator.get(t.timeStamp), 0, 2 * Math.PI), s.stroke(), s.fill(), h.up || (o += 1), h.animator.finished(t.timeStamp) || (t.animating = !0);\n              }\n            }\n\n            s.beginPath(), s.fillStyle = \"black\";\n\n            for (var l in this.touches) {\n              if (this.touches.hasOwnProperty(l)) for (var h = this.touches[l], u = 0; u < h.trace.length; u++) {\n                var c = h.trace[u];\n                s.rect(c.x - 1, c.y - 1, 2, 2);\n              }\n            }\n\n            s.fill(), a && (e += \"\\ntouches:\" + o);\n          }\n\n          if (e.length > 0) {\n            var d = this.chart.shell.getChartInnerArea(),\n                p = Math.max(30, d.findTopPosition(50, 200));\n            H.resetTextStyle(s), s.fillStyle = \"#000\", s.textAlign = \"start\", s.textBaseline = \"middle\", s.font = \"bold 11px Arial\", s.fillText(e, 50, p);\n          }\n        }, e.prototype.previewPointerDown = function (t) {\n          if (this.captureTouches) {\n            for (var e in this.touches) {\n              var i = this.touches[e];\n              this.touches.hasOwnProperty(e) && i.up && delete this.touches[e];\n            }\n\n            this.touches[t.identifier] = {\n              dx: t.x,\n              dy: t.y,\n              x: t.x,\n              y: t.y,\n              up: !1,\n              cancelled: !1,\n              trace: [],\n              animator: new r.Animator(10, 40, 200)\n            }, t.changes.requestPaint = !0;\n          }\n        }, e.prototype.previewPointerDrag = function (t) {\n          if (this.captureTouches) {\n            var e = this.touches[t.identifier];\n            e.x = t.x, e.y = t.y, this.settings.showTouchTrail && e.trace.push({\n              x: e.x,\n              y: e.y\n            }), t.changes.requestPaint = !0;\n          }\n        }, e.prototype.previewPointerUp = function (t) {\n          if (this.captureTouches) {\n            var e = this.touches[t.identifier];\n            e.up = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0;\n          }\n        }, e.prototype.previewPointerCancel = function (t) {\n          if (this.captureTouches) {\n            var e = this.touches[t.identifier];\n            e.up = !0, e.cancelled = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0;\n          }\n        }, e;\n      }(k);\n\n      r.TouchMarkers = Bt;\n\n      var Ut = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n          Gt = function () {\n        function t() {}\n\n        return t.createImage = function (e, i, n, s) {\n          var a = t.getSizes(e, n),\n              o = document.createElement(\"canvas\");\n          o.width = a.width, o.height = a.height;\n          var l = o.getContext(\"2d\");\n          s || (l.fillStyle = \"#fff\", l.fillRect(0, 0, a.width, a.height)), e.exportToContext(l, o, a.scale);\n\n          try {\n            return o.toDataURL(i);\n          } catch (t) {\n            throw r.Helpers.error(t), new Error(\"Browser security prevents exporting this chart. The canvas might be tainted. See `advanced.crossOriginHeader` setting in the documentation.\");\n          }\n        }, t.createPdf = function (e, i) {\n          var n,\n              r = e.exportToImageGetDimensions(),\n              s = [10, 10, 10, 10],\n              a = e.settings.advanced.exportPdfSize,\n              o = 0,\n              l = 0,\n              h = 0,\n              u = 0,\n              c = 72,\n              d = 1,\n              p = 0,\n              f = 0;\n          r.width >= r.height ? (a = [a[1], a[0]], n = \"l\") : n = \"p\", o = a[0] / 25.4 * c, l = a[1] / 25.4 * c, d = Math.min(l / r.height, o / r.width), \"l\" === n ? (p = r.width * d / o * a[0] - s[1] - s[3], h = (a[0] - p - s[1] - s[3]) / 2, f = r.height / r.width * p, u = (a[1] - s[0] - s[2] - f) / 2) : (f = r.height * d / l * a[1] - s[0] - s[2], u = (a[1] - f - s[0] - s[2]) / 2, p = r.width / r.height * f, h = (a[0] - s[1] - s[3] - p) / 2);\n          var g = t.createImage(e, \"image/jpeg\", {\n            scaling: 3 * d\n          }, !1),\n              v = new jsPDF(n, \"mm\", a);\n          return v.addImage(g, \"JPEG\", s[3] + h, s[0] + u, p, f), v.output(\"datauristring\");\n        }, t.createCsv = function (e) {\n          for (var i = /[^a-zA-Z0-9\\.]/, n = \"data:text/csv;charset=utf-8,\", r = encodeURIComponent(\"\\r\\n\"), s = 0; s < e.length; s++) {\n            for (var a = e[s], o = 0; o < a.length; o++) {\n              o > 0 && (n += t._csvSeparator);\n              var l = a[o];\n\n              if (null != l) {\n                var h = void 0;\n                h = l instanceof Date ? l.toISOString() : \"\" + l, n += i.test(h) ? '\"' + encodeURIComponent(h.replace('\"', '\"\"')) + '\"' : h;\n              }\n            }\n\n            n += r;\n          }\n\n          return n;\n        }, t.retrieveData = function (t, e) {\n          var i = t.exportVisibleData,\n              n = t.settings.advanced.dataExportFunction;\n          if (!i && !n) throw new Error(\"This chart type does not support data export. Provide `advanced.dataExportFunction` delegate to enable it.\");\n          var r = i ? t.exportVisibleData() : null;\n          n ? n(r, e) : e(r);\n        }, t.createExcel = function (t) {\n          function e(t) {\n            return (t.getTime() + 22091616e5) / 864e5;\n          }\n\n          for (var i = Object.create(null), n = {\n            s: {\n              c: 1 / 0,\n              r: 1 / 0\n            },\n            e: {\n              c: 0,\n              r: 0\n            }\n          }, r = 0; r < t.length; r++) {\n            n.s.r > r && (n.s.r = r), n.e.r < r && (n.e.r = r);\n\n            for (var s = t[r], a = 0; a < s.length; a++) {\n              n.s.c > a && (n.s.c = a), n.e.c < a && (n.e.c = a);\n              var o = s[a];\n\n              if (null != o) {\n                var l = {\n                  t: \"s\",\n                  v: o\n                };\n                \"number\" == typeof o ? (l.t = \"n\", Math.round(o) === o && (l.z = \"0\")) : \"boolean\" == typeof o ? l.t = \"b\" : o instanceof Date && (l.t = \"n\", l.z = XLSX.SSF._table[14], l.v = e(l.v)), i[XLSX.utils.encode_cell({\n                  c: a,\n                  r: r\n                })] = l;\n              }\n            }\n          }\n\n          n.s.c < 1 / 0 && (i[\"!ref\"] = XLSX.utils.encode_range(n));\n          var h = {\n            SheetNames: [\"export\"],\n            Sheets: {\n              export: i\n            }\n          },\n              u = XLSX.write(h, {\n            bookType: \"xlsx\",\n            bookSST: !0,\n            type: \"binary\"\n          });\n          return \"data:\" + Ut + \";base64,\" + d.base64Encode(u);\n        }, t.export = function (e, i, n, s, a) {\n          void 0 === i && (i = \"png\"), void 0 === n && (n = {}), void 0 === s && (s = null);\n          var o = e.shell;\n          if (!(o instanceof It)) throw new Error(\"Export functionality is only available on the top level chart, not within nested charts.\");\n          var l = t._mimeMap[i];\n          if (\"xls\" === i) r.Helpers.warn(\"XLS format is not supported. XLSX will be used instead.\");else if (null == i) i = \"png\", l = t._mimeMap.png;else if (void 0 === l) throw new Error(\"Export image type `\" + i + \"` is not supported. Supported types: \" + Object.keys(t._mimeMap).join(\", \"));\n          if (l.transparent ? null == s && (s = !0) : s && (r.Helpers.warn(\"Only PNG images can be exported as transparent.\"), s = !1), l.csv) return void t.retrieveData(e, function (e) {\n            a(t.createCsv(e), l.mime, l.extension);\n          });\n          if (l.excel) return void e.assetsLoader.ensureAssetsList([{\n            url: \"assets://xlsx.core.min.js\",\n            required: function required() {\n              return \"undefined\" == typeof XLSX;\n            }\n          }], function () {\n            t.retrieveData(e, function (e) {\n              a(t.createExcel(e), l.mime, l.extension);\n            });\n          });\n\n          if (l.image) {\n            var h = t.createImage(o, l.mime, t.getDimensions(e, n), s);\n            return a(h, l.mime, l.extension), h;\n          }\n\n          if (l.pdf) return void e.assetsLoader.ensureAssetsList([{\n            url: \"assets://jspdf.js\",\n            required: function required() {\n              return \"undefined\" == typeof jsPDF;\n            }\n          }], function () {\n            a(t.createPdf(o, n), l.mime, l.extension);\n          });\n          throw new Error(\"not implemented\");\n        }, t.download = function (t, e, i, n) {\n          var r = this;\n          void 0 === i && (i = {}), this.export(t, e, i, n, function (e, i, n) {\n            r.launchDownload(t, i, n, e);\n          });\n        }, t.getSizes = function (t, e) {\n          var i = t.exportToImageGetDimensions(),\n              n = i.width,\n              r = i.height,\n              s = d.tryParseFloat(e.width),\n              a = d.tryParseFloat(e.height),\n              o = 1;\n\n          if (\"mm\" === e.unit) {\n            var l = d.tryParseFloat(e.dpi, 300) / 25.4;\n            s > 0 && (s *= l), a > 0 && (a *= l);\n          }\n\n          s > 0 && a > 0 ? o = Math.min(s / n, a / r) : s > 0 ? (o = s / n, a = r * o) : a > 0 ? (o = a / r, s = n * o) : (s = n, a = r);\n          var h = d.tryParseFloat(e.scaling, 1);\n          return 1 !== h && (o *= h, s *= h, a *= h), {\n            width: s,\n            height: a,\n            scale: o,\n            chartWidth: n,\n            chartHeight: r\n          };\n        }, t.getDimensions = function (t, e) {\n          var i = t.shell;\n          if (!(i instanceof It)) throw new Error(\"Export functionality is only available on the top level chart, not within nested charts.\");\n          return this.getSizes(i, e || {});\n        }, t.dataUriToBlob = function (t, e) {\n          var i = e.indexOf(\",\"),\n              n = i > 13 && \";base64\" === e.substr(i - 7, 7);\n          e = e.substr(i + 1), e = n ? window.atob(e) : decodeURIComponent(e);\n\n          for (var r = new ArrayBuffer(e.length), s = new Uint8Array(r), a = 0; a < e.length; a++) {\n            s[a] = e.charCodeAt(a);\n          }\n\n          return new Blob([r], {\n            type: t\n          });\n        }, t.launchDownload = function (e, i, n, r, s) {\n          var a = document.body;\n          n.indexOf(\".\") === -1 && (n = \"export.\" + n);\n          var o = d.createDom(\"a\", null, null, null);\n\n          if (navigator.msSaveOrOpenBlob && window.atob) {\n            if (navigator.msSaveOrOpenBlob(t.dataUriToBlob(i, r), n)) return;\n          } else if (b.detect().isChrome && r.length > 2097152) ;else if (void 0 !== o.download) return o.download = n, o.type = i, o.href = r, a.appendChild(o), o.click(), void a.removeChild(o);\n\n          var l = e.settings.advanced.exportProxyURL;\n          if (!l) return void alert(e.settings.localization.exportNotAvailable);\n\n          var h = function h() {\n            var t = document.createElement(\"form\");\n            t.action = l, t.target = \"_top\", t.method = \"POST\", t.style.display = \"none\";\n            var e = document.createElement(\"input\");\n            e.name = \"name\", e.value = n, t.appendChild(e);\n            var i = document.createElement(\"textarea\");\n            i.name = \"data\", i.value = r, t.appendChild(i), a.appendChild(t), t.submit(), a.removeChild(t);\n          };\n\n          s ? s(h, function () {}) : h();\n        }, t;\n      }();\n\n      Gt._csvSeparator = \";\", Gt._mimeMap = {\n        png: {\n          mime: \"image/png\",\n          extension: \"png\",\n          image: !0,\n          transparent: !0\n        },\n        jpg: {\n          mime: \"image/jpeg\",\n          extension: \"jpg\",\n          image: !0\n        },\n        jpeg: {\n          mime: \"image/jpeg\",\n          extension: \"jpg\",\n          image: !0\n        },\n        csv: {\n          mime: \"text/csv\",\n          extension: \"csv\",\n          csv: !0\n        },\n        txt: {\n          mime: \"text/csv\",\n          extension: \"csv\",\n          csv: !0\n        },\n        xlsx: {\n          mime: Ut,\n          extension: \"xlsx\",\n          excel: !0\n        },\n        xls: {\n          mime: Ut,\n          extension: \"xlsx\",\n          excel: !0\n        },\n        pdf: {\n          mime: \"application/pdf\",\n          extension: \"pdf\",\n          pdf: !0\n        }\n      }, r.Export = Gt, function (t) {\n        var e = function (t) {\n          function e(e, i) {\n            var n,\n                r = e.settings.localization.toolbar;\n\n            if (!i.dropDownItems) {\n              var s = e.settings.toolbar.exportOptions,\n                  a = [];\n              (!s || s.indexOf(\"jpg\") > -1) && a.push({\n                label: r.exportJpeg,\n                onClick: function onClick() {\n                  return Gt.download(e, \"jpg\", {\n                    scaling: 2\n                  });\n                }\n              }), (!s || s.indexOf(\"png\") > -1) && a.push({\n                label: r.exportPNG,\n                onClick: function onClick() {\n                  return Gt.download(e, \"png\", {\n                    scaling: 3\n                  });\n                }\n              }), (!s || s.indexOf(\"pdf\") > -1) && a.push({\n                label: r.exportPDF,\n                onClick: function onClick() {\n                  return Gt.download(e, \"pdf\");\n                }\n              }), (e.exportVisibleData || e.settings.advanced.dataExportFunction) && ((!s || s.indexOf(\"csv\") > -1) && a.push({\n                label: r.exportCSV,\n                onClick: function onClick() {\n                  return Gt.download(e, \"csv\");\n                }\n              }), (!s || s.indexOf(\"xlsx\") > -1) && a.push({\n                label: r.exportXLS,\n                onClick: function onClick() {\n                  return Gt.download(e, \"xlsx\");\n                }\n              })), i.dropDownItems = a;\n            }\n\n            return i.title = i.title || r.exportTitle, i.label = i.label || r.exportButton, i.cssClass = i.cssClass || \"DVSL-bar-btn-export\", n = t.call(this, e, i) || this;\n          }\n\n          return n(e, t), e;\n        }(t.Dropdown);\n\n        t.ExportDropdown = e, r.Bar.ToolbarItemNames.export = function (t, e) {\n          return new r.Bar.ExportDropdown(t, e);\n        };\n      }(o = r.Bar || (r.Bar = {}));\n\n      var Vt = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 0, i.chart = e, i;\n        }\n\n        return n(e, t), e.prototype.onKeyDown = function (t) {\n          this.chart.isFullscreen() && 27 === t.keyCode ? (this.chart.setFullscreen(!1), t.consumed = !0) : 8 === t.keyCode && this.chart.back(!0, \"user\") && (t.consumed = !0);\n        }, e;\n      }(k);\n\n      r.KeyShortcuts = Vt;\n\n      var jt = \"C314F39F62CBF2AEFA1D5BA41E38EFFD080E88849EE210BA17971BF63A55C44E159C9F9ED004F8D50856EC8ECE673690F60C29AAC124B7C46D549D20EB22CC2A387B2FB643700546312114F831133F242CFFD023A1788167025FF398F5F09D1003C47C9B3208860A547577F540D07FF66403097FE27E7BB6B8D76036AD31B62B04EAD1BB8B2C314F6DA7489346978286491D0DF7504E9EE85A4459805F4FFCEE664122FC27B80DAD6751A7A6C0D38E9C2ECD7C0AD1F2B774D6FF81C5A2CE14D608F08E13BEE45663450519774ADF87D34CE6150FC819558EBD336511D51405A42E7A38EBB786ED5050345CBC532ED7C0EECB05C5D6D4D00534249ED4585DFABD\",\n          Wt = function () {\n        function t() {}\n\n        return t.verifySignature = function (t, e, i) {\n          var n = new Zt();\n          return n.setPublic(i || jt, \"10001\"), n.verify(t, e);\n        }, t.hash = function (t) {\n          return Zt.hash(t);\n        }, t;\n      }();\n\n      r.RsaCrypto = Wt, Object.freeze(Wt);\n\n      var Zt = function () {\n        function t(t, e) {\n          null != t && (null == e && \"string\" != typeof t ? this.fromString(t, 256) : this.fromString(t, e));\n        }\n\n        function e() {\n          return new t(null);\n        }\n\n        function i(t, e, i, n, r, s) {\n          for (; --s >= 0;) {\n            var a = e * this[t++] + i[n] + r;\n            r = Math.floor(a / 67108864), i[n++] = 67108863 & a;\n          }\n\n          return r;\n        }\n\n        function n(t, e, i, n, r, s) {\n          for (var a = 32767 & e, o = e >> 15; --s >= 0;) {\n            var l = 32767 & this[t],\n                h = this[t++] >> 15,\n                u = o * l + h * a;\n            l = a * l + ((32767 & u) << 15) + i[n] + (1073741823 & r), r = (l >>> 30) + (u >>> 15) + o * h + (r >>> 30), i[n++] = 1073741823 & l;\n          }\n\n          return r;\n        }\n\n        function r(t, e, i, n, r, s) {\n          for (var a = 16383 & e, o = e >> 14; --s >= 0;) {\n            var l = 16383 & this[t],\n                h = this[t++] >> 14,\n                u = o * l + h * a;\n            l = a * l + ((16383 & u) << 14) + i[n] + r, r = (l >> 28) + (u >> 14) + o * h, i[n++] = 268435455 & l;\n          }\n\n          return r;\n        }\n\n        function s(t) {\n          return et.charAt(t);\n        }\n\n        function a(t, e) {\n          var i = it[t.charCodeAt(e)];\n          return null == i ? -1 : i;\n        }\n\n        function o(t) {\n          for (var e = this.t - 1; e >= 0; --e) {\n            t[e] = this[e];\n          }\n\n          t.t = this.t, t.s = this.s;\n        }\n\n        function l(t) {\n          this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0;\n        }\n\n        function h(t) {\n          var i = e();\n          return i.fromInt(t), i;\n        }\n\n        function u(e, i) {\n          var n;\n          if (16 == i) n = 4;else if (8 == i) n = 3;else if (256 == i) n = 8;else if (2 == i) n = 1;else if (32 == i) n = 5;else {\n            if (4 != i) return void this.fromRadix(e, i);\n            n = 2;\n          }\n          this.t = 0, this.s = 0;\n\n          for (var r = e.length, s = !1, o = 0; --r >= 0;) {\n            var l = 8 == n ? 255 & e[r] : a(e, r);\n            l < 0 ? \"-\" == e.charAt(r) && (s = !0) : (s = !1, 0 == o ? this[this.t++] = l : o + n > this.DB ? (this[this.t - 1] |= (l & (1 << this.DB - o) - 1) << o, this[this.t++] = l >> this.DB - o) : this[this.t - 1] |= l << o, o += n, o >= this.DB && (o -= this.DB));\n          }\n\n          8 == n && 0 != (128 & e[0]) && (this.s = -1, o > 0 && (this[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), s && t.ZERO.subTo(this, this);\n        }\n\n        function c() {\n          for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) {\n            --this.t;\n          }\n        }\n\n        function d(t) {\n          if (this.s < 0) return \"-\" + this.negate().toString(t);\n          var e;\n          if (16 == t) e = 4;else if (8 == t) e = 3;else if (2 == t) e = 1;else if (32 == t) e = 5;else {\n            if (4 != t) return this.toRadix(t);\n            e = 2;\n          }\n          var i,\n              n = (1 << e) - 1,\n              r = !1,\n              a = \"\",\n              o = this.t,\n              l = this.DB - o * this.DB % e;\n          if (o-- > 0) for (l < this.DB && (i = this[o] >> l) > 0 && (r = !0, a = s(i)); o >= 0;) {\n            l < e ? (i = (this[o] & (1 << l) - 1) << e - l, i |= this[--o] >> (l += this.DB - e)) : (i = this[o] >> (l -= e) & n, l <= 0 && (l += this.DB, --o)), i > 0 && (r = !0), r && (a += s(i));\n          }\n          return r ? a : \"0\";\n        }\n\n        function p() {\n          var i = e();\n          return t.ZERO.subTo(this, i), i;\n        }\n\n        function f() {\n          return this.s < 0 ? this.negate() : this;\n        }\n\n        function g(t) {\n          var e = this.s - t.s;\n          if (0 != e) return e;\n          var i = this.t;\n          if (e = i - t.t, 0 != e) return this.s < 0 ? -e : e;\n\n          for (; --i >= 0;) {\n            if (0 != (e = this[i] - t[i])) return e;\n          }\n\n          return 0;\n        }\n\n        function v(t) {\n          var e,\n              i = 1;\n          return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i;\n        }\n\n        function m() {\n          return this.t <= 0 ? 0 : this.DB * (this.t - 1) + v(this[this.t - 1] ^ this.s & this.DM);\n        }\n\n        function y(t, e) {\n          var i;\n\n          for (i = this.t - 1; i >= 0; --i) {\n            e[i + t] = this[i];\n          }\n\n          for (i = t - 1; i >= 0; --i) {\n            e[i] = 0;\n          }\n\n          e.t = this.t + t, e.s = this.s;\n        }\n\n        function S(t, e) {\n          for (var i = t; i < this.t; ++i) {\n            e[i - t] = this[i];\n          }\n\n          e.t = Math.max(this.t - t, 0), e.s = this.s;\n        }\n\n        function b(t, e) {\n          var i,\n              n = t % this.DB,\n              r = this.DB - n,\n              s = (1 << r) - 1,\n              a = Math.floor(t / this.DB),\n              o = this.s << n & this.DM;\n\n          for (i = this.t - 1; i >= 0; --i) {\n            e[i + a + 1] = this[i] >> r | o, o = (this[i] & s) << n;\n          }\n\n          for (i = a - 1; i >= 0; --i) {\n            e[i] = 0;\n          }\n\n          e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp();\n        }\n\n        function x(t, e) {\n          e.s = this.s;\n          var i = Math.floor(t / this.DB);\n          if (i >= this.t) return void (e.t = 0);\n          var n = t % this.DB,\n              r = this.DB - n,\n              s = (1 << n) - 1;\n          e[0] = this[i] >> n;\n\n          for (var a = i + 1; a < this.t; ++a) {\n            e[a - i - 1] |= (this[a] & s) << r, e[a - i] = this[a] >> n;\n          }\n\n          n > 0 && (e[this.t - i - 1] |= (this.s & s) << r), e.t = this.t - i, e.clamp();\n        }\n\n        function C(t, e) {\n          for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r;) {\n            n += this[i] - t[i], e[i++] = n & this.DM, n >>= this.DB;\n          }\n\n          if (t.t < this.t) {\n            for (n -= t.s; i < this.t;) {\n              n += this[i], e[i++] = n & this.DM, n >>= this.DB;\n            }\n\n            n += this.s;\n          } else {\n            for (n += this.s; i < t.t;) {\n              n -= t[i], e[i++] = n & this.DM, n >>= this.DB;\n            }\n\n            n -= t.s;\n          }\n\n          e.s = n < 0 ? -1 : 0, n < -1 ? e[i++] = this.DV + n : n > 0 && (e[i++] = n), e.t = i, e.clamp();\n        }\n\n        function w(e, i) {\n          var n = this.abs(),\n              r = e.abs(),\n              s = n.t;\n\n          for (i.t = s + r.t; --s >= 0;) {\n            i[s] = 0;\n          }\n\n          for (s = 0; s < r.t; ++s) {\n            i[s + n.t] = n.am(0, r[s], i, s, 0, n.t);\n          }\n\n          i.s = 0, i.clamp(), this.s != e.s && t.ZERO.subTo(i, i);\n        }\n\n        function L(t) {\n          for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0;) {\n            t[i] = 0;\n          }\n\n          for (i = 0; i < e.t - 1; ++i) {\n            var n = e.am(i, e[i], t, 2 * i, 0, 1);\n            (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1);\n          }\n\n          t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp();\n        }\n\n        function T(i, n, r) {\n          var s = i.abs();\n\n          if (!(s.t <= 0)) {\n            var a = this.abs();\n            if (a.t < s.t) return null != n && n.fromInt(0), void (null != r && this.copyTo(r));\n            null == r && (r = e());\n            var o = e(),\n                l = this.s,\n                h = i.s,\n                u = this.DB - v(s[s.t - 1]);\n            u > 0 ? (s.lShiftTo(u, o), a.lShiftTo(u, r)) : (s.copyTo(o), a.copyTo(r));\n            var c = o.t,\n                d = o[c - 1];\n\n            if (0 != d) {\n              var p = d * (1 << this.F1) + (c > 1 ? o[c - 2] >> this.F2 : 0),\n                  f = this.FV / p,\n                  g = (1 << this.F1) / p,\n                  m = 1 << this.F2,\n                  y = r.t,\n                  S = y - c,\n                  b = null == n ? e() : n;\n\n              for (o.dlShiftTo(S, b), r.compareTo(b) >= 0 && (r[r.t++] = 1, r.subTo(b, r)), t.ONE.dlShiftTo(c, b), b.subTo(o, o); o.t < c;) {\n                o[o.t++] = 0;\n              }\n\n              for (; --S >= 0;) {\n                var x = r[--y] == d ? this.DM : Math.floor(r[y] * f + (r[y - 1] + m) * g);\n                if ((r[y] += o.am(0, x, r, S, 0, c)) < x) for (o.dlShiftTo(S, b), r.subTo(b, r); r[y] < --x;) {\n                  r.subTo(b, r);\n                }\n              }\n\n              null != n && (r.drShiftTo(c, n), l != h && t.ZERO.subTo(n, n)), r.t = c, r.clamp(), u > 0 && r.rShiftTo(u, r), l < 0 && t.ZERO.subTo(r, r);\n            }\n          }\n        }\n\n        function k(i) {\n          var n = e();\n          return this.abs().divRemTo(i, null, n), this.s < 0 && n.compareTo(t.ZERO) > 0 && i.subTo(n, n), n;\n        }\n\n        function M(t) {\n          this.m = t;\n        }\n\n        function A(t) {\n          return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;\n        }\n\n        function I(t) {\n          return t;\n        }\n\n        function P(t) {\n          t.divRemTo(this.m, null, t);\n        }\n\n        function D(t, e, i) {\n          t.multiplyTo(e, i), this.reduce(i);\n        }\n\n        function N(t, e) {\n          t.squareTo(e), this.reduce(e);\n        }\n\n        function F() {\n          if (this.t < 1) return 0;\n          var t = this[0];\n          if (0 == (1 & t)) return 0;\n          var e = 3 & t;\n          return e = e * (2 - (15 & t) * e) & 15, e = e * (2 - (255 & t) * e) & 255, e = e * (2 - ((65535 & t) * e & 65535)) & 65535, e = e * (2 - t * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e;\n        }\n\n        function O(t) {\n          this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t;\n        }\n\n        function E(i) {\n          var n = e();\n          return i.abs().dlShiftTo(this.m.t, n), n.divRemTo(this.m, null, n), i.s < 0 && n.compareTo(t.ZERO) > 0 && this.m.subTo(n, n), n;\n        }\n\n        function R(t) {\n          var i = e();\n          return t.copyTo(i), this.reduce(i), i;\n        }\n\n        function H(t) {\n          for (; t.t <= this.mt2;) {\n            t[t.t++] = 0;\n          }\n\n          for (var e = 0; e < this.m.t; ++e) {\n            var i = 32767 & t[e],\n                n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;\n\n            for (i = e + this.m.t, t[i] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV;) {\n              t[i] -= t.DV, t[++i]++;\n            }\n          }\n\n          t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);\n        }\n\n        function z(t, e) {\n          t.squareTo(e), this.reduce(e);\n        }\n\n        function B(t, e, i) {\n          t.multiplyTo(e, i), this.reduce(i);\n        }\n\n        function U() {\n          return 0 == (this.t > 0 ? 1 & this[0] : this.s);\n        }\n\n        function G(i, n) {\n          if (i > 4294967295 || i < 1) return t.ONE;\n          var r = e(),\n              s = e(),\n              a = n.convert(this),\n              o = v(i) - 1;\n\n          for (a.copyTo(r); --o >= 0;) {\n            if (n.sqrTo(r, s), (i & 1 << o) > 0) n.mulTo(s, a, r);else {\n              var l = r;\n              r = s, s = l;\n            }\n          }\n\n          return n.revert(r);\n        }\n\n        function V(t, e) {\n          var i;\n          return i = t < 256 || e.isEven() ? new M(e) : new O(e), this.exp(t, i);\n        }\n\n        function j(e, i) {\n          return new t(e, i);\n        }\n\n        function W() {\n          this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;\n        }\n\n        function Z(t, e) {\n          null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = j(t, 16), this.e = parseInt(e, 16)) : alert(\"Invalid RSA public key\");\n        }\n\n        function Y(t) {\n          return t.modPowInt(this.e, this.n);\n        }\n\n        function q(t) {\n          for (var e in rt.crypto.Util.DIGESTINFOHEAD) {\n            var i = rt.crypto.Util.DIGESTINFOHEAD[e],\n                n = i.length;\n            if (t.substring(0, n) == i) return [e, t.substring(n)];\n          }\n\n          return [];\n        }\n\n        function _(t, e) {\n          e = e.replace(st, \"\"), e = e.replace(/[ \\n]+/g, \"\");\n          var i = j(e, 16);\n          if (i.bitLength() > this.n.bitLength()) return !1;\n          var n = this.doPublic(i),\n              r = n.toString(16).replace(/^1f+00/, \"\"),\n              s = q(r);\n          if (0 === s.length) return !1;\n          var a = s[1],\n              o = nt.hash(t);\n          return a === o;\n        }\n\n        var X,\n            Q = 0xdeadbeefcafe,\n            J = 15715070 == (16777215 & Q);\n        \"undefined\" == typeof window ? null : window.crypto || window.msCrypto;\n        J && \"undefined\" != typeof navigator && \"Microsoft Internet Explorer\" === navigator.appName ? (t.prototype.am = n, X = 30) : J && \"undefined\" != typeof navigator && \"Netscape\" !== navigator.appName ? (t.prototype.am = i, X = 26) : (t.prototype.am = r, X = 28), t.prototype.DB = X, t.prototype.DM = (1 << X) - 1, t.prototype.DV = 1 << X;\n        var K = 52;\n        t.prototype.FV = Math.pow(2, K), t.prototype.F1 = K - X, t.prototype.F2 = 2 * X - K;\n        var $,\n            tt,\n            et = \"0123456789abcdefghijklmnopqrstuvwxyz\",\n            it = new Array();\n\n        for ($ = \"0\".charCodeAt(0), tt = 0; tt <= 9; ++tt) {\n          it[$++] = tt;\n        }\n\n        for ($ = \"a\".charCodeAt(0), tt = 10; tt < 36; ++tt) {\n          it[$++] = tt;\n        }\n\n        for ($ = \"A\".charCodeAt(0), tt = 10; tt < 36; ++tt) {\n          it[$++] = tt;\n        }\n\n        M.prototype.convert = A, M.prototype.revert = I, M.prototype.reduce = P, M.prototype.mulTo = D, M.prototype.sqrTo = N, O.prototype.convert = E, O.prototype.revert = R, O.prototype.reduce = H, O.prototype.mulTo = B, O.prototype.sqrTo = z, t.prototype.copyTo = o, t.prototype.fromInt = l, t.prototype.fromString = u, t.prototype.clamp = c, t.prototype.dlShiftTo = y, t.prototype.drShiftTo = S, t.prototype.lShiftTo = b, t.prototype.rShiftTo = x, t.prototype.subTo = C, t.prototype.multiplyTo = w, t.prototype.squareTo = L, t.prototype.divRemTo = T, t.prototype.invDigit = F, t.prototype.isEven = U, t.prototype.exp = G, t.prototype.toString = d, t.prototype.negate = p, t.prototype.abs = f, t.prototype.compareTo = g, t.prototype.bitLength = m, t.prototype.mod = k, t.prototype.modPowInt = V, t.ZERO = h(0), t.ONE = h(1), W.prototype.doPublic = Y, W.prototype.setPublic = Z;\n        var nt = {};\n        nt.utf8Encode = function (t) {\n          return window.unescape(encodeURIComponent(t));\n        }, nt.hash = function (t) {\n          t = nt.utf8Encode(t);\n          var e = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],\n              i = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];\n          t += String.fromCharCode(128);\n\n          for (var n = t.length / 4 + 2, r = Math.ceil(n / 16), s = new Array(r), a = 0; a < r; a++) {\n            s[a] = new Array(16);\n\n            for (var o = 0; o < 16; o++) {\n              s[a][o] = t.charCodeAt(64 * a + 4 * o) << 24 | t.charCodeAt(64 * a + 4 * o + 1) << 16 | t.charCodeAt(64 * a + 4 * o + 2) << 8 | t.charCodeAt(64 * a + 4 * o + 3);\n            }\n          }\n\n          s[r - 1][14] = 8 * (t.length - 1) / Math.pow(2, 32), s[r - 1][14] = Math.floor(s[r - 1][14]), s[r - 1][15] = 8 * (t.length - 1) & 4294967295;\n\n          for (var l, h, u, c, d, p, f, g, v = new Array(64), a = 0; a < r; a++) {\n            for (var m = 0; m < 16; m++) {\n              v[m] = s[a][m];\n            }\n\n            for (var m = 16; m < 64; m++) {\n              v[m] = nt.s1(v[m - 2]) + v[m - 7] + nt.s0(v[m - 15]) + v[m - 16] & 4294967295;\n            }\n\n            l = i[0], h = i[1], u = i[2], c = i[3], d = i[4], p = i[5], f = i[6], g = i[7];\n\n            for (var m = 0; m < 64; m++) {\n              var y = g + nt.S1(d) + nt.Ch(d, p, f) + e[m] + v[m],\n                  S = nt.S0(l) + nt.Maj(l, h, u);\n              g = f, f = p, p = d, d = c + y & 4294967295, c = u, u = h, h = l, l = y + S & 4294967295;\n            }\n\n            i[0] = i[0] + l & 4294967295, i[1] = i[1] + h & 4294967295, i[2] = i[2] + u & 4294967295, i[3] = i[3] + c & 4294967295, i[4] = i[4] + d & 4294967295, i[5] = i[5] + p & 4294967295, i[6] = i[6] + f & 4294967295, i[7] = i[7] + g & 4294967295;\n          }\n\n          return nt.toHexStr(i[0]) + nt.toHexStr(i[1]) + nt.toHexStr(i[2]) + nt.toHexStr(i[3]) + nt.toHexStr(i[4]) + nt.toHexStr(i[5]) + nt.toHexStr(i[6]) + nt.toHexStr(i[7]);\n        }, nt.ROTR = function (t, e) {\n          return e >>> t | e << 32 - t;\n        }, nt.S0 = function (t) {\n          return nt.ROTR(2, t) ^ nt.ROTR(13, t) ^ nt.ROTR(22, t);\n        }, nt.S1 = function (t) {\n          return nt.ROTR(6, t) ^ nt.ROTR(11, t) ^ nt.ROTR(25, t);\n        }, nt.s0 = function (t) {\n          return nt.ROTR(7, t) ^ nt.ROTR(18, t) ^ t >>> 3;\n        }, nt.s1 = function (t) {\n          return nt.ROTR(17, t) ^ nt.ROTR(19, t) ^ t >>> 10;\n        }, nt.Ch = function (t, e, i) {\n          return t & e ^ ~t & i;\n        }, nt.Maj = function (t, e, i) {\n          return t & e ^ t & i ^ e & i;\n        }, nt.toHexStr = function (t) {\n          for (var e, i = \"\", n = 7; n >= 0; n--) {\n            e = t >>> 4 * n & 15, i += e.toString(16);\n          }\n\n          return i;\n        };\n        var rt = {\n          crypto: {\n            Util: {\n              DIGESTINFOHEAD: {\n                sha256: \"3031300d060960864801650304020105000420\"\n              }\n            }\n          }\n        },\n            st = new RegExp(\"[^0-9a-f]\", \"gi\");\n        return W.prototype.verify = _, W.hash = nt.hash, W;\n      }(),\n          Yt = function () {\n        function t(t, e, i) {\n          var n = this;\n          this.api = null, this.scene = null, this.settings = null, this.shell = null, this.events = null, this.removed = !0, this.assetsLoaded = !1, this.toolbar = null, this.data = {}, this.navigator = null, this.curState = null, this.goingBack = !1, this.chartUpdateOrigin = null, this.chartUpdateTimeout = null, this.scene = e, this.settings = t, this.api = i, i._impl = this, this.scene.settings = t, this.scene.assetsLoader = this.assetsLoader = new Rt(this), this.data = {}, this.settings.parentChart ? (this.shell = new Pt(this, this.settings.parentChart._impl.shell), this.events = this.shell.events) : (this.shell = new It(this, this.createDomLayer()), this.events = this.shell.events, this.events.addElement(new Bt(this)), this.events.addElement(new it(this)), this.events.addElement(new F(this, this.settings.credits))), window.setTimeout(function () {\n            return Jt.execute(n, !n.settings.parentChart);\n          }, 500), this.removed = !1, this.EVENT_NAMES = {};\n          var r;\n\n          for (r in t.events) {\n            if (0 === r.indexOf(\"on\")) {\n              var s = r.charAt(2).toLowerCase() + r.slice(3);\n              this.EVENT_NAMES[r] = s, this.EVENT_NAMES[s] = s;\n            }\n          }\n\n          this.eventListeners = {}, this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {\n            return n.notifyAssetsLoaded();\n          }), this.clearData(), this.events.addElement(new Vt(this)), this.title = this.events.addElement(new B(this)), this.events.addElement(new Dt(this));\n        }\n\n        return t.prototype.createDomLayer = function () {\n          return new r.DomLayer(this);\n        }, t.prototype.updateFilters = function (t) {\n          this.events.notifySceneChanges({\n            filters: !0\n          });\n        }, t.prototype.updateStyle = function (t) {\n          this.events.notifySceneChanges({\n            style: !0\n          });\n        }, t.prototype.defaultDoubleClick = function (t, e) {}, t.prototype.defaultTripleClick = function (t, e) {}, t.prototype.defaultClick = function (t, e) {}, t.prototype.defaultRightClick = function (t, e) {}, t.prototype.finalInitialize = function () {\n          var t = {\n            settings: !0,\n            settingsChanges: this.scene.settings,\n            data: {}\n          };\n          this.processChangedSettings(t), this.events.notifySceneChanges(t), this.updateSize(), this.updateEvents(null, this.settings.events);\n        }, t.prototype.getRootChart = function () {\n          var t = this.settings.parentChart;\n          return t ? t._impl.getRootChart() : this;\n        }, t.prototype.processChangedSettings = function (t) {}, t.prototype.updateSettings = function (t, e) {\n          var i = this;\n\n          if (void 0 === e && (e = null), !this.removed) {\n            var n = d.clone(this.settings.events),\n                r = this.settings.apply(t),\n                s = {\n              settings: !0,\n              settingsChanges: r\n            };\n            this.processChangedSettings(s), r.events && this.updateEvents(n, this.settings.events), r.advanced && r.advanced.assets && r.advanced.assets.length > 0 && (this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {\n              return i.notifyAssetsLoaded();\n            })), r.data && this.dataSettingsChanged(r.data), this.shell.updateSettings(r), this.onSettingsChanged(r), r.toolbar && this.assetsLoaded && this.createToolbar(), this.events.notifySceneChanges(s);\n            var a = r.area;\n\n            if (a && (a.width || a.height || a.maxWidth || a.minWidth || a.minHeight || a.maxHeight) && this.updateSize(!0), e) {\n              var o = this.createEventArguments(null, e);\n              o.changes = r, this.notifySettingsChanged(o);\n            }\n          }\n        }, t.prototype.getData = function (t) {\n          if (this.data[t]) return this.data[t];\n          var e = this.settings._computedDataMap[t];\n\n          if (e) {\n            var i = this.createDataObj(e);\n            return i.applyPreloadedData(), this.data[t] = i, i;\n          }\n\n          throw new Error(\"No data configured for source ID \" + t);\n        }, t.prototype.addData = function (t, e) {\n          this.removed || this.getData(e).addData(t);\n        }, t.prototype.reloadData = function (t, e) {\n          if (void 0 === t && (t = null), void 0 === e && (e = !1), !this.removed) {\n            this.log(\"Reload data\"), t ? this.data[t] && (this.data[t].remove(), delete this.data[t]) : this.clearData(), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n            var i = {};\n\n            for (var n in this.settings._computedDataMap) {\n              i[n] = !0;\n            }\n\n            this.events.notifySceneChanges({\n              data: i,\n              dataDeep: e\n            }), this.navigator && this.navigator.onNewDataObject();\n          }\n        }, t.prototype.replaceData = function (t, e) {\n          if (void 0 === e && (e = \"default\"), null == e && (e = \"default\"), !this.removed) {\n            this.events.clearSceneChanges({\n              dataArrived: null\n            }), this.data[e] && this.data[e].remove();\n            var i = this.data[e] = this.createDataObj(this.settings._computedDataMap[e]);\n            i.addData(t), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n            var n = {};\n            n[e] = !0, this.events.notifySceneChanges({\n              data: n\n            }), this.navigator && this.navigator.onNewDataObject();\n          }\n        }, t.prototype.clearData = function (t) {\n          void 0 === t && (t = !1);\n\n          for (var e in this.data) {\n            var i = this.data[e];\n            i.remove();\n          }\n\n          this.events.clearSceneChanges({\n            dataArrived: null\n          }), this.data = {}, this.scene.mainData = null, !t && this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));\n        }, t.prototype.dataSettingsChanged = function (t) {\n          for (var e in this.data) {\n            !t[e] && this.settings._computedDataMap[e] || (this.data[e].remove(), delete this.data[e]);\n          }\n\n          this.events.clearSceneChanges({\n            dataArrived: null\n          }), this.events.notifySceneChanges({\n            data: t,\n            dataDeep: !0\n          }), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id)), this.navigator && this.navigator.onNewDataObject();\n        }, t.prototype.hasPendingRequests = function () {\n          if (!this.assetsLoaded) return !0;\n          if (this.assetsLoader.hasPendingRequests()) return !0;\n\n          for (var t in this.data) {\n            if (this.data[t].hasPendingRequests()) return !0;\n          }\n\n          return !1;\n        }, t.prototype.remove = function () {\n          return this.removed ? void r.Helpers.warn(\"Removing already removed chart\") : (this.cancelChartUpdateNotify(), this.removed = !0, this.toolbar && this.toolbar.remove(), this.shell.remove(), this.clearData(!0), this.shell = null, this.scene = null, void (this.events = null));\n        }, t.prototype.setFullscreen = function (t) {\n          this.shell.setFullscreen(t);\n        }, t.prototype.isFullscreen = function () {\n          return this.shell.fullScreenMode;\n        }, t.prototype.updateSize = function (t) {\n          void 0 === t && (t = !1), this.removed || this.shell.updateSize(t);\n        }, t.prototype.on = function (t, e) {\n          var i = this.EVENT_NAMES[t];\n          return i ? (this.eventListeners[i] || (this.eventListeners[i] = []), void this.eventListeners[i].push(e)) : void this.error(\"Unrecognized event name: \" + t);\n        }, t.prototype.off = function (t, e) {\n          var i = this.EVENT_NAMES[t];\n          return i ? this.eventListeners[i] ? d.removeFromArray(this.eventListeners[i], e) : void 0 : void this.error(\"Unrecognized event name: \" + t);\n        }, t.prototype.updateEvents = function (t, e) {\n          var i = t,\n              n = e;\n\n          for (var r in this.EVENT_NAMES) {\n            var s = this.EVENT_NAMES[r];\n            t && i[r] && this.off(s, i[r]), n[r] && this.on(s, n[r]);\n          }\n        }, t.prototype.notifyHoverChanged = function (t, e) {\n          this.dispatchEvent(\"hoverChange\", t, e, null);\n        }, t.prototype.notifyDoubleClick = function (t, e) {\n          var i = this;\n          this.dispatchEvent(\"doubleClick\", t, e, function (t, e) {\n            return i.defaultDoubleClick(t, e);\n          });\n        }, t.prototype.notifyTripleClick = function (t, e) {\n          var i = this;\n          this.dispatchEvent(\"tripleClick\", t, e, function (t, e) {\n            return i.defaultTripleClick(t, e);\n          });\n        }, t.prototype.notifyRightClick = function (t, e) {\n          var i = this;\n          this.dispatchEvent(\"rightClick\", t, e, function (t, e) {\n            return i.defaultRightClick(t, e);\n          });\n        }, t.prototype.notifyClick = function (t, e) {\n          var i = this;\n          this.dispatchEvent(\"click\", t, e, function (t, e) {\n            return i.defaultClick(t, e);\n          });\n        }, t.prototype.notifySelectionChanged = function (t) {\n          return this.dispatchEventParams(\"selectionChange\", t, null);\n        }, t.prototype.notifySettingsChanged = function (t) {\n          return this.dispatchEventParams(\"settingsChange\", t, null);\n        }, t.prototype.notifyPositionChange = function (t) {\n          return this.dispatchEventParams(\"positionChange\", t, null);\n        }, t.prototype.notifyPointerDown = function (t, e) {\n          this.dispatchEvent(\"pointerDown\", t, e, null);\n        }, t.prototype.notifyPointerUp = function (t, e) {\n          this.dispatchEvent(\"pointerUp\", t, e, null);\n        }, t.prototype.notifyPointerDrag = function (t, e) {\n          this.dispatchEvent(\"pointerDrag\", t, e, null);\n        }, t.prototype.notifyPointerMove = function (t, e) {\n          this.dispatchEvent(\"pointerMove\", t, e, null);\n        }, t.prototype.notifyDataUpdated = function (t) {\n          return this.dispatchEventParams(\"dataUpdated\", t, null);\n        }, t.prototype.notifyChartUpdate = function (t, e) {\n          var i = this;\n          void 0 === e && (e = !1);\n          var n = d.performanceNow();\n          e && (this.chartUpdateForce = !0), t && (this.chartUpdateWasBack = this.goingBack, this.chartUpdateOrigin = t, this.chartUpdateTime = n), this.chartUpdateState = this.saveNavigation(), null === this.chartUpdateTimeout && (this.chartUpdateTimeout = setTimeout(function () {\n            return i.chartUpdateNotify();\n          }, this.chartUpdateTime + this.scene.settings.events.chartUpdateDelay - n));\n        }, t.prototype.cancelChartUpdateNotify = function () {\n          this.chartUpdateOrigin = null, this.chartUpdateTimeout && (clearTimeout(this.chartUpdateTimeout), this.chartUpdateTimeout = null);\n        }, t.prototype.chartUpdateNotify = function () {\n          this.chartUpdateTimeout = null;\n          var t = this.chartUpdateOrigin;\n\n          if (t) {\n            var e = this.chartUpdateState;\n            !e || this.curState && JSON.stringify(e) === JSON.stringify(this.curState) ? this.chartUpdateForce && (this.chartUpdateForce = !1, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t)) : (this.chartUpdateForce = !1, !this.chartUpdateWasBack && this.curState && (this.scene.pushBack(this.curState), this.events.notifySceneChanges({\n              requestPaint: !0\n            })), this.curState = e, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t));\n          }\n        }, t.prototype.doChartUpdateNotify = function (t) {\n          var e = this.createEventArguments(null, t);\n          this.dispatchEventParams(\"chartUpdate\", e, null);\n        }, t.prototype.back = function (t, e) {\n          if (void 0 === t && (t = !0), void 0 === e && (e = \"api\"), 0 === this.scene.backStack.length) return !1;\n          var i = this.scene.backStack.pop();\n          return this.goingBack = !0, this.restoreNavigation(i, t, e), this.goingBack = !1, !0;\n        }, t.prototype.goHome = function (t, e) {\n          if (void 0 === t && (t = !0), void 0 === e && (e = \"api\"), 0 === this.scene.backStack.length) return !1;\n          var i = this.scene.backStack[0];\n          return this.restoreNavigation(i, t, e), !0;\n        }, t.prototype.clearHistory = function () {\n          return this.scene.backStack = [], !0;\n        }, t.prototype.dispatchEventParams = function (t, e, i) {\n          var n = new x(0, 0, d.performanceNow(), \"api\");\n          return i || this.eventListeners[t] && this.eventListeners[t].length ? (this.dispatchEvent(t, n, e, i), n) : n;\n        }, t.prototype.dispatchEvent = function (t, e, i, n) {\n          if (n || this.eventListeners[t] && this.eventListeners[t].length > 0) {\n            for (var r = Object.keys(i), s = 0; s < r.length; s++) {\n              e[r[s]] = i[r[s]];\n            }\n\n            if (this.eventListeners[t]) for (var a = 0; a < this.eventListeners[t].length; a++) {\n              var o = this.eventListeners[t][a];\n              this.log(\"Call user event handler, \" + t, e, i), o.call(this.api, e, i);\n            }\n            !e.defaultPrevented && n && (this.log(\"Call default event handler, \" + t), n.call(this.api, e, i));\n          }\n        }, t.prototype.error = function (t, e) {\n          var i = this;\n          void 0 === e && (e = null);\n          var n = this.createEventArguments(null, \"api\");\n          n.message = t, n.arg = e, this.dispatchEventParams(\"error\", n, function (t, e) {\n            return i.defaultError(t, e);\n          });\n        }, t.prototype.log = function (t) {\n          for (var e = [], i = 1; i < arguments.length; i++) {\n            e[i - 1] = arguments[i];\n          }\n\n          this.settings.advanced.logging && d.log(t, e);\n        }, t.prototype.deprecated = function (t, e) {\n          var i = \"Deprecated: \" + t + \".\";\n          e && (i += \" Use \" + e + \" instead\"), r.Helpers.warn(i);\n        }, t.prototype.defaultError = function (t, e) {\n          e.arg ? d.error(e.message, e.arg) : d.error(e.message);\n        }, t.prototype.createToolbar = function () {\n          this.toolbar && this.toolbar.remove(), this.assetsLoaded && (this.toolbar = new $(this, this.settings.toolbar));\n        }, t.prototype.notifyAssetsLoaded = function () {\n          this.removed || (this.assetsLoaded = !0, this.createToolbar(), this.updateSize(!0), this.events.notifySceneChanges({\n            assets: !0,\n            style: !0\n          }));\n        }, t;\n      }();\n\n      r.Impl = Yt;\n      var qt;\n      !function (t) {\n        t[t.FacetChart = 1] = \"FacetChart\", t[t.GeoChart = 2] = \"GeoChart\", t[t.NetChart = 4] = \"NetChart\", t[t.PieChart = 8] = \"PieChart\", t[t.TimeChart = 16] = \"TimeChart\";\n      }(qt || (qt = {}));\n\n      var _t,\n          Xt = !1,\n          Qt = {},\n          Jt = function () {\n        function e() {}\n\n        return e.checkChartType = function (t, e) {\n          var i = e.lastIndexOf(\"-\", e.indexOf(\":\"));\n          if (i === -1 || i === e.indexOf(\"-\")) return !0;\n          var n,\n              r = 0;\n\n          for (i++; (n = e.charCodeAt(i)) > 47 && n < 58;) {\n            r = 10 * r + n - 48, i++;\n          }\n\n          var s = qt[t];\n          return s > 0 && (r & s) === s;\n        }, e.execute = function (e, i) {\n          var n = this,\n              s = window.ZoomChartsLicense,\n              a = window.ZoomChartsLicenseKey,\n              o = e.api.typeName,\n              l = s + d.SeparatorChar + o,\n              h = Qt[l];\n          if (h) return void (h.result ? this.handleServerResponse([e], h.result) : h.charts.push(e));\n          Qt[l] = h = {\n            charts: [e],\n            result: null\n          };\n          var u = \"ZoomCharts \" + t.PackageInfo.Version;\n          s && a ? Wt.verifySignature(s, a) ? Xt || (d.log(u + \" license verified: \" + s), Xt = !0) : d.error(u + (\" license key for license '\" + s + \"' is invalid. Please configure the correct key in order to use the charts.\")) : (d.error(u + \" license key was not found on the page. Please make sure ZoomChartsLicense and ZoomChartsLicenseKey variables are correctly set before initializing the chart.\"), s = a = \"---:\");\n          var c = \". Please upgrade your license on https://zoomcharts.com\",\n              p = s.charAt(2);\n          if (!this.checkChartType(o, s) && (d.error(\"ZoomCharts license used on this page does not allow use of \" + o + c), p = \"-\", !i)) return void this.displayBanner(e, \"builtin://logo-license-expired\");\n          var f = /(\\d\\d\\d\\d-\\d\\d-\\d\\d)$/,\n              g = \"builtin://logo-license-expired\",\n              v = g;\n\n          switch (p) {\n            case \"F\":\n            case \"O\":\n              var m = s.match(f),\n                  y = t.PackageInfo.Built,\n                  S = s.substring(0, s.indexOf(\":\")),\n                  b = [\"ZCF-f7zr14ipl-25\", \"ZCF-6sag05711-16\", \"ZCF-981cwt0sy-8\", \"ZCF-x33yuxzf8-1\", \"ZCF-8r2n87ra8-8\", \"ZCF-1flw35m2i-16\"];\n              return b.indexOf(S) >= 0 ? void (g = null) : void (m && m[1] < y ? (h.result = {\n                status: 2,\n                bannerImage: g,\n                consoleMessages: [{\n                  level: \"error\",\n                  text: \"ZoomCharts license is not valid for this library version which was released on \" + y + c\n                }]\n              }, this.handleServerResponse(h.charts, h.result)) : (h.result = {\n                status: 1\n              }, h.charts = []));\n\n            case \"B\":\n              var x = s.match(f),\n                  C = \"https://zoomcharts.com/en/renew-licence/\";\n              return void (x && x[1] < new Date().toISOString() ? (h.result = {\n                status: 2,\n                bannerImage: \"builtin://logo-license-expired\",\n                consoleMessages: [{\n                  level: \"error\",\n                  text: \"ZoomCharts license has expired on \" + x[1] + \". Please renew the license at \" + C\n                }],\n                bannerTarget: C\n              }, this.handleServerResponse(h.charts, h.result)) : (h.result = {\n                status: 1\n              }, h.charts = []));\n\n            case \"-\":\n            case \"S\":\n              g = \"builtin://logo-development\";\n              break;\n\n            case \"X\":\n              g = \"builtin://logo-supported-by\";\n              break;\n\n            default:\n            case \"P\":\n              g = null;\n          }\n\n          var w = JSON.stringify({\n            protocol: 1,\n            version: t.PackageInfo.Version,\n            revision: t.PackageInfo.Revision,\n            libraryName: t.PackageInfo.LibraryName,\n            assetsDomain: this.parseUriDomain(e.assetsLoader.getAssetUrl(\"assets://\")),\n            pageDomain: location.hostname,\n            chartType: o,\n            license: s.substring(0, s.indexOf(\":\")),\n            licenseKeyHash: Wt.hash(a)\n          }, null, \" \");\n          r.Helpers.doPostRequest(e.assetsLoader.getAssetUrl(\"https://api.zoomcharts-cloud.com/lc/v1/\"), 3e4, w, function (t) {\n            try {\n              var i = JSON.parse(t);\n              if (1 !== i.protocol) throw \"Server response contains invalid protocol.\";\n              var r = Qt[l];\n              r.result = i, n.handleServerResponse(r.charts, r.result);\n            } catch (t) {\n              n.handleServerError(e, \"Unable to parse licensing server response: \" + t), g && n.displayBanner(e, g), delete Qt[l];\n            }\n          }, function (t) {\n            t = t || \"\", delete Qt[l], n.handleServerError(e, \"Unable to contact licensing server: \" + t), (2153644038 === t.result || t instanceof DOMException && t.code === DOMException.SECURITY_ERR || \"SecurityError\" === t.name) && (g = v), g && n.displayBanner(e, g);\n          });\n        }, e.displayBanner = function (t, e, i) {\n          if (!t.removed) {\n            var n = new N();\n            i && (n.url = i), n.imageScaling = .5, n.image = e, n.enabled = !0, n.enabledOnExport = !0, n.location = \"inside\", t.events.addElement(new F(t, n)), t.events.notifySceneChanges({\n              settings: !0,\n              settingsChanges: {\n                credits: {\n                  enabled: n.enabled\n                }\n              }\n            });\n          }\n        }, e.handleServerError = function (t, e) {\n          t.error(e);\n        }, e.handleServerResponse = function (t, e) {\n          if (null !== e) {\n            if (e.consoleMessages) for (var i = 0; i < e.consoleMessages.length; i++) {\n              var n = e.consoleMessages[i];\n\n              switch (n.level) {\n                case \"error\":\n                  d.error(n.text);\n                  break;\n\n                case \"warn\":\n                  d.warn(n.text);\n                  break;\n\n                default:\n                case \"info\":\n                  d.log(n.text);\n              }\n            }\n\n            for (var i = 0; i < t.length; i++) {\n              var r = t[i];\n              if (!r.removed) if (1 === e.status) ;else if (2 === e.status) this.displayBanner(r, e.bannerImage, e.bannerTarget);else {\n                if (3 !== e.status) {\n                  d.warn(\"Licensing server returned unknown status code \" + e.status);\n                  break;\n                }\n\n                this.blockChart(r, '<a href=\"' + e.bannerTarget + '\"><img src=\"' + e.bannerImage + '\" title=\"Problem with the license\"/></a>');\n              }\n            }\n\n            t.length = 0;\n          }\n        }, e.parseUriDomain = function (t) {\n          var e = document.createElement(\"a\");\n          return e.href = t, e.hostname || (e.href = e.href), e.hostname;\n        }, e.blockChart = function (t, e) {\n          var i = t.settings.container;\n          t.remove(), i.innerHTML = \"<strong>Unable to use ZoomCharts library because of a licensing issue:</strong><br/>\" + e;\n        }, e;\n      }();\n\n      !function (t) {\n        t[t.inside = 0] = \"inside\", t[t.outside = 1] = \"outside\";\n      }(_t = r.InfoPopupPosition || (r.InfoPopupPosition = {}));\n\n      var Kt = function () {\n        function t(t) {\n          this.chart = t, this.container = t.shell.interactiveContainer, this.events = t.events, this.popup = null, this.visible = !1, this.x0 = null, this.x1 = null, this.y = null, this.contentsChanged = !1;\n        }\n\n        return t.prototype.hide = function () {\n          return !(!this.visible || !this.popup) && (this.visible = !1, this.popup.style.display = \"none\", !0);\n        }, t.prototype.remove = function () {\n          this.popup && this.popup.parentNode && (this.popup.parentNode.removeChild(this.popup), this.popup = null);\n        }, t.prototype.ensurePopup = function () {\n          this.popup || (this.popup = d.createDom(\"div\", \"DVSL-info-center\", null, this.container), d.createDom(\"em\", null, null, this.popup), this.popup.style.position = \"absolute\", this.popup.style.display = \"none\");\n        }, t.prototype.show = function (t, e, i, n, r) {\n          void 0 === r && (r = _t.inside), this.ensurePopup();\n          var s = this.popup;\n          n ? (n.indexOf(\"<\") === -1 && n.indexOf(\">\") === -1 && (n = \"<b>\" + n + \"</b>\"), this.visible = !0, s.style.display = \"block\", n !== s.innerHTML && (s.innerHTML = n, this.postProcessHtml(s), this.contentsChanged = !0), this.updateXY(t, e, i, r)) : s.style.display = \"none\";\n        }, t.prototype.postProcessHtml = function (t) {\n          if (t instanceof HTMLElement) {\n            var e = t.getAttribute(\"data-color\");\n            e && (t.style.color = e, null != t.getAttribute(\"data-selected\") && (t.style.borderColor = e));\n          }\n\n          for (var i = t.firstElementChild; i;) {\n            this.postProcessHtml(i), i = i.nextElementSibling;\n          }\n        }, t.prototype.updateContents = function (t) {\n          null === t ? this.hide() : this.show(this.x0, this.x1, this.y, t, this.position);\n        }, t.prototype.updateXY = function (t, e, i, n) {\n          if (void 0 === n && (n = _t.inside), this.visible && (this.contentsChanged || this.x0 !== t || this.x1 !== e || this.y !== i || this.position !== n)) {\n            this.ensurePopup(), this.contentsChanged && (this.contentsChanged = !1, this.popup.style.right = null, this.width = this.popup.offsetWidth, this.height = this.popup.offsetHeight), this.x0 = t, this.x1 = e, this.y = i, this.position = n;\n            var r,\n                s = 12,\n                a = 10,\n                o = null,\n                l = this.popup.style,\n                h = this.chart.scene;\n            if (t > h.x0 + h.width || e < h.x0) return void (l.top = \"-10000px\");\n            var u,\n                c,\n                d,\n                p,\n                f,\n                g,\n                v = this.chart.getRootChart().scene;\n            x = this.applySceneTransform(v, t, i, e), f = x.sceneChartWidth, g = x.sceneChartHeight, u = x.sceneX0, c = x.sceneWidth, d = x.sceneY0, p = x.sceneHeight, t = x.x0, i = x.y, e = x.x1;\n            var m = this.width,\n                y = this.height;\n\n            switch (n) {\n              default:\n              case _t.inside:\n                u <= t - m - a ? (o = t - m - a, r = \"DVSL-info-left\") : u + c >= e + m + a ? (o = e + a, r = \"DVSL-info-right\") : (o = (Math.max(t, u) + Math.min(e, u + c) - m) / 2, r = \"DVSL-info-center\"), i = Math.min(Math.max(d + s, i - y / 2), d + p - y), i = Math.max(this.chart.shell.getChartInnerArea().findTopPosition(o, o + m), i);\n                break;\n\n              case _t.outside:\n                r = \"DVSL-info-center\", o = Math.min(u + c - m, Math.max(0, (t + e - m) / 2));\n                var S = this.chart.shell.container.offsetTop;\n                i = S > y ? d - y : d + p;\n            }\n\n            var b = null;\n            m >= f ? (b = 0, o = 0) : o + m > f - 20 && (o + m > f ? (b = 0, o = null) : (b = f - o - m, o = null)), l.right = null !== b ? b + \"px\" : null, l.left = null !== o ? o + \"px\" : null, l.top = i + \"px\", this.popupClass !== r && (this.popupClass = r, this.popup.className = r);\n            var x;\n          }\n        }, t.prototype.applySceneTransform = function (t, e, i, n) {\n          var s = t.x0,\n              a = t.x0 + t.width,\n              o = t.y0,\n              l = t.y0 + t.height,\n              h = t.chartWidth,\n              u = t.chartHeight;\n\n          if (t.transform) {\n            var c = r.Geometry.transformVec2d(e, i, this.chart.scene.transform),\n                d = r.Geometry.transformVec2d(n, i + t.width, this.chart.scene.transform);\n            e = Math.min(c.x, d.x), n = Math.max(c.x, d.x), i = c.y, g = this.transformSceneBounds(s, o, a, l), s = g.sceneX0, o = g.sceneY0, a = g.sceneX1, l = g.sceneY1, v = this.transformXY(h, 0), h = v.x, u = v.y;\n          }\n\n          var p = a - s,\n              f = l - o;\n          return {\n            sceneChartWidth: h,\n            sceneChartHeight: u,\n            sceneX0: s,\n            sceneWidth: p,\n            sceneY0: o,\n            sceneHeight: f,\n            x0: e,\n            y: i,\n            x1: n\n          };\n          var g, v;\n        }, t.prototype.transformSceneBounds = function (t, e, i, n) {\n          return r = this.transformXY(t, e), t = r.x, e = r.y, s = this.transformXY(i, n), i = s.x, n = s.y, {\n            sceneX0: t,\n            sceneY0: e,\n            sceneX1: i,\n            sceneY1: n\n          };\n          var r, s;\n        }, t.prototype.transformXY = function (t, e) {\n          var i = r.Geometry.transformVec2d(t, e, this.chart.scene.transform);\n          return t = i.x, e = i.y, {\n            x: t,\n            y: e\n          };\n        }, t;\n      }();\n\n      r.InfoPopup = Kt;\n\n      var $t = function () {\n        function t(t, e, i) {\n          void 0 === i && (i = !1), this._direction = 1, this._endTime = 0, this._midTime = 0, this._startTime = 0, this._preventOvershoot = !1, this._setTargetPending = !1, this._settableTargetValue = 0, this._settableAcceleration = 0, this._acceleration = t, this._initialValue = this._targetValue = e, this._preventOvershoot = i;\n        }\n\n        return t.prototype.setTarget = function (t, e, i, n) {\n          if (null == e) return this._settableTargetValue = t, this._settableAcceleration = i, void (this._setTargetPending = !0);\n          this._settableAcceleration = null, this._setTargetPending = !1, null != i && this.setAcceleration(i, e);\n\n          var r = this._getDeltaT(e),\n              s = this._getDistanceToV0(r),\n              a = this._composeValue(e, s),\n              o = Math.abs(t - a),\n              l = t > a ? 1 : -1;\n\n          if (e < this._startTime && (this._direction *= -1), this._targetValue = t, e < this._endTime) {\n            if (s > o || this._direction !== l) {\n              if (this._preventOvershoot) {\n                if (this._direction === l) {\n                  var h = this._getCurrentVelocity(r);\n\n                  this._acceleration = h * h / (2 * o), this._startTime = e - h / this._acceleration, this._initialValue = a - o * this._direction;\n                } else this._startTime = e, this._initialValue = a;\n              } else this._startTime = e + r, this._initialValue = a + s * this._direction;\n            } else (e >= this._midTime || e <= this._startTime) && (this._startTime = e - r, this._initialValue = a - s * this._direction);\n          } else this._startTime = e, this._initialValue = a;\n          this._direction = this._targetValue > this._initialValue ? 1 : -1;\n          var u = Math.abs(this._targetValue - this._initialValue),\n              c = Math.sqrt(u / this._acceleration);\n          this._midTime = this._startTime + c, this._endTime = this._startTime + 2 * c, null != n && this._endTime - this._startTime > n && (this._endTime = this._startTime + n, this._midTime = (this._startTime + this._endTime) / 2, c = this._endTime - this._midTime, this._acceleration = u / (c * c));\n        }, t.prototype.getValue = function (t) {\n          return this._setTargetPending && this.setTarget(this._settableTargetValue, t, this._settableAcceleration), this.finished(t) ? this._targetValue : this._composeValue(t, this._getDistanceToV0(this._getDeltaT(t)));\n        }, t.prototype.getTargetValue = function () {\n          return this._targetValue;\n        }, t.prototype.finished = function (t) {\n          return !this._setTargetPending && t >= this._endTime;\n        }, t.prototype.jump = function (t, e, i) {\n          if (this._initialValue = this._targetValue = t, this._startTime = this._midTime = this._endTime = 0, null != e && null != i && 0 !== e) {\n            var n = e > 0 ? 1 : -1,\n                r = Math.abs(e / this._acceleration);\n            this._direction = n, this._midTime = i, this._endTime = i + r, this._targetValue = t + this._getDistanceToV0(r) * n;\n          }\n\n          return this._targetValue;\n        }, t.prototype.setAcceleration = function (t, e) {\n          if (t !== this._acceleration) {\n            var i = e < this._endTime;\n\n            if (i) {\n              var n = this._getDeltaT(e),\n                  r = this._getCurrentVelocity(n),\n                  s = this._composeValue(e, this._getDistanceToV0(n));\n\n              e < this._startTime && (r = -r), this._acceleration = t, this.jump(s, r * this._direction, e);\n            } else this._acceleration = t;\n          }\n        }, t.prototype._composeValue = function (t, e) {\n          return t < this._startTime ? this._initialValue + e * this._direction : t < this._midTime ? this._initialValue + e * this._direction : t < this._endTime ? this._targetValue - e * this._direction : this._targetValue;\n        }, t.prototype._getDistanceToV0 = function (t) {\n          return this._acceleration * t * t / 2;\n        }, t.prototype._getDeltaT = function (t) {\n          return t < this._startTime ? this._startTime - t : t < this._midTime ? t - this._startTime : t < this._endTime ? this._endTime - t : 0;\n        }, t.prototype._getCurrentVelocity = function (t) {\n          return t * this._acceleration;\n        }, t;\n      }();\n\n      r.Inertia = $t;\n\n      var te = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(r.ChartElement);\n\n      r.Navigator = te;\n\n      var ee = function () {\n        function t() {}\n\n        return t.prototype.customize = function (t) {\n          var e = this.constructor.themes;\n          if (!e.hasOwnProperty(t)) throw new Error(\"The chart does not contain a predefined theme named `\" + t + \"`.\");\n          return this.updateSettings(e[t]);\n        }, t.prototype.saveState = function () {\n          return this._impl.save();\n        }, t.prototype.restoreState = function (t, e) {\n          void 0 === e && (e = !1), null == e && (e = !1), this._impl.restore(t, e);\n        }, t.prototype.fullscreen = function (t) {\n          return t === !0 ? this._impl.setFullscreen(!0) : t === !1 && this._impl.setFullscreen(!1), this._impl.isFullscreen();\n        }, t.prototype.updateSettings = function (t) {\n          return t && this._impl.updateSettings(t, \"api\"), this;\n        }, t.prototype.replaceSettings = function (t) {\n          if (t) {\n            var e = i.Base.SettingsHelper;\n\n            try {\n              e.replacingSettings = !0, this._impl.updateSettings(t, \"api\");\n            } finally {\n              e.replacingSettings = !1;\n            }\n          }\n\n          return this;\n        }, t.prototype.updateFilters = function () {\n          this._impl.updateFilters(null);\n        }, t.prototype.updateStyle = function () {\n          this._impl.updateStyle(null);\n        }, t.prototype.on = function (t, e) {\n          this._impl.on(t, e);\n        }, t.prototype.off = function (t, e) {\n          return this._impl.off(t, e);\n        }, t.prototype.updateSize = function () {\n          return this._impl.updateSize(!0), this;\n        }, t.prototype.reloadData = function (t) {\n          return void 0 === t && (t = null), this._impl.reloadData(t);\n        }, t.prototype.remove = function () {\n          return this._impl.remove();\n        }, t.prototype.saveAsImage = function (t, e, i) {\n          return this._impl.deprecated(\"saveAsImage\", \"exportAsString\"), this.exportImageAsString(t, e, i);\n        }, t.prototype.exportGetDimensions = function (t) {\n          return this._impl.deprecated(\"exportGetDimensions\", \"exportImageGetDimensions\"), this.exportImageGetDimensions(t);\n        }, t.prototype.exportImageAsString = function (t, e, i) {\n          return this._impl.deprecated(\"exportImageAsString\", \"exportAsString\"), Gt.export(this._impl, t, e, i, function () {});\n        }, t.prototype.exportImageGetDimensions = function (t) {\n          return Gt.getDimensions(this._impl, t);\n        }, t.prototype.exportAsString = function (t, e, i, n) {\n          if (void 0 === n && (n = !1), !e) throw new Error(\"`callback` argument is mandatory.\");\n          Gt.export(this._impl, t, i, n, e);\n        }, t.prototype.export = function (t, e, i) {\n          void 0 === i && (i = !1), Gt.download(this._impl, t, e, i);\n        }, t.prototype.addSubchartContainer = function (t) {\n          this._impl.shell.interactiveContainer.appendChild(t);\n        }, t.prototype.suspendPaint = function () {\n          this._impl.events.suspendPaint();\n        }, t.prototype.resumePaint = function () {\n          this._impl.events.resumePaint();\n        }, t.prototype.paintNow = function (t) {\n          return void 0 === t && (t = !1), this._impl.events.paintNow(t), this;\n        }, t.prototype.back = function () {\n          return this._impl.back(), this;\n        }, t.prototype.home = function () {\n          return this._impl.goHome();\n        }, t.prototype.clearHistory = function () {\n          return this._impl.clearHistory(), this;\n        }, t.prototype.profiler = function () {\n          return this._impl.shell.profiler;\n        }, t.prototype.measureFps = function (t, e) {\n          this._impl.deprecated(\"measureFps\"), this.profiler().measureFps(t, e);\n        }, t;\n      }();\n\n      ee.themes = {}, r.Api = ee;\n\n      var ie = function () {\n        function t(t, e, i, n) {\n          void 0 === i && (i = 0), void 0 === n && (n = t.length), null == n && (n = t.length), null == i && (i = 0), this.n0 = i;\n          var r = [];\n          r.length = n - i;\n          var s = 0;\n          r[n - i - 1] = (e[n - 1] - e[n - 2]) / (t[n - 1] - t[n - 2]);\n          var a,\n              o = (e[i + 1] - e[i]) / (t[i + 1] - t[i]);\n\n          for (a = i + 1; a < n - 1; a++) {\n            var l = (e[a + 1] - e[a]) / (t[a + 1] - t[a]),\n                h = void 0;\n            if (0 === o) h = s = 0;else {\n              h = (o + l) / 2;\n              var u = (s * s + h * h) / (o * o);\n\n              if (u > 9) {\n                var c = 3 / Math.sqrt(u);\n                s = c * s, h = c * h;\n              }\n            }\n            r[a - i - 1] = s, s = h, o = l;\n          }\n\n          r[a - i - 1] = s, this.x = t, this.y = e, this.m = r;\n        }\n\n        return t.prototype.interpolate = function (t, e) {\n          var i = this.x[t + 1] - this.x[t],\n              n = (e - this.x[t]) / i,\n              r = n * n,\n              s = r * n,\n              a = 2 * s - 3 * r + 1,\n              o = s - 2 * r + n,\n              l = -2 * s + 3 * r,\n              h = s - r,\n              u = a * this.y[t] + o * i * this.m[t - this.n0] + l * this.y[t + 1] + h * i * this.m[t - this.n0 + 1];\n          return u;\n        }, t.prototype.interpolateArray = function (t, e, i, n, r) {\n          for (var s = this.x[t], a = this.y[t], o = this.m[t - this.n0], l = this.y[t + 1], h = this.m[t - this.n0 + 1], u = this.x[t + 1] - s, c = 1 / u, d = i; d < n; d++) {\n            var p = (e[d] - s) * c,\n                f = p * p,\n                g = f * p,\n                v = 2 * g - 3 * f + 1,\n                m = g - 2 * f + p,\n                y = -2 * g + 3 * f,\n                S = g - f,\n                b = v * a + m * u * o + y * l + S * u * h;\n            r.push(b);\n          }\n        }, t.prototype.clear = function () {\n          this.m.length = 0;\n        }, t;\n      }();\n\n      r.MonotoneCurve = ie;\n\n      var ne = function () {\n        function t() {\n          this.locations = [], this.values = [], this.labels = [];\n        }\n\n        return t.prototype.generatePoints = function (t, e, i, n, r, s, a, o, l, h, u, c, d) {\n          this.locations = [], this.values = [];\n          var p;\n\n          if (t.isScaleValid()) {\n            if (this.fontHeight = this.getFontHeight(u), g = this.ensureInsideCanvas(e, i, this.fontHeight, h), e = g.y0, i = g.y1, t.isLogScale ? this.generateLogScale(t, e, i, a) : p = this.generateLinearScale(t, p, o, e, i, this.fontHeight, a, l), c && (this.forceLocation(t, this.fontHeight, e), this.forceLocation(t, this.fontHeight, i)), n <= 0 && r >= 0) {\n              var f = d;\n              (2 === f || 1 === f && (n < 0 || !s && 0 === n)) && (this.locations.push(Math.floor(t.zeroY)), this.values.push(0));\n            }\n          } else p = this.generateDummyScale(p, i, e, o, a, t.isLogScale);\n\n          return p;\n          var g;\n        }, t.prototype.negateValues = function () {\n          for (var t = 0; t < this.values.length; t++) {\n            this.values[t] = -this.values[t];\n          }\n        }, t.prototype.calcLinearValuePerLine = function (t, e, i, n) {\n          if (n) return n;\n          var r = t.linearRelativeYToValue(e),\n              s = Math.log(r) / Math.log(10),\n              a = Math.pow(10, Math.floor(s - 1));\n\n          for (a = Math.max(a, i); a < r;) {\n            if (2 * a >= r) return 2 * a;\n            if (a > 10 && 2.5 * a >= r) return 2.5 * a;\n            if (5 * a >= r) return 5 * a;\n            a *= 10;\n          }\n\n          return a;\n        }, t.prototype.calcExpValuePerLine = function (t, e) {\n          var i = t.valueToRelativeY(10) - t.valueToRelativeY(1),\n              n = 10,\n              r = 10,\n              s = i;\n          if (s > 4 * e) return {\n            unit: 2,\n            valueMultiplier: 2\n          };\n\n          for (; s < e;) {\n            n *= 10, s += i;\n          }\n\n          return {\n            unit: r,\n            valueMultiplier: n\n          };\n        }, t.prototype.generateLogScale = function (t, e, i, n) {\n          for (var r = this.calcExpValuePerLine(t, n), s = r.unit, a = r.valueMultiplier, o = 1 / s;;) {\n            o *= a;\n            var l = t.valueToScreenY(o);\n            if (l <= e) break;\n            l >= i || (this.locations.push(Math.floor(l) - .5), this.values.push(o));\n          }\n\n          for (o = -1 / s;;) {\n            o *= a;\n            var l = t.valueToScreenY(o);\n            if (l >= i) break;\n            this.locations.push(Math.floor(l) - .5), this.values.push(o);\n          }\n        }, t.prototype.generateLinearScale = function (t, e, i, n, r, s, a, o) {\n          e = this.calcLinearValuePerLine(t, a, o, i);\n          var l = 0;\n          i && (e = Math.max(e, t.linearRelativeYToValue(s)));\n\n          for (var h = Math.pow(10, d.countDecimals(e));;) {\n            l = (l * h + e * h) / h;\n            var u = t.valueToScreenY(l);\n            if (u < n) break;\n            u >= r || (this.locations.push(Math.floor(u)), this.values.push(Math.round(1e6 * l) / 1e6));\n          }\n\n          for (l = 0;;) {\n            l = (l * h - e * h) / h;\n            var u = t.valueToScreenY(l);\n            if (u >= r) break;\n            this.locations.push(Math.floor(u)), this.values.push(Math.round(1e6 * l) / 1e6);\n          }\n\n          return e;\n        }, t.prototype.ensureInsideCanvas = function (t, e, i, n) {\n          return 0 === t && (t += i / 2), n < i && (e -= i / 2), {\n            y0: t,\n            y1: e\n          };\n        }, t.prototype.getFontHeight = function (t) {\n          return this.fontHeight || (this.fontHeight = 1.4 * r.Graphics.getTextHeightWithoutContext(t) || 0), this.fontHeight;\n        }, t.prototype.generateDummyScale = function (t, e, i, n, r, s) {\n          t = n ? n : 100;\n          var a = r,\n              o = e - a,\n              l = 1;\n\n          for (s || (l = t); o > i;) {\n            this.locations.push(o), this.values.push(l), s ? l *= 10 : l += t, o -= a;\n          }\n\n          return t;\n        }, t.prototype.forceLocation = function (t, e, i) {\n          for (var n = Number.POSITIVE_INFINITY, r = -1, s = 0; s < this.locations.length; s++) {\n            var a = Math.abs(i - this.locations[s]);\n            a < n && (n = a, r = s);\n          }\n\n          var o = t.relativeYToValue(t.zeroY - i);\n          r !== -1 && n < e ? (this.locations[r] = i, this.values[r] = o) : (this.locations.push(i), this.values.push(o));\n        }, t.prototype.generateLabels = function (t, e, i, n, s, a, o, l, h) {\n          var u, c, d;\n\n          if (!t.isLogScale && !h) {\n            var p = r.Helpers.valueUnitAndName(e, i);\n            u = p.unit, c = p.digitsAfterComma, d = p.name;\n          }\n\n          for (var f = 0; f < this.values.length; f++) {\n            var g = this.values[f];\n\n            if (t.isLogScale || h) {\n              var p = r.Helpers.valueUnitAndName(g, i);\n              u = p.unit, c = p.digitsAfterComma, d = p.name;\n            }\n\n            var v = (g / u).toFixed(c);\n\n            if (g && (v = v + \" \" + d), n && (v = n(g, d, u, v)), !n && s) {\n              var m = r.Helpers.matchPercentFormat(s),\n                  y = r.Helpers.matchCurrencyFormat(s);\n\n              if (m) {\n                var p = r.Helpers.valueUnitAndName(100 * g, i);\n                u = p.unit, d = p.name, v = r.Helpers.printPercentValue(g / u, m, d);\n              } else {\n                var p = r.Helpers.valueUnitAndName(g, i);\n                u = p.unit, d = p.name, v = r.Helpers.printCurrencyValue(g / u, y, d);\n              }\n            }\n\n            var S = new r.Label(a);\n            S.text = v.toString(), l || (S.style.align = o ? \"left\" : \"right\"), this.labels[f] = S;\n          }\n        }, t.prototype.paintLabels = function (t, e, i, n, s, a, o, l, h, u, c) {\n          if (i.assetsLoaded) {\n            var d = s.left,\n                p = s.right;\n            u && (d = n.y0, p = d + n.height), u || (L = this.paintAxisTitle(a, n, l, p, d, e, t), p = L.x1, d = L.x0);\n            var f,\n                g = (d + p) / 2;\n\n            if (f = l ? d + c : p - 4 - c, !h) {\n              t.beginPath();\n\n              for (var v = 0; v < this.locations.length; v++) {\n                var m = this.locations[v];\n                u || (t.moveTo(f, m), t.lineTo(f + 4, m));\n              }\n\n              r.Graphics.stroke(t, o);\n            }\n\n            for (var y = 0; y < this.locations.length; y++) {\n              var S = this.locations[y],\n                  b = this.labels[y],\n                  x = void 0;\n              e.measure(t, b);\n              var C = u ? b.hheight : b.hwidth;\n\n              if (x = h ? g : l ? f + C + 7 : f - C - 3, u) {\n                x = Math.min(x, n.chartTop + n.chartHeight - b.hheight), x = Math.max(x, n.chartTop + b.hheight);\n                var w = x;\n                x = S, S = w;\n              } else x = Math.min(x, n.chartLeft + n.chartWidth - b.hwidth), x = Math.max(x, n.chartLeft + b.hwidth);\n\n              e.paint(t, x, S, 1, b);\n            }\n\n            var L;\n          }\n        }, t.prototype.paintAxisTitle = function (t, e, i, n, r, s, a) {\n          if (t.text && t) {\n            var o = e.y0,\n                l = e.height,\n                h = t.hheight,\n                u = t.style.margin || 0,\n                c = o + .5 * l,\n                d = void 0;\n            i ? (d = n - u - h, n -= h + 2 * u) : (d = r + u + h, r += h + 2 * u), s.paint(a, d, c, 1, t);\n          }\n\n          return {\n            x1: n,\n            x0: r\n          };\n        }, t.prototype.paintGrid = function (t, e, i, n, s) {\n          var a = i.y0;\n          a + i.height;\n          a += 1;\n          var o = this.locations,\n              l = e.lineColor;\n          e.lineWidth = 1;\n          var h;\n          h = this.beginDraw(t, s, e, !0);\n          var u, c;\n          n ? (u = i.y0, c = u + i.height) : (u = i.x0, c = i.x0 + i.width);\n\n          for (var d = 0; d < o.length; d++) {\n            var p = o[d];\n            d < this.values.length && 0 === this.values[d] || this.drawLineWithSwap(h, s, u, p + .5, c, p + .5, e, n);\n          }\n\n          this.endDraw(t, s, h, e);\n          var f = r.Colors.colorTone(l, .5, .5);\n\n          if (f.opacity < .3) {\n            e.lineColor = f.color, h = this.beginDraw(t, s, e, !1);\n\n            for (var d = 0; d < o.length; d++) {\n              var p = o[d];\n              d < this.values.length && 0 === this.values[d] || this.drawLineWithSwap(h, s, u, p - .5, c, p - .5, e, n);\n            }\n\n            this.endDraw(t, s, h, e), e.lineColor = l;\n          }\n        }, t.prototype.beginDraw = function (t, e, i, n) {\n          if (void 0 === e) return n && r.Graphics.clearShadow(t), r.Graphics.beginStrokeAndFill(t, i);\n        }, t.prototype.drawLineWithSwap = function (t, e, i, n, r, s, a, o) {\n          o ? this.drawLine(t, e, n, i, s, r, a) : this.drawLine(t, e, i, n, r, s, a);\n        }, t.prototype.drawArrowWithSwap = function (t, e, i, n, r, s, a, o, l) {\n          l ? this.drawArrow(t, e, n, i, a, o, !1) : this.drawArrow(t, e, r, s, a, o, !0);\n        }, t.prototype.drawArrow = function (t, e, i, n, r, s, a) {\n          var o = i,\n              l = n,\n              h = a ? i - 2 * r : i - r,\n              u = a ? n - r : n + 2 * r,\n              c = a ? i - 2 * r : i + r,\n              d = a ? n + r : n + 2 * r;\n\n          if (e) {\n            var p = [];\n            p.push(o, l), p.push(h, u), p.push(c, d), e.addAuraMesh(p, s.lineColor);\n          } else t.moveTo(o, l), t.lineTo(h, u), t.lineTo(c, d), t.lineTo(o, l);\n        }, t.prototype.drawLine = function (t, e, i, n, r, s, a) {\n          e ? e.addImmediateLine(i, n, r, s, a.lineWidth, a.lineColor) : (t.moveTo(i, n), t.lineTo(r, s));\n        }, t.prototype.endDraw = function (t, e, i, n) {\n          void 0 === e && r.Graphics.endStrokeAndFill(t, i, n);\n        }, t.prototype.paintZeroLine = function (t, e, i, n, r, s) {\n          var a = i,\n              o = n.x0,\n              l = o + n.width;\n          s && (o = n.y0, l = o + n.height);\n          var h = Math.round(e.zeroY) - .5 * (a.lineWidth || 1),\n              u = this.determineContext(t),\n              c = u.context2D,\n              d = u.contextGL,\n              p = this.beginDraw(c, d, a, !1);\n          this.drawLineWithSwap(p, d, o, h, l, h, a, s), r > 0 && this.drawArrowWithSwap(p, d, o, h, l, h, r, a, s), this.endDraw(c, d, p, a);\n        }, t.prototype.determineContext = function (t) {\n          var e = t,\n              i = t;\n          return t instanceof CanvasRenderingContext2D ? i = void 0 : e = void 0, {\n            context2D: e,\n            contextGL: i\n          };\n        }, t;\n      }();\n\n      r.ValueAxisPoints = ne;\n\n      var re = function () {\n        function t(t) {\n          this.updateScale(t), this.logOffset = 1, this._zeroY = 0, this.scale = 0;\n        }\n\n        return Object.defineProperty(t.prototype, \"zeroY\", {\n          get: function get() {\n            return this._zeroY;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"isLogScale\", {\n          get: function get() {\n            return this._isLogScale;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.getRawScale = function () {\n          return this.scale;\n        }, t.prototype.resetToDefaultScale = function (t) {\n          this.scale = 0, this._zeroY = t;\n        }, t.prototype.forceZeroY = function (t) {\n          var e = t - this._zeroY;\n          return this._zeroY += e, e;\n        }, t.prototype.isScaleValid = function () {\n          return this.scale > 0;\n        }, t.prototype.updateScale = function (t) {\n          this._isLogScale = t;\n        }, t.prototype.updateRange = function (t, e, i, n) {\n          var r = this.computeAndUpdateRange(t, e);\n          this.scale = n / r;\n          var s = this.valueToRelativeY(t);\n          this._zeroY = i + n + s;\n        }, t.prototype.computeAndUpdateRange = function (t, e) {\n          return this.isLogScale ? this.computeAndUpdateLogRange(t, e) : e - t;\n        }, t.prototype.computeAndUpdateLogRange = function (t, e) {\n          return t <= 0 && e >= 0 ? this.computeAndUpdateLogRangeTouchingZero(t, e) : t < 0 ? this.computeAndUpdatePositiveLogRange(t) : e > 0 ? this.computeAndUpdateNegativeLogRange(e) : null;\n        }, t.prototype.computeAndUpdateNegativeLogRange = function (t) {\n          return this.logOffset = 1 + t, Math.log(t + this.logOffset);\n        }, t.prototype.computeAndUpdatePositiveLogRange = function (t) {\n          return this.logOffset = 1 - t, Math.log(-t + this.logOffset);\n        }, t.prototype.computeAndUpdateLogRangeTouchingZero = function (t, e) {\n          return this.logOffset = 1, Math.log(e + this.logOffset) + Math.log(-t + this.logOffset);\n        }, t.prototype.valueToScreenYInRange = function (t, e, i) {\n          return r.Helpers.isNull(t) ? t : Math.floor(r.Helpers.clamp(this.valueToScreenY(t), e, i));\n        }, t.prototype.valueToScreenY = function (t) {\n          return Math.round(this.zeroY - this.valueToRelativeY(t));\n        }, t.prototype.linearValueToRelativeY = function (t) {\n          return this.scale * t;\n        }, t.prototype.linearRelativeYToValue = function (t) {\n          return t / this.scale;\n        }, t.prototype.valueToRelativeY = function (t) {\n          return 0 === this.scale ? 0 : this._isLogScale ? t > 0 ? this.scale * Math.log(t + this.logOffset) : t < 0 ? -this.scale * Math.log(-t + this.logOffset) : 0 : this.scale * t;\n        }, t.prototype.relativeYToValue = function (t) {\n          return 0 === this.scale ? t >= 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : this._isLogScale ? t > 0 ? Math.exp(t / this.scale) - this.logOffset : t < 0 ? -(Math.exp(-t / this.scale) - this.logOffset) : 0 : t / this.scale;\n        }, t.prototype.absLog = function (t) {\n          return t > 0 ? Math.log(t + this.logOffset) : -Math.log(-t + this.logOffset);\n        }, t.prototype.absExp = function (t) {\n          return t > 0 ? Math.exp(t) - this.logOffset : -(Math.exp(-t) - this.logOffset);\n        }, t;\n      }();\n\n      r.ValueAxisScale = re;\n\n      var se = function () {\n        function t() {}\n\n        return t.generatePanel = function (t, e, i, n, s) {\n          var a = new r.ChartPanel();\n          return a.packingOrder = 110, a.computeSize = function (a, o, l, h) {\n            if (!t.assetsLoaded) return {\n              width: 0,\n              height: 0\n            };\n            var u = 8;\n            if (e && (e.style.maxWidth = o), i) u = i;else {\n              var c = n,\n                  d = \"9999 M\";\n              s ? d = s(1e7 - 1 - 2e-4, \"M\", 1e3, d) || d : u++, u += 2 * c.margin + r.Graphics.getTextWidth(l, c.textStyle, d), e && e.text && (h.measure(l, e), u += 2 * (e.style.margin + e.hheight));\n            }\n            return {\n              width: Math.ceil(u),\n              height: o\n            };\n          }, a;\n        }, t;\n      }();\n\n      r.ValueAxisUtils = se, function (t) {\n        var e = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.onSceneChange = function (e) {\n            t.prototype.onSceneChange.call(this, e);\n            var i = this.chart.zoomOutPossible(),\n                n = this.options;\n            n.enabled !== i && (n.enabled = i, this.updateSettings());\n          }, e;\n        }(t.Button);\n\n        t.ToolbarItemNames.zoomOut = function (t, i) {\n          var n = t.settings.localization.toolbar;\n          i.label = i.label || n.zoomoutButton, i.title = i.title || n.zoomoutTitle, i.cssClass = i.cssClass || \"DVSL-bar-btn-zoomout\";\n          var r = i.onClick;\n          return i.onClick = function (e, i) {\n            t.zoomOut(!0, \"user\"), r && r(e, i);\n          }, new e(t, i);\n        };\n      }(o = r.Bar || (r.Bar = {}));\n    }(d = i.Base || (i.Base = {})), function (t) {\n      t.LicenseBannerBlank = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAxpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxQkU1RjhGREExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxQkU1RjhGQ0ExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjAzYTBmMDNkLTNiNTktNDRkNi05ZjhlLWZkMGI3MTQ3ZDk1YiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3YzdiOTZjNi0yYzYyLWM3NGEtOTEzYi00YTgzZTg1YmViODAiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5mb3ItY2hhcnRzLXpvb21jaGFydHMtYmxhbms8L3JkZjpsaT4gPC9yZGY6QWx0PiA8L2RjOnRpdGxlPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PtHwutkAABHoSURBVHja7J0J2ExlG8dvS1p9VCpF2SoqUlEptJK0UJKQ9oVEKNKVtIhLtIu0Ry6ilZK0XVEpok1RqGhBSUmS3fP59Xzne888c2bmnHlnmDH3/7qO18yc9Vnu577/93JKGJFFIlJOFApFoWNliS0CYcOW/5TWtlAoCh4bS275529tB4VCgSwoqW2gUCg8qEBQKBQqEBQKhQoEhUKhAkGhUKhAUCgUKhAUCoUKBIVCoQJBoVCoQFAoFCoQFApF9qBJTYr0sMMOIrvtJmKM/VyihMhff4ls2qRtoxqCouBw2mki33xTtH39tcjhh2u7qIawHWPXXUX23FOkbFm7+q1YIfK3Jof+C7SDvfeO/W6nnQpsOS1pNSO0JP5u3lykMalA2E7AKnfyySLNm4scdpjIf/5j1eMNG0T++Udk9myRN94Qeftt+/9CBe3hopDMhbp1RYYP3zKDtkyhjRtFypQRueMOkVdfVYGw3XRw794ibdtaae9i552tcKhY0arLrATPPy8ycKDI559r+xUa0ByPOy72u/33Vw5hu0DHjiIffCDSrl2wMAgC+7VpIzJtmkjnztqGqiGJrFunAiHvcf/9Io88Ym3iRB2/apXImjXBv++yi8iwYSJDh+okUeQ9CttkGDBApHv34N8wB95/X+STT0T++MMSZtWrizRsKHLGGSK1asXuf+21IqtXW7NDochXbLGEVxhrERfW1qqVCcTo0cbUrp382F13NaZ7d2NWr44//pJLCrf9jjmmcMZP48bxz3/FFfn+XCsK02QoV07k4Yfjv7/1VpELLxT56qvkx6MJPPCAyIkniixaFG+C7L578uPxWoTlKoKw44652a6JzKp8R1Bf/fln/HeYlmoypECDBiLnniuydm3658BOf/NNkbfeysw9odbvs0/sd7fdJnLnndHOM2uW9ThMny6yxx72O4TB9deL9O1rPRK4LhEchxxiWWieBRcVLjoEyy+/iEyZYt1VCxYUnbtUKZFq1USOPVakfn2RmjVF9trLejs8NyixEQQETZggMnWqyMqV0e5/v/3svZ1yisjBB1sehXtbv966WH/6SeTLL63pRPDR8uVJVE1jBVXlyiJNmth+P/BAK3z5nuflfjnf669bt21YEo625fkbNRI59FDbLsSIcF6uy70uXizy0Uci77yTntcHr0GVKtbbVLu2SNWqtv9obwjnsWNFzj7btg0bz+aiQweRgw6ybegBU/PHHy1PFeSWrVfPmqD0M3EdXM9zcc+bZ6/N+Fi4MPa4ffe17Yzbk/ZkHOWFydC7t8kIhgxJfa3SpY1p2tSYm24yZvhwY15+2ZhJk4x55RVjnnzSmBtvNOaCC4xZvDj23FOmFO8Z27WLPd+yZcY8/bQxS5eGf7716+0znniiMddea8x770Vrn3nzjGnbNtz97r67MYMHG7N8efjzL1pkTJcuiU2GzZuNmTXLmBUrwp1vxgxjmjdPfa+YYN99F60t6Pcw5kvFisZcfbUxTzxhny8RJk82pk+f9MfuTz8ZU6ZM7LUrVTJmzJhwx69bZ8yoUcbUrWuPPfpoO6YZL/37GzNunDFHHpkRkyH7AgFbOxMYNCjxNapVs78zKdJBgwbFf86pU01OIJXgZODMmZPeuT//PDUHExXduiW/3wkT0jsvAtYvwPxbhQp2Mi5ZEu5cY8ca07Nn+s84d26sQNhnH2O++Sb6efr1M6ZECWPuvtv284gRxvTta0zHjsbce2+80MlJDgEVORMIsptRGwcNshGDN95o1d6oQNVG5S8ucD3mArp2tVxIEFBzUS9Ru9NBptRSP+BiiP9IhKhmkJ+neeghkYsuiv8N84NronaHAWq83wyICsapB8KdR4+29xAVv/9uw+gxjz77TKR9e5EWLURGjLAh9TVq5AGHMGeOtYPCEC7YTdiHRx0V/xv2px9HH23tsqB9o+DddzPznDNmWFKNweM+0/z51o6EI6BTsUHZDzv1iCOsHZkM2JJsCD4GA53PAGVQNW4cHzHnhdAyaPwDcdy4eO4EfPGFFRTY99yfZ1MzwI45xtrV8B/Y1GHw/ff2eXnu336zNjF8BefBVnZBDAf8UBBHgQ1O3/PstDGE7w8/2LwScgeYIIyZk04SadlSpEKF2OMfe8wGj3FPHhKFWNN/kMS0MX3188/22nAS8D1cD94DPgyh2qVL7PG073vvxS5e9NPSpTa8GbRuLXLqqfHXnjjRhsTDFTA+ECIIcPqWMe5xGoynSpXseR980ArMCy6w7UBbb3duxyDVe+FCa+95+5x2mjGrViVXrxYsMObFF4159FHLJ6D2zZ4dv19YuzvVtuOOxnz5Zey5N2ywqnUYDmLt2vh7g/do1syYUqWSHz9gQPyxcBj+fTp3jt/nr7+MueiicJxDjx5WZfXU0iCTgWuefbZ1yyY611lnBZt2qORB+8MF1KoVrg+qVAkeP3AE/v0wEV0MHVpko4fZ6tSJP0ebNqmPg9Ny+YEOHZIfU7asNa1atrSfGbPwXqeeasz551sTsEWLPOEQomx0nAvIquOOK9qnSRNjNm0KFgKQedhW9erZQeyef7fdjDnkEEvE/PCDPYYGzdT9T5sWez9r1hhTvXq4Y7knFwi+sNeePj2eBGQg8dsOO8TzBhs3Rju/t3nCKUggVK0a7hzEeTAR/Jg5MzN9sMce8dwA46J8+eQCIWpbpBOHQNu5wnDixPSek3nAQsDWqFHG4hByRyB06hQ8ySFMvH0YcCtXBu+HMKlcOfz1GCDDhmVOQ6CzP/009p5Y9Y84Itzx++4bH+j0wAPhrx+kARx+uP2tYcP433j2TAcm1a8f/ng0Nj/++Se8QEm1DRwYf2+spskEQvv22RcILEjeQuQB7VUDkxxgIw0ZEv/9c8+JPPpo0ecnn7QZh67/m+SkK6+0Nl9YEFhCuPH48Zl5BmIEsPPSBXYmtqsfbr2BZHD91KB8efuXWAMXL7yQ+X4sGWE4ETPgEnfEamQCxGW4IOw8FwK34Af8gBQkZqNgApNSgQnO4IQV9gOC6+KLiz5fcYUNoHEBSfPSS+lfvzgBU35QRyFVhGLUSL8ozLZHWgVNUJe0XLJE5NNPt22/IwBdhCUtITyZ4BCVkGkE5zDRaD8IR353EUSmbm1AZhLg5Q9q4hkI/Bo1yi54EKdBfVkwAgFPASyx23BEfXmRbHT4LbfEH9uvX/GEQSZxySXFX13dFTbKihu0L6w4cPP0mYzpuvMyBdjyIFdhIpBMdtZZdkWF4UcQBAlMxkzQhCqO2zDT453niJmFW8b3ZZfZBZDIU6IiP/wwcx6wvBEIN90U7IOmcfzViBgErjqOK4lw41wArjR8wplGcctxeRPDTe3e1sIgkevPE2CuBnnXXSKXXx4uh4N9gvbLldJmr70mMniwjZtxQbg6YdP9+9vPM2dadyzuxWXLtsrtbTsOAf821YZcPPWUVZ/8oBCJi9tvz40OZvA9/rjkJLwJ5q68rh27LRAmuYu8CFbJa67J3YSudEAuDRpvqpJzxNrcfLPIxx/bfKDtVkOALAsitbBrIQj9YHVzuQMCRUiO2dYgcefFF0Xq1BFFhoFmQKJSUPQpATiMFdRqyFSC3jAJICYxJeBMMOGKk1GabVCLA/KTkn0EFsGJJDIRSbrCND7vvKybyNtGIIwcGW/XYlOidrv2H9FtbvQZmY/ZAvcVprry8cdbVY5MxFwFKmiQRpAPqy1agSsM6BfU6aeftv9PBAhETNFcf06iLtEU4MIYT5jGjCeiT4PwzDO2YA/E6XZjMvTpI3L66fHfI9EJzw0ik1xJDxObLRAOTKNjznjCiHwMVh5CRs8/32oFcBiuMIAQygV1/P/i/n/y3g379lK1cxX096WXxn6HFtC0qch99yUXBsANH891MGZIcSZt/oQTrHAg38EF4cxB3EPeagjUDvAIEz9YaRP5xV0XEnHxWZSQ/0ptViYITzYSeiB0WG28egZBoNAqWgXaT66B9vL7urHNMdu2ElGVlpaGO84PJgiCOqxmlM/vRyBGg42kOxK0/CBng/yOTLnLt5lAILOM5A8X2IGJ6hoC9+UfSNMolWmYyFRBwiZFmEDkuI2J7QYB9+yz1j4lwIlJA/CNJ/OPE+CEZEeNxTuSi3YrbDV2ql/IQuqSUJOL4P5cNyFJcmGBMChdOr6PM63FZBskfSHIGb8e8LYxl4IC0fJKIDBhvMg5v01IvEEqdcqV/lF8yggU3DxBwSoumCBk3IUZPPi78YbcfbfN6gOJKjdvS9UbBPmz8XnnqkDALYrw9i8GUSIN6QdXIGS6RHqQizQb5iLEql8gYA5lkRvZOhzCPfeINGsWr/rjSkkl6dyahQwSV51MtVqEef3at9/a6soQUngPPBD9RiAPGxwHfmQIL/zFV11VJAwSDZJcAIw8WoIfcCHpBFN5RGU2QZ+7kYznnJM8cMmPoBoIQfxUcYCW6gqZMKHmaKr++gip4BKMaKQuJ5RXAqFVK5Ebboj/nqIOFCehERNtTEy8D66/NupLRcNMVCYM+6FK+zuM2gJHHmnzLbxoOaLNECD5BIq/BvVBz56pSThyDAgOophJya2whtAPbj4C0ayTJqV28V53nUiPHvEaByttJkF9BZfc7NQpuOgKmpq3qlP/AjO5WzfrTkwGTFFXaGM6ZaNQzVYzGRK91QiCEe0gmfqDFoF54NprxCWgdWQSY8bYv64mQ7zDr79K3gN+BI4Dpt4PTB4GMiz33Ll28jDpMbGIuUf44nlhZYPUC3pjUTZABSomtl/1p6goZBtFSPA0eYVHEOAQwSRxBQkMAsfQ/jKtIXAPFGXxQHsRRARBTtEZxi0rPF4dLxQfjZM2RbjicqTNaVcKynBO2p5CrRwXlPQEaZ1FTTT7AiFRokYq6ZgMvIwVm9JfBac4oLIQ9jQrpT8qEtU1CpmV62BQopW5L5mhMlKY8lvJqi5nGnhGWEXd0nRMfl7EyxYGTLio1bTDgvJ9foEAIKNdkhzB5fELfrMHlzZuRrYwYHEikjeLyL7+lw33DzxCJv2xpEF72gxpzB4QElHcO646zeoWhY127fMo9nrQddzvcDOiIaQb5ennbsJcL+r9uu3HuzMI8013RSRjFhPPtbmLe+8e0FbCvKnLnztCKbZ0Fy0C97LMU2VfIIQlgqKCEGdX/U0H1FGgY1HTiBjz27G87rs4hBufoww013yK0nZBtn3Qd7hUaTeEYJTX2WP3+nNPgoRVlGcNuregc+Ih4vV5TzwRnCEZBALEevWy9QiDSOuw1w4D7o8UfN7RkUz4eQsjcS4QutRPDGuaYNYRf5CJmomp5PS/ZZNEymftCqj3+E6LY3syEChM6fIRFBQhbj2ZjY/tS+6Dm2LNOalQjArGSo5Q8EcekpuOsIgCbG0GIcKEQcAzU7w0VWSdN2jOPNNqKJ7LjUKfqPhhAJnFCz9QTb2XpqDhJGsb1G/IUlRWiEN4A45DK4LNxq5llWWwY575+/CAA6xgwS72Urcp7OoVaU0Foj7hgjwhwvEU401G1nJNMktpY1Rz6k8wkbHLMWeoNUBtAez3ZLEqqOqYHFwTwhrBG/QylKhaK/dFH9CWBLAxxhh7EKS0oast8xIfSGyIRp4HEp17QqNgbBMNS5vwwpytgz/z692Obs1CMH++rZOYrFQaxU79tQRHjjSmZs2i3ylY6QcvMPHX4NNNt8LYVuSXQDj00NjJ7eHnn4sq0ga9mJUXWvCmm65djalRo+g3ire6dRBB69Y6OHRTgZAXG+WmE2H8eFtMk1e6pSqhTYnzIPTqpQNDt4IVCNnnELIBSBnyIhKRWF69BEgz7DEelXBWSm/BaVB4Iij8GVIxV6owKRRbH3/mp0AApIgSMZiJ4iQIDQhLLzhJoShQgVAyb28dNxiuGHzVxYl1eOUVy7KrMFAoJH81BD9INCIsN+wLPHFRTZ5s3/mAW0ehUOS5yRAE/LjEszdqZItskCBFODK+coQA/lwy/6hkuz3kJygUKhAUCoVyCAqFIutQgaBQKFQgKBQKFQgKhUIFgkKhUIGgUChUICgUChUICoVCBYJCoVCBoFAoVCAoFIrsgVwGKmeW1qZQKAoeGxEEi7ds5bQtFIqCx8r/CjAAVYxYofEJKfkAAAAASUVORK5CYII=\", t.LicenseBannerExpired = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxRTNGMzgyRkExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxRTNGMzgyRUExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjNhMzUwODIzLTljMDYtNGFhOS1iOGEzLTNkOTE4ZGY3MzQ5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiZjFjMDMxMi02MTMwLWE4NDgtYWM1Zi1iMTljOTliOGVjMDIiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4BTPUAAAAjtklEQVR42uxdB5wURb7+JmxO7LLAElUUAyoSRJBwBkBQQRQRhTOhGJ4YTj15BvBUDlH0DlEBlVMQFT3E9O4ZT1Gf+QyYs+SFBZbNeXemXn1d3Ts9PT2zM7uzsCv9/X7NLD3d1VXVVf/w/f9V4xLARgBZcODAwb6OUpcUCPXyD6/TFw4c7PNocMt/Kpx+cODAAWWB2+kDBw4cGHAEggMHDhyB4MCBA0cgOHDgwBEIDhw4cASCAwcOHIHgwIEDRyA4cOCghXAyFB00D0lJQOfOQG0t4HJJ1SJ1S2EhUF/v9I0jEBzsczjxROCJJ4DqaiUQPB7g5JOBL790+sYRCL9T5OQAHTsCCQlAQwNQVKS0oAMgM1P1jRkpKfuYw+1WwlAI9TfHiCMQfmc48khg6lRg4EDg0EOBLl2AxERlCu/cCXz/vdKCTz0FfPPNvttPdq6Bz7fvtH/AAGDZsmCBcPvtwEsvOQLhd4FDDgFuugk46ywgNdXeZ+7ZUx1jxwJXXQW8+CJwxx3ATz85/bevITsbGDQo+BzHRns3epw3KzFzJvD118AFF9gLAzvwumnTgK++Aq6+2ulDx0JSfIojENo5Fi4EHnxQuQXhwBcdzhym5bBokSrDgQOHQ2jHuO8+4JprQs8zlPbss8D//i+wcSNQUqIERrduwODBimPo2zfUyqirA667zhlVDtovBFAsFC2ybx1nnils8fzzQhx1VOR7ExOFuPpqIUpLQ+8/77x9o/8mTQpt+zHH7DvjZ/jw0PZfdFF7b1fxvukydOoELF0aen72bGDSJMULRAItgfvvB4YMAX7+Ofg7ltu1q/19jNWTe8jKAtLTI7spduD1vK9DB/XpjvPro/vD+vGzObBzq1hnlhnvkKRRLg/2a2uAEQTjGVbYhZ9pScajTcnJ6tm/S5eBTOyYMYDf3wKmQw78jz4C3n03PnWim0ChYAZDRvPmxVbOjz8CEyequnGSEmlpwOWXA3/5i2Ki//AH4LDD1LHffiq3gS+dQqW0FFi/HvjsM+C114Affggun24J+48REN5Pl4Xxf04u8ho7digy9IMPgH/9C6ipia3+zDQ85RQVaj3iCFU3CgO6TMXFwObNKszK4513mi6fderRAzjpJODww4GDDlJhW7aXMfpdu4B164BPPgFeeCG2icJ+ZJnsiwMOUP3NcqnXOBHp2jEc/P77qj9jBSfh0UerOh94INC7N5CXB+TmqnH35JOqDhyLFRWqv6ygK0llwDFgHrsMVz/+uL3APOYY4Pjj1Xvu1UvdS8KS/f/ddyq0vXatGidm8F2NGydnsJzCL78M7N7dTlyGW28VccEjjzT9rOxsIUaOFGLOHCFWrRLirbeEePttIdauFWLNGlWXs84SYuvW4LJ5TUvaeMYZweUVFgqxerUQmzZF377KSiGWLhViwAAhZs0S4tNP1blo8fPPQlxySXT1TU8X4r77hMjPj638m24K7zL4/UJ8/bUQu3ZFV95XXwkxZUrTdb3iCiF+/DH6erIer70mxLBhTZfdo4cQ06cL8eKLqn3hwO9vv735Y7e4WIikpOBn5+WpMRrt/azDEUeoe489VohXXhHi0UeFWLBAiGeeEWLQoLi4DK0vEK65Jj4C4a67wj/j4IOFmDdPiPXrYy+XAygevu8774g2gYcfjlzP/v2F+Oab5pX92WeROYTm4LrrItf3hReaV25dnRImdmVyMq5YIUR5eXRlUZlcf33z2/jdd4p3Mp7ftasQ338fezmzZ6v777xTiOXLhXj5ZSHmzhXi8suVYEhNbQccAn3dePmMVtBkvOce4D//AW6+WZmSseL//k/d31K0lbDjpZcCt95q/x1dELoXduZuNIiXWWrG3/6mTO1woOkcjsehaxPOFWW6+eLFwHnnhX7HDFTmnEQ7NmmWm92AWEHXzMwJPPOMcgFjRWUlkJGh3sO//62yJUeOBP7xD6Cqqnnjf49zCPRxX3ml6TxvyicSNf37h2aAEfS3zSCh9/DDwFFHtax+b70Vn3ZSqNCHtpJnbDf9ZmYzbtum/F36iLyOawHYjqFDI5f9yy/Ahx8qP5n+KH1Y+vrduyv/87jjQvkQhky/+CJYoK5caU+Qffqp8kNZvkGWkf/gAKPPPnq04gKsaxfCYcsW1eZNm9R7o+/MgUx/ecSI0Os5cTlGrO+YIAHLsfHqq4ojYB15lJcrYcB+pM/PcUDBYuWGHnlE9d1vvwXOReJC6LOzv8mfsC84CclJ8B6Sl+x71ofPJFdkxpo1ih8xT34KEpZljP+zz1ZchBW8l/wH20ZBR2HFZxx8sOIKyB+xL1gP8gfkNshL8FqGuvmc7dt/h2HH994LNZV++02I3NzANaedpkzCcGhoEOKHH4R49VUhHntMiGXLlA9GU7miIvjac86JT71pEtKHNqO2VoiJE4PNRevh9ao61NeHtoNm7dChihuJ9Oy//jX03pUrQ31xK2pqVKgsUv14dOsmxMUXK1PVuNbOZXj8cSFGjBCic2f7ctxuIcaPt3ftbrjB/npyKn37RvcOundXvJEV9LXN17FPrbj3XvUc8ivRPOvAA0PL4Lhs6j76/tax2lSomi4OuQ5yVfz/tGlCvPuu4mB4L10S47s2zyHEcpA4tPMF+QKNa8aNCy8MduwQYv58FSMO94x+/RQ5tmFDfAUCj/ffD65PdbUQPXtGd+9ttzVvgBnHBx8E37t5c2BwcxJTQFqF1ahRsbfR5QovEA45JLoyeF1ZWfC9X3wRn3fQsaMaB2aQ6MzKiiwQTjkltueQvLaCQjPSPQkJQvzyS/A9L73UvHYef7wS0OTOIo33disQZsywn+SXXhq4Zv/9wxNBDz6oNFm0z6PFsXBh/ASCx6MGtVUDk8SLVrtZ27ZoUfTPt7MAjAQruyQaRjTinZg0eHD095MZN4OWG99vPN4FlYIVo0dHFgjUuq0tEDIzQyNPS5Y4iUm2sdglS0LPcwMO+oAGli8PJYLom114IXDllcpHjxb0D6+9FnjuufglO7WE1MnPD/UBrf5wJJh9ZLP/TZxwQuh3q1a1TiJPtKC/bAZ9YOYZxANPPx16jv743gb5CPr8ZjARbvjwNpOzt/fXMpAc48QnK2wGk3T+678C/58+XRFodskgJGSai3ht+UXm3khOau5kspJdsWQyUr7bJXQRVuKVgodk794Ek5Ts2PhowGXGTBqiwGOiFscOow6ccCRtWQ77wyygYhGurQWSq8xs7dMncI5k7dtvK8KXyo9k7F7chm7vCwRmgJFJNYMhlDPOUC+YIJPMzD8r/vu/WyYM4onLLmu5drVq2FhSk+20syEk9t8/1BqxY/T3tLa0CxWGgxEqZDYhN68h0x4OtBqtAqG56djxBlPeTz01tN0XX6wOCgRmJr7xhjr2MPauy3D99cDkyaHnufmIedMRpsIy7deMjz8GFixoGy+ZKyApwOINO60fC4xQlzXUyJBdW9CWVtjlFNAKYI4Hw7o33qhCoJGEgZE3YBWmLUmdjyc4ySONW+YWcF68/roKgbLNtIZ+9wKBsfd777WPST/2WPC5888PvY4d1RZAk5VWTmstsInHpLO6HrGueWgNRMM30Cr4/HO1tJx5DL8X0LJlIl1TG6rQDZ0/X1kNkZK32r3LwAQXZmtZwUQa6/4EJJuspAslZ7wWOrUErNvq1aEuT1uD1dLYSyvpYuaW/vlPezKwoECtSDWSiMrKAisFaT1wIjEByN2GF/NyonNBGl1NZhtGSrCjhUASmNxCK7vIe0cgUBhYXQD6tHQfrKYksxZJvJjBrLrWAlfrkaBiRmAk0I154IFQYWD1XfcmDKvFSlK1h92RqUX79Qs+x5Td225Tk4JCIZKgpgvHFYxtGd9+q9xjgtvaM9rGepMnsRNm3NiXgpBC8HfjMsyapfxAK5gGumFD6HkuR7WCZmRrgam6772nXJJhw5TG4cTi4GJdTj9daS76eFZhQN6jrfiqZoHAdFszWhIN2SOOrByW55wTfI4kJJdqk0+IJAwILkFuD1aQGSQS77pLjTmmNnPHLitoBbXy/p171kIgu3r33aHnec7OhSCsoShqO+va8HiCa9DJytOkI5iXT+uFTDDzycP5sjT9aLraxcD3tp/+669K+xhg2I6TJh65760BWo+01MxgDkq0i9CMNJv2CFrIXIDGg9yJddEc9xaha8RIXLsWCNS0VrKQ4GIQbn8eDlZCjOa8VeM15YtOmaI+I8V3OXkolZmwRHfBGJDG1uvhwB9v4eISLjRhWKwtgouCuEO0+V2QzW6rAoEWjDUEyc1oogWtNK/X3lqKt7CNxNW0FCTYjz0W+OMfg11autB21nS7EgjMCLRqe+74Q94gUkdaGXG+6FhiyvSXqV2iGRBccUfTNJpruSyXPh2XX3M1G8GIQ1uCMWi5VNaKSy5R7W2LYN9S8Js5AO5gFItAsQqEeG+Rbhc2bY1fbmLSklkgcDzHuvVem+MQ6BtZswyp5bn92Natke+luWvV+OH2LAynLYwJGwnMIKN1wIw2s1tAq4JWADPr6E4wqkB+gcu0SQiZy25L/IEZZOOtvAu5EPNAi1qF7AEdwjFBZWEGFUe0JKGVfzDebzzB8UuhFcm9tQPzKmKZ0LQQzGAOSSwWcpsTCMzVJmNsBScW05NpAkU67CYazd14g/4pn8MQp3m9BDde5eTnM+mHM5xFziMaIdOW/FIKZSuYP0HhFmmfAw5eptqSU7HbmLY1QE37/PPB57jfIKNLkd49Bfmf/gTccEPweUYn4rXvhQGa7NYNY7g5DetpBaMehhDg/pUU0Ew+skbazKDw4zUXXRTq/rWiq9f64p7EiB1IMFJLRTLPjRCe1V+jtWFHTrYEBqvLcKIZ3PyUxGJ7B0N13GSEv9BsBic6CVHjNygMl4mDmAOWacIUhGT+mSeyp37QlP4zJ7fZPWRojpu58PcTmaxD14IWHOtKwpdts1sgRe6KVl48QQKZSoRWrgEKTkaoKGhp5XDccmckclDkl2hRsP8YnWJS3ty5apEX20KLiH1PC4yWBjdFMRPBZiHempZoqy9/tm4IEQ9wU4nevaN7PpecNrXX4rp16tq0NCG2bw+c533WzTEjHTNnNn/5MzcDse51+Nxz0T977NjQdnHNvHWvAG6m0Vy88Ub8fpeB+w9YwSXw5mu4aWxLwT7NyGh6g5RYlz/zGDIkujpwyTM3wgn37Gjx5puB/Sja7fLn1sgWowZj6me8YCxMojVjzhun1rQuV42lrWTKY4mHt4QZt3uO9RxNXMbySVQ1B2Zuxe69xtJWu2utZfLXlWk2N5e9p+alBreu3Yjm2dGAETKre2IHWgbGu2yuhcW2MFLUyuHU1hcILdmcMhK4MowmZEtBtp2mH1NkyReYCUKarbHAGv3gIItlUlujFLFsUGu3UtCOAOQ+h+w3Cj+SpNGAeRjcV9DMIUT7vFjqa0e2/f3vavEYl8g3lZBkgNzUn/+s+CC7nBW7ejaXuafpT3LWvH+lHSdimPnkD0iQMvWebkdT4B4fXAzFtjSVPRsHuLRtk4DWS10bNUr5TC0J+5AU42akVj6C5ApZWA7ySJOMRIx18xK+DJJAzDrkxGMiiDlVloP/iitiqycX43DDU/q1FAa0LkiEReu/UpsxgsJQK7UxU1uj1eb0oZn2yoQVahEKYoZ6m5pETHQhacpkLPqunKjGD4XQDyZ5RoFp/cl78gunnaa0ryH4+OMrdr9oZAcSxnw272V9OUnZ1khpuewbYzxxg1luBGv0MycLiV5GU5j1FwmMJI0fr+rMyUoCj6sQW5rwNnasmrhULnx/7BtGNxj25UavVnAXbF7Pscn2cByyTryPbWFfkPexRlxaDyXt67cdP/nE3keMxCdwLz3zxqr8mxuQ9ukT4A3oG5uxe7cQXbrse7936Rz7+lHcvgRCuD0Vt21TJJfdPZzw3G+RG7heeWWw8CDpZkeyxWcHW+dwjnYnEFrfZYg3GKoM97uADK0tWqTM/0jkC1dQ0l2YMSOUTKLvyR8PadIVkgf3RKmGAwd7BtkMj8vj9dZzGdqfQCAmTFCTPxwRRAKMB/1e+pbkL/jDFkwK4bpzux/KIBi5MBY1NQXSGXNJuJGAdMaqg9aO1pF3kccseSxsPYHgbZedw40lmNjETSntdjrmenIe0YIkDpNg7BZfhQOXWDBRjUSx1RhJ0l8gI5ZMebeLxvFcov5ZqwsVl+X7BFMciOU0hHlWuPLr9HugP8ur/99Y48WyPPp3RpvsymmqHi69HuFQr99jV0+h1yvRpm0uvV9q9e+MNvj0thn3J+iHXz8vIvSN0Otjfi/mOvj057ksZQubNtksZ9DKCBe7M/e90RZzuT7T93bvIbn1LVJvu5WYb76p2HH+bBmjD5E26IwELlfmbyFa10w0K2Yj368clNWlLvj8LqQm+1XU0cZ74XVVpW7tMzXFrzwXoQ9qDpZMjfNFaZlbC5tnZvmVHVemDxp90FXJZ/nls6yhdb8sKzlRyG5RD6+tdKG23oXMNL9663oZfjlIqyrd2nhjPRqL8esDMF3+KQVfubyGdczoIL/I0uvhU2VobSl2a9V3WeYewXp4vcK2H3h/Q50L1eUuuC1toNfndgvZj0K7bnehR7umQ4YPrkR98uv9W77bjZpaF3Lkdx59Alv7hpG/JFmXxFyh7q3U+9GoQ5lLq2dKsl5Xeb6+xoWaskDd2K/8O62TXzW2LLjRbIfPF/w+hP5PkuV91De4Gu9l3bR3LA1ZFEVQJHAEQngwdMjfVlixQm3ZzjBWNKviGMZhHPihh5qfpGMHOYGqitw4e3YePvshGS//PR+DhtWqF2y5buc2L86R123b5cHaJfnofoCcmeW6VkuRbuIrqbj3qWx8/E0KEuQgHTW4CpeeUYoxo6saB7KQg3rq7K74cVOCNriqqt2NgmJnsQeP3bITF06XPo28Zd7DOVj6bAecObocD926U715OZl++i4RZ9+Sh6w0gTce2IqUDKE0ZIr6fs2adPxtVTa+/SUJaVJgjBlahavOKsExw2rUZJBtKS7w4PRZXVFc7kZZpQe1cmJqwobCscaNp+cVYPypFZqAC0Fn4OVnU3HZXV3QJbsBO4q9MCTL7hIPBh5ag3eW5iOlpx+PP5WJeY/mYPTQSjw1dwe8nLgZwD33Z2vnxx5bhRV3FCAlSU34c2/Lw7e/JWlR68oqN+pkF/fM8+Ey2Y+XTyuBO1W3imQZb/07BefKvjx1ZAVWLNih9RmF4T9XZ2CO7Lv0FIFdRR7Zz3Liyj6adlIZ/iTL6NTDp/pB9ledFAaXzOuCz35MlsJXtr3KrfVhgxQQZRUu3H/9Llx+eamm5Rcsy8bK1zNBMVpSJvtMvr/jBlbjxvOLcOxIWakKXWi7HIEQO7itFHdcYuyXO84wn4AxXsatyTMwrs4sPSbifP+92rG5NRaI6JNg2y4vduxM0DQyPPbXcZBu3enFlh1eOWB0TcVr5SB97IlMXHxHVww+shor7y5AZYkbc5Z2xJq30vHMnQU4+8xyNWAlNsv7f9mSiJunF2HggFolLDjOpcYbekRNo/DYXepBoRQST76agQkjKnHq6ZVaGazjpoIEZGf4Ne3X6MpILfvX+3MwZ0lnnDy8HCv/XoCCjR7MeSQXL76ThhcWbMfok6q0ieeTbf51awKqa9246cIiHHRQvTboWRy15YCDaxrrGwL+fqoUZDt2JqJ393osmbFTPb9O1S0n06cJRN5/wfgyLPufTKx+PQsTRlbi3KvKkf+hFw+u7iAtKS9mjC9FSiehJqjEVvbNpkTceOFuDB5cC5fs58efy8TM+XnyfAIW3rJL9bnsnyopuAqLE1Cw2xMw+eVnmZzUG7ck4/jBFbj9mt3ajPnog2Tc+Wgu3v8qBS/ctx05Wb7Ge7bKd//T+kTcetluHDWoVuOY2K8NcsIPOkwXolLo75ZC4NcNiZh6Shkmn14Bnzx/8wO5GDZ9P6yatw1Tp5QrBeF3BELzQS6AW5u9/vreeb6+Foua1JMoD7e9u2Bcly6vy0j1K3NUKC2z6acEzFnWET3y6vDc/G3oOaJBm6QpsrzJN/TEgieyMeWUcrjcAXOcrsnEP1Ri8KQaRREbJFSJrgFT1HXpctLTrF74dAecemKlpgH5bNYh3ewuSKG07j9JmLu8I/ofWo1/ysmfcZi/0fydOb8nFj6TjdHjqrS6sS2ae+L1Y+pJFbLO9Y2TUiuUdaoK41vLArUJL/84UAqESVMrlHVSrV9PLclcJ/lqOx7kw7xLd+PMWd2x/F9ZOPf8crzwdho25yfjojOKMObkKqVZRaBvkpL8GC8F4PCza7SyRh5WjS9/ScQTr2dgxsQyHH5UrXa918OX4lfuiQjULdGr/nPIfnWYdEGFNkEnDa/Az5sT8T/vpOPN91IxZVq5ei6fmaTacsZxFeg/RZZdYHofpbqLkajcB1437MgaTJpWoQnAfvvXYsRlvTBrcS6G9qvBARSslXueu3TQViA1xyffJmkWxrhhVejZRwqDjfJ8PjSX4frzC/HHseUQVaGmpOazGodXn1AVwW+4Vg66gYfW4cOvU7B8TabGSdBHtwO1X121CxP+UIGM7nIWrFcTk4Lniik7cZo0ra3+c2M93KZ6VJp89Sg4mKAD+iQy/Gn596SJFTh9VBnWfpaChX/rgMdfyUS3LrXS1C4OELmmuvCgdQT+yt8m6aJLl2Fk/xrp2rjx8xZvgFBtQtLT4jLKoMDq27tWa1RBkddWrQa9D48uEC3vg9+xHny/2CyFTv96TBlTjq3bEvDWf1IiE7WOhbBvhJYKOXhJNEqt38ikywnVIcuPe2/apSZHTYDhJmnplccqqfE+35CkfVchzdx+fWoxZmRVkMlZX+vB5FHl2K9LMuatyMF5E8uRlea3TdnQJpEUFknSMtGep0/I7l0bsPj2ner51YEIRYIcSQ1yjjzyQia6f9qgTcxyWY8RR1Vj6OAaVUaE1BCX1NCbt3vx8JIszV0hP0L3a9IJFcjr5lMTvUb59bOlW/LFT9Jsf6ojyitdmD+zEH3616mojw0xSYtNI0JJksqqr89PkJof6Jztt48U2AUPSAbq20YUfunBm5+mIiurHkMOrw7S4h5aSylCc80+3pCsfVctrbIjD6zDqKFV4ftAqChEr84qzFAkXQqHVHSAujq3NolJRDUOHiP8ZhMW9MhJS3OXfr14Wy0k27ozAZecXoIx9PGrg1Vw99wGTL6iEL3POACLn+qA808tC13851LWBIRL832DNLgRlrOESWn2V0qLghPBEDCbdyTgjssKMfS4mkDoMJwslG0gp3LX49kqAifbT27lmMNrkNfbFwgFSqE0aEgtThxUhaffyECPzg3440nlgUnlCtbSjIxsLkjA5p/r4ZYT7qEns/DhujRMOrEMxwzQuY3UyO8kNa1Bs5hGnNRTE9r5BR6UlHuwfM4ODDlelrErUIYRFXnu7XSItYZw9eLC8aUYNaIqsgCS9a/3qQa499Km0Y5AaGPwelU4ixM9JE6eobQITKt5GV0g+bZ41i6cPK5SmdgGSvT7TG+ZmueA4+oxWZqmc5fnoHfPOuRm+ZQACqqHYYGYZrFfj4KkK9IPpp28qAVprayeX4CjaRGYVxzvbrrdPikIBx1Wi9XztitNbhZ+paZ+kH3w47pEfP5DsjbZd0iTffXaDFx5cEmIRmXdGXG4eUkuau9zycmmLjl/Qgnu/FMhElJFUBvCwS/7hjzLEQfXagIhJ9WLd79MwUffJmPsCZVITQj0EfuxqNSNZ2Q7xpxapYRFo8/WtMuUoPc3w9aOQNjXISdcTqYfbq9ivRsTieQEKdrlwZOrMqSZ68OUE8vhtviXGilmJNEYk9dGG1VVu7Rr/jKjCG99lop7nsiW1oAbycn+IE2lMeecl7XuQGKONEDyN3ux6rUM9OlVj9NPrAjhBkLq4YueKXcZSVAJprqbk6CSVVm3PpKDb35LxFWTSvDvL9K0NowdUoU+/eqCQry0Muj73zJ9N4YfW4OGUuYw+HF43zrl6pREx23U1Hgx8JAyLH1Ud5W2AGdf1xX3rMhF/4NqMe288hDBEu37sLqMjFJQMGSm+fbKEHRIxdaa20INPs3vpBXMzywEMuDsIN3H/n3qNL/+g69TUFIgXw/3k+0OfP1LIq5ZkIcFT2YHMhxNijNN+q1aMlO6fnTQtbllMmoJUFJjH3FMLa6QE+q9dSla/kCCVwRpqoGaNhR4X2rChlJ5ohu0urz/VTJmLeqGh1/MUhaLyVcnMlJt6pEY2V0ImkTpuiXEz0z9MNoq/37t1TQ8+2YGBh5aiwVzCqW7UIbN+Um4e2V2wIIx1Ynh3aOl5TFkdA2Gy+Pwo+vUdSWxjH6hWUDgfsDrFak44BDlw2zZlRBK/gnL+8jQ+yHZ8j4EVFSjo+rb4i1uvPZRGtLSfTj2yOoAh+RYCO1cGPiVD7jupyQ0pKvBR22VJM3XPj3qGtdTMX4ftJu3tDD79q/FzRcU4YZFXTD5pm54YPZO1FVJLfdQrnbJhaeUwZ2BRiKLgoeZgt/8moisj32Nmoqma88uDcjp5GusEwewX6AxI/LKqSV4dm06NuQnonuX+qB6HDe8GteeU4KFT+Xiglu6YPa1RSjc6sHt/+ioqe3zx5WpCWUa4PT5P/8xCTV6dEF7jDR99+9aj8zM8ASeIUyKpTvz3eeJjXkIbANN/gN71MOTLlCV78LcFTmyUDcukj558v4CF5xWhuUvZ+LRlzIx+bhyjJtUpcKUev+y3cVlbmW6l4ZXhVodhCtku0JVN9N5PSWcZGajEBPBioDXfC3fR9pHfi3kKoRLq0v3zg3I7egLum7Tdi++ky6Qv8yFK+/shF83JmPBNTvQf2Bd+NwNRyC0N7i0vIGr7u2kCQK+eA7Kw3vX4uNHtyI9RzH7JOxIIjWy/A1qsP15RrEWz176fBYGTO6l5TP06VWHRTcU4OpzS4KIQpduas95uCMaFgdSYYuLPXj01h246GKVGWf4pJygRspt3iE+XDWlBFct6CLNYnewryvdg7uvLUQn6aIseykL/U/rpfm3fXvXYeXc7Zg6sVxNsCQ1acgfMB135oJAmzmJ6PqsuWs7TpsQJlPRpU8OOau+/DkRIy8L/ChOcYkH/Q+rwUf/2ApPmsC992fjwy9SccLQSpw3oVzT2D37NmD6hDLMWdwJtyzLRb8jtqFbjwZtMlGgkGPxC0Rm7BvrgGAuxaX3l9mnF6rN+3dVvszH3ySjdpsU9h1E47oWWgc3Lc6F737VDyyzvMKFB2ftxMyZ6n2Ql0iS1zE6tEIKNGZ3HiTdsOW3bcOFZ5dFXv/RmiO3Xa52bAu4WB43Inhxk742gJl/tXWuIPfAp+fR9+5WD3eCyp3fKLUDhQI1YAITVfwm4k6am2Wb3di4LUFjrqnts3r6lWVAwk3P4d+wTT2LQsEcPqS27t7Zh2w5oVlmgfRNC+UEy+uoaymfXob8ZJKNy6U0cdCailR1FK73IF/eT7eC2j61mwisqZBl+Opdsh5ebdIYefvGB+vEumdkhLEQpEoqLXFrEQaGLs0aukH+rVkI3eu1vv3+t0TUybYeIP+f1VEPhyao9Qa/5qt+OCBPficFLuvGvqGpH/H5UG0ol27Tpu0Jmu/eq1uDar9HCaV8WTeun+iRp5+Xz6yRwo/ZmQz5HiTfqVe6SgyVMnOUQtBteh9Ct9C65vqQk6Pex45dHhSVq7UZWiajPN1bPjetl7IqQtKW+Tfdttvl8VCrjeoSRyDEUyDoC2I0n9G6qMkI2RnpqB79OiODzbr6zqN8VU04CJ3Vr0boopdMm2cZJnGlfo9LaXytvCoEEoWMFYQZep2MpdzWeqQhQCzW6mX6TXyIx+Tr261YrNDr77InUjXfOsOGdHPrWrJMvy5T74+agMukPS9Zr6Nf719j8VembgNXIBC2tKcIVLkZej3LTG3RF3hp95cjEAI26lyvn/eZ3n2ChSswEpSs78PMKRirUysREj7dkwLBcRmai3T9BaVGR5g1wi7mHcUP/jQO2FiQqBOaZmTphx2So6xHrL9YF23GXUKYNqTaXJcRQxtyYqhrgj5Z7c6nhzmf2oL3Ee07pkDIC1MHh0NoA/hYHvPQZAaeAwdxoqWUIP7Q4RAcOHCwZ1Di5CE4cOAgyEKod1wHBw4cSDRQEHDxZZbTFw4c7PMo/X8BBgB5OBYtILpQMAAAAABJRU5ErkJggg==\", t.LicenseBannerDevelopment = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMDlCNDkzMEExRjQxMUU3OEEzQ0UxQUI2NDlFMzk5RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyMDlCNDkyRkExRjQxMUU3OEEzQ0UxQUI2NDlFMzk5RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOmNhMjU0YmI0LWZlMjEtNDM3NC05ZWE5LWNkZmFiY2RkZTA3ZiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiMGM4Y2MwNS0zN2M5LTY0NDEtYThmNC0zOTU0ZDM1MjY3ZTEiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7DNCRNAAAbLUlEQVR42uydCfxdwxXHT/5C1JaEqn3fGhKUWlpLba19J9Yi9qJKQ22xiyWaBrXFltKorQ1F06rUFhFViqKNpUQiqCIJUUvC9P81PX1z585977737vv/3/v/5/f5XPJ/9965c+fOnDnnd86Z6WFEJotIb4mIiOjumNmjXSDMbv9Hz9gWERHdHnPa2v8zK7ZDREQEsqAttkFERIQiCoSIiIgoECIiIqJAiIiIiAIhIiIiCoSIiIgoECIiIqJAiIiIiAIhIiIiCoSIiIgoECIiIhqHmNQUURtWWklkr71EZs0S6dGjvSe1d6XRo0X+9a/YNlEgRHQ7rLeeyNChyd8mTowCIQqELoh55xVZe22RddYRWWop+/enn4q89ZbIX/4i8uyzIh9/3L3baM6c9G+ff9593n+RRUQ23bTd6G63ur/4QmSuuWzfeP31KBC6DFZdVWT//UX22Udk+eWtGhwaCFOnWvX4lltE/vGP7tlWDAIfxnSf919jDZExY5K/HX64yLXXtvRrRVLxy1Zob4bzzxd5+mmR008XWXnlsDD4UoS2/77CCva6Z56x9809d2zD7gZ4kzy/RYHQYlhySZE//UnklFNE5puvunvnmcfeN26cyDLLxEHS3TWkLmAydW+TARPh4YdFFl88fB578O9/F3n3XZFevez1sOsLLpi8DlvyySft/198MQ6WiCgQWg7zz29twJAwuPtuawsy83/ySVIlXGUVkX33tfbiEkuUzn3tayK//rXIt78t8uGHsWdFRJOhpXD55ZYYcvHOOyI77CCy884i996bFAYA0uyll0TOOkvkG98Quemm5Pn+/UVuuCH2qu6Azz5L/zZ7dtQQKoucNkvEhWyuvMClA7tflI22ySYiBx2U/G3KFJHttxd5/vl8ZeBvP/BAkZkzRX74w9Lve+xhTYdHHin9BumIZoELs3dvka98xXYeNAk8Fn/7W/ln9e1rTZXFFhNZYAHrBkVY/fvf1kSZNq2+9kDTwRzq08fWlc7Oe+FmRQDmxfvvl/6N5gX5inuO+vLtOP/CC9YEqxWUufTSIgstZMtFSNOOb7xRnMeHdoATWnRRkYUXthPFhAkl0pC+yDf0QX2+HFU9k/2fvh9y07r9e801LZ9FuVxL+7/8sn2vDgTLsE+nCRr2hAMOEDnttPoEAo16zTUiw4fnux4b/6tftYMH25/BR0QdH5bO8/vfi2yzTVKyb7ihyF//Wlv9/PLGjhU55hj7G0IGrwXCgPr4IJ7hlVdEfvc7q7UwuOkU1Gfrra3w4l46S8ibgWBCiI0aJXLzzfnrTGfH9MHFutxyYdOJTkmHROjceac1od5+257bbTeR3/wmef2RR9oBtOuudtBSps+8U95zz4lceaXVwvLU83vfE9lpJ5F+/Ww7IGR88F0nTxYZP95qaU89lb8tENa09+abW60RwctzlWS+7z6R224T+clP7N/EpCCkl102WQ5tQx+DbHb7Lu23++5pDeLrXxc57jg7gay4ou2rvsbKhHHPPSJ33GH5LBU4TDx8NyYYyr/xxiJG6wxBIBgrZxtznHKKKQSXX17+OQstZMygQcaMHGnM888b8+mnyfs//9z+ftddxnzySfLcuefW945LLWXMrFnJMv3n58HbbxtzySXGPPVUbW10//3GrLZa5fruvbcxU6dWX/6995bK2G23+r/pmDHG9O1bvq7XXltb2ZddZsx882WX26+fMSecYMy4ccZ88UX5sm67zZghQ2p/zzffNKZXr+TzDznEmA8/zF8G/Xevvey9hx1mzGOPGXPllcYMHmzM7bfb8uofr9MbLxCOO64YgXDRReHyF1nEmLPOMua112or9513KnfKPMeIEaYpgFBZfvnsel54Ye1lP/hgsQIBTJhgzAILZNf3pptqL/uhh9IDkWPAAGNmzsxfzt13G3PSSbXX4+WXjZlnntLzGdi14Iwz7PucfbYVZu+9Z+vGJDB8uDFLLFG3QGg8h1Bt0A62JjZVyCvgAzXspz+1UYW1AvV++vT63xOVEvWvEj74wKqOqKMhO7RS27z5psh//mPVUlRWv61QdzEdUEN9zgWu46STwmVjt2K6KA+AHY0aq3axkqrVgjpwuGq0C7wyV1xh+ZgQfDPrtdesOxgTgXJpR+qJWebjO98R+eUvRQYOTHMycBCV8NFH1tREJed5mAq0PeYv7+O7nzmHCdjmcPXUD9Vf2w7zLyuaket4Pzgc+jvv5NaTshlP1Av+CJOOOtCnOMe18D5NTSpie0LYlSNVFNjPQ4ZYu9sH8QIu4BN+/OP660f8QBGAAMKeZ0C6Awi7G6GD3czH4mPSkfmwfEA4gqOOsvaxDzojvAYE5QMPWPubTkCHQRBgr2+2mciwYXYAu4OMAeZ6PCANEZ4+GFyXXmrtVDoZ9dOODA8DmYnXZccdbSfFfs36lhCdRG8++qjI44+LvPqqfQcGEMKPesEz4KHxeabLLkvb/fAPDMbf/taGiVM2hCRCyxVOtAPCkbKPOCJZxp572onD5TtCHgLalvL//GdL8jIwVQjMmGHfGy6Be3kfOAfczC7wPv3qV0mBgOCgTZU/4Fv7ggSi9dRTbV/k/VSAwmPAE1D/XXaxbUh78r7rrmt5FYQb3i7q/c9/1t+PG24yVHOssopVeX1cc03yutGjy9ta99xjVbw99zRm882N2XRTY3bayZovN99szEcfla7n96Lq/8QTybrAVaywQuX7UJmfey79LnntwnXWSXMYjzySvOaGG9Lljx1rTO/e+Z7Rp49tx7nnzjYZ9tmncjltbda+93Hjjelre/So/hscc0y67IkTk9dsuGH6GniVap6z5prpMtTGr6aPvPGGNXsr3QdHttJKJf4DbuWcc4w5/3xjRo0yZsUVW4RDyHssuKAxr76abuSnn07agRApWbj6amPWWKPys5ZbzpiLL7YDFoKmqHeA6PEFwlpr5bt3++3T5Nbhh+d/9nXXJe/FRl5ySXtuscXSNvOLLxoz77y1v2tIIOQhNPWYNCl575QpYXu/lmP8+GTZn31WGkxZAmHgwOqesckm1QtwSE6f66I/1/KOtNUuuxiz444lIV2AQGiewCRUQnzMvr2NqoTaBogd+MEP0veijn/rW1ZlRP2qBNTkE0+06nqlGIC8QJ1GxU45dnMmvGBa+GsJ8E558Yc/JP/GHFG32BZbpG3mESPSgVf1AhdYXmAGuMCdiC++CPguOMwzVOyyxnMHBe36/aHWHBjGxF13WVOvwICo5hAIJAiFeAMGv+aXQ8bQiX2wKMd3v2tt1mpB/jq2VxGgQ0Nu1Qo+8HvvJX+rJtkKbiErUAZ713+Wz8l0NCZNSgfn1EMOuyCmI/R9OhuQjvARLoiMveSS+vpOgej8XAZmL1KIfVx8sSVoFFzTp0+6UxG80wy5AwTPhLwj1QRf+cFb1Xhoymkifog2ATydnYTlDwz1bJQDpNo3vymy8cZ2AEGuoZnR7hBxMO0qVGlLl9yDfGsG3H+/yFprJX/70Y9EDj7YBh8R5Mah5G63EgiEzOIW8sFsr1FhAKaV9fsSbGi7xfP97zdPIhHscdHqZDVuvpBAUG+Ab8rA0tcTOVoEqjFXiHocNEjkkEPsv/MIXr/tmmWtArwpDH6EmQs8D/zOgbcNwYEXA+9SB67O1bkmw623plU53C64ilwQYuuHdeJCK8plWC/OPFNk9dWl6aBxCH68QzMI0dAADQlAeCMWrjnnHDsx5NXC6hGujQShyGi15daexDzmvQntxu2MBtHlBcIZZ9jgGR9ISD+hA2LRn13wnTcD+Lj4n5sROgja2sKCotmB1kWORoisBcQEEC8AkYwJBN/kJlg1K5jIMJX9OIYQyHeAYyCOogOIz84xGUjMOPvs9O/8BmvqAqLJZ5+xserN8CsCmCzXXde8HU9nSV8A9GyBZTDwChDB6IOZFTOTJCYiKzVyk3eCRCWykcVxb7+9uZe2I1EJTZjFfJkYiaakn/tBSwqSyeDU/KjLlhcIRPKRuejjoYfCMy0EjBs+C9zU4qKx/vqWhCP8NxTRpnUim/HQQ8Nqej3kYqFf93+fV922ilAYeLPh5JPTv0G6ER6OEAhpCwgGNAQIS40GbXYQHckBtwBRSlQoHrctt0xfiwAhk5To3y4hEBgovIzP+DLbZ0k+P8UUFBU7kKVmE/ILqfnYYzacFl6DUFI3TdbvbKQgc31ISHQWVDARI++CkFjeJ0vgdTaYJYkRcQGPkHd2ZPWqVlzwlFBvXOscW20lcvXVNnTcBSt1dRmBwIuGgm2IuyeOPgQ/2AX+oJGbgbDIBgMI240DTqMSyGMgrhyVjw/WbBwC9jUdTEEwDB2tWZeQZxLwVWdMgLwIeVBaTUAQqEZ8DaYRJKOrnbIehB+z0nICAXXHXVlIQVIHqx5XsoNdlTxPopQCm5JMREwV7svqGER7oa7R0HlnTsqDQyCDkKjK7bZrTg6BTnX00aXfMcEQEM0qEEImVzXfnPv97MqOEAhFu3IhTOFR3DgdtLuWFwjMtNdfn/6d0MsLLih/r+8iw/2YRbxkdQ4yAvNE/SEUYOR9F6cPTAjITxhwBluzz0JwLviyXffjscfaNNyiw5eLACYk9XW/WTVh3KQN+9+i6AFEX0EDc5/TCO9NyEXcQBdq492OdELUPX8QQyJCkFQCqbRuA0CUhXLfy6nNeUwM7H9meeIJ3Ig5gqRY7ovlzSC6iEgkfRdTwhUGDf5QdYG0a2I+/EFD/kjeNRk05bYjiDoGL/kpLtDe8mhg1I8Ueh+EuBcJzEpSkV34vEcIpKHvvXeaKA8B8tc3WRGWPifUUhoCASUDBoQ/OrkKoXUG3QGGvat75ynwBPgdvF4goACLaridHnXNd4W2IngPtqlz3434DgQuwo7IOD/+g7bHLcbGrvvtZwXrRht1TH1HjrSanavpQaYRf8IEA7Hsmnao0jDzmKWsu+ACQvKJJ4qtHzEPeDtWWy3JhVEvkquYXACRlfR/Jg8ECKYrgphYBLYBIJeGvUJdDQZBgEmHKeqvHUEOSihvpWUEAoM3BBZ94KgFzBQnnFCczUY5qP86EylQpxvp0ehI4LMn4g1txwU+e7wqzDqYQrgoUYPRHNAKGGgKFuDoKC0I3mfwYJu7oIAXIEsVcwfhxaDT1Yuwq7MSmHBnF11vzAMEE1v6udoJ7kP6pg5wCEHcoTopqguY99J304VvtO3xwmUlejU4IK/xAqERYbJIZXy1Rc3czJAMGOIPiCBT4HJs8d18E7jqKjvrk13qA1cdRzlUu9VdPWAAsyI0sfx+ijAcj++Oy8JFF9mNdxoBVu2ijr4Ji5fEdZezlL1yNSGTCy2CoxKOP772lcGbhkNoVCc677xiykED0EQqCE7XNAklXpWDz2zTcasJUvLNp2raLhR9GPoNrw7LjIWCeyrBdQ2HOnY17xqqm99+CGlMuFA6cx4bH8EXCnAK1bMWboRZHY2y0hocmpEJWKo9794frqbKuxDC3GA0XkNAzWRGrydjC5cTs4Q7QPD5I6FRK2sFtiXxA6hqxM2zbqCCFOFf/KL6AUPyCvXFW0EKK+pi3hkRNyADhfpAwhKokheoz5CHtDNl0VZZ2hmRonh44BTQtDbYIBy9SDnEWEC4QsqxNqSCaEDd5wI1l3rnfVcdTLwf7cRzuD+0gQuuN9YMwKbm+0Dq4rUKgfamnvjwCfPlW2Rdx7N1AyAEd60L7RKCjFlMNiYh+S7voW0IP6NuU8YDZhqaBe+EwAsF36lAJMEJToJoxg5A4zdqoaPpbjT12PjYW6F4hcMOK59PwEpBSHBfJSM0mSAiOvG22yY7O4BEc9djyAM6FrM89WWQYGdCJOV1RyEEKEM7KffmzYtnQGF7ci+dkBmPTl6p3akndi4H6ejch0uNwYkWgS0cIrG4judB7FEGA1tDhvPWl/flXurL/QiXSjEgfE82gKG+cBwMamZQhCFHnp2OuIdyeDbfirogUOuN3OQdiGZl5S88VbQHAhWhlsV3wX1ANMJ/UCfqwn0IM94ntG5E4zCjuRZZrXScfnp4LcWTT86+h0VEp02z17GOPYt5brFF6fx++6U3VWGt+1Zpk3jEo7hjemsJBI4HHggLhVtvzV5glZWX118/uZPPMsuEF2x9/fUiNryIRzyiQOiQg+WoH344LBTmzLHLrO+6qzELL2yX/A6tlsvqzNOnh4VBuV2P4hGPLi4QGs8hNALYWgR1hFJEFdjAEDiwurwqi2zgHgptaqoEDqQQQSIREd0TM1pTICgIOCFMtd71BwhKIs9eo8t86MIbEHwhb4nmV0BQ+kw7rjQEGGSbz2TjCQi5FrUciDuyPX3CCzIPAsvfwYh20NRyn7GHrKIsP8Yf0lGJK4gw1x3I75VIyazcEohJn4zUrex5F7+ttZ1cQGhWCihS0lrB9/GJ2FDZAG8ORCaTBO/ptxntRfl4U8q1g67oVO0295CifEfaqdxS6npdteV3eVIxdGy0kd3RuRawuxHmRaVnQDx+8IExRx0VPr/zzvb8aaclf2fnKHdjDjiL+ecvnT/1VHtf1sa27JTEeXb70XvmmsuYZ56xOwq7m6TSDmxqo2D3qmWXTe7uxMa2mFX+hi0uP+PuSPzCC3ZTk3Jtw85XoXdw68xx9NGlstk45Ygjkue33jpdzqOPGtO/f/nnn3de8r4ZM9Lfacstw3VkM1jOX3WVPY856e6mBRnNBjLldpHmWQo2Yc3TZ9mR6oorSve99JJ9/6ydxSHDqV+eXcC6HYeQday7rjFnnmkHRYgfADQqjf+zn1miMW/Zhx5q7z/xxPB53c2XnZXdDg6efNKYPfawW86DO+8sbVE2bJj9jV2kuEaP1Ve357faqlT3I48sbYVGR2WXJ/gUflt7bbuFHZ2X+91OSofimg02SNZHDwYL53v2tBwK0HNvvWX/3njj7LbZd197DVuSu+UizPzt1W65xZ7Trfh4f1eoqiDjGnZB0m/GzlOVtotnZ2Tu436AsNVrdtghWbYeKgC2286e//nP09/v+uvL9zlw6aV2MgB8s0r9iXYAeM2oh27jRz38aw88sPQtjz8+CoSqDwYbkpSt0QYNsjMRnYttr1Zd1Xb8ass86CD7QdgbMnR+993tefba8/fw0+3UONjHDyy+uP2bffnKbYGG0FIwONEO+P2VV+xsy/Z3/M12dGDIkKRWc8cddh9A/l5vPXsNM1PoWWxXjjZDua5WAcaNy24b9kQE+++f7fbFrTt1avJ3tA+3fXTQukL3ggvsb5zLev7IkfYavq3+NnmyFZh9+5a2yQNZGh7t+PHHVqDqb3xLsNlm2c9GuwTs87jyyvbf9LNyfUm3kYP81t/was2ebdvE759//KMx779v+87jjzdcIPTscrQIr0UgCEdnATucABUCS9wQYVbAIaBGbXYNViFtVm1I/k9wjWs7E3nHSjmEVhNm7duzZGryrHPPtTwAkYgEXnH4bUNUnLtLEKQrfAXnNKBKNz4hbp66kvGI7R9aO0HfgchRLZeyeG9sdNoBG37ChOR9BJmRas55t43cAB5dLctPM/bfCRDYQ84AYJdmgs5INSabUK8hV8V9d57LO8EjEIRGqjEBbLQ/gWlwB36KuwsW+yXfhahPvgm7MPPvctBNWsgyVfDtCGemnfl+yhXQV+gzQ4fab0IYNkFPDezbbRLRgFZtswPKX3CV0GQGtw4sjepjoRI8IhyEqPprFDB4SOsl048sODqqSw4SDUf4LNl3hHLrFupuaq6SaIQB67M4ttmm/LtA0PGsrFh/fQfqpmUSFqwdXwejP6iVvNQl4vU6VhdmABC3T3o8hG+1285p+2o7ah0JT3ff3U3l1r0mWTMTkhTBwYCvFHmJAGOQcg/pz5CQ7DHqZomG2ssnn1UQuv2FbwVYXIidzIC/Z0nRc1kcvQ3SUviwKhj8gcB5V1iQcKQLeMCS+zMxLPaFF9o1KVkngE7nlstzmNXY3YpZhLRyOhDrGDAwNSmJmZrsQTQJhb8QScjDQn2zWHZ9B4SahnrTuXV5Nh3wvpBTjcj3IrAyEoNSBwgLglSbuqzCS1ONtQ6jR5dW7qJM18WM0KFOZLvqO5ULXec7knRF+6KRoZEgCBAMw4bZzXdD64SqIPTbQwW8qyHp4FfvD3Xm21J+FAhNgCy3ZMjlpotn0EE0yYjBzIIXJOigimtHZRMOVXdDUNWZ9FddGGbKlNJ5hACdh9kVdZJdrdjliKXiEQqap8HzGKi6GExIs1FhBdBGiLVH7c5KTtOOTKJYqFySxIC/+zIJVe55LYcsVjbxASyIglsZrSpLS9D73AVGdAMgTQ7TdkboZr07rj8GMYvG8I34Zq5a7wMNAuGBFkH2KNeTXo4QYsk6fS8faHOu6aDuZzUF1FWLq1HXEnFTnjHN+LYNSsuPJkM16N/fZqrpofvzaad0d0hiFmamYS8BrmVrLmYRZgZfsLDgi1suSUZuufp/Fg1RTcKdSehI2J/MgNzPLItwCA04hJT7LM0cVA6BuAIGL+fUHnY1iqwBmbWZKrMk9/NcNBzKZdAjEJiB/fq5KrPa7+XWClDtgcFD2SxKClfAs3TpPL2GBDn33f11DMgqpO3RUPhu5bI3sfsRQiTGkeGoQpf24ztlAQ2NA20CzoJ68Cy0AMwujTchs5PJhJWuqA8HKdBobG5WbuHabVfzMjTiOOCAsBvz4IPt+YED7d94Ddz7Bg+27LXivvuMWXrp0vmhQ8PlqjsOlyAYNap0Dy5A8O67JS+DekJg8hUw7bi09Ly6HX3gsdBrnn02eW7mTBtLUa5t1O3oejhCx4gRybJx/fbqlXY7uq5IdbkNH55dLi6/rPbTY9ttw+8+cWLyOmJEeOe87kO+hRtnMmaMjeugTQcMyL5v0UWNGTs2XZ9jjy21yfjx9jfX5Uo8BHEkxKHE0OVOBNKbWUrTfBWo7UQfEgUHew/Z5y+AyYzDSkTMvr69rqsUUaZLEsL8M7vBFaBKEpHoMvFoKpQ3aVJSU6AeXK+agRspiGaCmsuz3HdgFlQ1llWIuE5naZ6ZtV+Ga86wVgX1rXQtz9eITn2mgt9RhSlDZ3bqQp2YNbNMKqIM4Vi0DXlnX10nQhLzx/9+qPn+mhNoDczCeRcxoW/w7RlOfF/+7tevtOZiOeBlge9AY4REZW0OzJAHH7RLrmG6sd6CC7wymBiNCbGfEQVCREQzAOHPYiksplIujLmxiAIhIiKiJBAiqRgREfF/RIEQERERBUJEREQacAgwGDFAKSIiYg6CYFr70Tu2RUREt8fM/wowALO9X+PzfEmSAAAAAElFTkSuQmCC\", t.LicenseBannerSupportedBy = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxM0JENjYxQkExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxM0JENjYxQUExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjgxYjI4YzQzLTQzNzctNGNlNC1hODk1LTZlNjE5ZjdkOWMxNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpjOGZmM2ZlNC0yZmRjLTgyNDAtYjlkZS02MDg1MjIwOGI0YTkiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5j1ZUXAAAYZklEQVR42uydB5gURROGixOzCCoYMGEWc845R8SAipgVzDlgxqyoPOYcwZxzwJww55wzZgUUFQXt/17b+rent3d3dnf2bveuv+cZ8WZnenp6uqurvqrq7mBEPhORzhIREdHeMaZDs0AY3/w/HWNbRES0e0xoav7P2NgOERERyIKm2AYRERGKKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiKgdYlJTRGWYay6RrbYSGTtWpEOH5p7U3JWuuUbku+9i20SBENHusPTSIiedlDz37LNRIESB0AYx2WQiiy0mssQSIjPPbP/+80+Rb74RefFFkddfF/njj/bdRhMm5J/7++/28/7TTSeyyirNRnez1f3PPyITTWT7xuefR4HQZjDvvCLbbivSt69Ijx5WDQ4NhC+/tOrx9deLvPtu+2wrBoEPY9rP+y+4oMhttyXPDRggcumlDf1akVT8txWam+Hkk0VefVXk6KNF5p47LAz+FaHN5+eYw1732mv2voknjm3Y3gBvkuZcFAgNhu7dRR55ROTww0WmmKK8eyeZxN738MMis84aB0l715DagMnUvk0GTIQnnhCZccbw79iD77wj8uOPIpNOaq+HXe/UKXkdtuRLL9l/338/DpaIKBAaDlNOaW3AkDC46y5rCzLzjxuXVAnnmUdkm22svTjTTLnfpp9e5JZbRFZYQeTXX2PPiogmQ0PhvPMsMeTi++9FNtpIZJNNRO65JykMAKTZBx+IHHusyOKLiwwblvx9oYVErrgi9qr2gL/+yj83fnzUEEqLnCZLxIVsrrTApQO7n5WNtvLKIjvumDz3xRciG24o8tZb6crA377DDiJjxojss0/u/BZbWNPhySdz5yAd0SxwYXbuLDL55LbzoEngsXjjjeLPmmYaa6rMMIPIVFNZNyjC6ocfrIkycmR17YGmgznUpYutK52d98LNigBMi59/zv0/mhfkK+456su34/e337YmWKWgzFlmEZl6alsuQpp2/Oqr7Dw+tAOcULduItNOayeKESNypCF9kW/og/r8O6o6Jvs/fT/kpnX79yKLWD6LcrmW9v/wQ/teLQiWYR9FE9TsCdtvL3LkkdUJBBr1kktEhgxJdz02fteudvBg+zP4iKjjw9J57r9fZL31kpJ9ueVEXnmlsvr55d13n8jee9tzCBm8FggD6uODeIaPPhK5916rtTC46RTUZ911rfDiXjpLyJuBYEKIXXmlyLXXpq8znR3TBxfr7LOHTSc6JR0SoXP77daE+vZb+9tmm4ncemvy+t13twNo003toKVMn3mnvDffFLngAquFpannOuuI9Ool0rOnbQeEjA++62efiTz1lNXSXn45fVsgrGnv1Ve3WiOCl+cqyTx8uMiNN4oceqj9m5gUhPRssyXLoW3oY5DNbt+l/TbfPF+DmH9+kf33txPInHPavuprrEwYd98tcvPNls9SgcPEw3djgqH8oUOzGK2jBYFgrJytzXH44SYTnHde8edMPbUxO+1kzMUXG/PWW8b8+Wfy/r//tufvuMOYceOSv51wQnXvOPPMxowdmyzTf34afPutMWedZczLL1fWRg89ZMx885Wu79ZbG/Pll+WXf889uTI226z6b3rbbcZMM03xul56aWVln3OOMVNMUbjcnj2NOfhgYx5+2Jh//ile1o03GnPUUZW/59dfGzPppMnn77KLMb/+mr4M+u9WW9l7+/c35plnjLngAmMOOsiYm26y5VU/XkfVXiDsv382AmHw4HD5001nzLHHGvPpp5WV+/33pTtlmuPMM01dAKHSo0fhep56auVlP/ZYtgIBjBhhzFRTFa7vsGGVl/344/kDkWPhhY0ZMyZ9OXfdZczAgZXX48MPjZlkktzzGdiV4Jhj7Pscd5wVZj/9ZOvGJDBkiDEzzVS1QKg9h1Bu0A62JjZVyCvgAzXsjDNsVGGlQL0fNar690SlRP0rhV9+saoj6mjIDi3VNl9/LfL771YtRWX12wp1F9MBNdTnXOA6Bg4Ml43diumiPAB2NGqs2sVKqpYL6sDhqtEu8Mqcf77lY0LwzaxPP7XuYEwEyqUdqSdmmY9VVxW5+mqRLbfM52TgIErht9+sqYlKzvMwFWh7zF/ex3c/8xsmYJPD1VM/VH9tO8y/QtGMXMf7weHQ33knt56UzXiiXvBHmHTUgT7Fb1wL71PXpCK2J4RdMVJFgf181FHW7vZBvIAL+IQDD6y+fsQPZAEIIOx5BqQ7gLC7ETrYzXwsPiYdmQ/LB4Qj2HNPax/7oDPCa0BQPvqotb/pBHQYBAH2+mqriZx2mh3A7iBjgLkeD0hDhKcPBtfZZ1s7lU5G/bQjw8NAZuJ12Xhj20mxXwt9S4hOojefflrkuedEPvnEvgMDCOFHveAZ8ND4PNM55+Tb/fAPDMY777Rh4pQNIYnQcoUT7YBwpOzddkuW0aePnThcviPkIaBtKf/55y3Jy8BUITB6tH1vuATu5X3gHHAzu8D7dN11SYGA4KBNlT/gW/uCBKL1iCNsX+T9VIDCY8ATUP/evW0b0p6875JLWl4F4Ya3i3p//HH1/bjmJkM5xzzzWJXXxyWXJK+75prittbdd1sVr08fY1Zf3ZhVVjGmVy9rvlx7rTG//Za7nvNZ1f+FF5J1gauYY47S96Eyv/lm/ruktQuXWCKfw3jyyeQ1V1yRX/599xnTuXO6Z3TpYttx4okLmwx9+5Yup6nJ2vc+hg7Nv7ZDh/K/wd5755f97LPJa5ZbLv8aeJVynrPIIvllqI1fTh/56itr9pa6D45srrly/AfcyvHHG3PyycZceaUxc87ZIBxC2qNTJ2M++SS/kV99NWkHQqQUwkUXGbPggqWfNfvsxpx+uh2wEDRZvQNEjy8QFl003b0bbphPbg0YkP7Zl12WvBcbuXt3+9sMM+TbzO+/b8xkk1X+riGBkIbQ1OO995L3fvFF2N6v5HjqqWTZf/2VG0yFBMKWW5b3jJVXLl+AQ3L6XBf9uZJ3pK169zZm441zQjoDgVA/gUmohPiYfXsbVQm1DRA7sMce+feiji+/vFUZUb9KATX5kEOsul4qBiAtUKdRsfMcuykTXjAt/LUEeKe0eOCB5N+YI+oWW2ONfJv5zDPzA6+qBS6wtMAMcIE7EV98FvBdcJhnqNhFjecWCtr1+0OlOTCMiTvusKZehgFR9SEQSBAK8QYMfs0vh4yhE/tgUY6117Y2a7kgfx3bKwvQoSG3KgUf+KefkufKSbaCWygUKIO96z/L52RaGu+9lx+cUw057IKYjtD3aW1AOsJHuCAy9qyzqus7GaL1cxmYvUgh9nH66ZagUXBNly75nYrgnXrIHSB4JuQdKSf4yg/eKsdDU0wT8UO0CeBp7SQsf2CoZ6MYINWWWkpkpZXsAIJcQzOj3SHiYNpVqNKWLrkH+VYPeOghkUUXTZ7bbz+RnXe2wUcEuXEouduuBAIhs7iFfDDba1QYgGll/b4EG9ps8Wy3Xf0kEsEeZ61OluPmCwkE9Qb4pgwsfTWRo1mgHHOFqMeddhLZZRf7/2kEr9929bJWAd4UBj/CzAWeB85z4G1DcODFwLvUgqtzta7JcMMN+aocbhdcRS4IsfXDOnGhZeUyrBaDBokssIDUHTQOwY93qAchGhqgIQEIb8TCNccfbyeGtFpYNcK1liAUGa222NqTmMe8N6HduJ3RINq8QDjmGBs84wMJ6Sd0QCz6swu+83oAHxf/cz1CB0FTU1hQ1DvQusjRCJG1gJgA4gUgkjGB4JvcBKt6BRMZprIfxxAC+Q5wDMRRtADx2TomA4kZxx2Xf55zsKYuIJp89hkbq9oMvyyAyXLZZfXb8XSW9AVAxwZYBgOvABGMPphZMTNJYiKyUiM3eSdIVCIbWRz3ppvqe2k7EpXQhFnMl4mRaEr6uR+0pCCZDE7Nj7pseIFAJB+Ziz4efzw800LAuOGzwE0tzhrLLGNJOMJ/QxFtWieyGXfdNaymV0MuZvp1//u86rZVhMLA6w2HHZZ/DtKN8HCEQEhbQDCgIUBYajRovYPoSA64BYhSokLxuK25Zv61CBAySYn+bRMCgYHCy/iML7N9Icnnp5iCrGIHCqnZhPxCaj7zjA2nhdcglNRNk/U7GynIXB8SEq0FFUzEyLsgJJb3KSTwWhvMksSIuIBHSDs7snpVIy54Sqg3rnWOtdYSuegiGzrugpW62oxA4EVDwTbE3RNHH4If7AJ/UMvNQFhkgwGE7cYBp1EK5DEQV47KxwerNw4B+5oOpiAYho5Wr0vIMwn4qjMmQFqEPCiNJiAIVCO+BtMIktHVTlkPwo9ZaTiBgLrjriykIKmDVY9L2cGuSp4mUUqBTUkmIqYK9xXqGER7oa7R0GlnTsqDQyCDkKjKDTaoTw6BTrXXXrnzmGAIiHoVCCGTq5xvzv1+dmVLCISsXbkQpvAobpwO2l3DCwRm2ssvzz9P6OUppxS/13eR4X4sRLwU6hxkBKaJ+kMowMj7Lk4fmBCQnzDgDLZ6n4XgXPBlu+7Hffe1abhZhy9nAUxI6ut+s3LCuEkb9r9F1gOIvoIG5j6nFt6bkIu4hi7U2rsd6YSoe/4ghkSEICkFUmndBoAoC+W+F1Ob05gY2P/M8sQTuBFzBEmx3BfLm0F0EZFI+i6mhCsMavyhqgJp18R8+IOG/JG0azJoym1LEHUMXvJTXKC9pdHAqB8p9D4Icc8SmJWkIrvweY8QSEPfeut8ojwEyF/fZEVY+pxQQ2kIBJQsvHD4o5OrEFpn0B1g2Lu6d54CT4DfwasFAgqwqIbb6VHXfFdoI4L3YJs6992I70DgIuyIjPPjP2h73GJs7NqvnxWsK67YMvW9+GKr2bmaHmQa8SdMMBDLrmmHKg0zj1nKugsuICRfeCHb+hHzgLdjvvmSXBj1IrmKyQUQWUn/Z/JAgGC6IoiJRWAbAHJp2CvU1WAQBJh0mKL+2hHkoITyVhpGIDB4Q2DRB45KwExx8MHZ2WyUg/qvM5ECdbqWHo2WBD57It7Qdlzgs8erwqyDKYSLEjUYzQGtgIGmYAGOltKC4H0OOsjmLijgBchSxdxBeDHodPUi7OpCCUy4s7OuN+YBgokt/VztBPchfVMHOIQg7lCdFNUFzHvpu+nCN9r2eOEKJXrVOCCv9gKhFmGySGV8tVnN3MyQDBjiD4ggU+BybPDdfBO48EI765Nd6gNXHUcxlLvVXTVgALMiNLH8foowHI/vjiuEwYPtxju1AKt2UUffhMVL4rrLWcpeuZqQyYUWwVEKBxxQ+crgdcMh1KoTnXhiNuWgAWgiFQSna5qEEq+KwWe26bjlBCn55lM5bReKPgydw6vDMmOh4J5ScF3DoY5dzruG6ua3H0IaEy6UzpzGxkfwhQKcQvWshBthVkejLLUGh2ZkApZqT7v3h6up8i6EMNcYtdcQUDOZ0avJ2MLlxCzhDhB8/kho1MpKgW1J/ACqGnHzrBuoIEX4qqvKHzAkr1BfvBWksKIupp0RcQMyUKgPJCyBKmmB+gx5SDtTFm1VSDsjUhQPD5wCmtayy4ajFymHGAsIV0g51oZUEA2o+1yg5lLvtO+qg4n3o514DveHNnDB9caaAdjUfB9IXbxWIdDe1BMfPmG+fItC1/Fs3QAIwV3pQruEIGMWk41JSL7Le2gbws+o25TxgJmGZsE7IfBCwXcqEElwgpMgmrEFUPuNWuhouhtNNTY+9lYoXqF//+L5BKwUhAT3VTJCkwkiohOvv36yswNINHc9hjSgYzHLU18GCXYmRFJadxRCgDK0k3Jv2rx4BhS2J/fSCZnx6OSl2p16YudykI7OfbjUGJxoEdjCIRKL63gexB5lMLA1ZDhtfXlf7qW+3I9wKRUDwvdkAxjqC8fBoGYGRRhypNnpiHsoh2fzragLArXayE3egWhWVv7CU0V7IFARaoX4LrgPiEb4D+pEXbgPYcb7hNaNqB1G19ciq6WOo48Or6V42GGF72ER0ZEj7XWsY89inmuskfu9X7/8TVVY675R2iQe8cjuGNVYAoHj0UfDQuGGGwovsMrKy8ssk9zJZ9ZZwwu2fv55FhtexCMeDSkQam8yZA3UKrwLobUUUFdxV5Fnjr8WdctX1QgewRxgBSZ/yS72j8Cmgz+IKAzMBQ2sCfEUqM7KSWDyuN8A8xG1GPXczcLken/dBv8a1zQLbfySxqOlAXJ+vdy6w7/4kY6h66lDsahW+qPyKm6bhbgaylfTyedzeG7LLKk2uvE0BF2jnj35iuGHH4x57jm7l+Ptt9ulub/5pvh2W2mXTG+vB/sk7LFHcl/IBx80Zuml8/e6pP3Z03DeeZO/XXWV/e2QQ3Ln2OaMb8V5F999FzYHjzjCXvv77/l7O8w9d7juCyxg92h0l6FnL1D/OjRH+oJfl9dft0ueu9dSN3c/EO5x9/x48cXctdtsY3//5ZfwdoLTTmuvo73Ym8R9Psvzn3RS7ppoMhQ42NNxwoTq9xdkExOETBz0xQ/dIIe9MnbYIbffIR127bWT+14ofDPugQfseTYYcfcYQHjopr6UzfHKK+FNXNhTA7zxRu7a006z59iwZv75k9cvu6zdmwGwWQ/Xv/22/fvEE5PXsrGOgj0UuXbffXPCZ7vtctfybvp8Nq5VQaPn1lsvd+1uu+UGv/6ux+ab5/Z+pEwF7cvvl19u//74Y2NmmSUKhKLHiitaLaASsLvRppvGgZ7mmG0222bjxxvTrVv+LPnuu8lZVjdIYZchtxwdOIMGJQXCBx/Y8662Qef/4w97np2S9DyDGLA5jVu2agAIB/c8OzeBXXfNnWODX90lbLXVksJMN8xx35N7wUsv2d2n/PZB29CdokPtt/POuc1ti7Uz7aUah7sBiwqFUrugt5mNWirFiBE2Jh+3JCGq+GsLuWqwMXEDsS4DEYnwEDVcbKJNQe157H8WiFGwXD6h5G56dTXApajAhaih4/juSwVyaQCTG+5MvAqL2hCf4bqRcclquLofQq9cgeuq1ghBojmbmsLuw6wD8dz4hHPPtf+SGFVOtm/dBSa1FAgz5iCZijhwshb5eBA/+OLxpxNEQkBKNTER7RVE2DHoSTqCuKVjkgNB4AxrXGYFTQrSGAkdFBC+PnzCkUxC4Iaba04Afn0/1VuDkfwBpoSiG5lJIBEglbya/sPK0f4O3CQ7hd7PBUvD8VwED/EfNVo5u2Ob67goPgSCcERkC9a0QCMjuYil4khfR8ASRq6zbbVgUGuEIYlDaAxESobW0WRw6I5HCy0kcuSRuXoqdPCiIfieA/VU+FuhMdhYqYsJBs0I7wArP5MTwfLo1YCAqlNPTZ4jE7OUQNBQb7SXGu6p0TH28oiywG5ZhHmTZsxemiSGoSkw2Nzt510BHfrbzyfQ8/4CvLiYSZMPzcqEXbtbAGIOsrw/Kd3+QGLw+3VRQeDnVWjd0CiJ0sREILW6Z0+bCl7N2goIGdekSQt9f+rS1BQFQkQrA1scWxuOBt4FHzvLezFgSAI78ECb++GuXYGQ8Aey/u3Pcjp7M8ujEahKz1oBhfDYY9ZE1PLYq9PPmSH8V/kAhIJrNujiML4poXEAvK/u84BmgBZExih8RqWzdKVp2BqmTZu4ZlUUCBGtAmL0mX1ZscclYtU0Q8XWQQ1fw4FKj6pNko5COQF/RSR3kKedgQkg04VtCoEENp5PijKJUW4qtO4QRjKUCxVq2PsqEHRTYHgpgpEqTdYrh39wV0ZCONG+vG8N8xuaYk+PSAW2m8fWxQYm+45Zkk1XMRkAyWKa2IQNrvY8hBm7W3E96bsw/ngO/O3rVatwF2Qp2Gv/67bFVttyByB7OQAyPFH9qQuCAeIZzwMrF4Xq4nIOuvo35kVoltc6FVLntSxmep7vHvAf/jMpB08Yv6N9sSwc7VrrXcIaPg4hHi13dO1qzNlnGzNuXC6Wg8g8YhFcn7keAwYkoxo1dqB79+R1xCGQQwJ69y5dj8GD7bXENKSte69eNtpQQYzEkCE2+tK9rkeP3DVLLpmMw9D3dpPj/HiM4cPDz+/fv3A8zOjRuShEIipDINZm8cVjLkNEHYI0aVRnuhCuObXTQ8ClRzowMx/p3KwHEJo9UelRxXEZlnKpkS6MJgF/UWjNg6CB3NFqBTwPdTxUb3IO8HRwDaaGyy+wShO8A6nhuGFdYBrhEaHuoVW2cBXq/go+oYong1WV0LBoA101Gi2BfyE/IThrj9FRIERERPxfIEQOISIiIpKKERERUSBEREREgRAREZEGkIrEb8YApYiIiAkIgpHNR+fYFhER7R5j/ifAAAu+3z0PC2TkAAAAAElFTkSuQmCC\", t.LicenseBannerUnlicensed = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAZAAA/+EECGh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InV1aWQ6NTgwNmJkZDgtY2Q5YS00NjcxLTllODUtNzA5YWVkODQwNjhjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI5RUZFREM2RTU5MzExRTc4MDU1QTE1NTdFRTNGMkY2IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI5RUZFREM1RTU5MzExRTc4MDU1QTE1NTdFRTNGMkY2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIElsbHVzdHJhdG9yIENDIDIwMTcgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTNCRDY2MUFBMUY0MTFFNzgwM0JCNjkyOENBMjM2RUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTNCRDY2MUJBMUY0MTFFNzgwM0JCNjkyOENBMjM2RUEiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7QBIUGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAA8cAVoAAxslRxwCAAACAAIAOEJJTQQlAAAAAAAQ/OEfici3yXgvNGI0B1h36//uAA5BZG9iZQBkwAAAAAH/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgMDAwMDAwMDAwMBAQEBAQEBAgEBAgICAQICAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA//AABEIAEgBBAMBEQACEQEDEQH/xADUAAEAAwEAAwEBAQAAAAAAAAAACAkKBwQFBgILAwEBAAIDAAMBAQAAAAAAAAAAAAcIBQYJAwQKAgEQAAAGAgEDAgIHAwkECwAAAAECAwQFBgcIABESCRMUFQohItUWllcZMRc5QTJCI7Z3tzh4UXWXGHMktNQ1VbVW1ogaEQACAQIFAwAFBwULBwURAAABAgMEBQAREgYHIRMIMUEiFAlRYTIj05RWcRUWGBmBQlJysyR0tHY3OKKyM3W1NhexQ1OTlZHRYoKS0nODNFSE1CU1hnc5/9oADAMBAAIRAxEAPwCmHnKfH3+YcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYlBrzpZtTtas5Jr9g+75HZMnHs31hYM2sRTmD7tIp7B/d7K7hagxkPTOB/QVfEW7B7u3t+nmzbf2ZundTEWCinqUU5FwAsYPyGRysYPzFs/mxBvL/AJLcD8CRo3Lm6LXZqmVNaU8jtNWSJmR3I6KmSarePMEa1gKZ9M8+mJF5Q8PvkexFXnNpter9tkIRk3M6er0Kfo+Tn7RFIgqOFF4HHdos9hIi2TATKK+0FIhQEwm6AIhsVz4i5FtNOaqqtkrQKMyYmimI+XNYnd+nrOnL58Q5sb4ifhnyHd0sNg3zb4bpK4VFroK22I5JyULPcKWmpyWPRV7usnIacyAa11UlUFVEVk1EVkVDpKpKkMmqkqmYSKJqJnADEUIYBAQEAEBDkcEFTpboRi6aOkqCWIho2AIIOYIPUEEdCCOoI9OPxz+Y/WHGGHGGHGGHGGHGGO66xYV/5jthMPYH+8v3N/exfYCj/er4N94fgHxx4Rp8U+B/FYP4r7Xu7vQ9427/ANnqF/bzObZsv6Rbgo7F3Oz73OkevTr06jlq06l1ZfJqGfy4ivnDkz/g1xDuPlX3L85fmC0z1vuve937/YQv2u/2p+1qyy19mTT6dB9GJUeTDx+/p2Zfo2Kf3t/vh++eNm2Qvj33C/d98N9xZ7JW/hHwv753f3nZ93vW9x7lLr63Z6YdncbaOSdg/wDD27wWr3v3zvUwl1drtZZu6adPckz+hnnmPTll0zMEeE3lx+uJx3dN+/o/+jv5tvTW/se/e/8Ac001NUd3u+50WjP3jR2+230NWv2tK1xcjvFy8OMMOMMOMMOMMOMMfZY8x/b8r3uoYzx/DHsV4vtiianUoJN3Hx6kvYJx4lHxUcR9LO2EY0M7eLkICjhdJEnXqY5Q6jz3LfQVd1robbQJ3K2eRY41zA1OxyUZsQozJ9JIHynGt7w3dt3YO1bjvbd1SKPa9po5aqrnKSSCGngQySyFIkklcIik6Y0Zzlkqk9Mdc2R1I2G1EsVeqexOOXON7BaoVWxQEc5sNRsJpCGRfLRqr0rioT9gaNyletzp9iqiag9OoF7eg8y249p7g2lUR0m4ac01RKmtQXjfNQcs843cDqMupBxH3DHkFw/5C2esv/Dt5S9WigqRTzyLT1dOI5igkCFauCnds0YNmisvXLPPpiOPNdxMuHGGHGGHGGHGGHGGHGGHGGHGGLoKn4E/INc6tWrhCV3FikLbICGssQdzk2NbuDxc7HNpSPOu3MyEyCxmjogmIIiJTdQ/k5MlLwTv+spY6yCOl7MsauucwB0sAwzGXQ5HHNa//Ff8RNtX2t25dKy/C5W+rmppgttkZRLBI0UgVtftDWpyPrHXHv8A/wDPd5Gv/beJf+KcX/3Hnn/4Acif9HSf9ev/AHsYn9rz4bf++7g/7Ll/8/FZ+1Gq2WtOMrL4ZzUzgmN2b1+GsqiFdm0Z+O+FzpXJo84SCCSSYrGBqfvJ06l+j/byNt0bWu2z7qbNeQi1ojV8kYMNLZ5dR6+mLs8D888f+R2wl5J4zkqpdsPVzUwaohMEndg09wdtiTp9oZHPrj3uENGtvdkI8k1hPXnJ98rypzpI2tlXV4ynOFkzimqg2uE8aKrDhwgcOiiZHZjp/wBIA557Jsjdu44+9ZbfUz059DhCsZ+YSNpQkesBumMVyf5R+PHDFWbbybvCx2q8KATSvULLWKCMwzUkAlqVVh9FmiAb1E4sb058Iu1WQNmaFTdosNXTFOFGpXlryDZ1XsK5QlIKCFscKbDzldl5Vo1n7W/dINC/1pF27Mzh0mUwtxKMibP4V3TX7lgo9z0c1LZRm8r5qQyrl9WrIzAO5IX05hdTDPTim3kb8TvgbaPCV23JwZuS2X/kyQpS2+mCTK0U8+oe+TQVEUTtBSxq8p9kxySiGByomzFonkS8yMRpDODpfodj/HsO8xEyQqlotbqGI5pmPZFukB1qVRqowXZMJSwQ51Q+Jvnx10EnwrIHbruAVVJJ3IXMMOyZ/wBDdi09Oj0ihHcrnHER/wA3EgIDOv79mzAbNSrNmRRfw7+HDcfJ+1/rK+Vl3vFTT7hkaqpaVZitZcI2OQrK2qkV5IqeYD+bQQBHaARyrNFEY0atrCXzDe9VDuLGRy+6oudKOo7SCbrEhTq7Q5okcJwFcKzZKNFRCUdJFIH9Wo/ZSaP7QMkIiBixzZfILfFDWLJdzBXURPtIY0ibL16HiVcj8hZXHzYujyd8H/xY3VtyWj47S67W3QsZ7FTHWVFdCZMvZ95pq6WYyR5/SWCamf1hx6DYJ5EdC6N5McL4o378e9MQmckZKeR7XIFLZK12pObi0fO3EPKStmLJykfX4zJGOrQ1MymFzOQTfNPUWMuqVsidbfuQtiUPJNmpd+cfwh7jUkCWMaIzICSrM+pgizQuNMhzyZcyWOlSajeHnldunwl5Kv8A4meXtyem2ZZY5GoKxxUVa0boizRRUxjikqJbdcKZhNSII9UMuiNYozNKsdf1e+XO8gc1GEfyUrr5UnR0gUNCWHI9jcyaZxABFA6tUoFmhhVAR6dSuzE6h/O/Z10Gn8eN/TRdyR7fE+X0Xmct+T2InX/Kyxbe7/GQ8RrbXGkoqfd9wgDZd6nt1OsRH8ICqr6abL8sQPzYjhb/AAneSSqZCYY8b6+PLgtKorOY24VC1VR7j1Zs3Ommuo/t0pLw7CtrFMp9RvKgwdrlATJJKFDrzXavhfkaluC29beZmcZiSN0MWQ9OcjMoT8j6WPqBxM23via+F9/2hLvCbd8dujp2CyUlXS1SXAMwJUR0kUM0lQCB1kpe/EhIEjoTliSUN8uX5ApOLLIPZnXmuuxTA4wczkazryhTD0/qTLV/Hk7C+oHX9oPBJ9H87mxw+O+/pYu472+N8votM5b/ACImX/KxC9y+Ml4j0NcaSlpt4VlPqy78NupliI+XKouEE2X5Yc/mxWztpoRtJpNKxbLP+NnNfhp9dVrWrvCv2VlothcopmWUZsLHEqrN2koVEhlPYvStHwpEFQEfTDv5HO69ibn2XKqX+mMcMhySRSHicj1B1zAb16W0tl1yy64ul4/+WHBXk3QT1PEt6SruVIgapopo3pq6nVjkHenlCs8WZC9+EywaiE7mv2cckwLrpm3Z++tMZ4Gx1YMkXJyiZ2rHQqTdJnFRxFE0VJawzkkuygq3DpLKkTM7fuW7cFDkJ395ylHEWLbt63NXi22KnkqawjPJcslH8J2JCoufTUxAzIGeZGJB5X5j4x4O2pJvbla80ll24jaBJMWLyyEEiKngjV56iYgFhFBHJJpVm06VYi3xh8uf5BHkQSScSevsU9Ol6hq+/wAkWFSXSP2gb0DrRdCkoAVev1epXxidf6XT6eS5H48b/eHuM1vV8voGZ9X5M1iK/wCVl8+Od9X8ZDxGp7iaKGDd09MGy94jt1OISM/pBZa+OfL19YA2Xqz6Y5trxpDshpL5LdG6zsNR21VWuGcqs9p8rGWSvWaFs7KDnYtCVcxruCkXqzf2KsmgCiTxJq4D1Sj6faIDzG7e2TuPZXJFkptwQCIzVyGNldHVwrKGIKk5ZahmGCnqOmN15h8n+GPJzwp5RvfD90evjt21qpKuKSnqKaameeCVolkSeNA2sRyFXhaWM6WGvMEYuZ8zHjP2u3p2oxXZ8F1esnpVZwZG1edulwuMPXYZhYS369SxooGJTv7Q9WJGySCxlG8csgUqgAJwN9Xkx8xcbbq3xuilqbHFF7lFQhGkkkVFD92VtOXVz0IOYQjr6c8c2/huebPAfizwPfrHylXVw3NXbpkqoKOko5qiZ6f3Chi7uvKOlQGSN0CyVCOSpIUr1xTzlXwA+Q3GdXf2iNrmM8sljGyjx3A4qvDuTtAtkUxVXFhC2yu01aZcpkKPa2ZGcu1jfVSSUMIFGIbpwJyDbaVqqOOmqwozKwSEvl68lkSPUfmXNj6ACcdFth/Fs8P97XyKx1tbe9vtO4RJ7pRJHTaicl7k1JUVghUn0yTCOJB7UjooJFLD5i+i3zyMk2bqOko504YyEe+brNHzF80WO3ds3jRwRNdq6arpmIomcpTkOUQEAEBDkMujxOYpQVkUkEEZEEdCCD1BB6EH0Y6XUtVS11LHW0Ukc1FNGrxyIwdHRwGR0dSVZWUhlZSQwIIJBxc7ifwF+QvKVdi7O6rWMMZx80waSkYjkTIzUsg4j36Cbpm5UY0SMvSzIV26pT+k49JcnXochTAIcmS1cD8gXSnWpaOlpo3UMvdmGZBGYOUQlyzHqORHrAxzY398WXxA2LeJ7HBW3y91lNK8Upt9ubtrIjFXUPXSUIfSwI1R60b0qzDrj4XYfwk7+66VKUvkrjyvZOqUC0XkLBKYcshre7hY9sQyriQdVl/GV+3umLZEhlFlmke4TbpFFRUSEATB6O4eFt+7epGrpaeOppIwS7U79wqB6SUISQgDqSqEAdTkMbVw/wDE48S+Y9wQbVoLxWWPcFXIsdPFeKb3RJpGICxrUxyVFIrsxCoktRG0jEJGGYgGrqmUi55GssXTMfVKy3m3zixm8NVqhBydksUsuRI6yiUdDQ7V5IvVE0UzHMCaZu0hRMPQAEeRhR0VZcalaO3xST1bnJUjVndj6eiqCT069Bi9G5Nz7b2bZZ9ybuuFFa9u0q6pqqrnipqeJSQoMk0zJGgLEKNTDMkAdSMWwYt8EfkfyYybSb3E9dxdHuylUbq5SvlfhXpkzFA3c5r8CtZ7PGmAR6Cm6ZIKgP8AR6fTyVbXwZyLckEj0kdLGfR35UU/uoutx+RlB+bFBN9fFU8Mtk1L0VNf6y+1cZyYWyhqJkzz9C1E4pqaQevVFM65fvsSu0n8Me52MtxsVZFmG+LZWm687HUBTIMxBXtRX6lZUp94mBgo+VhIiUkvbw04iUvcgj6i4HKXqUAMbatl8Obytm8KW4zClajt9xi7rLL/AAO3I2kMqsclYeoZnMD5cQH5NfEm8bN7+OV+2dbnvsG494bMrxQQz0IHWpFXRQ9+SKaWKPVNA5OTvpQqzZElRZR5qPGbtHvJmTD92wLFUuQgqXjJ9VpxSz3BpW3Kcs4tMlLJkbN3DdYzhAWbkgicBAAN1Dkj8zca7n3veKOtsSQtBDTFG1yBDqLlugI6jI+nFK/hoebXBfi5xxuLbPK9Rcobpcr2lVAKakeoUxLSxxEsysNLa1Ps/J1xlMvelmxFF2ikNOBo6twz8wkYKLCn0R0nZCPHVgqcTdmh2smkDdmDFpXJhNy8dLGSbMkyKnWORNI5wqzXbM3DQ7nbZ/YM1+VlXtxHXmXjWQZHoMgjAsxyCgEkgAnHe3avktw9urguHyOF0W3cSywzy+91ymmKLT1UtE4aM6n1vUQtHDEgeSZmRY1Z3VTZjDfLr+QqUgk5d8pgiuSB24LGq0zkuTXnUlBL3e0UcV6nT1ZFwA/V6lkTJdf6fT6eSTD49cgSwd5/cY5MvoNMS35M0jZM/wDx8vnxSW5fGJ8QaG6m30o3VWUgfL3qG2xrARn9MLUVkFTp9eRpw2X73PpiBmR/G3uPijM8Vge74jdR18nYN3aYMWc7X5qvy9VZSLaHWn2M9DST5kqgeXfN2aTURCSXfum7RNsd24RQU0W48c7wtV5WxVtIVrpELrkyMjICF1hlJGWohQv0yzKgUuyqbXbN80fHHf3G0/K22NwpNtWlqkpZ9cFRDURVTxtMIHgmjRwwiSSZpetMkEU1Q8y08MsqReyria94WtzqkZDhhhZ5qmosCZHLZ61coIv30S5UbOmiiqQrR8zFu2D1ufsdR8kzcsnaSDtuugnrF0tNdZqs0VwTROPnBBGZU5EfIysrA5MjqyOFdWUTnsPkDavJe3o9z7PqfebU5AzKsjKxjSVQyuAcpIZYp4ZF1RVFPNDU07y080Ur835jsbnhxhhxhhxhhxhiyOA8vXkdrEFC1qB2htMdB16JjoKGj06pjZVNjFRLNFhHM01HFKWXUI2ZtyEAxzmOIF6iIj1HkjQct8i00CU0FzlWCNAqjRD0VRkB1jz6AZdcUvu3w8vDS+XSpvd12NQTXSsqJJ5pDVXEF5ZXMkjkLWhQWdixCgAZ9AB0xrp0Pu+yWCtN7btx5Ls+WF8eWriF8b1OzwtWgy4toCCIng2bmOr1fg38jke+uXqPSOVMqskdVmyTSTeGcEG2exa3cdj2fLuzkmvkYvGJRG6ovYiH0QQiKTNKSPYOZGaIAHLDHz2eVe2OF+VPI+3+PnhRtOjiWnrWoWq6aaqn/OdexyndZKionSO3UCo+dQoVGCVNS7vTrCwgBpvrfB+UvPuTPKVuJVIiNwPGyrmuYDxJYBaI1mQquNQXajaMjvlhSZztZqhkFiuiLHFnJTJXvrlTYNCNV9C2ftyDlC/VPJ+74kWxKxSlgfLQUhzGuYnoyJkdWfsvJr1ZRoFa23kdzNdPBPiayeCnjnX1E/Ks0C1F9u1PrNTHVXLS3u1uRc3gqarUhiKDu09GabtF6udp4vg9vfmL06VY32NNHMX0qXqdVOMC1ynkRjLDX5ZCOAGSf3Bx7X39ZVj4BsRAAZOnzvqsl06sEilDv9DdvkMKKoa27IpYXpIvZE8obQwHT6qJCmSDL2WZuo/5sD07X48fBwfc1mi3r5RXy509/rx32tdveL3iJpPbPv8AcKiOpEk7FvrooIvYbP8AncjE6Y7YS+ZR2Zr1mYkz3iXFeSKOs5SLKGojOcoN3YtlDlIs5jHj2eslbkDNUhE5GqzFAVzB2C6RA3eXXrL5H7lp6lRfqSlqaIn2u0GikA9ZUlnQ5enSVGfo1D04mHk74LHCV3skrcT7gv1l3QqExe/PBX0TsBmFkRIKepj1H2TKk76AdQgkI0nPVke2L37Id9vTpw8durpdLRbHLuRAgSDpexzj6YWcPgTWcEB4so8EyvRRQO8R6GN+0a/3GravuE9cxJaaZ5CT6SXYtmfT1OfXqeuOvmzNvxbT2fadrQJHHBbLbS0ipHn21WngSEKmYU6FCZLmqnSB0Hox8Zz08bLjcv8ALgRtsZaHW93PFdEgZjYq9P6QDoD9isKhTsdRUo5jzG+r8NNaY5+l0L9AOkVx/aI9bu+OsdWmxZnnz7D3GUx5/wAERwqxHzaww/jBsfLf8ZqtsFV5WW6ntRjN2ptnUMdbpyzEzVlwliWTLr3BSyQNmevaeL1AYzR3by++SOZtcq+W2svbAzaWeFbs4CKpdbikU0HKqSKIRMDWI6OVRTTKAdFEj9/TqbuHqPK3VvLnI01UztdZ1yc5BVjReh6DSqAf90flx2v2x8O/wwttggpYthWqUPTpqeeWsqJSWUEt3Z6mSQEnrmrDL0LkOmNWPio3azlt54/cpZJyHMRj7NuKJrJlBZ3c0HGNW9ifwmP4K6VKzTcBFoxsKLxqvaCNnKLdFui4IyA4gB1Tjy0vFu9L5u3YNVcbg6teqV5ohJpUBysSyRuyqAuYLhWAAB05+knHBTz08ZOLfHny4sWy9n008XGV/prbXvRd+Vmp0mr56OrpoZ5TJNoZaZpY3keR4zMVBKooxk3tXl78kNvmzzz/AGtyDGODLeskwqres1GEQKBu5NAkJW4GMjVUUwAC/wBamoY4B9cTCIiNVKrlvkarn78l1qFbP0IEjUfNpRVGX5Qfnzx38sPw8fDHb1sFqpNg2ieILkZKpqmrmbp1YzVM8sgY+n2GUA/RCgADSjh7Kk95L/CLnmZ2JTjrRkKnU3M8evawi46OUkbxh2vfvBoF1Iyj2rVjFyqfqsEXotCIkcARwAFIRc6YWPtF0n5J4Vr5tw6ZbhDDUAvpAzlp07sUmQACt9ENpAB9r0BiMcWORdh2rwn+J3tS28Omah2hcblZ5Fpe7JII6K71HuFfRF5GZ5YjlO8PdZ2jzhJLNEr49LpIFW8Yfhem9uGVWiZjKuRKcxyxJLSJDFCxT98sban4SgH66B0ZJSqQUdYY5yu1SVIIC4fqpGTMuY4eDZXuvGfDb7sSJHulRCJzn+/aVxHTISOuhQ6EqCPTIRkWzxk/Jz8++cPxKaXx7qq+op9hWe4vaoxGQfd4KGnarvU8asDGKqeSnqI0ldCMo6SNw6xBTm9t/ls8i9ztLq2PNrMmwjpw7O5Rh6g+ZVKrMU/UE6LNrWYJkyhztG5OhA9dJZRQodVTqGExhrpV8sch1lUat7rUoxOemMiNB8wRQFyHzgk+sk47Obd+H34cbbsMe36bYVkqoEjCmarR6uqc5ZF2qZ3eYOx6nQyKpPsKigASL1l3j2O3J308drHYi4ML5I4kzjEsaxZQrkJAT7plbZutKP206eus4uLlBamraHore1I5HuUFZRUTAJdi21vfcW8N97eTcMyzyUlcoR9CqxEjJmG0BVbLQMjpB9OZOIb5t8XeGvG/xR5iquHrdLaqPcG15Xqab3iaeBXpIKkRtAKh5ZYtXvL607rR9EEaRgEG23zueQ7bbVTNmLsRa+5PDGlXteH214sDuLrFVk7E/mHN0t8CKac5YoeZdRbJJlBICUrP26neJxMcwG7QljnPkHdm1r1S2mwVXu1LLRiRyqIzljJIv0nVioyUfRyOefXHPv4Vfh94+89cZX3kLl2x/nu+0G4moqdJamqip44Vo6SfMwU80KyuXnfMzdxdOnJQRmYUeKzy8bjT232I8LZzyrIZgxlmOzkoz1pbYyDPO16cnGrpGuTdfsMfGMJVIU54GyThs4VcNFGiinamRbsVJpfFvLe8J93UlmvlU1ZbayXtESKupGYEIyOAG+lkCCSpUnIA5EWa88vh5+OVq8eNw8l8W2GHbu99uUJrkeklnEFRBAytUQVFPJJJEc4O40ckaxyrKqanaPUjcq+YdwhWMWbyRd3qka2ikM54shb9Z2zRAjZuveo6dsFTnpMiKRSolVl42Fj3Lk4AB13qq6ynU6hjGxXkFZKa173WtpVCrXUqyuAMgZQzxs3ye0FRj8rFiepzxvnwfeT75vvxdn2xf5nnl2tfpqCmZ2LMtDJBT1UERJzOUMk1RHGD0SFYo0yVAo4jV9yPMltOVBLEF52luERAt2kMghgCmzMBXIJpHtU2zNi+f4vrsWyRFFskUvqP3B1lB6Cc5jj1HC0u8OYd0ZC0T3SaKMBQKWNlRQBkATCigdPWxzPrJOJPvvjh8ODggvJyJa9iW64VbvMzX6shnqJ2kYs7pHc6iVzmxJ0wRhFHRVVRkL0/Ehl3yuweby4f3YxvnqwYct1YnXMHkXKlLkTvaFb4NiEyxLI34zH3K0NZI9quzFvJrqj78zYG50jCqmtOHE925Ugvf5o3pTV8lnmiYrNPGc4pFGoZy5Z6XAK5OT7WnSR1DcsfiDceeA104wPIvjLetp0nI1vroFnt9rrIwldSTv2XMdBr0iamkaObuUyIOwJu8rgRvFwbGWCKpr98x+2rNFjG0HULdXL7k+Hg2SBGzGIXveB7VJ2NkwbpFTbto773FkFGyKRSJN0FCIkACphzBW2xUtg8ihTUKhKSaOWZVAyCmWldnAHoA7msgDoAQB6MSvvflW/8ufBle97pneq3Db6ygtk07sWeVaG+0sVO8jElmk9093WR2JaSRWkYkucc980nkm3VwJuRbMF4YzfLY3xtC0ygyzWKrddpyUoeRsFeQkpJ0vaXleeWcfUcKj2pkeESIXp0L1+nmP5l5H3nYd4S2OzVr01uSGJgqJHqzdASS5Qv6fUGA+bG3/DU8LfGflfxwt/KfJO16e9b0qblXxNLU1FYYhHT1DRxqtKlQlN0UDNmhZifS2XTEBfH55AN0LNunrpSp/ZDJ0vVcpbH42LkODfTZV2VuLOTtcr8sWZKdv3uQfQkei2P9YOqSRSh06c0PYO/t5VO87dRVFxqXpaq4w91S2Yk1MiNq6dc1AU/MMWy8ufEnxqsnjRvHc1p2ZY6e/WLZlxNvnSHS9J2IKioi7JDZLomkeReh9tifXi1vz9bi7Qa2Z3wZXMEZtvWLoOw4kkZubjKpJEYtZKWSuMqxTfuiHQVE7gjNEqYD1D6pQ5KnPW79zbcvtDT2KtnpYJKQsyocgW7jDM9PTl0xQf4S3jnwbzTxVum88q7YtV9ulHuGOGGWqjLtHEaOJyikMMlLktl8px8T8vBdXOdtntwM3Zptbm/7DPMeYvZRtqsy6Ly0SFUWdyMLbXSaokIcUmKdVq7JRQhQ7EvSII9DfT6Xj5WtfNzXe9XmU1G4DTwgO5BcpmVkP7miFSfkyHrxs/xhNsw8V8Hcd8Y8aUCWniCO8XN5KWmUpTR1QSOakUjMjNzVXOZVJObdxgPZ6Rx8kOdvNFhPP8Ak+12u2Z2xvh5pdbCpjecxUiujhZvQiSrsKgmrOVVmtDneqQRUTrpTygShle8V0wHqAa7yNfOZbLf6qqqpa6mtAmfstBn7uItR7ftINOenLMSnXnnqGJm8MeK/hq8m8S2OwWG37VvXIslspxcYLoVN5auMSe9kQVTiYIJy4RqFfdQukROR1Nd8j5SNqbtkKjZFzBaWuSbBR6NK45ZznwqDqFqUrUlaq9d2rlCbrsMjHt7RXrXVY96wkVY9yIqN+12m7SOomePZOT901twguN3lFTUQQNCG0rG+gukgIZFyDo6IyuUPUZOHBINwaPwV4G2xtC6bO47oJLLaLpdIri8Hdnq6UVMdLUUTK0NRMZGpailqp4Z6daiMaZNVO9PIqOsU9gM5TuwF9PdpuMZQ/pNpFoxYNDJLLiM1a7NfLDLTD9BnHISU/ZrtcpWUfLItWbX3L05GzZs2Ii3T1a/3ue/1/vs6qmQIAHU+07yuzEAAu8kjuxCqubEKqqAonviPi618SbUG2LZPLU6njd5HzVfqaWmoaeKFGeRo4Kaio6WlgR5Zpe3CrTTTTNJK/D+YTEoYcYYcYYcYYcYY0XeCzxllz5dmm3ecIAqmEcZTYmxtX5lsHsMn5FhFwOaWcoOC+m/pFCeJAZbqHt30sQrcRUTbPURsNwfxr+fq0btvcf/ANEpn+pRh0mmU/SIPpjiPp9TPkvUK6444/FN83DxPtiTx54vqyOT73S5XGohb6y2W+Zcu0rKc0ra9DkmX1kFKWmAR56aQc4823k0Ntpk4+v2HJ4Vtc8Rzq4O5WNcCLLLWRY/1mTu0Cskb0nlRrYnVawoF7knJjLPu5QqzYEMdzVyV+ldz/MFnkz27SOc2B6TzDMF/njTqsfqPV+oK6dy+GN4SDx/2OOXOR6TTzJuGlXRFIvt2m3yaXSmyPVKupyWWsJyaMCOlyRo5zLbd5G7A81V8GmFsZY5UNDo3+mYBw1LyMab0Flo60Utze7+7FREQJ1u61beoPunUqyUmsXp0P8ARLHIlQ+1uEaK2W46FqIaWnYjp0eMyyn/ANZoYN8odvlxz68NbRT89fFH3NvfeSioltFyv14hjk9oCSmrFoaBMj1/mQqYXg9aNTRH97jFVymWPphxNuq+N3e28VKs3un6tZbslQuUFEWerz8RXReMJuvz0ehKQ8uxOkuJzspGPcpqpnEodSHD/bzdKXjnfNdSRV1Ja6uSkmRXRlTMMjAMrDr6CCCMVjv3mf4rbX3BXbV3Fvvb1FuK21UtNVQS1GiSGogkaKaJwVyDxyKyMMzkQcd21h8TGw+es7W/WvIDSR1vy1E4Ke53qUblWryZI2z19jf67QBRfKxqykpCsXsjNrCk+Savg9RgokKI9wHLnds8U7hvt8m23XhrddkoTVRidDk6CVIuuR1KCWOTBW6qRp9YivnD4gHD3FHFdu5p2jJDvPj+o3Uljq5LXVRmSmqHoKivzQSKIpnSOFNcDSwezOjiUZaWsbw98tXmNKzpyezWf8SVHGEOcZCfUxQ8s9ksj+JZdV36SUleKfSICrJqtkzf9fXLIFbB1OZscA7RkS0eOF4FSJdy19JDbE6v2C7uVHU9ZY41Tp++OvL0lTimvIvxqeOJLI1DwjtLcNx3xUDtwC6pTU1NHK/soTHRVdbPVEMR9QhpzIfZWdc88aTNJcwao2usWrA2nzqNk8W6smrONxlq2YHlOcysiykZR0hXrAZZVS3rpqonXkZcBUSfv3SipVlzCdQbG7Ku+1aqmlsW0CrWu16IdSdYyxBYhHz+sPTN5OoZmJDN1OOLnk5x1z5Yb5QcreRUc0G+t9ipuPaqfYrFijeOJWqKfSBSKQQlPSHS8EESI0UQCoP5rs//AOOzX+9pL/ti3OcU/wDp3/jn/lx9ptp/+1U39Hj/AMwY2N/L3/w6dqf75smf4GY25b/gD+7y6f0yb+rQ4+cn4vH+MbYf9m7b/tu44xncp3j6RsbJfEL/AATttv8A7Yf4IQXLg8Sf3L3b/wCO/qy4+cH4hv8A/TXj7/8AFf8AbU+Pp9jW6+YvlyaE/pKRpT7pa/a6OJBuwAVTChiK20it3xU5UwMHbAhXX7pz16AQrRQR+kvTntbiVrv47wSUQ1dqgpCQPkgkjSX/AMnQzH5NJxg+GpouOfjKXak3Mwg/OG7twrG0nT2rtSVtTQgZ+uf3iCKPL6RlQDocYs+U0x9LWJ1+MX+IRp5/f3QP/V0ubxxn/eBaP6fF/nYqx5wf4Q+Rf7J1/wDInFp/zMH+b7B3+m6M/wAT8kclHyS/3uof9XD+WmxRD4Jv+HjdH9tJP9mW7FUvjS/iBac/6hsY/wBpmPIs43/3+s/+sIf88Yvv5rf4R+R/7H3P+rPjTT5N9dahtX5dPHvhDIAqHo1lxdc5q2MUXKrRWagqG7vl+fV0rhuok7QTsZKz7FVRA5F0kHB1EzFMUDBZTkvb1Junlnb9kr//AGGSlkaQZ5aliMspTMdRr0aSRkQCSCCMcRvCHmLcXAvw9uXuT9o5DdFFfaOGlcqHEM9clDQJUaWBRjTmp76K4ZGeNUdWViD4XlK8tN28e2Qq3qJqfiHGdWSrGPa9Lu56wV5wNbrsfO+++DV/H1Krz6uw7VONZsyqKu3JnLc6qxkQagKQqn/HJ/K9bx/cI9pbVpKaIRU6MWdDoQNnpSKNCijIDMscxmSNPTM+z4KfD+2x5e7QrfIXn7cV7r5K68VEKQU9QvvFRJBo71RcK2oSomYyO5VYoxHIFRZDOQ4RY/8Air8vW6+1O7WMMF5is1Jncf3KOyK7mW8Xj6FgpJqatY7tVnijspOJK3VbkLLxTch/UBQDpiJf2m68wHFvLe9N071pbHeJYZKCZZiwWJVI0RO65MuWXtKPTnmOmJc88vh5eM3A3jHfOU+OaG50u7rbNb0haWvmnjb3m4UtNKHil1Bj2pZCNJXJsm9AyxJO5nIb5k3EpSmKYyevckRQCiAiQ44ayYoBTgH80wpqFN0H+QQH+XmyVhB8jqTL1W8/1ebELbbVl+C3uAsCA274yPnH54tozH7oI/KDilnz/wD8SbIn93mJv7HM+Qzz3/ePUf0eD+TGOlvwk/8ABbZ/9cXX+uPiFXjf/wA/mm3+pHEP9tYjmmcdf7+2f/WNP/KLizHmb/hL5I/sXdv6lLi4j5mn/Mlrn/chK/28muS95K/7x27+hN/KtjnR8Ef+5feX9qIv6jDigHBeect615JgsuYSu0rQr7XhWIymYz266Tlk6ApXsTMRb9B3FTkJIEIALs3iKzdXtKIk7ilEIEsd9u227kl2sszwV8foZcjmD6VZSCrKfWrAg/J0GOtfKXFHH3NWy6rj3k62QXbadZkXhl1KVdeqSwyxsksE0ZJKTQuki5kBsmYHSLrP8ylak5CIrG3eFK9NV92ojHy2RsQneRUtHtFOiKsjKY8sLyXjbCJim7nBWclGgBAMKTc49qQ2M215H1QkSm3bRRvTno01PmrAejNonLB/n0unzKfRjjBzb8FewvSVF78etzVlNd4wZIrddgksUjjqI4rhTpFJT+jKMzU1QScu5Kozcem8/wDpJgmjUTEu6uBa9X6a1yXcI6lXmIqMehD1e2rWypzl2p9/j4Rqg0ZxUo5Y1t4lInSSTB8Zw3VUIC5VlFvDz3sqx0NDSbzsUccK1MwjlWMBUk7kbSRyhQAFYhGDkAas1JGrMnJfCT8nOVN0bq3B4z8r1lXcp7JbpK2hmq5GmqaQUlVBRVdBJMzO8sSvUwtThmbsCOaNGMRjSPLryseO6GHGGHGGHGGHGGHGGN/lf8gfiUHXKD12ebEY+gMZmxhGY6k6bV3mUKYZvXzwaEdKwredp8fDWJgLwhlU3Kzd6mu49RQVFD+ocTX1p9/cUfo6m3nuFPHbfdViaNDNHkmkBlDRhXGfUMQwJzOZOZx8lF38RviBjmWq5ip9n3er3sL5LcIqyqS2VgaoE7SRTNBVyTU8mg6WjSSFkj0poRdCgQR/dh8sf/5njz/i7t1/815o35s8af4VP/19f9pi1P6cfG9/6C8f9k7T/wDksT42bxjgTyY+N28Yi02vlZvzHGKFbj8RqxsvKu0Iq74jioxxBUmWf2wxJsjydprk0WR7IqGMPxEjlVY4FOYd83LbLDyVxzPadnzxTpTBBBkzELJAqlY2L+1m0Z0anP78MSeuKncIb35Y8JfM+18h+SFqrbTVXxqmS7CSKJGlortLKs9bFHSgwlIKxRUmGnUD+btBHGpKgYErFXZ+oz0zVrVDSlcstdk3sLPQE0xcRkvDS8a4UaSEbJx7tNJ0yfM3KRk1ElClOQ5RAQ68obUU89JO9LVI0dTGxVlYEMrA5EEHqCD0IOPrNs94tO4bTTX2w1MFZZayBJoJ4XWSGaKRQ8ckciEq6OpDKykgggg4/pAalZVxvhXxs6mZIyxda7j+jVzU3AjuYstmkUI2ObELimsGTbpGVN6z6RdmJ2Nmjcirp0qIJopnUMUo9FdqXS3WXji03G6zR09DHaqUs7kAD6hOnzk+gKM2Y9ACemPjJ8gdhbz5M80uQNmbAtlZd901vIF9SGmpo2kkYm6VILHLokaZ6pJZCsUSZvI6oCwhNhPMiaL/AHJ8yea4WTouKnuKIzGGrlWtSQw9qmcE0Z8vNRsw5ZuO87N7nrKD1qeGbG7RKZUBAVUFUHCml2W8ASXjmG9I0FralWGiR/ZdqaIlgxB9BqpipjHz+tSrGzfJvHDyUnG/w4OM6mC679jv8tz3PVUp71LDfK1FhkhV1yDpYrYkorJBmCEIIjlSWFMX+Vdrdl83lkWuWc+5kyDDyT9zIHrdvydd7HWGqjh0o7BCPgJqdfxbJm1VU6IJJpgRIoABQAADlN7purcl7DLda+sqIWYnRJNI6DM55BGYqAPUAOnqx9KWwuBOE+MGhn4/2ltu0XGGJYxU0lsoqepYKoTVJPDBHK7sB7bsxLkktmTi/jwGbpauas4t2EhNgcyVrGErbL/T5Wusp1vNrKysfH12QaPHTcYqKkUypoOVSkHvEo9R+gB5PPA+89sbXtdwgv8AWR00stRGyBg3tAIQSNKn0HHJf4snjTzpztvraFz4j23W3ygt9pq4qh4GhAikkqI3RW7ssZzZQSMgR09OMzMysk4l5VwicFEV5J8skoHXodJV0qdM4dQAehimAeVrmIaZ2X0Fj/y47bW2N4bdBDKMpFhQEfIQoBH7hxp58LW7Oq+uekWw+Nc2ZmrOPbzbco32brlcmW84q9lYqUxHRIGPetzxsS+bFSdTEW4QKB1Cm70h6gAdBGzHDW9Nr7d2VcLbeqyKnrpaqVkRg2bK0ESgjJSOrKR6fVjh58Szxl545k8ntn704y21XXja1vsVDDUVELQBIpYrtXTyIwklRs1hljc5KRkwyOeYxl05WPHdDGoHxpbq6tYb8U2yODMnZlrNQyzcP+Yz7tUmSbzikpL/AHvxPEQVb9soyiXTAvxaXbnQT71i9Dl+t2h9PLNcb7z2vZ+LLjY7nWRQ3Wb3vRGQ2pu5AqplkpHtMMh1xw281/Gfnbkfz22XylsjbddcdgW79Hvea2NoBFF7pdZp6nUHlWT6qJg7ZIeh6ZnpjhXiJ8t9F1YpM5qrtXEvZ7XWyvpl1XbG3hRtZKH96iHTt9as1SBJy4sOO7GdZV0om0QcOm7pdx1bOk3Q+3wfEvLFDteifa26UaTb0jMUcLr7Wv8A0iPH1LxP1YhQWDFvZYN7Mp/EL+Hzunnfc1LzzwLURUnMdFFCtRTtN7qa73Ug0lTTVearT3CnAWJWleOKSJIfroHgHenhOawfLmXqSc5CY50p1RjJJY0mtUIPNllrUaQy4mcLJNqhYUVrdEoqG69GiHoEQ6gmkmmUCkDep9s+PFdIbgldDFEx1dtal0HXr0jf6xf4oyy9AA6DFVLXzj8ZHatEm0Kra1yuFdCvaFXPZaapkIX2QWq6ciklI6fWvrL/AE5HclmMKcsZc8WWL95PHo+0ud16rYpwplB5PZ2yKnC5C9s5BedpqsU+lLTfGq9ut6cO1iX5wMkC7NuDgQb/AEKGANLut24vtm99vvs0xxWqiqi1TNplyObR6SzygySaQrejNRn7PpOLM7A4+87t8+LnL9L5Kx1lfv3c1jSCx28zW/UumCsEqRUtCy0lIZmlgBDaJpO2O91RTjj/AJ5Nl8FbQ7L4luWAskQmTKxA4LYVmXmIJGTRbMZ5K/3qVUjVSyrCPWFcsfJoK9SkMXtVD6evUAxHOu5LHufclJWWGpSppo6EIzLqyDd2VsvaAOeTA/u4kT4UvCfKnBnCe4Nt8s2Wqsl8q90yVMMM5iLPAaChiEg7Uki6TJFIvUg5qemWRxXXofe6ji/c3WHIl+nGlZpVLzXQbHabA+K4OzhoOKnmjqQkXJGqLhyZFq3TExgIQ5ugfQA8j3YtdSWzeNsuFe4iooa2J3c55KqsCScszkB8gxcXyr2ruHfPjZvjZ206WSt3Nc9s19PS06FQ808sDrHGpYqupmIA1MB8pxc75W/IxjRbenUDaLUPJdcyi6wZT1VJFWNJMtYtdytbJsZmoSx38fHPCM7PVJRdm4MiUTFbujCUwHAOkx8qch2074tG59pVMdU1DD1y1BSe42qNswDk6MVOXqY5dcc2fAjw33tH4s8icF+Q1krbFBum4gRiQwtKqilh7NXEI5JEL01VEk0YcgGSIagVzxO6/bOeEbylQlSt+yk8liTLtfhEIcTXSUsWNbrX2B1VHq0AW8RKa1CulcQlHThRn7hVwqh6h1AQaGXUIbea/cvCvKEEVXuSQUl2jQL9YzwyIPSV7i/VSIGJK5kkZk6ULEGqu0+EPideCd0uG3uFaRtwce1lU038zip7lRVEgARZ/cpSK6jqGiWNZu2savpVDLULEjL/AKYtzL4LPGJ94MnYQvrXKGV3sK8hmTmpzNgzDfX8csZNdxAwUkYrPHlRRfqtiAs5UXjjLkACHWUL0T5/bXeOD+M+5c7JOKq6shUGNnqJSPSVU9Io88upJTMdCSOmPxvrjf4pvnD7nsfk+0vYtgxVKTOtVDT2ihjkAKrPPGC9wqzGGOiNUqAjHUsaNm+KkNQfIJWsieYdluxslZYnFdMnSZIQFWQVfyEPSa5+6afpVArALMGCrl2q3akZtlXBGyYOniii5iJ+oYAifaO/6a4cvLvTcciUtHJ3h1zKxp2GjiTMDM5DSCQBqYlshnjoN5D+I172f8OiXxl4Xoqi/blpTbmyjEcc1bUfnWCtr6nTJIFQMxmkWNpGMUKpEGfQCeAeZfOOKNh96rtk7C11i8gUOSpOOI1jZYdN+kxcPoesNWUk3ISRaMXQHaOiCQ3VMA6h9AiHMBzFe7VuHfE1zs0y1FA0MIDrnkSqAEdQD0PzYlv4bnF+/uHvFi2bH5Ltk9o3XDc7jI9NMULqk1SzxsTG7rk6kEZNnl6csV34jyVPYayrjTLtXKgeyYuvtRyFApOwMLRaXp0+wsMe3eFIIGOzcOY8pFSh/OTMYP5eR9ablPZ7rTXaly95pZ45Vz9BaNg4B+YkZH5sXB5C2VauSNhXvjy+lxZb7aau3zlMtaxVkElPIyE9A6rIWQ+pgDjYrk7Y/wALflVpWPrZsfkZtirIdHinCZYq3WmXxhdaoWWBs7m6wE8dqanXmFO+alUbqNzOzkHqZMGyiyyQ2+ue4+GuUqKnq9xVApbhAp9mR2hkTVkWTVl25VzGYI1fNpJYY+czZHDPxK/Azc132/wzZnv2z7pOpMtJSxXOiqjFqSGp7AYVlDMEYrIsgiB6BzOkcTioTElj8RWLPIRshSsgRMffNF7RjasUbFVocxN7u7aFuSMTi6SsdqJPN/TyfDLL2ONn0PikQmJw9wYiAFYqFEIktNRxLa+QLjRV6LPseWmSKByssgWQLAXfUPrlJcSjXGPXkuSHHQ/kGzfEK334h7M3NtGomtXlLQ3qprrpTLLQ0TTUbS3OOnpTA2dsmVaeSgf3arbI9sNLqqkINjsJrD8uTASjTIps5VCah2K6cqjSJvNtskotT25gcJNndUSTSvUggBigBmq6inrAHYoQ4CYoyJDtnx3glFx9+heFTq7bVMhXp1yKf6Uj/wAEk5+gg+jFNLnzj8ZO7UMmzhta401xlUxGthstJHKNXslkqiTQxt6cpUVdH0kZSAwr080flDxvuZ+77Aeujd6pgbFc2a1ObS+h3NcRu1xbxD2twJ63XHqDORh6pVa9JvEm5naDZw5VfKALdFNBMy0f8y8nW7ePu9h26G/MVK+suVKdyQKUXQhAKoiMwGoAksfZAUE2++Gp4M708bfzvyzzG8Q5Wv1KKVaVJlqDRUbSpUTipqEZ45qqqqIoXkETyRxrAh70jyusdCHIIx1hw4ww4ww4ww4ww4ww4ww4wxPPQHyC5h8fuVV7xj4qNnpVnIyj8m4tmHq7SAu8SyVVO0XSdIpuDQVphgcrDHSZEVjNxVUIoksgqqipvWwt/wB32DdDW2/KWilyE0DEhZFHoOfXS65nQ4ByzIIZSVNUfLXxF468uNhLtfdxah3NQl5LbdIUV56KVwA6lSVE9LNpQVFMzoJNCMjxSpHKmj+2bF+CzybtGNvz+eJw1mVRi1bycpdFJnEl9aCgim3Ii/yHXTK4+vLFsVP0mgyLp6qigUv9Q26gQLF1e4eD+S0Wrv2ijvBUBmk1QSjLp1lT6qUD0LrZiB+9X0Y4zWDhz4pvhDUS7d4lFRuTjcSs0UVGIbtQvqJYmO31AFfQuxOqUU8UKPIT9bNlqPpHpvAfq8nAW+2ZqkNrZbHrFq3xvS7Fka3bJMYRGLRSSjoSs06L9HFDBq2bNiJt05cEmKJUygUxBAvPA54I2wI6urrWustOoEMbzSVgUKOipGv1AAAAAkyUZDqMZOmX4sXOb1e3tv7Zh2Db7vKzXGsp7dSbceZpWJkmqayXO6yMzMzSNSF53LMSrZnFKvk18ruR9/ZaOpUDCuMW65U+SCQq2OSPE3EtYpRskq0ZWq/O2fYxcSTZoqcrKPbALKMIqcpTuFBFwaGeSuVLjv2VaKBDS7dhbNIc82dh0DykdCQM9KD2UzPVj7WOmHhH4DbM8SrfNua61KX3mS4w9uquJQrFTxMQ70tAj5usbOFM1RJlNUlFJWFMoRUlyJ8dBMOMMOMMOMMOMMOMMaU/H1rHr5kTUnFtwvWHqFa7RLLXsJKem6+zfSb0GGRbZGsgcOlSCooDVgzSRJ1/mpplD+TnK/yT5Y5K2xzPd7Jt+93GjtEK0miGKZkjTXRU7tpUHIanZmPykk44r+XXN/LuzvIK+7d2tuO7UFip1oe3BDUOkady30sj6VByGqR2c/KzE+vH5hJfx6T2G9oM3s9W2SdU1MyNlfGORo9zj6kksM1PYej4mSszulNErUtGyMQ+QmUgYKPncasqcpgVSRAAE2YuW2PKG18h7J40qN4Z33flntdyt8i1tYYIYLtJLHTJWMaUSRyo0LGdYIqhFBXtvISQKcQeZ/NE9nul7TdW5hSWmpnhmBqDrZ6cKXMY7uRUhhpLMhPXMLj5zKuRPGhhfFesOZsg64xEPQtqSUpxTpT931NUNSo+8ViJtrKVyUQ1nTTiI+IiJcgvzxp5YyJ01PTKqUoGNl9i8deXPI2+d68dbT3S9RunYxrFq4vfase+SUVTLSvFbj7sTLJLLEwgFQKUMGXUUYlR69182uX7LarZebhu3cqUF17Zjb3g/ViVFkDTfWeyFVhq0dzLI5ZjrjsqdM0OV2mJqOlrTWFMiqYSLntOwJ0eqHoalNPbAp5GJJUs4M6ewnkh9UEgjfai3+t7ju+pyO3q/I9ODzz4+66kbQG5fzGYDV1IrRVil97LmLs9kQCP2dXvHd7nTtafaxmR5ec3HdP6JDdm4zcTRe9a/eW7Xb7nby1dzVrz65aNOX77Ppjy9dqBorszC5InaHrPWIlpi/MV6wjPp26jVdg5eWvH5owszIQ5IaZnknFecjKp+1VWO3cn7Td6CfQOvg5cufkVwxcbPa90bsqZ6i97eorzAaWrqHVKWu7nZjlM0MBWde03cVBJGMxplfrl+tu+XXOG5oameg3ZuNEpayWmfuVLAl4tOorpds0OoaScieuajCHoGi03sxb9VWus9YTyFS8WwuW5SZcUarkpjitzs0jBNGUfIpzKs2rNpu1wMompHJIAn1EqxjfV4uF08irbwxb+c592VJ2lcr5NaooVq6g1a1EEJmd5IzCIRCVUhWWoZy3QxgdcIfLnnCfcs21U3ZuP84Q0qzsxqW7ZRm0gA69WrM9QUAy9eIlXfY/xe0q7XCvl1Lt9xx9je0BS8m7FULXgtm17x3aU3hY5/D2i+ISCL1NeLkFUkVTtI50ioddP0DrFN3BPW2uB/Mbcm27fdTvW127dl4ovfLdYK6++7X6vpincSWmoWjKFZIwzqJZ4nUI3dWMjI6nW+dnLVFWzU/6U7tmt9NL25quJ5XpIXzyKvKHzzU5AlUYEkaScdd2cnNB9YpTB8E800nM3zmwrW5vcZQmu2IqnkiYmGlGjKxNSzlOLcWqvPnyDiHtaLpuZgm8AzZBdRT0yEKJ9B4W2r5Kc1UO5rnT79ods2zaT0iXGa/3Opt8UT1slTDEpkWlnRGWWleKQTtCRI8SLrZiFy+5vNDmzbMtDA+5t1109wEhhWkmaZmESozHSZUJBVww0hugYnIDr4H3j0gjdaMqbRXzQHKOIqjiWTQjpqj5cwDW6DlGeQcrVlqjN1OtTNtTjJSBO7tCaIOVZBsAqtXJAATJgB/a/RDyDrOZrHwltbk/b9/v9/haSGstV7nrrbAyipYw1VRDSmSOcLTM5jWCQhZIWJyc6fH+ujznHtqq3RX3/AHlSUlIwDRVDtFOwOgao0aXSy5uBmXHVWHq6+we2nxspU/U++RGvFdtNZ3Gvlaxzi+Qr1Bqa3wayWRUWgpXtKRsEYeHSgJRNZnJFZhIrt3TdUhUlO3qPqU2zPLOTcG/Nr1+5p6G9ceWuouFyjnrKkd6npxrzojHBIJTPGVmpzL2EkikRi6Z5DyP5p8wijtNfFu7cktNeJ0hgKVLHS79Prc5F06GzV9OshgRkcsem2HvPj117yS4xAGmttzjkmJqLe/W+p684DZ5Hf0KlOlVEW9muiysrAsYeMOYhRMIKqqJEWROoUhFkzGyHEmwfKDlnZycgHftr2zs6ouDUNLVX69Nb0rqxQC1NRgRTvNIATkNKqxSRUZmjcDw7h81+aNv3I2j9Jt211ySESyR0kkkxijPQPJ7ahV/dJAIJABGfn3u6+NOm6q1TcOJ12h8l4nukrAwdfaY6xpX390eTU7NuqyESNeskzV0iSUVYWK7J2h7n1CuEhKmCodoj6u19ieW+4uc67x8r9zyWbfltgnmnevr50o0hghWo7vfp4akmOWndJon7ekowLlOoHkrvNbmCj2rFvCHd25am0zOqoIahzIWZimnQ7p1VwVYZ55jpnjy8Mr6hZeSyG6kfG3nPCEfjmlSN4fyuwGtMTjWLsLKMKdR1DVN8vZ5NCWsQIJmUBucUCemAmFQADng5FsfNnH8lpgo+W9qbmq7xco6JIrFuCS4yQPIQFmqkWmjaKn1EL3BrOo5BCcfqzeZfPd3FQ8l73tQx00BlLVRkhVwvpWMmRgz5dcunT1447g/Y3xm5ps2Na6902vWFGOaHhonDl5zngKFqON8pTpTikEBSrxCWS1QcnKKL9qKYGUSSUcKpoEUMsoRM0hcl8E+XfHFlvN3pt+2fclTtyPu3aist6lqrhbIMs+/WUU1PSzRxBc2YhWZY1eRlEaM4w9k86+Xr1U01O+5t30SVp008tS7xwzt/AjlWR1Zs+g6gEkKDqIGOweQ/WfX/ABxqhkC3UPEFDqdnjpOkJMZ2DgGbCSapvrpBMXhEHKJAUIVyzcHTOAftIYQ5E3jNytyRujmO22XcV7uNZaZYqovFLMzoxSlldSVJyOlgGHyEA4vV4e828t7z59tG3t17iutwsk0FaXgnnd42KUc7oWUnI6XVWHyEA4zc86k47P4cYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYYcYY1j+Mf/ACTYd/6fI3+KV15xt8sP7+75/Fov9n0uOAnm/wD4m9x/xLd/suixTHZs607XfDPlR01ypGXuG2Dz9slsRcsG0mPx/cZ02V65m5hW4WmytSlYmGdRCrXtiDOlxcrtzCgoUiBVnAHQL0ysvGG4eXOReDfIjY81rqOJ9q7OsNJeqx66kh/NlRZnqJquKqilmWUN9aI07aSDWpaQxwlZTytqr7R7es26dm3RZ03BX3KrkpoxFI3fSpCLG0bKpXL2dRzI6HJdTZqJHbR4NaS+I/DJrnmaugqgrL4zxJkmtODEFRu6a4Ci6tZGCa4FP7d/HPkFfRXJ9dFdMqhBAxSiEP8ACPJtRb9/eRfL3HVXlKtPcbpb6hc8mVr5JU07lempJEZdaHo6MyMCpIxse6LGk1p2bt28x5qXhgmQ+oilVHGfqIIORHUEAjqMc30Jr2YcdeV2cwbmhwrNTGvelVgw/Sbw4KuDjImJYnL9ZsuMLY5FUBR92Sp2pvGLESOqVFaNMkdQ65FTDuHlNduPd3+CdNybxyi01v3byRBdayiXTpoLpLaqmnuVKuXXSaqlepQsFLpUK6qsbRjGN2HT3i3crPY7yS81vsr08cpzzmgWoR4ZD6s+24Q5Z5FCCSwOPrtAd+NTNcnOz+G8zZX+5uSLRvnn6Zgq59xclWH30bY52uwEK5+L1WnTkC295LRThLsWdJqJ+n3KFKQxTDgfKzxY555fh2TyHx1Yvzjs+h4tscM9R77boNElPDUTzL2qmrhnbRFKjZpGytq0qWYED29gb92ntxrnZ7zV9m5S36qZU7Uz5h2RFOpI2UZspHVgRlmchkcTCoH8ZbPv+iXHX+Ikfyvm6/8A+du1f/2TcP6hJjcLf/fHcP8AUkP8qMQP1m2iw/ppr1kzSPZfFV2yPsMyy/khs010c4ln7ersLBXC1g8hbFXV3lcm6VYa5NswUWTUeuDe5TaCZIqpRII2i5n4S5B8ieWrL5KcM3222fiWTb9vZr+t0gpBYZ6Sl0TU9QqVENZT1EL6UZYYx22lAkMZDAaJtndFn2bt6p2TuWknqdwrWTAUhgeT3tZJM1dCUaN0YZkFj7QXMA9MfYeVV/jSrZe8WjvKt3yBqNjaKgtjkJ6y4LkX8HecONgxzh9nGVulP6LVbE5ZIM5Q7eEU+HxSiIsFVClImiImJr3gzS7zvmwOcINjWy07/wB4z1W32gp71Gk1Fdm/OF2eSorEramnV2eISVi9+pVxOqMWeQBW9zlSS20t32s91nqLRbUjrAz0xKy047NOFSMxI5ADZRnQhGgkZAdR7/OGRME37w77Uo6/7F5i2gqlScNIKWyZnaQuMxkMbC7vePLEtAvpe60uiyT+Pi42bbe1FJmZBJJQEwUMYpwLiuNNo8obV+IRsaTlbaG3tk32vRp4rdZY6SKg7C0VfTidIqOsrY0kkkhk7uqYOzLrKBWUn2L3cbFX8P3UWC41l0pIiFaaqMjS6zLE5UtJHESFDLpyXIA5Z5g4h/kjD961r2n8e+MYRiK2seW9qMCbEYsFMi5WuOMjTI12Jy5jhkUCizaxEnJPms0wapggi2QWFNEhxKuYtgtncg7Y5k4P5Z3rcpdPNVg2NfLBc8yuq4W+H3iW1XB/37SxxpLRzyNreR0DyMoMQbT7lZ67be6dv2yFc9s1d1pauD05QzNoWohHqCsSsiKMgoOQB9rKWPkKtuAMfbU2a73bJGyujGZY/FkGzoGzuNoiw23Fuf2INVHiFBs1RrsHLNpqSq8sB0jt3y7BNRNmQy6wEIzEII8TLDyruzg2i21tuz7N5O47mvkz123LhLBS3KxPqCNXU9VUTRNDHUxZMskKTsrSssUZZqgHbOQauwW/dUtbW1Nysd5WlURVsKvJBVDLMRPGisGKN0IYoCFBY5BMfCbR3PIV28MWHbpnypnwxcpXK+MHtvTrFWTx69aRLbJ8shH3+NqsXHlGuzE9V2zeXAiLMgGcresggVI6SYbPwjtzaW2/iL7h25xZXjce3YLFckpDU1Jr0eVrbE0lDJVSyfziGCpaSlzeUkRp25ZWdXc+huituFbw1R1t+i9yrHq4TJoTtEKJmAlCKPYZkAk6L9I5qoBAxKHUnK2qNlxptXT9fN2Nntup5XD81ZZ5tsnP5Is69JiIuAs8WkvT312xhj5nHJTTybKV8kidyquLdAwlKVIRGE+e9i862beexdwcscbbK2Ba13BDTwNt6C30y1kss9NIRVpR3KveQwpCTCzrGqCSUAsXyG0bSuu1Km23Wj2/e7nd5zRs7CseZzGqo65xmSGIDUW9oAknJfRliuHGmXqZtXpfoDpDgRCw5Az1Rcy41ueTVGFOtTGu4MrdJsNulZe4WS5y8Iyr5TnjZkE2osHDoFiisl3guZBBxcDeXH+4uDPIzlbyW5TaktPFl027caS3B6umeovVRWQUsUVJT0kUzz5CSHVJ30iKERyaTEJJYo5tt3o91bMsGyLCJKi/QVkMk2UbhKZI3kZpHkZQnobJdJbP2hnq0q13/lE/yXZN/wB7Y9/t9XOctfEj+/a0/wDoaz+pz460eDH+JWyf0e4f1CoxlH52Jx3xw4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4ww4wxaHrj5ObXrrhyp4fjMUV6zMqoewHRm39lko908+P2WYsigKtG8a4SS9srLmSL0OPcUgCPQR6cqTyh4nWfk7fFbvarvNTST1ghBiSBHVezBFAMmLqTqEYY9OhOXqxRnmXwgsHMXI1w5Err/WUNTXinBhSmjkVOxTQ0wydpFJ1CEMcwMixHqx2/9aa9fkVUvxjMfY3NA/UR29+Ia37tF9riL/2aW1fxVcPucP22H6016/IqpfjGY+xuP1EdvfiGt+7Rfa4fs0tq/iq4fc4ftsP1pr1+RVS/GMx9jcfqI7e/ENb92i+1w/ZpbV/FVw+5w/bYfrTXr8iql+MZj7G4/UR29+Ia37tF9rh+zS2r+Krh9zh+2w/WmvX5FVL8YzH2Nx+ojt78Q1v3aL7XD9mltX8VXD7nD9th+tNevyKqX4xmPsbj9RHb34hrfu0X2uH7NLav4quH3OH7bD9aa9fkVUvxjMfY3H6iO3vxDW/dovtcP2aW1fxVcPucP22H6016/IqpfjGY+xuP1EdvfiGt+7Rfa4fs0tq/iq4fc4ftsP1pr1+RVS/GMx9jcfqI7e/ENb92i+1w/ZpbV/FVw+5w/bYfrTXr8iql+MZj7G4/UR29+Ia37tF9rh+zS2r+Krh9zh+2w/WmvX5FVL8YzH2Nx+ojt78Q1v3aL7XD9mltX8VXD7nD9th+tNevyKqX4xmPsbj9RHb34hrfu0X2uH7NLav4quH3OH7bD9aa9fkVUvxjMfY3H6iO3vxDW/dovtcP2aW1fxVcPucP22OE7J+TK1bH4gseI5TFVfq7KxOoF0rNMLJJSLpsMFOR82mRNo4jW6SgOFGAJmETh2gYRDqIdOSHxZ4pWfi7e1LvSkvFTVz0qTKIngRFbuxPESWV2I0h8x06kZYlXhbwksPDPIlHyFQ36srqmjjnUQyU0cat34JICS6yMRpEhYdOpGWKw+WyxeHDjDDjDH//2Q==\", t.ErrorImage = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQIHWP4zwAAAgEBAMVfG14AAAAASUVORK5CYII=\", t.PiechartBack = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAMAAADmtEJjAAAAYFBMVEVMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgUIAAAAH3RSTlMACbeu3XUBgH/vy+gqMRghOfqXYUpWwkDGihCfgmebkGEUkgAAAQVJREFUeNqV0ttugzAURNEx2BADBMItTXqZ///Lyi0qrXOkZvajtcbyg2F1gtSJIqfIKXKKnCKnyClyipwip8gpcmo8FaNvitewdtV/PB8WYRD4V83sBJ5q50rgqW2QOBlHiZOXUeJkewZQ8/kKiIOrOCigDS5ncbBCG9ygDUqYgxhpt8EcALh3Syjb3L/AHAB7/a3N7jcHOHIhZu83BvjduTj8BHOAP1XTjw8wB8gG5fGBzAGynN//g4M5QN7y7Rs8VJu+8ky9wR7gocBUD2tg+TFxD7Pa8C75GnbWeSQ54Pk8WULzV8VHNgp35Kr4nk2l+JkLlD42SPle4t0Eqfe75jvsfQLbYGzTrP2yIAAAAABJRU5ErkJggg==\";\n    }(c = i.Resources || (i.Resources = {})), function (t) {\n      var e = function () {\n        function t() {\n          this._dict = new Object(null), this._count = 0;\n        }\n\n        return t.prototype.add = function (t) {\n          var e = this._dict[t.id];\n          e ? e.push(t) : this._dict[t.id] = [t], this._count++;\n        }, t.prototype.remove = function (t) {\n          var e = this._dict[t.id];\n          e && d.Helpers.removeFromArrayHasty(e, t), this._count--;\n        }, t.prototype.contains = function (t) {\n          var e = this._dict[t.id];\n          return e && e.indexOf(t) >= 0;\n        }, t.prototype.clone = function () {\n          var e = new t();\n\n          for (var i in this._dict) {\n            e._dict[i] = this._dict[i].slice();\n          }\n\n          return e._count = this._count, e;\n        }, t.prototype.count = function () {\n          return this._count;\n        }, t;\n      }(),\n          i = function (t) {\n        function i() {\n          var i = t.apply(this, arguments) || this;\n          return i.centerX = 0, i.centerY = 0, i.zoom = 1, i.hoverNode = null, i.hoverLink = null, i.hoverItem = null, i.lastClickedNode = null, i.selection = [], i.selectionSet = new e(), i.notifyChanges = !0, i.lastNotifiedSelectionSet = new e(), i.autoZoomMode = !1, i.layoutActive = !1, i;\n        }\n\n        return n(i, t), i.prototype.xyInChart = function (t, e) {\n          return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height;\n        }, i.prototype.toDisplay = function (t, e) {\n          return {\n            x: (t - this.centerX) * this.zoom + this.x0 + .5 * this.width,\n            y: (e - this.centerY) * this.zoom + this.y0 + .5 * this.height\n          };\n        }, i.prototype.fromDisplay = function (t, e) {\n          return {\n            x: (t - this.x0 - .5 * this.width) / this.zoom + this.centerX,\n            y: (e - this.y0 - .5 * this.height) / this.zoom + this.centerY\n          };\n        }, i.prototype.toDisplayTransform = function () {\n          return {\n            xm: this.zoom,\n            xa: this.x0 + .5 * this.width - this.centerX * this.zoom,\n            ym: this.zoom,\n            ya: this.y0 + .5 * this.height - this.centerY * this.zoom\n          };\n        }, i.prototype.objectRemoved = function (t) {\n          d.Helpers.removeFromArray(this.selection, t) && (t.selected = !1), this.hoverNode !== t && this.hoverLink !== t || this.setActiveObject(null, null);\n        }, i.prototype.addToSelection = function (t) {\n          return !this.selectionSet.contains(t) && (this.selectionSet.add(t), this.selection.push(t), t.layer.touchNodeOrLink(t), t.selected = !0, !0);\n        }, i.prototype.removeFromSelection = function (t) {\n          return !!this.selectionSet.contains(t) && (this.selectionSet.remove(t), d.Helpers.removeFromArray(this.selection, t), t.selected = !1, t.layer.touchNodeOrLink(t), !0);\n        }, i.prototype.setSelection = function (t) {\n          for (var i = this.selectionSet, n = this.selection, r = new e(), s = [], a = !1, o = 0; o < t.length; o++) {\n            var l = t[o];\n            r.contains(l) || (r.add(l), s.push(l)), i.contains(l) || (i.add(l), l.selected = !0, a = !0, l.layer.touchNodeOrLink(l));\n          }\n\n          for (var o = 0; o < n.length; o++) {\n            var l = n[o];\n            r.contains(l) || (l.selected = !1, l.layer.touchNodeOrLink(l), a = !0);\n          }\n\n          return this.selectionSet = r, this.selection = s, a;\n        }, i.prototype.setActiveObject = function (t, e) {\n          if (this.hoverNode) {\n            this.hoverNode.layer.touchNode(this.hoverNode);\n\n            for (var i = 0; i < this.hoverNode.links.length; i++) {\n              var n = this.hoverNode.links[i];\n              n.layer.touchLink(n);\n            }\n\n            this.hoverNode.hovered = !1, this.hoverNode.locks--;\n          }\n\n          if (this.hoverLink && (this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to), this.hoverLink.hovered = !1), this.hoverNode = null, this.hoverLink = null, this.hoverItem = e, t instanceof h) {\n            this.hoverNode = t, t.hovered = !0, t.locks++, this.hoverNode.layer.touchNode(this.hoverNode);\n\n            for (var i = 0; i < this.hoverNode.links.length; i++) {\n              var n = this.hoverNode.links[i];\n              n.layer.touchLink(n);\n            }\n          } else if (t instanceof u) this.hoverLink = t, t.hovered = !0, this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to);else if (null !== t) throw \"scene.setActiveObject invalid active object type \" + t;\n        }, i.prototype.getVisibleBounds = function () {\n          var t = this.fromDisplay(this.x0, this.y0),\n              e = t.x,\n              i = t.y;\n          t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);\n          var n = t.x,\n              r = t.y;\n          return new d.Rect(e, i, n, r);\n        }, i.prototype.disableSelectionChangeNotification = function () {\n          this.notifyChanges = !1;\n        }, i.prototype.enableSelectionChangeNotification = function () {\n          this.notifyChanges = !0;\n        }, i.prototype.notifySelectionChangesIfNeeded = function (t, e) {\n          if (this.notifyChanges) {\n            for (var i = !1, n = 0; n < this.selection.length; n++) {\n              if (!this.lastNotifiedSelectionSet.contains(this.selection[n])) {\n                i = !0;\n                break;\n              }\n            }\n\n            (i || this.selection.length !== this.lastNotifiedSelectionSet.count()) && (t.events.notifySceneChanges({\n              selection: !0\n            }), t.notifySelectionChanged(t.createEventArguments(null, e)), this.lastNotifiedSelectionSet = this.selectionSet.clone());\n          }\n        }, i;\n      }(d.Scene);\n\n      t.Scene = i;\n\n      var r = 2 * Math.PI,\n          s = function () {\n        function t(t, e) {\n          this.node = t, this.nodesLayer = e;\n        }\n\n        return t.prototype.postProcess = function (t, e, i) {\n          var n = this.node;\n          n.targetHWidth = n.targetHHeight, n.bounds = new d.Rect(-n.targetHHeight, -n.targetHHeight, n.targetHHeight, n.targetHHeight), this.sizeScale = n.targetHHeight / t.nodeLabelScaleBase, this.postProcessLabel(e, i);\n        }, t.prototype.postProcessLabel = function (t, e) {\n          var i,\n              n,\n              r,\n              s = this.node;\n\n          if (null != s.label && this.nodesLayer.chart.assetsLoaded) {\n            var a = s.label.toString();\n            if (0 === a.length) this.currentLabel = null;else {\n              var o = this.currentLabel;\n              null == o ? o = this.currentLabel = new d.Label(s.labelStyle, !0) : o.style = s.labelStyle, o.text = a, e.measure(t, o), r = o.style.scaleWithSize ? this.sizeScale : (o.style.scaleWithZoom, 1), i = 0, n = s.targetHHeight + o.hheight * r * .8, s.outerBounds.addBounds(i - o.hwidth * r, n - o.hheight * r, i + o.hwidth * r, n + o.hheight * r);\n            }\n          }\n        }, t.prototype.getAnchor = function () {\n          return {\n            x: 0,\n            y: 0\n          };\n        }, t.prototype.adaptToViewport = function (t, e, i, n, r) {\n          var s = this.node;\n          this.x = s.x * t + e, this.y = s.y * i + n, this.hWidth = s.hHeight * r, this.hHeight = s.hWidth * r, this.zoom = r;\n        }, t.prototype.isInViewport = function (t, e, i, n, r) {\n          var s = this.node.outerBounds;\n          return this.x + s.x0 * r < e && this.x + s.x1 * r > t && this.y + s.y0 * r < n && this.y + s.y1 * r > i;\n        }, t.prototype.paintSelection = function (t, e, i) {\n          var n = this.hWidth * (1 + e) + i;\n          t.moveTo(this.x, this.y), t.arc(this.x, this.y, n, 0, 2 * Math.PI), t.closePath();\n        }, t.prototype.paint = function (t, e, i) {\n          this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !0), this.paintDetails(t, e));\n        }, t.prototype.paintBasicShape = function (t) {\n          var e = d.Graphics.beginStrokeAndFill(t, this.node);\n\n          if (this.hWidth !== this.hHeight) {\n            var i = this.x + this.hHeight - this.hWidth;\n            e.moveTo(i, this.y - this.hWidth), e.arc(i, this.y, this.hWidth, -Math.PI / 2, Math.PI / 2, !1), i = this.x - this.hHeight + this.hWidth, e.lineTo(i, this.y + this.hWidth), e.arc(i, this.y, this.hWidth, .5 * Math.PI, 1.5 * Math.PI, !1), e.closePath();\n          } else e.moveTo(this.x + this.hWidth, this.y), e.arc(this.x, this.y, this.hWidth, 0, r, !1);\n\n          this.applyRadialGradient(t), d.Graphics.endStrokeAndFill(t, e, this.node);\n        }, t.prototype.applyRadialGradient = function (t) {\n          var e = this.node.fillGradient;\n\n          if (e) {\n            var i = this.hWidth;\n            \"rectangle\" == this.node.display && (i *= 2);\n\n            for (var n = t.createRadialGradient(this.x, this.y, 0, this.x, this.y, i), r = 0; r < e.length; r++) {\n              var s = e[r];\n              n.addColorStop(s[0], s[1]);\n            }\n\n            this.node.fillColor = n;\n          }\n        }, t.prototype.paintDetails = function (t, e) {\n          this.image && this.basicPaintImage(t), this.paintLabel(t, e);\n        }, t.prototype.basicPaintImage = function (t, e) {\n          if (void 0 === e && (e = 1), this.image) {\n            var i,\n                n,\n                r = 0,\n                s = 0;\n\n            if (this.node.imageSlicing) {\n              var a = this.node.imageSlicing;\n              r = a[0], s = a[1], i = a[2], n = a[3];\n            } else i = this.image.width, n = this.image.height;\n\n            d.Graphics.drawImageInSquare(t, this.image, r, s, i, n, this.x - this.hHeight + this.hWidth, this.y, this.hWidth * e);\n          }\n        }, t.prototype.paintLabel = function (t, e) {\n          var i = this.nodesLayer.style.nodeLabelScaleBase;\n\n          if (this.node.hovered && (i = d.Helpers.toleranceMin(i, this.hWidth, .9)), this.currentLabel) {\n            var n = this.hWidth / i,\n                r = this.currentLabel,\n                s = 1;\n\n            if (this.node.labelStyle.scaleWithSize ? s = n : this.node.labelStyle.scaleWithZoom && (s = this.zoom), e.measure(t, r), r.hheight > 1.5) {\n              var a = this.getLabelPosition(r, s);\n              e.paint(t, a.x, a.y, s, r);\n            }\n          }\n        }, t.prototype.getLabelPosition = function (t, e) {\n          return {\n            x: this.x,\n            y: this.y + this.hWidth + t.hheight * e * .8 + (t.style.margin || 0) * this.zoom\n          };\n        }, t.prototype.distanceToEdge = function (t, e, i, n) {\n          return t;\n        }, t.prototype.hitTest = function (t, e, i, n) {\n          var r,\n              s = this.node,\n              a = s.renderHheight * i,\n              o = s.renderHwidth * i,\n              l = s.x,\n              h = s.y;\n\n          if (a < o) {\n            var u = o - a;\n            r = d.Geometry.distanceToSegmentSq(l - u, h, l + u, h, t, e);\n          } else r = (t - l) * (t - l) + (e - h) * (e - h);\n\n          var c = (a + n) * (a + n);\n\n          if (r < c) {\n            var p = a * a;\n            return r < p ? 0 : Math.sqrt(r) - a;\n          }\n\n          return n;\n        }, t;\n      }();\n\n      t.Shape = s;\n\n      var a = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e, i) || this;\n          return n.validate(), n;\n        }\n\n        return n(e, t), e.prototype.postProcess = function (t, e) {\n          var i = this.node.customShape.onUpdate.call(this.node, e, this.node.radius),\n              n = new d.Rect(i.bounds[0], i.bounds[1], i.bounds[2], i.bounds[3]);\n          this.node.targetHWidth = i.HWidth, this.node.targetHHeight = i.HHeight, this.node.bounds = n, this.node.outerBounds = n.clone(), i.anchor && (this.node.shapeAnchorX = i.anchor[0], this.node.shapeAnchorY = i.anchor[1]);\n        }, e.prototype.paint = function (t, e, i) {\n          var n = this.nodesLayer.getNodeImage(this.node, !0);\n          this.node.customShape.paint.call(this.node, t, this.x, this.y, this.hWidth, this.hHeight, n, i);\n        }, e.prototype.paintSelection = function (e, i, n) {\n          this.node.customShape.paintSelection ? this.node.customShape.paintSelection.call(this.node, e, this.x, this.y, this.hWidth, this.hHeight) : t.prototype.paintSelection.call(this, e, i, n);\n        }, e.prototype.distanceToEdge = function (e, i, n, r) {\n          return \"function\" == typeof this.node.customShape.distanceToEdge ? this.node.customShape.distanceToEdge.call(this.node, e, i, n, r) : t.prototype.distanceToEdge.call(this, e, i, n, r);\n        }, e.prototype.hitTest = function (e, i, n, r) {\n          return \"function\" == typeof this.node.customShape.hitTest ? this.node.customShape.hitTest.call(this.node, e, i, n, r) : t.prototype.hitTest.call(this, e, i, n, r);\n        }, e.prototype.validate = function () {\n          var t = this.node;\n          \"object\" != typeof t.customShape ? d.Helpers.error('If the display of an object is \"customShape\", it\\'s mandatory to supply the rendering methods for the custom shape') : (\"function\" != typeof t.customShape.onUpdate && d.Helpers.error(\"onUpdate function was not supplied for the custom shape\"), \"function\" != typeof t.customShape.paint && d.Helpers.error(\"paint function was not supplied for the custom shape\"));\n        }, e;\n      }(t.Shape);\n\n      t.CustomShape = a;\n      var o;\n      !function (t) {\n        t[t.Floating = 0] = \"Floating\", t[t.Scene = 1] = \"Scene\", t[t.Fixed = 2] = \"Fixed\";\n      }(o = t.NodeAnchorMode || (t.NodeAnchorMode = {}));\n\n      var l = function () {\n        function t() {\n          this.id = null, this.data = null, this.added = !1, this.removed = !1, this.visibility = 1, this.selected = !1, this.hovered = !1, this.dragging = !1, this.selectionLock = !1, this.cursor = null, this.invisible = !1, this.items = [], this.currentItems = null, this.label = null, this._labelStyle = null;\n        }\n\n        return Object.defineProperty(t.prototype, \"labelStyle\", {\n          get: function get() {\n            return this._labelStyle;\n          },\n          set: function set(t) {\n            null !== this._labelStyle ? (d.Helpers.warn(\"For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object.\"), d.SettingsHelper.updateRecursive(this._labelStyle, t, d.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {})) : this._labelStyle = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }();\n\n      t.ItemsLayerObject = l;\n\n      var h = function (t) {\n        function e(e, i, n) {\n          void 0 === n && (n = !1);\n          var r = t.call(this) || this;\n          return r.parentNode = null, r.data = null, r.links = [], r.dataLinks = [], r.isNode = !0, r.isLink = !1, r.aura = null, r.x = null, r.y = null, r.anchorX = null, r.anchorY = null, r.shapeAnchorX = 0, r.shapeAnchorY = 0, r.targetHHeight = null, r.targetHWidth = null, r.hHeight = 0, r.hWidth = 0, r.renderHheight = 0, r.renderHwidth = 0, r.anchorMode = o.Floating, r.coordinates = null, r.coordinatesCache = null, r.coordinatesCachePrecision = 1 / 0, r.hierarchyOffset = 0, r.hierarchyLevel = -1, r.expanded = !1, r.focused = !1, r.background = !1, r.loading = !1, r.userLock = !1, r.relevance = 1, r.display = \"image\", r.image = null, r.imageCropping = null, r.imageSlicing = null, r.tintImage = !1, r._anchorStyle = null, r.zindex = 0, r.opacity = 1, r.aspectRatio = 1, r.locks = 0, r.locked = null, r.fillColor = null, r.fillGradient = null, r.lineColor = null, r.lineWidth = 1, r.draggable = !0, r.layer = i, r.id = e, r;\n        }\n\n        return n(e, t), Object.defineProperty(e.prototype, \"anchorStyle\", {\n          get: function get() {\n            return this._anchorStyle;\n          },\n          set: function set(t) {\n            null !== this._anchorStyle ? (d.Helpers.warn(\"For performance reasons it is not recommended to set `anchorStyle` to a custom object. Instead modify properties on the existing object.\"), d.SettingsHelper.updateRecursive(this._anchorStyle, t, d.SettingsMapping.ItemsChartSettingsNodeAnchorStyle, {})) : this._anchorStyle = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e;\n      }(l);\n\n      t.Node = h;\n\n      var u = function (t) {\n        function e(e, i) {\n          var n = t.call(this) || this;\n          return n.definesLayout = !0, n.data = null, n.from = null, n.to = null, n.isNode = !1, n.isLink = !0, n.multiId = null, n.radius = 1, n.fillColor = null, n.lineColor = null, n.length = 1, n.strength = 1, n.dashed = !1, n.currentRadius = 0, n.background = null, n._angle = null, n.targetRadius = null, n.targetStrength = null, n.targetLength = null, n.direction = null, n.fromDecoration = null, n.toDecoration = null, n.relevance = 1, n.toPieValue = 0, n.toPieColor = null, n.toPie0 = null, n.toPie1 = null, n.currentCenterOffset = 0, n.layer = i, n.id = e, n;\n        }\n\n        return n(e, t), e.prototype.otherEnd = function (t) {\n          return t === this.from ? this.to : t === this.to ? this.from : null;\n        }, e.prototype.commonNode = function (t) {\n          return this.from === t.from || this.from === t.to ? this.from : this.to === t.from || this.to === t.to ? this.to : null;\n        }, e;\n      }(l);\n\n      t.Link = u;\n\n      var c = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e) || this;\n          return n.parentId = null, n.scaleNodesWithZoom = !0, n.scaleLinksWithZoom = !0, n._nodes = [], n._links = [], n._nodesDel = null, n._linksDel = null, n.idToNode = {}, n.idToLink = {}, n.lastClickedNode = null, n.newNodes = {}, n.newLinks = {}, n.modifiedNodes = {}, n.modifiedLinks = {}, n.deletedNodes = {}, n.deletedLinks = {}, n.drilldownId = null, n.layerSettings = i, n.scene = e, n.clearModified(), n.styleUpdater = n.createStyleUpdater(n.layerSettings.style), n;\n        }\n\n        return n(e, t), e.prototype.onSettingsChanged = function (t) {\n          if (t.style) {\n            this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);\n\n            for (var e = 0, i = this.nodes(); e < i.length; e++) {\n              var n = i[e];\n              this.touchNode(n);\n            }\n\n            for (var r = 0, s = this.links(); r < s.length; r++) {\n              var a = s[r];\n              this.touchLink(a);\n            }\n          }\n        }, e.prototype.updateStyle = function (t) {\n          this.styleUpdater.updateLayer(t, !0);\n        }, e.prototype.postprocessStyle = function (t) {\n          this.styleUpdater.postprocessLayer(t);\n        }, e.prototype.createStyleUpdater = function (t) {\n          return null;\n        }, e.prototype.paintPrepare = function (t) {}, e.prototype.paintBackground = function (t) {}, e.prototype.findObjectById = function (t) {\n          return this.idToNode.hasOwnProperty(t) ? this.idToNode[t] : this.idToLink.hasOwnProperty(t) ? this.idToLink[t] : null;\n        }, e.prototype.paint = function (t) {\n          this.paintPrepare(t), this.clearModified(), this.paintBackground(t);\n          var e = this.scene.selection;\n\n          if (e.length > 0) {\n            for (var i = [], n = [], r = 0; r < e.length; r++) {\n              var s = e[r];\n              s.layer === this && s instanceof h && i.push(s), s.layer === this && s instanceof u && n.push(s);\n            }\n\n            (i.length > 0 || n.length > 0) && this.paintSelection(t, i, n);\n          }\n\n          var a = this.links(),\n              o = this._makeHoveredLast(a, this.scene.hoverLink);\n\n          this.paintLinks(t, a), this._restoreHovered(a, o);\n\n          var l = this.nodes(),\n              c = this._makeHoveredLast(l, this.scene.hoverNode);\n\n          this.paintNodes(t, l), this._restoreHovered(l, c);\n        }, e.prototype.clearObjects = function () {\n          for (var t = 0, e = this.nodes(); t < e.length; t++) {\n            var i = e[t];\n            this.removeNode(i);\n          }\n\n          for (var n = 0, r = this.links(); n < r.length; n++) {\n            var s = r[n];\n            this.removeLink(s);\n          }\n        }, e.prototype.nodes = function () {\n          if (null === this._nodesDel) return this._nodes;\n\n          for (var t = [], e = 0; e < this._nodes.length; e++) {\n            var i = this._nodes[e];\n            this._nodesDel[i.id] || t.push(i);\n          }\n\n          return this._nodes = t, this._nodesDel = null, t;\n        }, e.prototype.links = function () {\n          if (null === this._linksDel) return this._links;\n\n          for (var t = [], e = 0; e < this._links.length; e++) {\n            var i = this._links[e];\n            this._linksDel[i.id] || t.push(i);\n          }\n\n          return this._links = t, this._linksDel = null, t;\n        }, e.prototype.addNode = function (t) {\n          this.nodes();\n          var e;\n          return this.idToNode.hasOwnProperty(t) ? (e = this.idToNode[t], e.removed = !1, e.added || (e.added = !0)) : this.deletedNodes.hasOwnProperty(t) ? (e = this.deletedNodes[t], e.removed = !1, e.added || (e.added = !0), this.idToNode[t] = e, this._nodes.push(e), delete this.deletedNodes[t]) : (e = new h(t, this), e.added = !0, this.idToNode[t] = e, this._nodes.push(e), this.newNodes[t] = e), this.modifiedNodes[t] = e, e;\n        }, e.prototype.touchNodeOrLink = function (t) {\n          t instanceof h ? this.modifiedNodes[t.id] = t : t instanceof u && (this.modifiedLinks[t.id] = t);\n        }, e.prototype.touchNode = function (t) {\n          this.modifiedNodes[t.id] = t;\n        }, e.prototype.removeNode = function (t) {\n          var e = t.id;\n          this.idToNode.hasOwnProperty(e) && (t === this.lastClickedNode && (this.lastClickedNode = null), this.scene.objectRemoved(t), this.newNodes.hasOwnProperty(t.id) ? this.deleteNode(t) : (t.removed || (t.removed = !0), t.added = !1, this.modifiedNodes[e] = t));\n        }, e.prototype.deleteNode = function (t) {\n          null === this._nodesDel && (this._nodesDel = {}), this._nodesDel[t.id] = !0, this.scene.objectRemoved(t), delete this.newNodes[t.id], delete this.modifiedNodes[t.id], delete this.idToNode[t.id], this.deletedNodes[t.id] = t;\n        }, e.prototype.addLink = function (t, e, i) {\n          var n = this.idToNode[e],\n              r = this.idToNode[i];\n          if (!n || !r) throw new Error(\"Cannot add link - missing nodes\");\n          var s = null;\n          return this.links(), this.idToLink.hasOwnProperty(t) ? (s = this.idToLink[t], s.removed = !1, s.added || (s.added = !0)) : this.deletedLinks.hasOwnProperty(t) ? (s = this.deletedLinks[t], delete this.deletedLinks[t], this.idToLink[t] = s, this._links.push(s), s.removed = !1, s.added || (s.added = !0)) : (s = new u(t, this), s.added = !0, this._links.push(s), this.idToLink[t] = s, this.newLinks[t] = s), s.from && s.from !== n && (d.Helpers.removeFromArrayHasty(s.from.links, s), s.from = null), s.from || (s.from = n, s.from.links.push(s), this.touchNode(s.from)), s.to && s.to !== r && (d.Helpers.removeFromArrayHasty(s.to.links, s), s.to = null), s.to || (s.to = r, s.to !== s.from && (s.to.links.push(s), this.touchNode(s.to))), s.multiId = e < i ? e + d.Helpers.SeparatorChar + i : i + d.Helpers.SeparatorChar + e, this.modifiedLinks[t] = s, s;\n        }, e.prototype.removeLink = function (t) {\n          var e = t.id;\n          this.idToLink.hasOwnProperty(e) && (this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(e) ? this.deleteLink(t) : (t.added = !1, t.removed || (t.removed = !0), this.modifiedLinks[e] = t));\n        }, e.prototype.deleteLink = function (t) {\n          null === this._linksDel && (this._linksDel = {}), this._linksDel[t.id] = !0, this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(t.id) ? delete this.newLinks[t.id] : this.deletedLinks[t.id] = t, delete this.modifiedLinks[t.id], delete this.idToLink[t.id], d.Helpers.removeFromArrayHasty(t.from.links, t), d.Helpers.removeFromArrayHasty(t.to.links, t);\n        }, e.prototype.touchLink = function (t) {\n          this.modifiedLinks[t.id] = t;\n        }, e.prototype.getModified = function () {\n          return {\n            this_newNodes: this.newNodes,\n            this_newLinks: this.newLinks,\n            this_modifiedNodes: this.modifiedNodes,\n            this_modifiedLinks: this.modifiedLinks,\n            this_deletedNodes: this.deletedNodes,\n            this_deletedLinks: this.deletedLinks\n          };\n        }, e.prototype.hasTopologyChanges = function () {\n          return d.Helpers.hasProperties(this.newNodes) || d.Helpers.hasProperties(this.newLinks) || d.Helpers.hasProperties(this.deletedNodes) || d.Helpers.hasProperties(this.deletedLinks);\n        }, e.prototype.hasStyleChanges = function () {\n          return this.hasTopologyChanges() || d.Helpers.hasProperties(this.modifiedLinks) || d.Helpers.hasProperties(this.modifiedNodes);\n        }, e.prototype.clearModified = function () {\n          this.newNodes = {}, this.newLinks = {}, this.modifiedNodes = {}, this.modifiedLinks = {}, this.deletedNodes = {}, this.deletedLinks = {};\n        }, e.prototype.paintNodeDetails = function (t, e, i, n, r, s, a, o, l) {\n          var h,\n              u,\n              c,\n              p = o.labelRenderer,\n              f = o.context;\n          if (t.hovered ? (u = d.Helpers.toleranceMax(s, 1, .9), c = d.Helpers.toleranceMin(a, r, .9)) : (u = s, c = a), t.currentItems) for (var g = 0; g < t.currentItems.length; g++) {\n            var v = t.currentItems[g];\n\n            if (l) {\n              if (v.style.zIndex >= 0) break;\n            } else if (v.style.zIndex < 0) continue;\n\n            var m = v.style.x || 0,\n                y = v.style.y || 0,\n                S = v.style.px || 0,\n                b = v.style.py || 0,\n                x = e + n * S + m,\n                C = i + r * b + y;\n            h = v.style.scaleWithSize ? r / (v.style.hoverEffect ? c : a) : v.style.scaleWithZoom ? v.style.hoverEffect ? u : s : 1, p.measure(f, v), v.hheight > 1.5 && p.paint(f, x, C, h, v);\n          }\n        }, e.prototype.getNodesSceneZoom = function () {\n          return this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;\n        }, e.prototype.getGeometry = function () {\n          var t = this.scene.toDisplayTransform(),\n              e = t.xm,\n              i = t.xa,\n              n = t.ym,\n              r = t.ya,\n              s = this.bounds.x0,\n              a = this.bounds.x1,\n              o = this.bounds.y0,\n              l = this.bounds.y1,\n              h = (s - i) / e,\n              u = (a - i) / e,\n              c = (o - r) / n,\n              d = (l - r) / n,\n              p = this.scaleNodesWithZoom ? this.scene.zoom : 1,\n              f = this.scaleLinksWithZoom ? this.scene.zoom : 1;\n          return {\n            txm: e,\n            txa: i,\n            tym: n,\n            tya: r,\n            zoom: p,\n            linkZoom: f,\n            x0s: s,\n            x1s: a,\n            y0s: o,\n            y1s: l,\n            x0w: h,\n            y0w: c,\n            x1w: u,\n            y1w: d\n          };\n        }, e.prototype._makeHoveredLast = function (t, e) {\n          var i = t.length;\n          if (i < 2 || !e || e === t[i - 1]) return i - 1;\n\n          for (var n = 0; n < t.length; n++) {\n            var r = t[n];\n\n            if (r === e) {\n              var s = t[i - 1];\n              return t[i - 1] = e, t[n] = s, n;\n            }\n          }\n\n          return i - 1;\n        }, e.prototype._restoreHovered = function (t, e) {\n          var i = t.length;\n\n          if (e !== i - 1) {\n            var n = t[e];\n            t[e] = t[i - 1], t[i - 1] = n;\n          }\n        }, e;\n      }(d.Layer);\n\n      t.ItemsLayer = c;\n\n      var p = function () {\n        function t() {\n          this.nameLegend = null, this.showInLegend = !0, this.legendGroupId = null;\n        }\n\n        return t;\n      }();\n\n      t.SettingsItemClass = p;\n\n      var f = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(p);\n\n      t.SettingsNodeClass = f;\n\n      var g = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(p);\n\n      t.SettingsLinkClass = g;\n\n      var v = function () {\n        function t() {\n          this.allObjectsStyleFunction = null, this.linkStyleFunction = null, this.nodeStyleFunction = null, this.nodeRules = {}, this.linkRules = {}, this.nodeClasses = [], this.linkClasses = [], this.node = {\n            fillColor: \"#c7dae0\",\n            lineColor: null,\n            lineWidth: null,\n            radius: 30,\n            aspectRatio: 1,\n            shadowColor: null,\n            lineDash: null\n          }, this.nodeAnchor = {\n            lineColor: \"blue\",\n            lineWidth: 1\n          }, this.link = {\n            fillColor: \"#333\",\n            shadowColor: null,\n            fromDecoration: null,\n            toDecoration: null,\n            label: null,\n            radius: 1,\n            length: 1,\n            strength: 1,\n            lineDash: null,\n            toPieValue: 0,\n            toPieColor: null\n          }, this.item = {\n            align: \"center\",\n            aspectRatio: 4,\n            borderRadius: 1e3,\n            textStyle: {\n              fillColor: \"black\",\n              font: \"12px Arial\"\n            },\n            backgroundStyle: {\n              fillColor: \"rgba(255,255,255,0.7)\"\n            },\n            hoverEffect: !0,\n            zIndex: 0\n          }, this.linkLabel = {\n            padding: .6,\n            margin: 0,\n            align: \"center\",\n            aspectRatio: 4,\n            borderRadius: 1e3,\n            lineSpacing: .2,\n            textStyle: {\n              fillColor: \"black\",\n              font: \"12px Arial\"\n            },\n            backgroundStyle: {\n              fillColor: \"#FFF\",\n              lineColor: \"gray\"\n            },\n            scaleWithZoom: !0,\n            scaleWithSize: !1,\n            rotateWithLink: !1\n          }, this.nodeLabel = {\n            padding: 0,\n            margin: 0,\n            align: \"center\",\n            aspectRatio: 4,\n            borderRadius: 1e3,\n            lineSpacing: .2,\n            textStyle: {\n              fillColor: \"black\",\n              font: \"12px Arial\"\n            },\n            backgroundStyle: {\n              fillColor: \"rgba(255,255,255,0.7)\"\n            },\n            scaleWithZoom: !1,\n            scaleWithSize: !0\n          }, this.nodeLocked = {}, this.nodeExpanded = {}, this.nodeFocused = {\n            fillColor: \"#09c\"\n          }, this.nodeNotLoaded = {\n            fillColor: \"#fff\"\n          }, this.nodeHovered = {\n            shadowOffsetX: 0,\n            shadowOffsetY: 2,\n            shadowBlur: 6,\n            shadowColor: \"rgba(0,0,0,.6)\"\n          }, this.linkHovered = {\n            shadowOffsetX: 0,\n            shadowOffsetY: 0,\n            shadowBlur: 2,\n            shadowColor: \"blue\"\n          }, this.nodeSelected = {}, this.linkSelected = {}, this.selection = {\n            enabled: !0,\n            fillColor: null,\n            lineColor: \"rgba(0,0,0,0)\",\n            lineWidth: 1,\n            sizeConstant: .5,\n            sizeProportional: 0,\n            shadowBlur: 8,\n            shadowOffsetX: 1,\n            shadowOffsetY: 3,\n            shadowColor: \"rgba(0,0,0,0.8)\"\n          }, this.removedColor = \"#EEE\", this.nodeBackground = {}, this.nodeDetailMinZoom = .2, this.nodeDetailMinSize = 5, this.linkDetailMinZoom = .5, this.linkDetailMinSize = 12, this.linkDecorationScale = 4, this.linkDecorationMinSize = 4, this.nodeLabelScaleBase = 30, this.linkLabelScaleBase = 1, this.scaleObjectsWithZoom = !0, this.scaleLinksWithZoom = null;\n        }\n\n        return t;\n      }();\n\n      t.SettingsItemsLayerStyle = v;\n\n      var m = function () {\n        function t(t, e) {\n          this.layer = e, this.styleSettings = t, this.nodeClasses = d.Helpers.arrayToMap(this.styleSettings.nodeClasses, \"className\"), this.linkClasses = d.Helpers.arrayToMap(this.styleSettings.linkClasses, \"className\"), this.nodeRules = this.sortRules(this.styleSettings.nodeRules), this.styleSettings.nodeStyleFunction && this.nodeRules.unshift(this.styleSettings.nodeStyleFunction), this.linkRules = this.sortRules(this.styleSettings.linkRules), this.styleSettings.linkStyleFunction && this.linkRules.unshift(this.styleSettings.linkStyleFunction);\n        }\n\n        return t.getClasses = function (t) {\n          return t ? t.trim().split(/\\s+/g) : [];\n        }, t.prototype.updateLayer = function (t, e) {\n          void 0 === e && (e = !1), null == e && (e = !1), this.isIncremental = e;\n          var i = this.styleSettings,\n              n = t.changes.style || t.changes.zoom && !(!this.nodeRules.length && !this.linkRules.length);\n\n          if (n) {\n            this.isIncremental = !1;\n\n            for (var r = 0, s = this.layer.nodes(); r < s.length; r++) {\n              this.layer.touchNode(s[r]);\n            }\n\n            for (var a = 0, o = this.layer.links(); a < o.length; a++) {\n              this.layer.touchLink(o[a]);\n            }\n          }\n\n          var l = this.layer.modifiedNodes;\n\n          for (var h in l) {\n            var u = l[h];\n            if (this.updateNode(u), e) for (var a = 0; a < u.links.length; a++) {\n              this.layer.touchLink(u.links[a]);\n            }\n          }\n\n          var c = this.layer.modifiedLinks;\n\n          for (var h in c) {\n            var d = c[h];\n            this.updateLink(d);\n          }\n\n          if (i.allObjectsStyleFunction && (t.changes.zoom || this.layer.hasStyleChanges())) {\n            var p = this.layer.nodes(),\n                f = this.layer.links(),\n                g = i.allObjectsStyleFunction(p, f),\n                v = f,\n                m = p;\n            g && (v = g.modifiedLinks, m = g.modifiedNodes);\n\n            for (var y = 0; y < m.length; y += 1) {\n              this.layer.touchNode(m[y]);\n            }\n\n            for (var y = 0; y < v.length; y += 1) {\n              this.layer.touchLink(v[y]);\n            }\n          }\n\n          if (this.nodeRules.length > 0) {\n            l = this.layer.modifiedNodes;\n\n            for (var h in l) {\n              var u = l[h];\n              this.applyStyleRules(u, this.nodeRules);\n            }\n          }\n\n          if (this.linkRules.length > 0) {\n            c = this.layer.modifiedLinks;\n\n            for (var h in c) {\n              var d = c[h];\n              this.applyStyleRules(d, this.linkRules);\n            }\n          }\n        }, t.prototype.postprocessLayer = function (t) {\n          var e = this.layer.modifiedNodes;\n\n          for (var i in e) {\n            var n = e[i];\n            this.postprocessNode(n);\n          }\n\n          var r = this.layer.modifiedLinks;\n\n          for (var i in r) {\n            var s = r[i];\n            this.postprocessLink(s);\n          }\n        }, t.prototype.postprocessItems = function (t) {\n          for (var e = t.currentItems, i = t instanceof h ? d.SettingsMapping.ItemsChartSettingsNodeItem : d.SettingsMapping.ItemsChartSettingsLinkItem, n = this.styleSettings.item, r = 0; r < t.items.length; r++) {\n            var s = t.items[r],\n                a = new d.Label(n);\n            d.SettingsHelper.updateRecursive(a.style, s, i, {}, \"items[\" + r + \"]\"), e.push(a);\n          }\n        }, t.prototype.sortRules = function (t) {\n          var e = [];\n\n          for (var i in t) {\n            e.push(i);\n          }\n\n          e.sort();\n\n          for (var n = [], r = 0; r < e.length; r++) {\n            var i = e[r];\n            n.push(t[i]);\n          }\n\n          return n;\n        }, t.prototype.updateNode = function (t) {\n          var e = this.styleSettings,\n              i = t.hovered;\n          if (t.radius || (t.radius = 10), t.label = null, d.Helpers.extendStyleTo(e.node, t), t._labelStyle = d.Helpers.realClone(e.nodeLabel), t._anchorStyle = d.Helpers.realClone(e.nodeAnchor), t.userLock && d.Helpers.extendStyleTo(e.nodeLocked, t), t.expanded && d.Helpers.extendStyleTo(e.nodeExpanded, t), t.focused && d.Helpers.extendStyleTo(e.nodeFocused, t), t.background && d.Helpers.extendStyleTo(e.nodeBackground, t), t.data.loaded || d.Helpers.extendStyleTo(e.nodeNotLoaded, t), t.data && (t.data.error && (t.label = t.data.error, t.fillColor = \"red\"), t.data.style && d.Helpers.extendStyleTo(t.data.style, t), t.data.className)) for (var n = this.getClassSequence(t.data.className, this.nodeClasses), r = 0; r < n.length; r++) {\n            var s = n[r];\n            d.Helpers.extendStyleTo(this.styleSettings.nodeClasses[s].style, t);\n          }\n          t.removed && (t.fillColor = e.removedColor), t.selected && d.Helpers.extendStyleTo(e.nodeSelected, t), i && d.Helpers.extendStyleTo(e.nodeHovered, t);\n        }, t.prototype.updateLink = function (t) {\n          var e = this.styleSettings;\n          t.label = null, t._labelStyle = d.Helpers.realClone(e.linkLabel), t.radius = 1, d.Helpers.extendStyleTo(e.link, t);\n          var i = t.hovered || t.from.hovered || t.to.hovered;\n          if (t.data.style && d.Helpers.extendStyleTo(t.data.style, t), t.data.className) for (var n = this.getClassSequence(t.data.className, this.linkClasses), r = 0; r < n.length; r++) {\n            var s = n[r];\n            d.Helpers.extendStyleTo(e.linkClasses[s].style, t);\n          }\n          t.selected && d.Helpers.extendStyleTo(e.linkSelected, t), i && (d.Helpers.extendStyleTo(e.linkHovered, t), t.from.hovered && (t.toPieColor = t.fillColor)), t.removed && (t.fillColor = e.removedColor);\n        }, t.prototype.applyStyleRules = function (t, e) {\n          for (var i = 0; i < e.length; i++) {\n            var n = e[i];\n            n(t);\n          }\n        }, t.prototype.getClassSequence = function (e, i) {\n          for (var n = t.getClasses(e), r = [], s = 0; s < n.length; s++) {\n            var a = n[s],\n                o = i[a];\n            o && r.push(o.index);\n          }\n\n          return r.sort(function (t, e) {\n            return t - e;\n          });\n        }, t;\n      }();\n\n      t.ItemsStyle = m;\n\n      var y = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = [], e.info = {\n            enabled: !1,\n            nodeContentsFunction: null,\n            linkContentsFunction: null\n          }, e.interaction = new b(), e.nodeMenu = new z(), e.linkMenu = new B(), e.advanced = new w(), e.style = {}, e;\n        }\n\n        return n(e, t), e.prototype.apply = function (e) {\n          return this.applyCompatibility(e, [{\n            from: \"style.makeImagesCircular\",\n            to: \"style.node.imageCropping\"\n          }, {\n            from: \"style.nodeDecorationMinSize\",\n            alternative: \"style.nodeDetailMinSize\"\n          }, {\n            from: \"style.nodeLabelMinSize\",\n            to: \"style.nodeDetailMinSize\"\n          }, {\n            from: \"style.nodeRules\",\n            alternative: \"style.nodeStyleFunction\",\n            alternativeAsWarning: !0\n          }, {\n            from: \"style.linkRules\",\n            alternative: \"style.linkStyleFunction\",\n            alternativeAsWarning: !0\n          }]), t.prototype.apply.call(this, e);\n        }, e;\n      }(d.Settings);\n\n      t.Settings = y;\n\n      var S = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.cacheSize = 1e4, e.random = null, e.randomGridLinkProbability = .6, e.randomNodes = 0, e.randomLinks = 0, e.randomTreeDensity = 3, e.requestMaxUnits = 2, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsData);\n\n      t.SettingsData = S;\n\n      var b = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.nodesMovable = !0, e.zooming = new C(), e.panning = {\n            enabled: !0\n          }, e.selection = new x(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsInteraction);\n\n      t.SettingsInteraction = b;\n\n      var x = function () {\n        function t() {\n          this.enabled = !0, this.nodesSelectable = !0, this.linksSelectable = !0, this.lockNodesOnMove = !0, this.allowMoveNodesOffscreen = !0, this.tolerance = 10;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionSelection = x;\n\n      var C = function () {\n        function t() {\n          this.zoomInOnDoubleClick = !0, this.autoZoomAfterClick = !1, this.doubleClickZoom = 1.5, this.sensitivity = 1, this.wheel = !0, this.fingers = !0;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionZooming = C;\n\n      var w = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.perNodeLoadingIndicator = !0, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsAdvanced);\n\n      t.SettingsAdvanced = w;\n\n      var L = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(s);\n\n      t.ImageShape = L;\n\n      var T = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.leftOffset = 0, e;\n        }\n\n        return n(e, t), e.prototype.postProcessLabel = function (t, e) {\n          if (this.nodesLayer.chart.assetsLoaded) {\n            var i = this.node.targetHHeight,\n                n = this.currentLabel;\n            null == n ? n = this.currentLabel = new d.Label(this.node.labelStyle, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.backgroundStyle = null, n.style.image = null, e.measure(t, n);\n            var r = n.hwidth,\n                s = n.hheight,\n                a = r / s * i;\n            this.node.image && (a += i), this.node.targetHWidth = Math.max(a, i), this.node.bounds.x0 = -this.node.targetHWidth, this.node.bounds.x1 = this.node.targetHWidth;\n          }\n        }, e.prototype.distanceToEdge = function (t, e, i, n) {\n          return d.Geometry.distanceToBalloon(t, e, i, n);\n        }, e.prototype.paintSelection = function (t, e, i) {\n          var n = this.node.renderHheight * (1 + e) + i,\n              r = this.node.renderHwidth - this.node.renderHheight + n,\n              s = this.x,\n              a = this.y,\n              o = s + r - n;\n          t.moveTo(o, a - n), t.arc(o, a, n, -Math.PI / 2, Math.PI / 2, !1), o = s - r + n, t.lineTo(o, a + n), t.arc(o, a, n, Math.PI / 2, -Math.PI / 2, !1), t.closePath();\n        }, e.prototype.paintDetails = function (t, e) {\n          var i = this.currentLabel;\n\n          if (i) {\n            if (this.hWidth > 2) {\n              if (e.measure(t, i), this._computeScale(), this.image) {\n                var n = this.image,\n                    r = this.x - this.hHeight,\n                    s = this.y - this.imSize / 2;\n\n                if (this.node.imageSlicing) {\n                  var a = this.node.imageSlicing;\n                  d.Graphics.drawImageHighQuality(t, n, a[0], a[1], a[2], a[3], r, s, this.imSize, this.imSize);\n                } else d.Graphics.drawImageHighQuality(t, n, 0, 0, n.width, n.height, r, s, this.imSize, this.imSize);\n              }\n\n              e.paint(t, this.x + this.leftOffset, this.y, this.scale, i), d.Graphics.clearShadow(t);\n            }\n          } else this.basicPaintImage(t);\n        }, e.prototype._computeScale = function () {\n          this.scale = this.hWidth / this.currentLabel.hheight, this.image && (this.leftOffset = this.hWidth, this.imSize = 2 * this.hWidth);\n        }, e;\n      }(s);\n\n      t.TextShape = T;\n\n      var k = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e.prototype.postProcessLabel = function (t, e) {\n          if (this.nodesLayer.chart.assetsLoaded) {\n            var i = this.node.labelStyle;\n            i.backgroundStyle.fillColor = \"transparent\";\n            var n = this.currentLabel;\n            null == n ? n = this.currentLabel = new d.Label(i, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.aspectRatio = 1, n.style.image = null;\n          }\n        }, e.prototype.distanceToEdge = function (t, e, i, n) {\n          return s.prototype.distanceToEdge.call(this, t, e, i, n);\n        }, e.prototype._computeScale = function () {\n          var t = Math.sqrt(this.currentLabel.hwidth * this.currentLabel.hwidth + this.currentLabel.hheight * this.currentLabel.hheight);\n\n          if (this.image) {\n            var e = this.currentLabel.lineHeight + 2 * this.currentLabel.hwidth,\n                i = (e * e + this.currentLabel.hheight * this.currentLabel.hheight) / 2 / e;\n            i > t && (this.leftOffset = i - t, t = i);\n          }\n\n          this.scale = this.hWidth / t, this.image && (this.imSize = this.currentLabel.lineHeight * this.scale);\n        }, e;\n      }(T);\n\n      t.RoundTextShape = k;\n\n      var M = {\n        a0x: 0,\n        a0y: -1,\n        a1x: .556548642145067,\n        a1y: -1,\n        a2x: 1,\n        a2y: -.5534547954623581,\n        b0x: 1,\n        b0y: 0,\n        b1x: 1,\n        b1y: .808869027157099,\n        b2x: 0,\n        b2y: 1.2870402200068753,\n        apexX: 0,\n        apexY: 1.878652526641458,\n        imageRadius: .6170212765957447\n      },\n          A = [M.a0x, M.a0y, M.a1x, M.a1y, M.a2x, M.a2y, M.b0x, M.b0y, M.b1x, M.b1y, M.b2x, M.b2y, M.apexX, M.apexY],\n          I = d.Helpers.reversePolyline(d.Geometry.transformPolyline(A, -1, 0, 1, 0)),\n          P = [0, -1, .7095605708093294, -.7046444467621514, 1, 0, 1, 0, .4313896533498214, .9021657092700437, 1, 0],\n          D = d.Helpers.reversePolyline(d.Geometry.transformPolyline(P, -1, 0, 1, 0)),\n          N = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e.prototype.postProcess = function (e, i, n) {\n          t.prototype.postProcess.call(this, e, i, n), this.node.bounds.addBounds(0, 0, 0, this.node.targetHHeight * M.apexY), this.node.shapeAnchorX = 0, this.node.shapeAnchorY = this.node.radius * M.apexY;\n        }, e.prototype.getAnchor = function () {\n          return {\n            x: 0,\n            y: this.hWidth * M.apexY\n          };\n        }, e.prototype.adaptToViewport = function (e, i, n, r, s) {\n          t.prototype.adaptToViewport.call(this, e, i, n, r, s), this.controlPoints = d.Geometry.transformPolyline(A, this.hWidth, this.x, this.hHeight, this.y), this.reverseControlPoints = d.Geometry.transformPolyline(I, this.hWidth, this.x, this.hHeight, this.y);\n        }, e.prototype.paintSelection = function (t, e, i) {\n          var n = this.hWidth * e + i,\n              r = d.Geometry.outlinePolylineByVectors(this.controlPoints, P, n),\n              s = d.Geometry.outlinePolylineByVectors(this.reverseControlPoints, D, n);\n          t.moveTo.apply(t, r.slice(0, 2)), t.bezierCurveTo.apply(t, r.slice(2, 8)), t.bezierCurveTo.apply(t, r.slice(8, 14)), t.arc(this.controlPoints[12], this.controlPoints[13], n, 0, Math.PI, !1), t.bezierCurveTo.apply(t, s.slice(2, 8)), t.bezierCurveTo.apply(t, s.slice(8, 14)), t.closePath();\n        }, e.prototype.paintBasicShape = function (t) {\n          var e = d.Graphics.beginStrokeAndFill(t, this.node);\n          e.beginPath(), e.moveTo.apply(e, this.controlPoints.slice(0, 2)), e.bezierCurveTo.apply(e, this.controlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.controlPoints.slice(8, 14)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(8, 14)), e.closePath(), d.Graphics.endStrokeAndFill(t, e, this.node);\n        }, e.prototype.paintDetails = function (t, e) {\n          this.image && this.basicPaintImage(t, M.imageRadius), this.paintLabel(t, e);\n        }, e.prototype.getLabelPosition = function (t, e) {\n          return {\n            x: this.x,\n            y: this.y - this.hWidth - t.hheight * e * 1.1\n          };\n        }, e.prototype.distanceToEdge = function (t, e, i, n) {\n          var r = e,\n              s = t * M.apexY,\n              a = d.Geometry.rayIntersectsSegment(0, 0, i, n, 0, s, r, 0),\n              o = d.Geometry.rayIntersectsSegment(0, 0, i, n, -r, 0, 0, s),\n              l = Math.min(a, o);\n          return l < 1 / 0 ? l : t;\n        }, e;\n      }(s);\n\n      t.DropletShape = N;\n\n      var F = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e.prototype.calcHalf = function (t, e) {\n          return this.node.aspectRatio > 1 ? {\n            hWidth: t,\n            hHeight: t / this.node.aspectRatio\n          } : {\n            hWidth: e * this.node.aspectRatio,\n            hHeight: e\n          };\n        }, e.prototype.render = function (t, e, i) {\n          var n = this.calcHalf(this.hWidth, this.hHeight),\n              r = n.hHeight,\n              s = n.hWidth;\n          r = r * (1 + e) + i, s = s * (1 + e) + i, t.moveTo(this.x, this.y), t.moveTo(this.x - s, this.y - r), t.lineTo(this.x + s, this.y - r), t.lineTo(this.x + s, this.y + r), t.lineTo(this.x - s, this.y + r), t.lineTo(this.x - s, this.y - r);\n        }, e.prototype.paint = function (t, e, i) {\n          this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !1), this.paintDetails(t, e));\n        }, e.prototype.paintBasicShape = function (t) {\n          var e = d.Graphics.beginStrokeAndFill(t, this.node);\n          this.render(e, 0, 0), this.applyRadialGradient(t), d.Graphics.endStrokeAndFill(t, e, this.node);\n        }, e.prototype.basicPaintImage = function (t, e) {\n          if (void 0 === e && (e = 1), this.image) {\n            var i, n, r, s, a, o, l, h;\n\n            if (this.node.imageSlicing) {\n              var u = this.node.imageSlicing;\n              i = u[0], n = u[1], r = u[2], s = u[3];\n            } else i = 0, n = 0, r = this.image.width, s = this.image.height;\n\n            var c = this.calcHalf(this.hWidth, this.hHeight),\n                p = c.hHeight,\n                f = c.hWidth;\n\n            switch (this.node.imageCropping) {\n              case !0:\n                a = this.x - f, o = this.y - p, l = 2 * f, h = 2 * p;\n                break;\n\n              case \"crop\":\n                if (a = this.x - f, o = this.y - p, l = 2 * f, h = 2 * p, s * this.node.aspectRatio <= r) {\n                  var g = s * this.node.aspectRatio;\n                  i += (r - g) / 2, r = g;\n                } else {\n                  var v = r / this.node.aspectRatio;\n                  n += (s - v) / 2, s = v;\n                }\n\n                break;\n\n              case \"letterbox\":\n              case \"fit\":\n                var m = Math.min(2 * p / s, 2 * f / r);\n                h = s * m, l = r * m, a = this.x - l / 2, o = this.y - h / 2;\n                break;\n\n              default:\n                var y = 2 * Math.max(f, p),\n                    S = Math.min(y / s, y / r);\n                h = s * S, l = r * S, a = this.x - l / 2, o = this.y - h / 2;\n            }\n\n            d.Graphics.drawImageHighQuality(t, this.image, i, n, r, s, a, o, l, h);\n          }\n        }, e.prototype.paintSelection = function (t, e, i) {\n          this.render(t, e, i), t.closePath();\n        }, e.prototype.distanceToEdge = function (t, e, i, n) {\n          var r = this.calcHalf(t, e);\n          return Math.min(r.hHeight / Math.abs(n), r.hWidth / Math.abs(i));\n        }, e.prototype.hitTest = function (t, e, i, n) {\n          var r = this.node,\n              s = this.calcHalf(r.renderHwidth * i, r.renderHheight * i),\n              a = Math.max(Math.abs(t - r.x) - s.hWidth, Math.abs(e - r.y) - s.hHeight);\n          return a < 0 ? 0 : Math.min(a, n);\n        }, e;\n      }(s);\n\n      t.RectangleShape = F;\n\n      var O = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.multilinkSpacing = 10, e.nodeRadiusExtent = [10, 150], e.linkRadiusExtent = [.6, 30], e.linkStrengthExtent = [.1, 1], e.linkLengthExtent = [.3, 150], e.nodeAutoScaling = null, e.linkAutoScaling = null, e.linkStrengthAutoScaling = null, e.linkLengthAutoScaling = null, e.hiddenLinks = {\n            lineColor: \"rgba(100,100,100,0.3)\",\n            lineWidth: 1,\n            size: 7\n          }, e.fadeTime = 600, e.selfLinkHeightFactor = 1, e.selfLinkWidthFactor = 1, e.selfLinkShape = \"quadratic\", e.selfLinkAngle = 60, e;\n        }\n\n        return n(e, t), e;\n      }(v);\n\n      t.SettingsNodesLayerStyle = O;\n\n      var E = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e, i) || this;\n          return r.g = null, r.fadeout = n, r.styleSettings = e, r;\n        }\n\n        return n(e, t), e.prototype.updateLayer = function (e, i) {\n          void 0 === i && (i = !1), this.nodeRadiusChanged = d.Helpers.hasProperties(this.layer.newNodes) || d.Helpers.hasProperties(this.layer.deletedNodes) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.nodeRules.length > 0, this.linkRadiusChanged = d.Helpers.hasProperties(this.layer.newLinks) || d.Helpers.hasProperties(this.layer.deletedLinks) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.linkRules.length > 0, t.prototype.updateLayer.call(this, e, i);\n        }, e.prototype.setItemRenderer = function (t) {\n          this.itemRenderer = t;\n        }, e.prototype.setContext = function (t) {\n          this.g = t;\n        }, e.prototype.postprocessLayer = function (t) {\n          this.g = t.context;\n          var e = this.layer,\n              i = this.styleSettings.removedColor;\n          this.setItemRenderer(t.labelRenderer);\n\n          for (var n in e.modifiedLinks) {\n            var r = e.modifiedLinks[n];\n            this.fadeout && r.relevance < 1 && (r.fillColor && (r.fillColor = d.Colors.blend(i, r.fillColor, r.relevance)), r.lineColor && (r.lineColor = d.Colors.blend(i, r.lineColor, r.relevance)), r.length = .2 + (r.length - .2) * r.relevance), this.postprocessLink(r);\n          }\n\n          for (var s in e.modifiedNodes) {\n            var a = e.modifiedNodes[s];\n            this.fadeout && a.relevance < 1 && (a.fillColor && (a.fillGradient || (a.fillColor = d.Colors.blend(i, a.fillColor, a.relevance))), a.lineColor && (a.lineColor = d.Colors.blend(i, a.lineColor, a.relevance)));\n          }\n\n          var o = this.layer.nodes();\n\n          if (this.nodeRadiusChanged || this.fadeout && t.changes.navigation) {\n            this.computeNodeSize(o, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);\n\n            for (var l = 0; l < o.length; l++) {\n              var h = o[l];\n              this.postprocessNode(h);\n            }\n          } else for (var u in e.modifiedNodes) {\n            var c = e.modifiedNodes[u];\n            this.postprocessNode(c);\n          }\n\n          if (this.linkRadiusChanged || t.changes.navigation) {\n            var p = e.links();\n            this.computeRadii(p, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent), this.computeStrengths(p, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent), this.computeLengths(p, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent), d.Helpers.sort(p, function (t, e) {\n              return t.targetRadius === e.targetRadius ? 0 : t.targetRadius > e.targetRadius ? 1 : -1;\n            });\n          }\n\n          d.Helpers.sort(o, function (t, e) {\n            return t.zindex - e.zindex;\n          });\n        }, e.prototype.updateLink = function (e) {\n          var i = e.radius;\n          t.prototype.updateLink.call(this, e), i !== e.radius && (this.linkRadiusChanged = !0);\n        }, e.prototype.updateNode = function (e) {\n          var i = e.radius;\n          t.prototype.updateNode.call(this, e), i !== e.radius && (this.nodeRadiusChanged = !0), null == e.label && e.data && (e.label = e.data.id);\n        }, e.prototype.computeNodeSize = function (t, e, i) {\n          var n = i[0],\n              r = i[1];\n\n          if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed && !l.invisible) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) ? (s = Math.min(s, h), a = Math.max(a, h)) : l.targetHHeight = n;\n              }\n            }\n\n            if (s >= a) for (var o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetHHeight = r);\n            } else if (\"linear\" === e) for (var u = r / a, o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) && (l.targetHHeight = Math.max(n, h * u));\n              }\n            } else if (\"square\" === e) for (var u = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) && (l.targetHHeight = Math.max(n, Math.sqrt(h) * u));\n              }\n            } else {\n              s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n              for (var u = r / Math.log(a), o = 0; o < t.length; o++) {\n                var l = t[o];\n                !l.removed && d.Helpers.isNumber(l.radius) && (l.targetHHeight = Math.max(n, Math.log(Math.max(1e-4, l.radius)) * u));\n              }\n            }\n          } else for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.removed || (d.Helpers.isNumber(l.radius) ? l.targetHHeight = Math.min(Math.max(1e-6, l.radius), 1e30) : l.targetHHeight = n);\n          }\n\n          if (this.fadeout) for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.relevance < 1 && (l.targetHHeight = l.targetHHeight * l.relevance);\n          }\n        }, e.prototype.computeRadii = function (t, e, i) {\n          var n = i[0],\n              r = i[1];\n\n          if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) ? (s = Math.min(s, h), a = Math.max(a, h)) : l.targetRadius = n;\n              }\n            }\n\n            if (s >= a) for (var o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetRadius = n);\n            } else if (\"linear\" === e) for (var u = r / a, o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) && (l.targetRadius = Math.max(n, h * u));\n              }\n            } else if (\"square\" === e) for (var u = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var h = l.radius;\n                d.Helpers.isNumber(h) && (l.targetRadius = Math.max(n, Math.sqrt(h) * u));\n              }\n            } else {\n              s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n              for (var u = r / Math.log(a), o = 0; o < t.length; o++) {\n                var l = t[o];\n                !l.removed && d.Helpers.isNumber(l.radius) && (l.targetRadius = Math.max(n, Math.log(Math.max(1e-4, l.radius)) * u));\n              }\n            }\n          } else for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.removed || (d.Helpers.isNumber(l.radius) ? l.targetRadius = Math.min(Math.max(1e-6, l.radius), 1e30) : l.targetRadius = n);\n          }\n\n          if (this.fadeout) for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.relevance < 1 && (l.targetRadius = l.targetRadius * l.relevance);\n          }\n        }, e.prototype.computeStrengths = function (t, e, i) {\n          var n = i[0],\n              r = i[1];\n\n          if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (s = Math.min(s, l.strength), a = Math.max(a, l.strength));\n            }\n\n            if (s >= a) for (var o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetStrength = n);\n            } else if (\"linear\" === e) for (var h = r / a, o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetStrength = Math.min(n, l.strength * h));\n            } else if (\"square\" === e) for (var h = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var u = l.strength;\n                d.Helpers.isNumber(u) && (l.targetStrength = Math.max(n, Math.sqrt(u) * h));\n              }\n            } else {\n              s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n              for (var h = r / Math.log(a), o = 0; o < t.length; o++) {\n                var l = t[o];\n                l.removed || (l.targetStrength = Math.max(n, Math.log(Math.max(1e-4, l.strength)) * h));\n              }\n            }\n          } else for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.removed || (l.targetStrength = Math.min(Math.max(n, l.strength), r));\n          }\n        }, e.prototype.computeLengths = function (t, e, i) {\n          var n = i[0],\n              r = i[1];\n\n          if (\"linear\" === e || \"logarithmic\" === e || \"square\" === e) {\n            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (s = Math.min(s, l.length), a = Math.max(a, l.length));\n            }\n\n            if (s >= a) for (var o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetLength = n);\n            } else if (\"linear\" === e) for (var h = (r - n) / (a - s), u = r - a * h, o = 0; o < t.length; o++) {\n              var l = t[o];\n              l.removed || (l.targetLength = l.length * h + u);\n            } else if (\"square\" === e) for (var h = r / Math.sqrt(a), o = 0; o < t.length; o++) {\n              var l = t[o];\n\n              if (!l.removed) {\n                var c = l.length;\n                d.Helpers.isNumber(c) && (l.targetLength = Math.max(n, Math.sqrt(c) * h));\n              }\n            } else {\n              s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);\n\n              for (var h = (r - n) / Math.log(a / s), u = r - h * Math.log(a), o = 0; o < t.length; o++) {\n                var l = t[o];\n                l.removed || (l.targetLength = Math.log(Math.max(1e-4, l.length)) * h + u);\n              }\n            }\n          } else for (var o = 0; o < t.length; o++) {\n            var l = t[o];\n            l.removed || (l.targetLength = Math.min(Math.max(n, l.length), r));\n          }\n        }, e.prototype.postprocessNode = function (t) {\n          var e;\n\n          switch (t.display) {\n            case \"customShape\":\n              e = a;\n              break;\n\n            case \"roundtext\":\n              e = k;\n              break;\n\n            case \"text\":\n              e = T;\n              break;\n\n            case \"droplet\":\n              e = N;\n              break;\n\n            case \"rectangle\":\n              e = F;\n              break;\n\n            default:\n              e = L;\n          }\n\n          t.shape && t.shape.constructor === e || (t.shape && (t.shape.node = null), t.shape = new e(t, this.layer));\n          var i = t.outerBounds = d.Rect.createEmpty();\n          t.shape.postProcess(this.styleSettings, this.g, this.itemRenderer), i.addRect(t.bounds), t.currentItems = [], this.postprocessItems(t);\n\n          for (var n = t.targetHWidth, r = t.targetHHeight, s = 0; s < t.currentItems.length; s++) {\n            var o = t.currentItems[s];\n            this.measureCustomItem(n, r, t.shape.sizeScale, o, i);\n          }\n        }, e.prototype.measureCustomItem = function (t, e, i, n, r) {\n          this.itemRenderer.measure(this.g, n);\n          var s = 1;\n          n.style.scaleWithSize && (s = i);\n          var a = n.style.x || 0,\n              o = n.style.y || 0,\n              l = n.style.px || 0,\n              h = n.style.py || 0,\n              u = t * l + a,\n              c = e * h + o;\n          r.addBounds(u - n.hwidth * s, c - n.hheight * s, u + n.hwidth * s, c + n.hheight * s);\n        }, e.prototype.postprocessLink = function (t) {\n          var e = [];\n\n          if (t.label) {\n            var i = void 0;\n            t.currentItems && t.currentItems.length ? (i = t.currentItems[0], i.style = t.labelStyle) : i = new d.Label(t.labelStyle), i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i);\n          }\n\n          t.currentItems = e, this.postprocessItems(t);\n        }, e;\n      }(m);\n\n      t.NodesStyle = E;\n\n      var R = function () {\n        function t() {\n          this.className = null, this.text = null, this.title = null, this.onInit = null, this.onRefresh = null, this.onClick = null;\n        }\n\n        return t;\n      }();\n\n      t.SettingsMenuButton = R;\n\n      var H = function () {\n        function t() {\n          this.enabled = !0, this.showData = !1, this.contentsFunction = null, this.buttons = [];\n        }\n\n        return t;\n      }();\n\n      t.SettingsMenu = H;\n\n      var z = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.contentsFunction = null, e.buttons = [], e;\n        }\n\n        return n(e, t), e;\n      }(H);\n\n      t.SettingsNodeMenu = z;\n\n      var B = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.contentsFunction = null, e;\n        }\n\n        return n(e, t), e;\n      }(H);\n\n      t.SettingsLinkMenu = B;\n\n      var U = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 600, i.paintOrder = 40, i.updateOrder = 2e3, i.node = null, i.link = null, i.contents = null, i.x = 0, i.y = 0, i.chart = e, i.container = e.shell.menuContainer, i.scene = e.scene, i.events = e.events, i.buttons = [], i.popup = d.Helpers.createDom(\"div\", \"DVSL-Menu\", null, i.container), i.closeButton = d.Helpers.createDom(\"a\", \"DVSL-Menu-close\", null, i.popup), i.popupValue = d.Helpers.createDom(\"div\", \"DVSL-Menu-title\", null, i.popup), i.detailsDiv = d.Helpers.createDom(\"div\", \"DVSL-Menu-details\", null, i.popup), i.popupActions = d.Helpers.createDom(\"nav\", null, null, i.popup), i.buildDetailsPanel(i.detailsDiv), i.buildCloseButton(i.closeButton), i.popup.style.position = \"absolute\", i.popup.style.display = \"none\", i;\n        }\n\n        return n(e, t), e.prototype.remove = function () {\n          this.popup.parentNode && this.popup.parentNode.removeChild(this.popup);\n        }, e.prototype.doAnimations = function (t) {\n          this.node && (this.node.removed || this.link && this.link.removed ? this.hideMenu() : this.node.layer.modifiedNodes.hasOwnProperty(this.node.id) && this.updateMenu());\n        }, e.prototype.previewPointerDown = function (t) {\n          this.hideMenu();\n        }, e.prototype.previewWheel = function (t) {\n          this.hideMenu();\n        }, e.prototype.toggleNodeMenu = function (t) {\n          this.node === t ? this.hideMenu() : this.showNodeMenu(t);\n        }, e.prototype.toggleLinkMenu = function (t, e, i) {\n          this.link === i ? this.hideMenu() : this.showLinkMenu(t, e, i);\n        }, e.prototype.showNodeMenu = function (t) {\n          this.scene.settings.nodeMenu.enabled && (this.node === t ? this.updateMenu() : (this.hideMenu(), this.showPopup(t, null)));\n        }, e.prototype.showLinkMenu = function (t, e, i) {\n          this.scene.settings.linkMenu.enabled && (this.x = t, this.y = e, this.link === i ? this.updateMenu() : (this.hideMenu(), this.showPopup(null, i)));\n        }, e.prototype.showPopup = function (t, e) {\n          this.node = t, this.link = e, this.node && (this.node.locks += 1), this.buildButtons(), this.contents = null, this.popupValue.innerHTML = \"\", this.popup.style.display = \"block\", this.updateMenu(), this.updateXY();\n        }, e.prototype.hideMenu = function () {\n          (this.node || this.link) && (this.node && (this.node.locks -= 1), this.node = null, this.link = null, this.popup.style.display = \"none\");\n        }, e.prototype.updateMenu = function () {\n          var t = this;\n          this.closeButton.title = this.scene.settings.localization.closeButton;\n          var e, i;\n          this.node ? (e = this.scene.settings.nodeMenu, i = this.node) : (e = this.scene.settings.linkMenu, i = this.link);\n\n          var n = null,\n              r = this.node,\n              s = this.link,\n              a = function a(e) {\n            if (t.node === r && t.link === s && e !== t.contents) {\n              if (null == e) t.popupValue.innerHTML = \"\";else if (d.Helpers.isString(e)) t.popupValue.innerHTML = e;else {\n                if (!d.Helpers.isDomObject(e)) return void d.Helpers.error(\"Invalid value for menu text. Must be either a string or a DOM element.\");\n                t.popupValue.innerHTML = \"\", t.popupValue.appendChild(e);\n              }\n              t.contents = e;\n            }\n          };\n\n          if (e.contentsFunction) {\n            var o = e.contentsFunction.call(this.chart.api, i.data, i, a);\n            n = d.Helpers.isString(o) || d.Helpers.isDomObject(o) ? o : null == this.contents ? \"<small>\" + this.scene.settings.localization.loadingLabel + \"</small>\" : this.contents;\n          } else n = i.label;\n\n          a(n), this.updateButtons(), e.showData ? (this.details.innerHTML = JSON.stringify(i.data, null, \"  \"), this.detailsDiv.style.display = \"block\") : (this.detailsDiv.style.display = \"none\", null == n && 0 === this.buttons.length && this.hideMenu());\n        }, e.prototype.updateXY = function () {\n          var t,\n              e,\n              i,\n              n,\n              r,\n              s,\n              a = 12;\n\n          if (this.node) {\n            var o = this.scene.toDisplay(this.node.x, this.node.y);\n            r = o.x, s = o.y, t = s - this.node.renderHheight - a, n = s + this.node.renderHheight + a, e = r - this.node.renderHheight - a, i = r + this.node.renderHheight + a;\n          } else t = n = s = this.y, e = this.x - a, i = this.x + a;\n\n          var l = this.chart.getRootChart().scene,\n              h = l.x0,\n              u = l.x0 + l.width,\n              c = this.popup.offsetWidth,\n              d = this.popup.offsetHeight;\n          s = Math.max(Math.min(s, l.y0 + l.height - d), l.y0), i + c <= u ? r = i : e - c >= h ? r = e - c : (r = Math.max(e - c / 2, h), s = n), this.popup.style.left = r + \"px\", this.popup.style.top = s + \"px\";\n        }, e.prototype.buildDefaultButton = function (t, e) {\n          this.chart.error(\"The menu does not support any named buttons.\");\n        }, e.prototype.buildButton = function (t, e, i, n, r, s, a) {\n          var o = this,\n              l = d.Helpers.createDom(\"a\", e, i, this.popupActions);\n          l.title = n, l.onclick = function (e) {\n            s && s.call(o.chart.api, t, l), o.hideMenu(), e.preventDefault();\n          }, l.href = \"#\", r && r.call(this.chart.api, t, l), this.buttons.push({\n            e: l,\n            t: t,\n            a: a\n          });\n        }, e.prototype.buildButtons = function () {\n          this.popupActions.innerHTML = \"\", this.buttons = [];\n          var t, e;\n          this.node ? (t = this.scene.settings.nodeMenu, e = this.node) : (t = this.scene.settings.linkMenu, e = this.link);\n          var i = t.buttons;\n          if (i) for (var n = 0; n < i.length; n++) {\n            var r = i[n];\n            d.Helpers.isString(r) ? this.buildDefaultButton(e, r) : this.buildButton(e, r.className, r.text, null == r.title ? r.text : r.title, r.onInit, r.onClick, r.onRefresh);\n          }\n        }, e.prototype.updateButtons = function () {\n          for (var t = 0; t < this.buttons.length; t++) {\n            var e = this.buttons[t];\n            e.a && e.a.call(this.chart.api, e.t, e.e);\n          }\n        }, e.prototype.buildCloseButton = function (t) {\n          var e = this;\n\n          t.onclick = function (t) {\n            e.hideMenu(), t.preventDefault();\n          };\n        }, e.prototype.buildDetailsPanel = function (t) {\n          var e = d.Helpers.createDom(\"small\", null, \"Technical data\", t),\n              i = this.details = d.Helpers.createDom(\"pre\", null, \"\", t);\n          i.style.display = \"none\", e.onclick = function () {\n            \"none\" === i.style.display ? i.style.display = \"block\" : i.style.display = \"none\";\n          };\n        }, e;\n      }(d.ChartElement);\n\n      t.Menu = U;\n\n      var G = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 800, i.paintOrder = 45, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.item = null, i.x = null, i.y = null, i.popup = new d.InfoPopup(e), i;\n        }\n\n        return n(e, t), e.prototype.previewPointerMove = function (t) {\n          this.onMove(t.x, t.y);\n        }, e.prototype.doAnimations = function (t) {\n          null !== this.x && null !== this.y && this.onMove(this.x, this.y);\n        }, e.prototype.previewPointerDown = function (t) {\n          this.x = this.y = null, this.setCurrentObject(0, 0, null);\n        }, e.prototype.previewPointerDrag = function (t) {\n          this.x = this.y = null, this.setCurrentObject(0, 0, null);\n        }, e.prototype.onPointerOut = function (t) {\n          this.x = this.y = null, this.setCurrentObject(0, 0, null);\n        }, e.prototype.onMove = function (t, e) {\n          if (this.y = e, this.x = t, this.options.info.enabled) {\n            var i = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;\n            this.setCurrentObject(t, e, i);\n          }\n        }, e.prototype.setCurrentObject = function (t, e, i) {\n          if (i) {\n            if (i !== this.item) {\n              var n = this.buildContents(i);\n              this.popup.show(t, t, e, n);\n            } else this.popup.updateXY(t, t, e);\n\n            this.item = i;\n          } else this.item = null, this.popup.hide();\n        }, e.prototype.buildContents = function (t) {\n          var e = this,\n              i = null;\n\n          if (t instanceof h ? i = this.options.info.nodeContentsFunction : t instanceof u && (i = this.options.info.linkContentsFunction), i) {\n            var n = function n(i) {\n              t === e.item && e.popup.updateContents(i);\n            };\n\n            return i.call(this.chart.api, t.data, t, n);\n          }\n\n          return t.label;\n        }, e.prototype.remove = function () {\n          this.popup.remove();\n        }, e;\n      }(d.ChartElement);\n\n      t.InfoPopup = G;\n\n      var V = \"undefined\" != typeof Float32Array,\n          j = function () {\n        function t() {\n          this._calculatedStyles = {}, this._defaultStyles = {}, this.enabled = !0, this.drawLimit = .8, this.cellSize = 3, this.intensity = 6, this.style = {}, this.defaultStyle = null, this.defaultColors = [\"rgba(47,195,47,0.3)\", \"rgba(176,220,11,0.3)\", \"rgba(234,180,4,0.3)\", \"rgba(222,103,44,0.3)\", \"rgba(236,46,46,0.3)\", \"rgba(213,66,155,0.3)\", \"rgba(111,82,184,0.3)\", \"rgba(28,124,213,0.3)\", \"rgba(86,185,247,0.3)\", \"rgba(10,232,235,0.3)\"], this.overlap = !1;\n        }\n\n        return t;\n      }();\n\n      t.SettingsNodesLayerAuras = j;\n\n      var W = function () {\n        function t(t, e, i) {\n          this._marginCells = 1, this._polygons = [], this._autoAuraCounter = 0, this._overlapWarning = !0, this._auraCounter = 0, this._settings = i, this._scene = t, this._events = e;\n        }\n\n        return t.prototype.recalculateStyles = function (t) {\n          var e = this._settings,\n              i = Object.keys(e.style);\n          e._calculatedStyles = {};\n\n          for (var n = 0; n < i.length; n++) {\n            var r = i[n],\n                s = d.Helpers.realClone(this._settings._defaultStyles[r]);\n            e.defaultStyle && d.Helpers.extendStyleTo(e.defaultStyle, s), e.style[r] && d.Helpers.extendStyleTo(e.style[r], s), e._calculatedStyles[r] = s, s.__auraCounter = this._auraCounter++;\n          }\n\n          i = Object.keys(t).filter(function (t) {\n            return e._calculatedStyles[t].enabled;\n          }), i.sort(function (t, i) {\n            var n = e._calculatedStyles[t].zIndex - e._calculatedStyles[i].zIndex;\n            return 0 === n ? t.localeCompare(i) : n;\n          }), this._auras = new Array(i.length + 1), this._aurasMap = Object.create(null), this._aurasMap[\"\"] = 0;\n\n          for (var n = 0; n < i.length; n++) {\n            var a = i[n];\n            this._aurasMap[a] = n + 1, this._auras[n + 1] = e._calculatedStyles[a];\n          }\n\n          this._events.notifySceneChanges({\n            auras: !0\n          });\n        }, t.prototype.recalculateGrid = function () {\n          var t = this._scene,\n              e = this._settings;\n          this._overlapWarning = e.overlap;\n\n          for (var i = t.width, n = t.height, r = this._marginCells, s = e.cellSize, a = this._widthCells = Math.ceil(i / s) + 2 * r, o = this._heightCells = Math.ceil(n / s) + 2 * r, l = this._cellLength = this._auras.length, h = a * o * l, u = this._cells = V ? new Float32Array(h) : new Array(h), c = this._cellEdges = V ? new Int8Array(h) : new Array(h), d = a * l, p = 0; p < h; p++) {\n            c[p] = -1;\n          }\n\n          if (!V) for (var f = 0; f < u.length; f++) {\n            u[f] = 0;\n          }\n          var g = [-d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l, -d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l];\n          this._edgeFinderDeltas = V ? new Int16Array(g) : g;\n        }, t.prototype.doAnimations = function (t, e) {\n          if (this._settings.enabled && t) {\n            for (var i = !1, n = {}, r = 0; r < t.length; r++) {\n              var s = t[r].aura;\n\n              if (s) {\n                Array.isArray(s) ? !this._overlapWarning && s.length > 1 && (d.Helpers.warn(\"One or more nodes defined more than one aura. It is recommended to set `overlap: true` in the chart configuration to better handle this scenario.\"), this._overlapWarning = !0) : s = [s];\n\n                for (var a = 0; a < s.length; a++) {\n                  var o = \"\" + (s[a] || \"\");\n                  \"\" !== o && (i = !0, n[o] = !0, this.ensureAura(o));\n                }\n              }\n            }\n\n            for (var r in this._settings.style) {\n              d.Helpers.hasProperty(this._settings.style, r) && this.ensureAura(r);\n            }\n\n            var l,\n                h = e.changes,\n                u = h.settingsChanges,\n                c = !1;\n            if (!this._auras || u && u.auras) l = !0;else if (i) {\n              for (var p = Object.keys(n), f = 0, g = this._settings._calculatedStyles, r = 0; r < p.length; r++) {\n                var v = p[r];\n\n                if (null == g[v]) {\n                  l = !0;\n                  break;\n                }\n\n                g[v].enabled && f++;\n              }\n\n              l = l || this._auras.length - 1 !== f;\n            }\n            if (l ? (this.recalculateStyles(n), c = !0) : h.bounds && (c = !0), !i || this._auras.length < 2) return void (this._polygons.length > 0 && (this._polygons = []));\n            c && this.recalculateGrid(), this.reset(), this.stage1(t), this.stage2(), this.stage3();\n          }\n        }, t.prototype.ensureAura = function (t) {\n          if (this._settings.style[t] || (this._settings.style[t] = {}), !this._settings._defaultStyles[t]) {\n            var e = this._settings.defaultColors;\n            e && e.length || (e = [\"rgba(47,195,47,0.3)\"]), this._autoAuraCounter = (this._autoAuraCounter + 1) % e.length, this._settings._defaultStyles[t] = {\n              lineWidth: 1,\n              showInLegend: !0,\n              enabled: !0,\n              zIndex: 0,\n              fillColor: e[this._autoAuraCounter]\n            };\n          }\n        }, t.prototype.reset = function () {\n          for (var t = this._cellEdges, e = 0; e < t.length; e++) {\n            t[e] = -1;\n          }\n\n          for (var i = this._cells, e = 0; e < i.length; e++) {\n            i[e] = 0;\n          }\n\n          this._polygons = new Array(this._auras.length);\n\n          for (var e = 0; e < this._polygons.length; e++) {\n            this._polygons[e] = [];\n          }\n        }, t.prototype.stage1 = function (t) {\n          for (var e = this._scene, i = e.zoom, n = this._settings, r = n.cellSize, s = this._marginCells, a = this._widthCells, o = this._heightCells, l = this._cells, h = this._cellLength, u = this._aurasMap, c = n.intensity, p = e.centerX * e.zoom % r, f = e.centerY * e.zoom % r, g = 0; g < t.length; g++) {\n            var v = t[g],\n                m = e.toDisplay(v.x, v.y),\n                y = (m.x + p) / r + s,\n                S = (m.y + f) / r + s,\n                b = d.Helpers.trunc(y),\n                x = d.Helpers.trunc(S),\n                C = y - b,\n                w = S - x,\n                L = t[g].aura;\n\n            if (L) {\n              Array.isArray(L) || (L = [L]);\n\n              for (var T = 0; T < L.length; T++) {\n                var k = \"\" + (L[T] || \"\"),\n                    M = u[k];\n\n                if (void 0 !== M && this._auras[M].enabled) {\n                  var A = Math.min((v.hHeight * i + 5) / r, a, o),\n                      I = A * c + 1,\n                      P = 2 * I;\n\n                  if (y > -P && y < a + P && S > -P && S < o + P) {\n                    var D = A / 2,\n                        N = Math.ceil(I);\n                    I -= D;\n\n                    for (var F = -N; F < N; F++) {\n                      if (!(y + F < s || y + F >= a - s)) for (var O = C - F, E = -N; E < N; E++) {\n                        if (!(S + E < s || S + E >= o - s)) {\n                          var R = w - E,\n                              H = Math.sqrt(O * O + R * R) - D;\n\n                          if (H < I) {\n                            H = H <= 0 ? 1 : 1 - H / I;\n                            var z = M + (x + E) * a * h + (b + F) * h;\n                            l[z] = l[z] + H - l[z] * H;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }, t.prototype.stage2 = function () {\n          var t = this._cellLength;\n          if (1 !== t && !this._settings.overlap) for (var e = this._cells, i = 0; i < e.length; i += t) {\n            for (var n = i, r = e[i], s = 1; s < t; s++) {\n              var a = e[i + s];\n              a > r ? (r = a, e[n] = 0, n = i + s) : a > 0 && (e[i + s] = 0);\n            }\n          }\n        }, t.prototype.stage3FindEdge = function (t, e) {\n          var i = this._cells,\n              n = this._cellEdges,\n              r = this._settings,\n              s = r.drawLimit,\n              a = this._edgeFinderDeltas,\n              o = [e],\n              l = e,\n              h = 2,\n              u = 0,\n              c = 0,\n              p = r.overlap,\n              f = 0,\n              g = 0;\n\n          do {\n            for (var v = n[l], m = void 0, y = (h + 5) % 8, S = y, b = !1; S < y + 8; S++) {\n              if (v !== S && (m = l + a[S], i[m] >= s)) {\n                b = !0;\n                break;\n              }\n            }\n\n            if (!b) {\n              l !== e && d.Helpers.error(\"Edge finder stuck\");\n              break;\n            }\n\n            if (S %= 8, (h !== S || ++f > 5) && (0 === u && (u = 7 === S ? 7 : 1, c = 7 === S ? 6 : 2), (!p || h !== (S + u) % 8 && h !== (S + c) % 8) && o.push(l), f = 0), v === -1 && (n[l] = S), h = S, l = m, ++g > 1e4) {\n              d.Helpers.error(\"Edge finder run into a loop\");\n              break;\n            }\n          } while (l !== e);\n\n          o[o.length - 1] !== e && o.push(e), t.push(o);\n        }, t.prototype.stage3 = function () {\n          for (var t = this._cellLength, e = this._widthCells * t, i = this._cells, n = this._cellEdges, r = this._settings, s = r.drawLimit, a = e - t, o = this._polygons, l = 0, h = i.length - t, u = 0; u < h; u++) {\n            var c = i[u];\n\n            if (u % e >= a || c < s) {\n              var p = u + t;\n\n              if (i[p] >= s && n[p] < 0 && (this.stage3FindEdge(o[p % t], p), ++l > 1e4)) {\n                d.Helpers.error(\"Edge finder found too many polygons\");\n                break;\n              }\n            }\n          }\n        }, t.prototype.paintPolygons = function (t) {\n          if (this._settings.enabled) {\n            var e = t.context;\n            e.save();\n\n            for (var i = this._settings, n = i.cellSize, r = this._marginCells, s = r * n - n / 2, a = this._cellLength, o = this._widthCells, l = this._auras, h = this._polygons, u = this._scene, c = -u.centerX * u.zoom % n, p = -u.centerY * u.zoom % n, f = 1; f < h.length; f++) {\n              for (var g = h[f], v = l[f], m = d.Graphics.beginStrokeAndFill(e, v), y = 0; y < g.length; y++) {\n                var S = g[y],\n                    b = d.Helpers.trunc(S[0] / a),\n                    x = b % o * n - s + c,\n                    C = d.Helpers.trunc(b / o) * n - s + p,\n                    w = d.Helpers.trunc(S[1] / a),\n                    L = w % o * n - s + c,\n                    T = d.Helpers.trunc(w / o) * n - s + p;\n                m.moveTo((x + L) / 2, (T + C) / 2);\n\n                for (var k = 2; k < S.length; k++) {\n                  w = d.Helpers.trunc(S[k] / a);\n                  var M = w % o * n - s + c,\n                      A = d.Helpers.trunc(w / o) * n - s + p;\n                  m.quadraticCurveTo(L, T, (M + L) / 2, (A + T) / 2), L = M, T = A;\n                }\n\n                w = d.Helpers.trunc(S[1] / a);\n                var I = w % o * n - s + c,\n                    P = d.Helpers.trunc(w / o) * n - s + p;\n                m.quadraticCurveTo(L, T, (I + L) / 2, (P + T) / 2), m.closePath();\n              }\n\n              d.Graphics.endStrokeAndFill(e, m, v);\n            }\n\n            d.Graphics.restore(e);\n          }\n        }, t;\n      }();\n\n      t.NodesLayerAuras = W;\n\n      var Z = function (e) {\n        function i(t, i, n) {\n          var r = e.call(this, t.scene, i) || this;\n          r.chart = t, r.imageCache = {}, r.imageLoading = {}, r.multilinks = {}, r.useFadeout = n, r.styleUpdater = r.createStyleUpdater(i.style), r.events = t.events, r.layerSettings = i;\n          var s = i.style;\n          return r.style = s, r.scaleNodesWithZoom = s.scaleObjectsWithZoom, r.scaleLinksWithZoom = null == s.scaleLinksWithZoom ? s.scaleObjectsWithZoom : s.scaleLinksWithZoom, r._auras = new W(t.scene, t.events, i.auras), r;\n        }\n\n        return n(i, e), i.prototype.createStyleUpdater = function (t) {\n          return null == this.useFadeout ? null : new E(t, this, this.useFadeout);\n        }, i.prototype.updateStyle = function (t) {\n          var e = !t.changes.newGraph;\n          this.styleUpdater.updateLayer(t, e);\n        }, i.prototype.postprocessStyle = function (t) {\n          e.prototype.postprocessStyle.call(this, t), this.animateSize(t);\n        }, i.prototype.animateSize = function (t) {\n          var e = t.timeStamp,\n              i = t.changes.newGraph,\n              n = t.dtime,\n              r = !1,\n              s = !1,\n              a = this.style.fadeTime;\n          i = i || !(a > 0) || n > a;\n          var o = [],\n              l = [];\n\n          if (i) {\n            for (var h = 0, u = this.nodes(); h < u.length; h++) {\n              var c = u[h];\n              c.removed ? (c.visibility = 0, o.push(c)) : c.targetHWidth !== c.hWidth && (c.added = !1, c.visibility = 1, c.hHeight = c.targetHHeight, c.hWidth = c.targetHWidth);\n            }\n\n            for (var d = 0, p = this.links(); d < p.length; d++) {\n              var f = p[d];\n              f.removed ? (f.visibility = 0, l.push(f)) : f.targetRadius !== f.currentRadius && (f.added = !1, f.visibility = 1, f.currentRadius = f.targetRadius);\n            }\n          } else {\n            for (var g = a > 0 ? Math.max(0, Math.pow(.2, n / a)) : 0, v = .01, h = 0, u = this.nodes(); h < u.length; h++) {\n              var c = u[h];\n              if (c.added === !0 && (c.added = e), c.added + a < e && (c.added = !1), c.removed === !0 && (c.removed = e), c.removed) r = !0, c.visibility = g, c.hHeight = c.hHeight * g, c.hWidth = c.hWidth * g, e - c.removed < a ? c.visibility = 1 - (e - c.removed) / a : o.push(c);else {\n                e - c.added < a ? (c.visibility = (e - c.added) / a, r = !0) : c.visibility = 1;\n                var m = c.targetHHeight,\n                    y = c.hHeight,\n                    S = c.targetHWidth,\n                    b = c.hWidth;\n                m === y && S === b || (s || (Math.abs(m - y) / Math.max(m, y) >= .5 || Math.abs(S - b) / Math.max(S, b) >= .5) && (s = !0), r = !0, c.hHeight = y * g + m * (1 - g), c.hWidth = b * g + S * (1 - g), Math.abs(c.hHeight - m) < v * m && (c.hHeight = m, c.hWidth = S));\n              }\n            }\n\n            for (var d = 0, p = this.links(); d < p.length; d++) {\n              var f = p[d];\n              f.added === !0 && (f.added = e), f.added + a < e && (f.added = !1), f.removed === !0 && (f.removed = e), f.removed ? (r = !0, f.currentRadius = f.currentRadius * g, e - f.removed < a ? f.visibility = 1 - (e - f.removed) / a : l.push(f)) : (e - f.added < a && !f.invisible ? (f.visibility = (e - f.added) / a, r = !0) : f.visibility = 1, f.targetRadius !== f.currentRadius && (r = !0, f.currentRadius = f.currentRadius * g + f.targetRadius * (1 - g), Math.abs(f.currentRadius - f.targetRadius) < v * f.targetRadius && (f.currentRadius = f.targetRadius)));\n            }\n          }\n\n          for (var x = 0; x < l.length; x++) {\n            var C = l[x];\n            this.deleteLink(C);\n          }\n\n          for (var w = 0; w < o.length; w++) {\n            var L = o[w];\n            this.deleteNode(L);\n          }\n\n          if (r) {\n            var T = {\n              position: !0\n            };\n            s && (T.dynamicLayout = !0), this.events.notifySceneChanges(T), t.animating = !0;\n          }\n        }, i.prototype.paintPrepare = function (t) {\n          this.computeNodeRenderRadii(), this.multilinks = this.updateMultilinks(), (t.changes.position || this.hasTopologyChanges()) && this.placePies();\n        }, i.prototype.paintBackground = function (t) {\n          this._auras.doAnimations(this.nodes(), t), this._auras.paintPolygons(t);\n        }, i.prototype.paintSelection = function (t, e, i) {\n          var n = this.style.selection;\n\n          if (n.enabled) {\n            null === n.fillColor && (n = d.Helpers.clone(n), n.fillColor = this.chart.settings.area.style.fillColor, n.fillColor && \"transparent\" !== n.fillColor || (n.fillColor = \"white\"));\n            var r = this.getGeometry(),\n                s = r.txm,\n                a = r.txa,\n                o = r.tym,\n                l = r.tya,\n                h = r.zoom,\n                u = t.context,\n                c = n.sizeProportional,\n                p = n.sizeConstant;\n            u.beginPath();\n\n            for (var f = 0; f < e.length; f++) {\n              var g = e[f];\n              g.invisible || (g.shape.adaptToViewport(s, a, o, l, h), g.shape.paintSelection(u, c, p * h));\n            }\n\n            for (var f = 0; f < i.length; f++) {\n              var v = i[f];\n\n              if (!v.invisible) {\n                var m = (v.currentRadius / 2 * (1 + c) + .9 * p) * h,\n                    y = v.from,\n                    S = v.to,\n                    b = y.x * s + a,\n                    x = y.y * o + l,\n                    C = S.x * s + a,\n                    w = S.y * o + l,\n                    L = b - C,\n                    T = x - w,\n                    k = 1 / Math.sqrt(L * L + T * T),\n                    M = L * k,\n                    A = T * k;\n\n                if (0 !== v.currentCenterOffset) {\n                  var I = A * v.currentCenterOffset * h,\n                      P = -M * v.currentCenterOffset * h;\n                  b += I, x += P, C += I, w += P;\n                }\n\n                M *= m, A *= m, u.moveTo(b + A, x - M), u.lineTo(b - A, x + M), u.lineTo(C - A, w + M), u.lineTo(C + A, w - M), u.closePath();\n              }\n            }\n\n            return d.Graphics.paint(u, n);\n          }\n        }, i.prototype.paintLinks = function (t, e) {\n          var i = this.getGeometry();\n          this.paintLinksImpl(t, e, this.multilinks, {\n            geometry: i,\n            paintDetails: i.zoom > this.style.linkDetailMinZoom\n          });\n        }, i.prototype.paintNodes = function (t, e) {\n          var i = this.getGeometry();\n          t.animating = this.paintNodesImpl(t, e, {\n            geometry: i,\n            paintDetails: i.zoom > this.style.nodeDetailMinZoom\n          }, t.timeStamp) || t.animating;\n        }, i.prototype.updateMultilinks = function () {\n          if (!this.hasTopologyChanges()) return this.multilinks;\n\n          for (var t = this.links(), e = {}, i = [], n = 0; n < t.length; n++) {\n            var r = t[n],\n                s = r.multiId;\n\n            if (e.hasOwnProperty(s)) {\n              var a = e[s];\n              if (a instanceof Array) a.push(r);else {\n                var o = [a, r];\n                i.push(o), e[s] = o;\n              }\n            } else e[s] = r;\n          }\n\n          for (var l = 0; l < i.length; l++) {\n            i[l].sort(function (t, e) {\n              return (\"\" + (t.id || \"\")).localeCompare(\"\" + (e.id || \"\"));\n            });\n          }\n\n          return e;\n        }, i.prototype.gradientToString = function (t) {\n          for (var e = \"\", i = 0; i < t.length; i++) {\n            e += t[i][1];\n          }\n\n          return e;\n        }, i.prototype.getNodeImage = function (t, e, i) {\n          if (void 0 === i && (i = !1), !t.image) return null;\n          var n = t.tintImage && t.fillColor,\n              r = !!e && t.imageCropping,\n              s = t.image,\n              a = s;\n          if (n && !t.fillGradient && (s += \"##\" + t.fillColor), s += \"##\" + r, this.imageCache.hasOwnProperty(s)) return this.imageCache[s];\n          if (this.imageLoading[s]) return null;\n          var o = this.scene.assetsLoader.getAssetImage(a);\n          return i ? o : o ? (r && (o = d.Graphics.cropImageToCircle(o, r)), n && !t.fillGradient && (o = d.Graphics.applyColorToImage(o, t.fillColor, !1)), this.imageCache[s] = o, delete this.imageLoading[s], this.events.notifySceneChanges({\n            layout: !0\n          }), o) : null;\n        }, i.prototype.computeNodeRenderRadii = function () {\n          for (var t = this.getGeometry().zoom, e = 0, i = this.nodes(); e < i.length; e++) {\n            var n = i[e],\n                r = n.hHeight * t,\n                s = n.hWidth * t;\n            n.lineWidth && (r += n.lineWidth / 2, s += n.lineWidth / 2), n.renderHheight = r, n.renderHwidth = s;\n          }\n        }, i.prototype.paintLinksImpl = function (t, e, i, n) {\n          var r = t.context,\n              s = n.geometry.txm,\n              a = n.geometry.txa,\n              o = n.geometry.tym,\n              l = n.geometry.tya,\n              h = n.geometry.linkZoom,\n              u = n.geometry.x0w,\n              c = n.geometry.y0w,\n              p = n.geometry.x1w,\n              f = n.geometry.y1w,\n              g = 1 / h,\n              v = this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;\n          r.textAlign = \"center\", r.textBaseline = \"middle\";\n\n          for (var m = this.style, y = m.linkDetailMinSize * m.linkDetailMinSize, S = n.paintDetails && this.chart.assetsLoaded, b = m.multilinkSpacing * h, x = m.linkDecorationScale, C = m.linkDecorationMinSize, w = m.linkLabelScaleBase, L = 2, T = 5, k = .1, M = 0; M < e.length; M++) {\n            var A = e[M];\n\n            if (!A.invisible && A.from !== A.to) {\n              var I = A.from.x,\n                  P = A.from.y,\n                  D = A.to.x,\n                  N = A.to.y,\n                  F = A.currentItems,\n                  O = F && F.length && F[0].style.rotateWithLink,\n                  E = void 0,\n                  R = A.from.renderHheight,\n                  H = A.to.renderHheight,\n                  z = A.from.renderHwidth,\n                  B = A.to.renderHwidth,\n                  U = d.Geometry.clipSegmentToBounds(I, P, D, N, (R + z) * v, (H + B) * v, u, c, p, f);\n\n              if (U) {\n                I = U[0], P = U[1], D = U[2], N = U[3], I = I * s + a, P = P * o + l, D = D * s + a, N = N * o + l;\n                var G = D - I,\n                    V = N - P,\n                    j = G * G + V * V,\n                    W = Math.max(.25, A.currentRadius * h * .5),\n                    Z = A.hovered || A.from.hovered || A.to.hovered,\n                    Y = Z || S && j > y;\n\n                if (j > 25) {\n                  var q = Math.sqrt(j);\n\n                  if (O && (E = Math.atan2(V, G) * (180 / Math.PI), I >= D && (E -= 180), A.currentItems[0].style.angle = E), A.toPieValue > 0) {\n                    var _ = H + L,\n                        X = _ + T + k * H;\n\n                    this.paintLinkPie(r, D, N, _, X, A.toPie0, A.toPie1, A.toPieColor), H = X;\n                  }\n\n                  var Q = 1 / q,\n                      J = G * Q,\n                      K = V * Q,\n                      $ = void 0,\n                      tt = void 0;\n                  if ($ = A.from.shape.distanceToEdge(R, z, J, K), tt = A.to.shape.distanceToEdge(H, B, -J, -K), q <= $ + tt) continue;\n                  var et = Math.min((q - $ - tt) / 4, Math.max(C, W * x));\n                  A.fromDecoration && ($ += et), A.toDecoration && (tt += et), I += J * $, P += K * $, D -= J * tt, N -= K * tt, G = D - I, V = N - P, q = q - $ - tt, Q = 1 / q;\n                  var it = A.multiId,\n                      nt = i[it];\n\n                  if (nt instanceof Array) {\n                    var rt = nt.length,\n                        st = Math.min(b * (rt - 1), 1.5 * R, 1.5 * H),\n                        at = st * (nt.indexOf(A) - (rt - 1) / 2) / (rt - 1);\n                    A.from.id > A.to.id && (at = -at), A.currentCenterOffset = at * g, I -= K * at, D -= K * at, P += J * at, N += J * at;\n                  } else A.currentCenterOffset = 0;\n\n                  if (A.renderPointsX ? (A.renderPointsX[0] = I, A.renderPointsX[1] = D) : A.renderPointsX = [I, D], A.renderPointsY ? (A.renderPointsY[0] = P, A.renderPointsY[1] = N) : A.renderPointsY = [P, N], A.renderBounds ? (A.renderBounds.x0 = Math.min(I, D), A.renderBounds.x1 = Math.max(I, D), A.renderBounds.y0 = Math.min(P, N), A.renderBounds.y1 = Math.max(P, N)) : A.renderBounds = new d.Rect(I, P, D, N), Y && A.currentItems && !A.removed && (A.currentItems.sort(function (t, e) {\n                    return t.style.zIndex - e.style.zIndex;\n                  }), this.paintLinkItems(r, t.labelRenderer, h, W / w, I, P, J, K, q, W, A.currentItems, A.renderBounds, Z, !0)), A.lineDash && A.lineDashBackgroundFillColor && (r.beginPath(), r.moveTo(I + K * W, P - J * W), r.lineTo(I - K * W, P + J * W), r.lineTo(D - K * W, N + J * W), r.lineTo(D + K * W, N - J * W), r.closePath(), d.Graphics.fill(r, {\n                    fillColor: A.lineDashBackgroundFillColor\n                  })), r.beginPath(), A.fromDecoration && this.paintLinkDecoration(r, I, P, J, K, et, A.fromDecoration, A.fillColor), A.toDecoration && this.paintLinkDecoration(r, D, N, -J, -K, et, A.toDecoration, A.fillColor), A.lineDash) {\n                    var ot = I + K * W,\n                        lt = P - J * W,\n                        ht = I - K * W,\n                        ut = P + J * W;\n                    if (A.lineDash.length > 0) for (var ct = A.lineDash, dt = ct.length, pt = ct.reduce(function (t, e) {\n                      return t + e;\n                    }) * h, ft = 0, gt = 0; gt <= q / pt; gt++) {\n                      for (var vt = 0; vt <= dt - 1; vt += 2) {\n                        var mt = gt * pt + ft;\n                        if (mt > q - W) break;\n                        var yt = mt + ct[vt] * h,\n                            St = yt >= q - W ? q - W : yt,\n                            bt = [ot + mt * J, lt + mt * K],\n                            xt = [ht + mt * J, ut + mt * K],\n                            Ct = [ht + St * J, ut + St * K],\n                            wt = [ot + St * J, lt + St * K];\n\n                        if (A.lineDashShape && \"rectangle\" != A.lineDashShape) {\n                          if (\"triangle\" == A.lineDashShape) {\n                            var Lt = [(bt[0] + xt[0]) / 2, (bt[1] + xt[1]) / 2];\n                            r.moveTo(Lt[0], Lt[1]), r.lineTo(Ct[0], Ct[1]), r.lineTo(wt[0], wt[1]);\n                          } else if (\"inverseTriangle\" == A.lineDashShape) {\n                            var Tt = [(Ct[0] + wt[0]) / 2, (Ct[1] + wt[1]) / 2];\n                            r.moveTo(Tt[0], Tt[1]), r.lineTo(bt[0], bt[1]), r.lineTo(xt[0], xt[1]);\n                          } else if (\"diamond\" == A.lineDashShape) {\n                            var Lt = [(bt[0] + xt[0]) / 2, (bt[1] + xt[1]) / 2],\n                                kt = [(xt[0] + Ct[0]) / 2, (xt[1] + Ct[1]) / 2],\n                                Tt = [(Ct[0] + wt[0]) / 2, (Ct[1] + wt[1]) / 2],\n                                Mt = [(wt[0] + bt[0]) / 2, (wt[1] + bt[1]) / 2];\n                            r.moveTo(Lt[0], Lt[1]), r.lineTo(kt[0], kt[1]), r.lineTo(Tt[0], Tt[1]), r.lineTo(Mt[0], Mt[1]);\n                          } else if (\"hexagon\" == A.lineDashShape) {\n                            var Lt = [(bt[0] + xt[0]) / 2, (bt[1] + xt[1]) / 2],\n                                kt = [(xt[0] + Ct[0]) / 2, (xt[1] + Ct[1]) / 2],\n                                Mt = [(bt[0] + wt[0]) / 2, (bt[1] + wt[1]) / 2],\n                                At = [(kt[0] + Mt[0]) / 2, (kt[1] + Mt[1]) / 2];\n                            r.moveTo(Lt[0], Lt[1]), r.lineTo(kt[0], kt[1]), r.lineTo(Ct[0], Ct[1]), r.lineTo(At[0], At[1]), r.lineTo(wt[0], wt[1]), r.lineTo(Mt[0], Mt[1]);\n                          } else if (\"inverseHexagon\" == A.lineDashShape) {\n                            var It = [(bt[0] + Ct[0]) / 2, (bt[1] + Ct[1]) / 2],\n                                kt = [(xt[0] + Ct[0]) / 2, (xt[1] + Ct[1]) / 2],\n                                Tt = [(Ct[0] + wt[0]) / 2, (Ct[1] + wt[1]) / 2],\n                                Mt = [(bt[0] + wt[0]) / 2, (bt[1] + wt[1]) / 2];\n                            r.moveTo(bt[0], bt[1]), r.lineTo(It[0], It[1]), r.lineTo(xt[0], xt[1]), r.lineTo(kt[0], kt[1]), r.lineTo(Tt[0], Tt[1]), r.lineTo(Mt[0], Mt[1]);\n                          }\n                        } else r.moveTo(bt[0], bt[1]), r.lineTo(xt[0], xt[1]), r.lineTo(Ct[0], Ct[1]), r.lineTo(wt[0], wt[1]);\n\n                        r.closePath(), ft += h * (ct[vt] + ct[vt + 1]);\n                      }\n\n                      ft = 0;\n                    } else for (var Pt = Math.max(5, 3 * W), gt = 0; gt <= q / Pt; gt += 2) {\n                      var mt = gt * Pt,\n                          St = Math.min((gt + 1) * Pt, q);\n                      r.moveTo(ot + mt * J, lt + mt * K), r.lineTo(ht + mt * J, ut + mt * K), r.lineTo(ht + St * J, ut + St * K), r.lineTo(ot + St * J, lt + St * K), r.closePath();\n                    }\n                  } else r.moveTo(I + K * W, P - J * W), r.lineTo(I - K * W, P + J * W), r.lineTo(D - K * W, N + J * W), r.lineTo(D + K * W, N - J * W), r.closePath();\n\n                  d.Graphics.fill(r, A), Y && A.currentItems && !A.removed && this.paintLinkItems(r, t.labelRenderer, h, W / w, I, P, J, K, q, W, A.currentItems, A.renderBounds, Z, !1);\n                } else if (A.fillColor) {\n                  if (r.beginPath(), r.lineWidth = Math.max(.1, 2 * W), r.strokeStyle = A.fillColor, A.dashed) for (var q = Math.sqrt(j), Q = 1 / q, J = G * Q, K = V * Q, Pt = Math.max(5, 3 * W), gt = 0; gt <= q / Pt; gt += 2) {\n                    var mt = gt * Pt,\n                        St = Math.min((gt + 1) * Pt, q);\n                    r.moveTo(I + mt * J, P + mt * K), r.lineTo(I + St * J, P + St * K);\n                  } else r.moveTo(I, P), r.lineTo(D, N);\n                  r.stroke(), A.renderPointsX ? (A.renderPointsX[0] = I, A.renderPointsX[1] = D) : A.renderPointsX = [I, D], A.renderPointsY ? (A.renderPointsY[0] = P, A.renderPointsY[1] = N) : A.renderPointsY = [P, N], A.renderBounds ? (A.renderBounds.x0 = Math.min(I, D), A.renderBounds.x1 = Math.max(I, D), A.renderBounds.y0 = Math.min(P, N), A.renderBounds.y1 = Math.max(P, N)) : A.renderBounds = new d.Rect(I, P, D, N);\n                }\n              }\n            }\n          }\n        }, i.prototype.paintNodesImpl = function (e, i, n, r) {\n          var s = !1,\n              a = e.context,\n              o = n.geometry.txm,\n              l = n.geometry.txa,\n              h = n.geometry.tym,\n              u = n.geometry.tya,\n              c = n.geometry.zoom,\n              p = n.geometry.x0s,\n              f = n.geometry.x1s,\n              g = n.geometry.y0s,\n              v = n.geometry.y1s,\n              m = 1 / o,\n              y = n.paintDetails,\n              S = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * m * m,\n              b = this.style.hiddenLinks,\n              x = this.style.nodeLabelScaleBase;\n          a.textAlign = \"center\", a.textBaseline = \"middle\";\n\n          for (var C = this.style.removedColor, w = 0; w < i.length; w++) {\n            var L = i[w];\n            L.data && !L.invisible && this.paintSelfLinks(e, L, n);\n          }\n\n          for (var w = 0; w < i.length; w++) {\n            var L = i[w];\n\n            if (L.data && !L.invisible) {\n              var T = L.shape;\n\n              if (T.adaptToViewport(o, l, h, u, c), null != L.anchorX && null != L.anchorY && L.anchorMode === t.NodeAnchorMode.Floating) {\n                var k = L.anchorX * o + l,\n                    M = L.anchorY * h + u,\n                    A = T.getAnchor(),\n                    I = T.x + A.x,\n                    P = T.y + A.y,\n                    D = I - k,\n                    N = P - M,\n                    F = P;\n                N < 0 && (F = Math.max(F, M - N * Math.min(.3, Math.abs(D) / N))), a.beginPath(), a.moveTo(I, P), a.lineTo(I, F), a.lineTo(k, M), d.Graphics.stroke(a, L.anchorStyle);\n              }\n            }\n          }\n\n          for (var w = 0; w < i.length; w++) {\n            var L = i[w],\n                T = L.shape;\n\n            if (L.data && !L.invisible && T.isInViewport(p, f, g, v, c)) {\n              var O = L.opacity,\n                  E = L.outerBounds.w(),\n                  R = L.outerBounds.h(),\n                  H = y && E * R > S || L.hovered;\n\n              if (O < 1 && (a.globalAlpha = O), H && !L.removed) {\n                var z = L.dataLinks.length - L.links.length;\n                if (z > 0) if (this.useFadeout && L.relevance < 1) {\n                  var B = b.lineColor;\n                  b.lineColor = d.Colors.blend(C, B, L.relevance), this.paintHiddenLinks(a, L, T.x, T.y, T.hWidth, T.hHeight, z, b, b.size * c), b.lineColor = B;\n                } else this.paintHiddenLinks(a, L, T.x, T.y, T.hWidth, T.hHeight, z, b, b.size * c);\n                L.items.sort(function (t, e) {\n                  return t.zIndex - e.zIndex;\n                }), this.paintNodeDetails(L, T.x, T.y, T.hHeight, T.hWidth, c, x, e, !0);\n              }\n\n              T.paint(a, e.labelRenderer, H), H && !L.removed && this.paintNodeDetails(L, T.x, T.y, T.hHeight, T.hWidth, c, x, e, !1), O < 1 && (a.globalAlpha = 1);\n            }\n          }\n\n          if (this.scene.settings.advanced.perNodeLoadingIndicator) {\n            var U = this.scene.settings.advanced.style.loadingArcStyle;\n            a.save(), a.lineCap = \"round\", a.lineWidth = U.lineWidth, a.strokeStyle = U.lineColor;\n            var G = r / 1400;\n            G = (G - Math.floor(G)) * (2 * Math.PI);\n\n            for (var V = G + Math.PI / 2, w = 0; w < i.length; w++) {\n              var L = i[w];\n\n              if (!L.invisible) {\n                var T = L.shape;\n\n                if (L.loading || L.image && null === this.getNodeImage(L, !1, !0)) {\n                  if (!T.isInViewport(p, f, g, v, c)) continue;\n                  s = !0, a.beginPath(), a.arc(T.x, T.y, T.hWidth, G, V), a.stroke();\n                }\n              }\n            }\n\n            d.Graphics.restore(a);\n          }\n\n          return s;\n        }, i.prototype.paintLinkDecoration = function (t, e, i, n, r, s, a, o) {\n          t.fillStyle = o, \"circle\" === a ? (t.moveTo(e + s, i), t.arc(e, i, s, 0, 2 * Math.PI, !0)) : \"arrow\" === a ? (t.moveTo(e - n * s, i - r * s), t.lineTo(e + n * s - r * s, i + r * s + n * s), t.lineTo(e + n * s + r * s, i + r * s - n * s)) : d.Helpers.error(\"Unrecognized link decoration value. Valid values are 'circle' and 'arrow'.\");\n        }, i.prototype.paintLinkPie = function (t, e, i, n, r, s, a, o) {\n          var l = (n + r) / 2,\n              h = r - n;\n          t.beginPath(), t.arc(e, i, l, s, a), d.Graphics.paint(t, {\n            lineColor: o,\n            lineWidth: h\n          });\n        }, i.prototype.paintLinkItems = function (t, e, i, n, r, s, a, o, l, h, u, c, p, f) {\n          var g, v;\n          p ? (g = d.Helpers.toleranceMax(i, 1, .9), v = d.Helpers.toleranceMax(n, 1, .9)) : (g = i, v = n);\n\n          for (var m = 0; m < u.length; m++) {\n            var y = u[m];\n\n            if (f) {\n              if (y.style.zIndex >= 0) break;\n            } else if (y.style.zIndex < 0) continue;\n\n            var S = y.x || 0,\n                b = y.y || 0,\n                x = y.style.px || 0,\n                C = y.style.py || 0,\n                w = y.style.lx || 0,\n                L = y.style.ly || 0;\n            x = l * (x + 1) * .5 + w, C = C * h + L;\n            var T = r + a * x - o * C + S,\n                k = s + o * x + a * C + b,\n                M = 0;\n            M = y.style.scaleWithSize ? y.style.hoverEffect ? v : n : y.style.scaleWithZoom ? y.style.hoverEffect ? g : i : 1, e.paint(t, T, k, M, y);\n          }\n        }, i.prototype.paintBezierLinkItems = function (t, e, i, n, r, s, a, o, l, h, u) {\n          var c, p;\n          h ? (c = d.Helpers.toleranceMax(i, 1, .9), p = d.Helpers.toleranceMax(n, 1, .9)) : (c = i, p = n);\n\n          for (var f = 0; f < o.length; f++) {\n            var g = o[f];\n\n            if (u) {\n              if (g.style.zIndex >= 0) break;\n            } else if (g.style.zIndex < 0) continue;\n\n            var v = g.x || 0,\n                m = g.y || 0,\n                y = g.style.px || 0,\n                S = g.style.py || 0,\n                b = g.style.lx || 0,\n                x = g.style.ly || 0,\n                C = 0;\n            y <= 0 ? y = 1 + y : C = 2;\n            var w = 1 - y,\n                L = r[C] * w + r[C + 1] * y,\n                T = s[C] * w + s[C + 1] * y,\n                k = r[C + 1] * w + r[C + 2] * y,\n                M = s[C + 1] * w + s[C + 2] * y,\n                A = k - L,\n                I = M - T,\n                P = Math.sqrt(A * A + I * I),\n                D = A / P,\n                N = I / P,\n                F = L * w + k * y + D * b - N * (S * a + x) + v,\n                O = T * w + M * y + N * b + D * (S * a + x) + m,\n                E = 0;\n            E = g.style.scaleWithSize ? g.style.hoverEffect ? p : n : g.style.scaleWithZoom ? g.style.hoverEffect ? c : i : 1, g.style.rotateWithLink && (g.style.angle = 180 * Math.atan2(N, D) / Math.PI), e.paint(t, F, O, E, g), l.addRect(g.currentBounds);\n          }\n        }, i.prototype.paintSelfLinks = function (t, e, i) {\n          var n = this.multilinks[e.id + d.Helpers.SeparatorChar + e.id];\n\n          if (null != n) {\n            n instanceof u && (n = [n]), n = n.filter(function (t) {\n              return !t.invisible;\n            });\n            var r = n.length;\n\n            if (!(r < 1)) {\n              for (var s, a, o, l = e.dataLinks.length > e.links.length, h = 0, c = 0, p = 0, f = 0; f < e.links.length; f++) {\n                var g = e.links[f];\n\n                if (g.from !== g.to) {\n                  var v = g.otherEnd(e);\n                  h += v.x, c += v.y, p++;\n                }\n              }\n\n              if (0 === p) s = -1, a = 0, o = l ? 4 * Math.PI / 3 : 2 * Math.PI;else {\n                h = e.x - h / p, c = e.y - c / p;\n                var m = h * h + c * c,\n                    y = 1 / Math.sqrt(0 === m ? 1e-4 : m);\n\n                if (s = h * y, a = c * y, s || a || (s = 1), l) {\n                  o = Math.PI / 2;\n                  var S = Math.SQRT2 / 2,\n                      b = S * (s - a);\n                  a = S * (a + s), s = b;\n                } else o = Math.PI;\n              }\n              var x,\n                  C,\n                  w,\n                  L,\n                  T = this.style.selfLinkAngle;\n              T <= 0 ? T = 60 : T > 90 && (T = 90);\n              var k = Math.PI * T / 180,\n                  M = Math.cos(k),\n                  A = Math.sin(k),\n                  I = Math.cos(k / 2),\n                  P = Math.sin(k / 2);\n\n              if (o >= k * r) {\n                o /= r;\n                var D = -(o * (r - 1) + k) / 2;\n                w = Math.cos(D), L = Math.sin(D), x = s * w - a * L, C = s * L + a * w, w = Math.cos(o), L = Math.sin(o);\n              } else {\n                var D = -o / 2;\n                w = Math.cos(D), L = Math.sin(D), x = s * w - a * L, C = s * L + a * w;\n                var N = (o - k) / (r - 1);\n                w = Math.cos(N), L = Math.sin(N);\n              }\n\n              var F = t.context,\n                  O = i.geometry.txm,\n                  E = i.geometry.txa,\n                  R = i.geometry.tym,\n                  H = i.geometry.tya,\n                  z = i.geometry.linkZoom;\n              F.textAlign = \"center\", F.textBaseline = \"middle\";\n\n              for (var B = this.style, U = B.linkDetailMinSize * B.linkDetailMinSize, G = i.paintDetails && this.chart.assetsLoaded, V = B.linkDecorationScale, j = B.linkDecorationMinSize, W = B.linkLabelScaleBase, Z = 2, Y = 5, q = .1, _ = 5, X = e.x * O + E, Q = e.y * R + H, J = 1 + (this.style.selfLinkHeightFactor <= 0 ? 1 : this.style.selfLinkHeightFactor), K = Math.max(this.style.selfLinkWidthFactor, 0), $ = [0, 0, 0, 0, 0], tt = [0, 0, 0, 0, 0], et = [0, 0, 0, 0, 0], it = [0, 0, 0, 0, 0], nt = [0, 0, 0, 0, 0], rt = [0, 0, 0, 0, 0], st = 0; st < r; st++) {\n                var g = n[st];\n\n                if (!g.invisible) {\n                  var at = Math.max(e.renderHheight, e.renderHwidth);\n                  at *= at;\n                  var ot = e.renderHheight;\n\n                  if (at > 25 && g.toPieValue > 0) {\n                    var lt = ot + Z,\n                        ht = lt + Y + q * ot;\n                    this.paintLinkPie(F, X, Q, lt, ht, g.toPie0, g.toPie1, g.toPieColor), ot = ht;\n                  }\n\n                  var ut = x * M - C * A,\n                      ct = x * A + C * M,\n                      dt = x * I - C * P,\n                      pt = x * P + C * I,\n                      ft = e.shape.distanceToEdge(ot, e.renderHwidth, x, C),\n                      gt = e.shape.distanceToEdge(ot, e.renderHwidth, ut, ct),\n                      vt = Math.max(ft, gt) * J,\n                      mt = Math.max(.25, g.currentRadius * z * .5),\n                      yt = Math.min((vt - Math.max(ft, gt) - mt) / 2, Math.max(j, mt * V));\n                  g.fromDecoration && (ft += yt), g.toDecoration && (gt += yt), et[0] = X + x * ft, it[0] = Q + C * ft, et[2] = X + dt * vt, it[2] = Q + pt * vt, et[4] = X + ut * gt, it[4] = Q + ct * gt, $[2] = X + dt * (vt - mt), tt[2] = Q + pt * (vt - mt), nt[2] = X + dt * (vt + mt), rt[2] = Q + pt * (vt + mt);\n                  var St = void 0,\n                      bt = void 0,\n                      xt = void 0,\n                      Ct = void 0;\n\n                  if (\"parabolic\" === this.style.selfLinkShape) {\n                    St = x, bt = C, xt = ut, Ct = ct, $[0] = et[0] - C * mt, tt[0] = it[0] + x * mt, $[4] = et[4] + ct * mt, tt[4] = it[4] - ut * mt;\n                    var wt = ((vt - mt) * P - mt) / I * K;\n                    $[1] = $[2] + pt * wt, tt[1] = tt[2] - dt * wt, $[3] = $[2] - pt * wt, tt[3] = tt[2] + dt * wt, nt[0] = et[0] + C * mt, rt[0] = it[0] - x * mt, nt[4] = et[4] - ct * mt, rt[4] = it[4] + ut * mt, wt = ((vt + mt) * P + mt) / I * K, nt[1] = nt[2] + pt * wt, rt[1] = rt[2] - dt * wt, nt[3] = nt[2] - pt * wt, rt[3] = rt[2] + dt * wt, wt = vt * P / I * K, et[1] = et[2] + pt * wt, it[1] = it[2] - dt * wt, et[3] = et[2] - pt * wt, it[3] = it[2] + dt * wt;\n                  } else {\n                    St = dt, bt = pt, xt = dt, Ct = pt, $[0] = et[0] - pt * mt, tt[0] = it[0] + dt * mt, $[4] = et[4] + pt * mt, tt[4] = it[4] - dt * mt;\n                    var Lt = ($[4] - $[0]) * K / 2,\n                        Tt = (tt[4] - tt[0]) * K / 2;\n                    $[1] = $[2] - Lt, tt[1] = tt[2] - Tt, $[3] = $[2] + Lt, tt[3] = tt[2] + Tt, nt[0] = et[0] + pt * mt, rt[0] = it[0] - dt * mt, nt[4] = et[4] - pt * mt, rt[4] = it[4] + dt * mt, Lt = (nt[4] - nt[0]) * K / 2, Tt = (rt[4] - rt[0]) * K / 2, nt[1] = nt[2] - Lt, rt[1] = rt[2] - Tt, nt[3] = nt[2] + Lt, rt[3] = rt[2] + Tt, Lt = (et[4] - et[0]) * K / 2, Tt = (it[4] - it[0]) * K / 2, et[1] = et[2] - Lt, it[1] = it[2] - Tt, et[3] = et[2] + Lt, it[3] = it[2] + Tt;\n                  }\n\n                  g.renderBounds || (g.renderBounds = new d.Rect(0, 0, 0, 0)), g.renderBounds.x0 = Math.min.apply(Math, nt), g.renderBounds.y0 = Math.min.apply(Math, rt), g.renderBounds.x1 = Math.max.apply(Math, nt), g.renderBounds.y1 = Math.max.apply(Math, rt), g.renderPointsX || (g.renderPointsX = new Array(2 * _), g.renderPointsY = new Array(2 * _));\n\n                  for (var kt = 0; kt < _; kt++) {\n                    var Mt = kt / (_ - 1),\n                        At = 1 - Mt;\n                    g.renderPointsX[kt] = At * At * et[0] + 2 * At * Mt * et[1] + Mt * Mt * et[2], g.renderPointsY[kt] = At * At * it[0] + 2 * At * Mt * it[1] + Mt * Mt * it[2], g.renderPointsX[kt + _] = At * At * et[2] + 2 * At * Mt * et[3] + Mt * Mt * et[4], g.renderPointsY[kt + _] = At * At * it[2] + 2 * At * Mt * it[3] + Mt * Mt * it[4];\n                  }\n\n                  if (at > 25) {\n                    var It = g.hovered || g.from.hovered || g.to.hovered,\n                        Pt = It || G && at > U;\n                    Pt && g.currentItems && !g.removed && (g.currentItems.sort(function (t, e) {\n                      return t.style.zIndex - e.style.zIndex;\n                    }), this.paintBezierLinkItems(F, t.labelRenderer, z, mt / W, et, it, mt, g.currentItems, g.renderBounds, It, !0)), F.beginPath(), g.fromDecoration && this.paintLinkDecoration(F, et[0], it[0], St, bt, yt, g.fromDecoration, g.fillColor), g.toDecoration && this.paintLinkDecoration(F, et[4], it[4], xt, Ct, yt, g.toDecoration, g.fillColor), F.moveTo($[0], tt[0]), F.quadraticCurveTo($[1], tt[1], $[2], tt[2]), F.quadraticCurveTo($[3], tt[3], $[4], tt[4]), F.lineTo(nt[4], rt[4]), F.quadraticCurveTo(nt[3], rt[3], nt[2], rt[2]), F.quadraticCurveTo(nt[1], rt[1], nt[0], rt[0]), F.closePath(), d.Graphics.fill(F, g), Pt && g.currentItems && !g.removed && (g.currentItems.sort(function (t, e) {\n                      return t.style.zIndex - e.style.zIndex;\n                    }), this.paintBezierLinkItems(F, t.labelRenderer, z, mt / W, et, it, mt, g.currentItems, g.renderBounds, It, !1));\n                  } else g.fillColor && (F.beginPath(), F.lineWidth = Math.max(.1, 2 * mt), F.strokeStyle = g.fillColor, F.moveTo(et[0], it[0]), F.quadraticCurveTo(et[1], it[1], et[2], it[2]), F.quadraticCurveTo(et[3], it[3], et[4], it[4]), F.stroke());\n\n                  var b = x * w - C * L;\n                  C = x * L + C * w, x = b;\n                }\n              }\n            }\n          }\n        }, i.prototype.paintHiddenLinks = function (t, e, i, n, r, s, a, o, l) {\n          for (var h, u, c, d = 0, p = 0, f = 0, g = !1, v = 0; v < e.links.length; v++) {\n            var m = e.links[v];\n            if (m.from === m.to) g = !0;else {\n              var y = m.otherEnd(e);\n              d += y.x, p += y.y, f++;\n            }\n          }\n\n          if (0 === f) h = 1, u = 0, c = 2 * Math.PI / a / 3;else {\n            d = e.x - d / e.links.length, p = e.y - p / e.links.length;\n            var S = 1 / Math.sqrt(d * d + p * p);\n\n            if (h = d * S, u = p * S, g) {\n              c = Math.PI / a / 2;\n              var b = Math.SQRT2 / 2,\n                  x = b * (h + u);\n              u = b * (u - h), h = x;\n            } else c = 2 * Math.PI / a / 3;\n          }\n          var C = Math.cos(-c * (a - 1) / 2),\n              w = Math.sin(-c * (a - 1) / 2),\n              L = h * C - u * w,\n              T = h * w + u * C,\n              k = L;\n          C = Math.cos(c), w = Math.sin(c), t.beginPath();\n\n          for (var M = 1; M <= a; M++) {\n            var A = e.shape.distanceToEdge(r, s, k, T);\n            t.moveTo(i + k * A, n + T * A), t.lineTo(i + k * (A + l), n + T * (A + l)), L = k * C - T * w, T = k * w + T * C, k = L;\n          }\n\n          t.strokeStyle = o.lineColor, t.lineWidth = o.lineWidth, t.stroke();\n        }, i.prototype.findObjectAt = function (t, e, i) {\n          var n = this.scene,\n              r = n.fromDisplay(t, e),\n              s = r.x,\n              a = r.y,\n              o = 1 / n.zoom,\n              l = this.scaleLinksWithZoom ? o : 1,\n              h = null,\n              u = [],\n              c = null,\n              p = i,\n              f = n.hoverNode;\n\n          if (f && f.layer === this && !f.invisible) {\n            var g = f.shape.hitTest(s, a, o, p * o);\n\n            if (g / o < p) {\n              p = g / o, h = f;\n              var v = this.findItem(t, e, h, i);\n              if (v && (c = v.item, p = Math.min(p, v.distance)), p <= 0) return {\n                object: h,\n                details: c\n              };\n            }\n          }\n\n          for (var m = this.nodes(), y = m.length - 1; y >= 0; y--) {\n            var S = m[y];\n\n            if (!S.removed && !S.invisible && d.Geometry.distanceToRect(s - S.x, a - S.y, S.outerBounds) < p * o) {\n              var g = S.shape.hitTest(s, a, o, p * o);\n\n              if (g <= 0) {\n                p = 0, h = S;\n                break;\n              }\n\n              g / o < p && (p = g / o, h = S), u.push(S);\n            }\n          }\n\n          if (p > 0) {\n            var b = n.hoverLink;\n            if (b && b.layer === this && !b.invisible) for (var x = b.targetRadius / 2 * l, y = 1; y < b.renderPointsX.length; y++) {\n              var C = d.Geometry.distanceToSegmentSq(b.renderPointsX[y - 1], b.renderPointsY[y - 1], b.renderPointsX[y], b.renderPointsY[y], t, e);\n\n              if (C <= (p + x) * (p + x)) {\n                p = 0, h = b;\n                var v = this.findItem(t, e, h, i);\n                if (v && (c = v.item, p = Math.min(p, v.distance)), p <= 0) return {\n                  object: h,\n                  details: c\n                };\n                break;\n              }\n            }\n          }\n\n          if (p > 0) for (var w = 0, L = this.links(); w < L.length; w++) {\n            var T = L[w];\n\n            if (!T.removed && !T.invisible && T.renderPointsX && d.Geometry.distanceToRect(t, e, T.renderBounds) < p) {\n              for (var x = T.targetRadius / l * 2, k = Math.min(p * p, x * x), y = 1; y < T.renderPointsX.length; y++) {\n                var C = d.Geometry.distanceToSegmentSq(T.renderPointsX[y - 1], T.renderPointsY[y - 1], T.renderPointsX[y], T.renderPointsY[y], t, e);\n\n                if (C < k) {\n                  p = Math.sqrt(C), h = T;\n                  break;\n                }\n              }\n\n              u.push(T);\n            }\n          }\n\n          if (0 === p) {\n            var v = this.findItem(t, e, h, i);\n            return {\n              object: h,\n              details: v ? v.item : null\n            };\n          }\n\n          for (var y = 0; y < u.length; y++) {\n            var M = u[y],\n                v = this.findItem(t, e, M, i);\n            v && v.distance < p && (p = v.distance, h = M, c = v.item);\n          }\n\n          return p > i && (h = null, c = null), {\n            object: h,\n            details: c\n          };\n        }, i.prototype.findItem = function (t, e, i, n) {\n          if (!i) return null;\n          var r = n * n,\n              s = this.scene.hoverItem;\n\n          if (s && s.hwidth && i.currentItems.indexOf(s) > -1) {\n            var a = d.Geometry.distanceToRect(t, e, s.currentBounds, !0);\n            if (a <= r) return {\n              item: s,\n              distance: Math.sqrt(a)\n            };\n          }\n\n          var o = null,\n              l = n * n;\n\n          if (i instanceof h) {\n            var u = i.shape.currentLabel;\n\n            if (u && u.currentBounds) {\n              var a = d.Geometry.distanceToRect(t, e, u.currentBounds, !0);\n              a < l && (o = u, l = a);\n            }\n          }\n\n          for (var c = 0; c < i.currentItems.length; c++) {\n            var p = i.currentItems[c];\n\n            if (p.hwidth) {\n              var a = d.Geometry.distanceToRect(t, e, p.currentBounds, !0);\n              a <= l && (o = p, l = a);\n            }\n          }\n\n          return l > r || !o ? null : {\n            item: o,\n            distance: Math.sqrt(l)\n          };\n        }, i.prototype.getGraphBounds = function (t) {\n          if (void 0 === t && (t = this.nodes()), !t || !t.length) return new d.Rect(0, 0, 0, 0);\n\n          for (var e = d.Rect.createEmpty(), i = 0, n = 0; n < t.length; n++) {\n            var r = t[n];\n\n            if (!r.removed) {\n              i++;\n              var s = r.x,\n                  a = r.y,\n                  o = r.outerBounds;\n              e.addBounds(o.x0 + s, o.y0 + a, o.x1 + s, o.y1 + a);\n            }\n          }\n\n          return i ? e : new d.Rect(0, 0, 0, 0);\n        }, i.prototype.getNodeNeighborsBounds = function (t) {\n          if (!t || 0 === this.nodes().length) return new d.Rect(0, 0, 0, 0);\n\n          for (var e = t.outerBounds.clone().moveBy(t.x, t.y), i = t, n = 0; n < t.links.length; n++) {\n            var r = t.links[n];\n\n            if (i = r.otherEnd(t), !i.removed) {\n              var s = i.outerBounds,\n                  a = i.x,\n                  o = i.y;\n              e.addBounds(s.x0 + a, s.y0 + o, s.x1 + a, s.y1 + o);\n            }\n          }\n\n          return e;\n        }, i.prototype.placePies = function () {\n          for (var t = 2 * Math.PI, e = [], i = 0, n = this.nodes(); i < n.length; i++) {\n            for (var r = n[i], s = 0, a = 0; a < r.links.length; a++) {\n              var o = r.links[a];\n              o.to === r && o.toPieValue > 0 && (s += o.toPieValue, e.push(o), o._angle = Math.atan2(o.to.y - o.from.y, o.to.x - o.from.x));\n            }\n\n            if (s > 0) {\n              e.sort(function (t, e) {\n                return t._angle - e._angle;\n              });\n\n              for (var l = t / s, h = 0, u = 0, c = 0; c < e.length; c++) {\n                var d = e[c];\n                d.toPie0 = h, h += d.toPieValue * l, d.toPie1 = h;\n                var p = d._angle - (d.toPie0 + d.toPie1) / 2;\n                p < 0 && (p += 2 * Math.PI), u += p;\n              }\n\n              u /= e.length, u -= Math.PI;\n\n              for (var f = 0; f < e.length; f++) {\n                var g = e[f];\n                g.toPie0 += u, g.toPie1 += u;\n              }\n\n              e = [];\n            }\n          }\n        }, i;\n      }(c);\n\n      t.NodesLayer = Z;\n\n      var Y = function (t) {\n        function e(e, i, n) {\n          return t.call(this, e, i, n) || this;\n        }\n\n        return n(e, t), e.prototype.zoomOut = function () {}, e.prototype.zoomOutPossible = function () {\n          return !1;\n        }, e.prototype.setSelection = function (t) {\n          for (var e, i = [], n = 0; n < t.length; n++) {\n            var r = t[n];\n            r instanceof h || r instanceof u ? i.push(r) : d.Helpers.isString(r) && (e = this.getNode(r) || this.getLink(r)) ? i.push(e) : this.error(\"setSelection: Could not find a chart object with the ID `\" + r + \"`.\");\n          }\n\n          this.scene.setSelection(i) && (this.events.notifySceneChanges({\n            selection: !0\n          }), this.notifySelectionChanged(this.createEventArguments(null, \"api\")));\n        }, e.prototype.createEventArguments = function (t, e) {\n          var i = null,\n              n = null;\n\n          if (t && (t.x || t.y)) {\n            var r = this.scene.fromDisplay(t.x, t.y);\n            i = r.x, n = r.y;\n          }\n\n          return {\n            chart: this.api,\n            origin: e,\n            chartX: i,\n            chartY: n,\n            hoverLink: this.scene.hoverLink,\n            hoverNode: this.scene.hoverNode,\n            hoverItem: this.scene.hoverItem,\n            selection: this.scene.selection.slice()\n          };\n        }, e;\n      }(d.Impl);\n\n      t.Impl = Y;\n    }(u = i.ItemsChart || (i.ItemsChart = {})), function (t) {\n      var e,\n          i = t.Gestures || (t.Gestures = {}),\n          r = t.Layouts || (t.Layouts = {}),\n          s = t.Bar || (t.Bar = {});\n      !function (t) {\n        t[t.NodeClass = 0] = \"NodeClass\", t[t.LinkClass = 1] = \"LinkClass\", t[t.Aura = 2] = \"Aura\";\n      }(e = t.LegendItemType || (t.LegendItemType = {}));\n\n      var a = function (t) {\n        function e(e, i, n, r, s, a, o, l, h) {\n          var u = t.call(this, i, n, r, s) || this;\n          return u.itemId = e, u.enabled = a, u.node = o, u.link = l, u.aura = h, u;\n        }\n\n        return n(e, t), e;\n      }(d.LegendEntry),\n          o = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e, null) || this;\n          return n.halfSize = i, n;\n        }\n\n        return n(e, t), e.prototype.distanceToEdge = function () {\n          return this.halfSize;\n        }, e;\n      }(u.Shape),\n          l = function (t) {\n        function e(e, i) {\n          var n = t.call(this, null, null, !0) || this;\n          return n.label = \"\", n.data = {\n            id: null,\n            loaded: !0\n          }, n.hHeight = e, n.hWidth = e, n.renderHheight = e, n.renderHwidth = e, n.x = i ? 2 * -e : e + e / 2, n.y = 0, n.shape = new o(n, e), n;\n        }\n\n        return n(e, t), e;\n      }(u.Node),\n          h = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.textColorDisabled = \"rgba(64,62,62,0.3)\", e.showItemsWithClasses = \"any\", e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegendAdvanced);\n\n      t.SettingsLegendAdvanced = h;\n\n      var c = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.panel = new d.SettingsLegendPanel(\"bottom\", \"left\"), e.advanced = new h(), e.mode = \"hide\", e.marker.size = 30, e.padding = 15, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegend);\n\n      t.SettingsLegend = c;\n\n      var p = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.paintOrder = 51, e.updateOrder = 100, e.linkClassState = Object.create(null), e.nodeClassState = Object.create(null), e.allNodeClassesEnabled = !0, e.allLinkClassesEnabled = !0, e;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (e) {\n          t.prototype.onSceneChange.call(this, e);\n          var i = e.changes.settingsChanges;\n          (e.changes.auras || i && (i.style && (i.style.nodeClasses || i.style.linkClasses) || i.legend && i.legend.text)) && (this.rebuildItems(e), e.changes.bounds = !0, e.changes.filters = !0);\n        }, e.prototype.doAnimations = function () {\n          return 1;\n        }, e.prototype.paintMarker = function (t, e, i, n, r) {\n          if (r.node) {\n            var s = {\n              geometry: this.getGeometry(e, i, .6),\n              paintDetails: !1\n            };\n            this.chart.renderer.paintNodes(t, [r.node], s, 0);\n          } else if (r.link) {\n            var s = {\n              geometry: this.getGeometry(e, i, 1),\n              paintDetails: !0\n            };\n            this.chart.renderer.paintLinks(t, [r.link], {}, s);\n          } else this.paintAuraMarker(t.context, e, i, n, r.aura);\n        }, e.prototype.paintAuraMarker = function (t, e, i, n, r) {\n          var s = n / 527,\n              a = e - n,\n              o = i - n,\n              l = d.Graphics.beginStrokeAndFill(t, r);\n          l.moveTo(878.4 * s + a, 413.8 * s + o), l.bezierCurveTo(856.4 * s + a, 404.2 * s + o, 817.1 * s + a, 388.9 * s + o, 769.7 * s + a, 378.2 * s + o), l.bezierCurveTo(696.1 * s + a, 361.5 * s + o, 679.5 * s + a, 324.1 * s + o, 676.7 * s + a, 308.7 * s + o), l.bezierCurveTo(674.4 * s + a, 296.1 * s + o, 652.9 * s + a, 188.3 * s + o, 589.9 * s + a, 107 * s + o), l.bezierCurveTo(543 * s + a, 42.5 * s + o, 466.9 * s + a, .6 * s + o, 381 * s + a, .6 * s + o), l.bezierCurveTo(238.4 * s + a, .6 * s + o, 122.8 * s + a, 116.2 * s + o, 122.8 * s + a, 258.8 * s + o), l.bezierCurveTo(122.8 * s + a, 264.7 * s + o, 123 * s + a, 270.5 * s + o, 123.4 * s + a, 276.3 * s + o), l.lineTo(122.8 * s + a, 276.9 * s + o), l.bezierCurveTo(122.8 * s + a, 276.9 * s + o, 127 * s + a, 333.8 * s + o, 136.7 * s + a, 389.3 * s + o), l.bezierCurveTo(146.4 * s + a, 444.8 * s + o, 138.1 * s + a, 500.4 * s + o, 106.2 * s + a, 543.4 * s + o), l.bezierCurveTo(74.3 * s + a, 586.4 * s + o, 2.1 * s + a, 689.2 * s + o, 4.9 * s + a, 754.4 * s + o), l.bezierCurveTo(5 * s + a, 755.9 * s + o, 5.2 * s + a, 757.3 * s + o, 5.4 * s + a, 758.8 * s + o), l.bezierCurveTo(4.1 * s + a, 769.2 * s + o, 3.5 * s + a, 779.8 * s + o, 3.5 * s + a, 790.5 * s + o), l.bezierCurveTo(3.5 * s + a, 933.1 * s + o, 119.1 * s + a, 1048.7 * s + o, 261.7 * s + a, 1048.7 * s + o), l.bezierCurveTo(349.6 * s + a, 1048.7 * s + o, 427.2 * s + a, 1004.7 * s + o, 473.9 * s + a, 937.6 * s + o), l.lineTo(474.1 * s + a, 937.6 * s + o), l.bezierCurveTo(474.1 * s + a, 937.6 * s + o, 510.2 * s + a, 891.8 * s + o, 518.5 * s + a, 884.8 * s + o), l.bezierCurveTo(526.8 * s + a, 877.9 * s + o, 568.5 * s + a, 854.3 * s + o, 608.7 * s + a, 869.5 * s + o), l.bezierCurveTo(631.7 * s + a, 878.2 * s + o, 675.6 * s + a, 894.2 * s + o, 719.1 * s + a, 905 * s + o), l.bezierCurveTo(743.4 * s + a, 912.6 * s + o, 769.3 * s + a, 916.7 * s + o, 796.1 * s + a, 916.7 * s + o), l.bezierCurveTo(938.7 * s + a, 916.7 * s + o, 1054.3 * s + a, 801.1 * s + o, 1054.3 * s + a, 658.5 * s + o), l.bezierCurveTo(1054.3 * s + a, 544.8 * s + o, 980.6 * s + a, 448.1 * s + o, 878.4 * s + a, 413.8 * s + o), l.closePath(), d.Graphics.endStrokeAndFill(t, l, r), l = d.Graphics.beginStrokeAndFill(t, {\n            fillColor: \"white\"\n          }), l.moveTo(796.1 * s + a, 825.2 * s + o), l.bezierCurveTo(718.8 * s + a, 825.2 * s + o, 653.8 * s + a, 772.6 * s + o, 635 * s + a, 701.2 * s + o), l.lineTo(423.3 * s + a, 750 * s + o), l.bezierCurveTo(426.5 * s + a, 763 * s + o, 428.3 * s + a, 776.5 * s + o, 428.3 * s + a, 790.5 * s + o), l.bezierCurveTo(428.3 * s + a, 882.5 * s + o, 353.7 * s + a, 957.1 * s + o, 261.7 * s + a, 957.1 * s + o), l.bezierCurveTo(169.7 * s + a, 957.1 * s + o, 95.1 * s + a, 882.5 * s + o, 95.1 * s + a, 790.5 * s + o), l.bezierCurveTo(95.1 * s + a, 698.5 * s + o, 169.7 * s + a, 623.9 * s + o, 261.7 * s + a, 623.9 * s + o), l.bezierCurveTo(270.7 * s + a, 623.9 * s + o, 279.4 * s + a, 624.6 * s + o, 288 * s + a, 626 * s + o), l.lineTo(331.2 * s + a, 417.8 * s + o), l.bezierCurveTo(263.6 * s + a, 396.6 * s + o, 214.5 * s + a, 333.4 * s + o, 214.5 * s + a, 258.8 * s + o), l.bezierCurveTo(214.5 * s + a, 166.8 * s + o, 289.1 * s + a, 92.2 * s + o, 381.1 * s + a, 92.2 * s + o), l.bezierCurveTo(473.1 * s + a, 92.2 * s + o, 547.7 * s + a, 166.8 * s + o, 547.7 * s + a, 258.8 * s + o), l.bezierCurveTo(547.7 * s + a, 298.1 * s + o, 534.1 * s + a, 334.1 * s + o, 511.4 * s + a, 362.6 * s + o), l.lineTo(684 * s + a, 535.3 * s + o), l.bezierCurveTo(713.6 * s + a, 508.4 * s + o, 752.9 * s + a, 492 * s + o, 796.1 * s + a, 492 * s + o), l.bezierCurveTo(888.1 * s + a, 492 * s + o, 962.7 * s + a, 566.6 * s + o, 962.7 * s + a, 658.6 * s + o), l.bezierCurveTo(962.7 * s + a, 750.6 * s + o, 888.1 * s + a, 825.2 * s + o, 796.1 * s + a, 825.2 * s + o), l.closePath(), l.moveTo(381 * s + a, 425.4 * s + o), l.bezierCurveTo(374.2 * s + a, 425.4 * s + o, 367.6 * s + a, 425 * s + o, 361 * s + a, 424.2 * s + o), l.lineTo(317.5 * s + a, 633.5 * s + o), l.bezierCurveTo(359.9 * s + a, 648.6 * s + o, 394.3 * s + a, 680.4 * s + o, 413 * s + a, 721 * s + o), l.lineTo(630 * s + a, 671 * s + o), l.bezierCurveTo(629.7 * s + a, 666.9 * s + o, 629.5 * s + a, 662.8 * s + o, 629.5 * s + a, 658.6 * s + o), l.bezierCurveTo(629.5 * s + a, 620.8 * s + o, 642.1 * s + a, 585.9 * s + o, 663.4 * s + a, 557.9 * s + o), l.lineTo(490.2 * s + a, 384.6 * s + o), l.bezierCurveTo(460.9 * s + a, 410 * s + o, 422.8 * s + a, 425.4 * s + o, 381 * s + a, 425.4 * s + o), l.closePath(), d.Graphics.endStrokeAndFill(t, l, {\n            fillColor: \"white\"\n          });\n        }, e.prototype.rebuildItems = function (t) {\n          var e = this.chart.scene.settings.style,\n              i = [],\n              n = this.settings.marker.size / 2,\n              r = this.settings.text.fillColor,\n              s = this.settings.advanced.textColorDisabled,\n              o = this.nodeClassState,\n              h = this.linkClassState;\n          this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0, this.chart.layer.styleUpdater.setItemRenderer(t.labelRenderer), this.chart.layer.styleUpdater.setContext(t.context);\n\n          for (var c = 0; c < e.nodeClasses.length; c++) {\n            var p = e.nodeClasses[c];\n\n            if (p.showInLegend && null != p.style) {\n              var f = d.Helpers.clone(e.node);\n              d.Helpers.extendStyleTo(p.style, f);\n              var g = new l(n, !1);\n              d.Helpers.extendStyleTo(f, g), this.chart.layer.styleUpdater.postprocessNode(g);\n              var v = !d.Helpers.hasProperty(o, p.className) || o[p.className];\n              this.nodeClassState[p.className] = v, v || (this.allNodeClassesEnabled = !1), i.push(new a(p.className, p.nameLegend || p.className, r, s, p.legendGroupId, v, g, null, null));\n            }\n          }\n\n          for (var m = 0; m < e.linkClasses.length; m++) {\n            var y = e.linkClasses[m];\n\n            if (y.showInLegend && null != y.style) {\n              var f = d.Helpers.clone(e.link);\n              d.Helpers.extendStyleTo(y.style, f);\n              var S = new u.Link(null, null);\n              d.Helpers.extendStyleTo(f, S), S.currentRadius = S.radius, S.from = new l(n, !0), S.to = new l(n, !1);\n              var v = !d.Helpers.hasProperty(h, y.className) || h[y.className];\n              this.linkClassState[y.className] = v, this.allLinkClassesEnabled = this.allLinkClassesEnabled && v, i.push(new a(y.className, y.nameLegend || y.className, r, s, y.legendGroupId, v, null, S, null));\n            }\n          }\n\n          for (var b = this.chart.settings.auras._calculatedStyles, x = Object.keys(b), C = 0; C < x.length; C++) {\n            var w = x[C],\n                L = b[w];\n            L.enabled || (this.allNodeClassesEnabled = !1), (L.showInLegend || null == L.showInLegend) && i.push(new a(w, L.nameLegend || w, r, s, L.legendGroupId, L.enabled, null, null, L));\n          }\n\n          this.resetEntries(i);\n        }, e.prototype.getGeometry = function (t, e, i) {\n          var n = this.settings.marker.size,\n              r = -n,\n              s = n,\n              a = -n,\n              o = n,\n              l = i,\n              h = i,\n              u = t,\n              c = e,\n              d = t - n,\n              p = t + n,\n              f = e - n,\n              g = e + n;\n          return {\n            txm: l,\n            txa: u,\n            tym: h,\n            tya: c,\n            zoom: i,\n            x0s: d,\n            x1s: p,\n            y0s: f,\n            y1s: g,\n            x0w: r,\n            y0w: a,\n            x1w: s,\n            y1w: o,\n            linkZoom: i\n          };\n        }, e.prototype.itemClicked = function (e, i) {\n          t.prototype.itemClicked.call(this, e, i), this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0;\n\n          for (var n = 0; n < this.entries.length; n++) {\n            var r = this.entries[n];\n            if (r.node) this.nodeClassState[r.itemId] = r.enabled, r.enabled || (this.allNodeClassesEnabled = !1);else if (r.link) this.linkClassState[r.itemId] = r.enabled, r.enabled || (this.allLinkClassesEnabled = !1);else {\n              var s = this.chart.settings.auras;\n              s._calculatedStyles[r.itemId].enabled = r.enabled, s.style[r.itemId].enabled = r.enabled, s._defaultStyles[r.itemId].enabled = r.enabled, this.chart.events.notifySceneChanges({\n                settingsChanges: {\n                  auras: {}\n                }\n              }), r.enabled || (this.allNodeClassesEnabled = !1);\n            }\n          }\n\n          this.chart.events.notifySceneChanges({\n            filters: !0\n          });\n        }, e.prototype.isNodeVisible = function (t) {\n          return \"hide\" !== this.settings.mode || this.isNodeEnabled(t);\n        }, e.prototype.isLinkVisible = function (t) {\n          return \"hide\" !== this.settings.mode || this.isLinkEnabled(t);\n        }, e.prototype.isNodeHighlighted = function (t) {\n          return \"highlight\" === this.settings.mode && !this.isNodeEnabled(t);\n        }, e.prototype.isLinkHighlighted = function (t) {\n          return \"highlight\" === this.settings.mode && !this.isLinkEnabled(t);\n        }, e.prototype.isNodeEnabled = function (t) {\n          if (this.allNodeClassesEnabled) return !0;\n          var e = t.className,\n              i = t.style ? t.style.aura : null;\n          if (!e && !i) return !0;\n          var n = u.ItemsStyle.getClasses(e),\n              r = Array.isArray(i) ? i : [i],\n              s = this.chart.settings.auras._calculatedStyles;\n\n          if (\"any\" === this.settings.advanced.showItemsWithClasses) {\n            for (var a = !1, o = !1, l = 0; l < n.length; l++) {\n              if (d.Helpers.hasProperty(this.nodeClassState, n[l])) {\n                if (this.nodeClassState[n[l]]) {\n                  o = !0;\n                  break;\n                }\n\n                a = !0;\n              }\n            }\n\n            for (var l = 0; l < r.length; l++) {\n              if (d.Helpers.hasProperty(s, r[l])) {\n                if (s[r[l]].enabled) {\n                  o = !0;\n                  break;\n                }\n\n                a = !0;\n              }\n            }\n\n            return o || !a;\n          }\n\n          for (var l = 0; l < n.length; l++) {\n            if (d.Helpers.hasProperty(this.nodeClassState, n[l]) && !this.nodeClassState[n[l]]) return !1;\n          }\n\n          for (var l = 0; l < r.length; l++) {\n            if (d.Helpers.hasProperty(s, r[l]) && !s[r[l]].enabled) return !1;\n          }\n\n          return !0;\n        }, e.prototype.isLinkEnabled = function (t) {\n          if (this.allLinkClassesEnabled) return !0;\n          var e = t.className;\n          if (!e) return !0;\n          var i = u.ItemsStyle.getClasses(e);\n\n          if (\"any\" === this.settings.advanced.showItemsWithClasses) {\n            for (var n = !1, r = !1, s = 0; s < i.length; s++) {\n              if (d.Helpers.hasProperty(this.linkClassState, i[s])) {\n                if (this.linkClassState[i[s]]) {\n                  r = !0;\n                  break;\n                }\n\n                n = !0;\n              }\n            }\n\n            return r || !n;\n          }\n\n          for (var s = 0; s < i.length; s++) {\n            if (d.Helpers.hasProperty(this.linkClassState, i[s]) && !this.linkClassState[i[s]]) return !1;\n          }\n\n          return !0;\n        }, e;\n      }(d.Legend);\n\n      t.Legend = p, function (e) {\n        var i = function (t) {\n          function e(e, i) {\n            var n = t.call(this, e, i) || this;\n            n.scene = e.scene, n.events = e.events;\n            var r = d.Helpers.createDom(\"li\", null, null, null);\n            r.style.display = \"inline\";\n            var s = d.Helpers.createDom(\"span\", \"DVSL-NC-zoom\", null, r);\n            return n.handle = d.Helpers.createDom(\"em\", null, null, s), n.mouse = new d.MouseEvents(r, n.scene.settings.advanced.pointer), n.mouse.listen(\"drag\", function (t) {\n              return n.zoomMove(t);\n            }), n.mouse.listen(\"down\", function (t) {\n              return n.zoomDown(t);\n            }), n.domElement = r, n;\n          }\n\n          return n(e, t), e.prototype.zoomDown = function (t) {\n            t.y < 100 && this.zoomMove(t);\n          }, e.prototype.zoomMove = function (t) {\n            var e = t.y - 10;\n            e = Math.max(0, Math.min(80, e)), this.handle.style.top = e + \"px\";\n            var i = this.getZoomValue(e / 80);\n            this.chart.autoZoom.manualZoom(i / this.scene.zoom), this.events.notifySceneChanges({\n              position: !0\n            }), t.consumed = !0;\n          }, e.prototype.getSliderPosition = function () {\n            var t = this.scene.settings.interaction.zooming.zoomExtent,\n                e = Math.min(t[0], this.chart.autoZoom.minimumAutoZoom),\n                i = t[1],\n                n = Math.log(Math.max(e, Math.min(i, this.scene.zoom)));\n            return e = Math.log(e), i = Math.log(i), 1 - (n - e) / (i - e);\n          }, e.prototype.getZoomValue = function (t) {\n            var e = this.scene.settings.interaction.zooming.zoomExtent,\n                i = Math.min(e[0], this.chart.autoZoom.minimumAutoZoom),\n                n = e[1];\n            i = Math.log(i), n = Math.log(n);\n            var r = (1 - t) * (n - i) + i;\n            return Math.exp(r);\n          }, e.prototype.doAnimations = function (t) {\n            var e = this.getSliderPosition();\n            this.handle.style.top = 80 * e + \"px\";\n          }, e.prototype.remove = function () {\n            this.mouse.remove();\n          }, e;\n        }(d.Bar.Item);\n\n        e.ZoomControl = i, d.Bar.ToolbarItemNames.zoomControl = d.Bar.ToolbarItemNames.zoomcontrol = function (e, i) {\n          return new t.Bar.ZoomControl(e, i);\n        }, d.Bar.ToolbarItemNames.rearrange = function (t, e) {\n          var i = t.settings.localization.toolbar;\n          e.label = e.label || i.rearrangeButton, e.title = e.title || i.rearrangeTitle, e.cssClass = e.cssClass || \"DVSL-bar-btn-rearrange\";\n          var n = e.onClick;\n          return e.onClick = function (e, i) {\n            t.resetLayout(), n && n(e, i);\n          }, new d.Bar.Button(t, e);\n        }, d.Bar.ToolbarItemNames.freeze = function (t, e) {\n          var i = t.settings.localization.toolbar;\n          return new d.Bar.ToggleButton(t, e, {\n            labelDisabled: e.label || i.freezeButton,\n            cssClassEnabled: \"DVSL-bar-btn-lock-all-active\",\n            cssClassDisabled: e.cssClass || \"DVSL-bar-btn-lock-all\",\n            titleEnabled: i.unfreezeTitle,\n            titleDisabled: i.freezeTitle,\n            getChartState: function getChartState() {\n              return t.isLayoutFrozen;\n            },\n            onEnable: function onEnable() {\n              return t.freezeLayout();\n            },\n            onDisable: function onDisable() {\n              return t.unfreezeLayout();\n            }\n          });\n        }, d.Bar.ToolbarItemNames.fit = function (t, e) {\n          var i = t.settings.localization.toolbar;\n          return new d.Bar.ToggleButton(t, e, {\n            labelDisabled: e.label || i.fitButton,\n            cssClassEnabled: \"DVSL-bar-btn-fit-active\",\n            cssClassDisabled: e.cssClass || \"DVSL-bar-btn-fit\",\n            titleDisabled: e.title || i.fitTitle,\n            getChartState: function getChartState() {\n              return \"overview\" === t.scene.autoZoomMode;\n            },\n            onEnable: function onEnable() {\n              return t.autoZoom.setZoom(\"overview\");\n            },\n            onDisable: function onDisable() {\n              return t.autoZoom.setZoom(\"auto\");\n            }\n          });\n        };\n\n        var r = function (t) {\n          function e() {\n            var e = t.call(this) || this;\n            return e.zoomControl = !0, e.enabled = !0, e.side = \"bottom\", e.align = \"left\", e.showLabels = !1, e.fullscreen = !0, e.export = !1, e.items = [new d.SettingsToolbarItem(\"fit\"), new d.SettingsToolbarItem(\"rearrange\"), new d.SettingsToolbarItem(\"freeze\"), new d.SettingsToolbarItem(\"back\"), new d.SettingsToolbarItem(\"fullscreen\"), new d.SettingsToolbarItem(\"export\"), new d.SettingsToolbarItem(\"zoomControl\", \"bottom\", \"left\")], e;\n          }\n\n          return n(e, t), e;\n        }(d.SettingsToolbar);\n\n        e.SettingsToolbar = r;\n\n        var s = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.rearrangeButton = \"Rearrange\", e.rearrangeTitle = \"Rearrange elements\", e.freezeButton = \"Freeze\", e.freezeTitle = \"Lock all\", e.unfreezeTitle = \"Unlock all\", e.fitButton = \"Fit\", e.fitTitle = \"Fit to screen\", e;\n          }\n\n          return n(e, t), e;\n        }(d.SettingsLocalizationToolbar);\n\n        e.SettingsLocalizationToolbar = s;\n      }(s = t.Bar || (t.Bar = {}));\n\n      var f = function (t) {\n        function e(i) {\n          var n = t.call(this, d.SettingsMapping.NetChartSettings) || this;\n          return n.theme = e.FlatTheme, n.data = [], n.area = new v(), n.events = new L(), n.style = new w(), n.auras = new u.SettingsNodesLayerAuras(), n.layout = new C(), n.filters = {\n            nodeFilter: null,\n            linkFilter: null,\n            nodeLinksProcessor: null,\n            multilinkProcessor: null\n          }, n.interaction = new m(), n.navigation = new b(), n.toolbar = new s.SettingsToolbar(), n.localization = new g(), n.legend = new c(), n.nodeMenu.buttons = [\"hide\", \"expand\", \"focus\", \"lock\"], n.apply(i), n._initializing = !1, n;\n        }\n\n        return n(e, t), e.prototype.apply = function (e) {\n          return this.applyCompatibility(e, [{\n            from: \"interaction.zooming.autoZoomPositionEllasticity\",\n            to: \"interaction.zooming.autoZoomPositionElasticity\"\n          }, {\n            from: \"navigation.nodeExpansionRadius\",\n            to: \"navigation.focusNodeExpansionRadius\"\n          }, {\n            from: \"localization.menu.dynaminc\",\n            to: \"localization.menu.dynamic\"\n          }]), t.prototype.apply.call(this, e);\n        }, e;\n      }(u.Settings);\n\n      f.FlatTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\"\n        }\n      }, f.DarkTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-dark\"\n        },\n        area: {\n          style: {\n            fillColor: \"rgba(28,26,28,1)\"\n          }\n        },\n        title: {\n          margin: 15,\n          style: {\n            fillColor: \"#A8A7A8\"\n          }\n        },\n        legend: {\n          text: {\n            fillColor: \"#A8A7A8\"\n          }\n        },\n        style: {\n          node: {\n            fillColor: \"gray\"\n          },\n          link: {\n            fillColor: \"#09c\"\n          },\n          linkHovered: {\n            shadowColor: \"#09c\"\n          },\n          hiddenLinks: {\n            lineColor: \"#A8A7A8\"\n          },\n          nodeHovered: {\n            shadowColor: \"#fff\",\n            shadowOffsetY: 0,\n            shadowBlur: 12\n          },\n          nodeLabel: {\n            padding: 4,\n            borderRadius: 10,\n            textStyle: {\n              fillColor: \"rgba(180,180,180,1)\"\n            },\n            backgroundStyle: {\n              fillColor: \"rgba(60,60,60,0.8)\",\n              lineColor: null\n            }\n          },\n          linkLabel: {\n            padding: .6,\n            backgroundStyle: {\n              lineColor: \"#09c\",\n              fillColor: \"#333333\"\n            },\n            textStyle: {\n              fillColor: \"#A8A7A8\"\n            }\n          },\n          selection: {\n            fillColor: \"white\",\n            shadowColor: \"rgba(255,255,255,0.6)\",\n            sizeConstant: 4,\n            shadowBlur: 24,\n            shadowOffsetY: 4\n          }\n        }\n      }, t.Settings = f;\n\n      var g = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.toolbar = new s.SettingsLocalizationToolbar(), e.menu = {\n            dynamic: \"Pin\",\n            fixed: \"Unpin\",\n            focus: \"Focus\",\n            unfocus: \"Unfocus\",\n            collapse: \"Collapse\",\n            close: \"Close\",\n            expand: \"Expand\",\n            hide: \"Hide\"\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLocalization);\n\n      t.SettingsLocalization = g;\n\n      var v = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.centerX = .5, e.centerY = .5, e.paddingTop = 0, e.paddingLeft = 0, e.paddingRight = 0, e.paddingBottom = 0, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsArea);\n\n      t.SettingsArea = v;\n\n      var m = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.zooming = new S(), e.selection = new y(), e.rotation = {\n            fingers: !1\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsInteraction);\n\n      t.SettingsInteraction = m;\n\n      var y = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.dragSelect = !0, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsInteractionSelection);\n\n      t.SettingsInteractionSelection = y;\n\n      var S = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.initialAutoZoom = \"overview\", e.zoomExtent = [.5, 4], e.autoZoomExtent = [null, 1], e.autoZoomSize = .9, e.autoZoomPositionElasticity = 2.5e-7, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsInteractionZooming);\n\n      t.SettingsInteractionZooming = S;\n\n      var b = function () {\n        function t() {\n          this.mode = \"showall\", this.initialNodes = null, this.focusNodeExpansionRadius = 2, this.focusNodeTailExpansionRadius = null, this.focusAutoFadeout = !1, this.numberOfFocusNodes = 3, this.minNumberOfFocusNodes = 1, this.expandDelay = 0, this.expandOnClick = !0, this.autoZoomOnFocus = !1, this.autoUnfocus = !0;\n        }\n\n        return t;\n      }();\n\n      t.SettingsNavigation = b;\n\n      var x = function () {\n        function t() {\n          this.strength = .01, this.from = \"auto\", this.fromCenter = \"weighted\", this.to = \"graph\", this.toCenter = \"weighted\";\n        }\n\n        return t;\n      }();\n\n      t.GravitySettings = x;\n\n      var C = function () {\n        function t() {\n          this.mode = \"dynamic\", this.nodeSpacing = 16, this.rowSpacing = null, this.groupSpacing = null, this.incrementalLayoutMaxTime = 300, this.initialLayoutMaxTime = 2e3, this.layoutFreezeTimeout = 1e4, this.layoutFreezeMinTimeout = 1500, this.aspectRatio = !1, this.globalLayoutOnChanges = !0, this.advanced = {\n            adaptiveFreezeTreshold: 1.2\n          }, this.twoRingRadialLayout = !1, this.rotation = 0, this.gravity = new x();\n        }\n\n        return t;\n      }();\n\n      t.SettingsLayout = C;\n\n      var w = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.dragSelection = {\n            fillColor: \"rgba(30,160,220,0.15)\",\n            lineColor: \"#000000\",\n            lineWidth: 1,\n            lineDash: [1, 2]\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsNodesLayerStyle);\n\n      t.SettingsStyle = w;\n\n      var L = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.onPointerDown = null, e.onPointerUp = null, e.onPointerDrag = null, e.onPointerMove = null, e.onDataUpdated = null, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsEvents);\n\n      t.SettingsEvents = L;\n\n      var T = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(u.Scene);\n\n      t.Scene = T, function (t) {\n        function e(t) {\n          if (0 === t.children.length) return 0;\n          var e = t.children[0],\n              i = t.children[t.children.length - 1];\n          return (e.node.x - e.hWidth + (i.node.x + i.hWidth)) / 2;\n        }\n\n        function i(t, e, i, n, r) {\n          null == e && (t[0].node.x = 0, e = t[0]);\n\n          for (var s = e.levelIndex + 1, a = null === i ? t.length : i.levelIndex, o = e.node.x + e.hWidth, l = s; l < a; l++) {\n            var h = t[l];\n            o += h.hWidth + (null == t[l].parent || t[l - 1].parent !== t[l].parent ? r : n), h.node.x = o, o += h.hWidth;\n          }\n        }\n\n        var r = function () {\n          function t() {\n            this.forceLinkList = null, this.fx = 0, this.fy = 0, this.sizeEstimate = 0, this.left = null, this.right = null, this.leafCount = 0, this.leaves = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0;\n          }\n\n          return t;\n        }(),\n            s = function () {\n          function t() {\n            this.maxLeafCount = 5, this.root = null, this.freeNodeRoot = null, this.temperature = 0, this.nodeCount = 0;\n          }\n\n          return t._swap = function (t, e, i) {\n            var n = t[e];\n            t[e] = t[i], t[i] = n;\n          }, t.prototype.buildTree = function (t) {\n            this.iters = 0;\n            var e = t.length;\n            this.root && this.freeNode(this.root), this.root = this.newNode(), e > 0 && this.buildTreeRecursive(t, 0, e, this.root);\n\n            for (var i = 0; i <= e - 1; i++) {\n              t[i].repulsiveForceX = 0, t[i].repulsiveForceY = 0, t[i].repulsiveForceZ = 0;\n            }\n\n            this.calculateForces();\n          }, t.prototype.freeNode = function (t) {\n            t.left && this.freeNode(t.left), t.right && this.freeNode(t.right), t.left = this.freeNodeRoot, this.freeNodeRoot = t;\n          }, t.prototype.newNode = function () {\n            var t;\n            return this.freeNodeRoot ? (t = this.freeNodeRoot, this.freeNodeRoot = t.left, t.left = null, t.right = null, t.leafCount = 0, t.sizeEstimate = 0, t.forceLinkList.length = 0) : (t = new r(), t.forceLinkList = [], t.leaves = new Array(this.maxLeafCount)), t.repulsiveForceX = 0, t.repulsiveForceY = 0, t.repulsiveForceZ = 0, t;\n          }, t.prototype.addForceLink = function (t, e) {\n            t.forceLinkList.push(e);\n          }, t.prototype.getMedianX = function (e, i, n) {\n            n -= 1;\n\n            for (var r = d.Helpers.trunc((i + n) / 2);;) {\n              if (n <= i) return r;\n              if (n === i + 1 && e[i].x > e[n].x) return t._swap(e, i, n), r;\n              var s = d.Helpers.trunc((i + n) / 2);\n              e[s].x > e[n].x && t._swap(e, s, n), e[i].x > e[n].x && t._swap(e, i, n), e[s].x > e[i].x && t._swap(e, s, i), t._swap(e, s, i + 1);\n\n              for (var a = i + 1, o = n;;) {\n                for (;;) {\n                  if (a += 1, !(e[i].x > e[a].x)) break;\n                }\n\n                for (;;) {\n                  if (o -= 1, !(e[o].x > e[i].x)) break;\n                }\n\n                if (o < a) break;\n                var l = e[a];\n                e[a] = e[o], e[o] = l;\n              }\n\n              t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1);\n            }\n          }, t.prototype.getMedianY = function (e, i, n) {\n            n -= 1;\n\n            for (var r = d.Helpers.trunc((i + n) / 2);;) {\n              if (n <= i) return r;\n              if (n === i + 1) return e[i].y > e[n].y && t._swap(e, i, n), r;\n              var s = d.Helpers.trunc((i + n) / 2);\n              e[s].y > e[n].y && t._swap(e, s, n), e[i].y > e[n].y && t._swap(e, i, n), e[s].y > e[i].y && t._swap(e, s, i), t._swap(e, s, i + 1);\n\n              for (var a = i + 1, o = n;;) {\n                for (;;) {\n                  if (a += 1, !(e[i].y > e[a].y)) break;\n                }\n\n                for (;;) {\n                  if (o -= 1, !(e[o].y > e[i].y)) break;\n                }\n\n                if (o < a) break;\n                var l = e[a];\n                e[a] = e[o], e[o] = l;\n              }\n\n              t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1);\n            }\n          }, t.prototype.buildTreeRecursive = function (t, e, i, n) {\n            for (var r = t[e].x, s = t[e].y, a = r, o = s, l = e + 1; l < i; l++) {\n              var h = t[l],\n                  u = h.x,\n                  c = h.y;\n              u < r && (r = u), u > a && (a = u), c < s && (s = c), c > o && (o = c);\n            }\n\n            n.sizeEstimate = Math.max(a - r, o - s), n.sizeEstimate = n.sizeEstimate * n.sizeEstimate + .1, n.sizeEstimate *= 2;\n            var d = i - e;\n\n            if (d <= this.maxLeafCount) {\n              n.leafCount = d;\n\n              for (var u = 0, c = 0, p = 0, f = 0, l = 0; l < d; l++) {\n                var g = t[l + e];\n                u += g.x, c += g.y, p += g.z, f += g.r, n.leaves[l] = g;\n              }\n\n              var v = 1 / d;\n              return n.r = f, n.x = u * v, n.y = c * v, void (n.z = p * v);\n            }\n\n            var m;\n            m = a - r > o - s ? this.getMedianX(t, e, i) : this.getMedianY(t, e, i), m++;\n            var y = this.newNode();\n            n.left = y, this.buildTreeRecursive(t, e, m, y), y = this.newNode(), n.right = y, this.buildTreeRecursive(t, m, i, y);\n            var S = 1 / d;\n            n.r = n.right.r + n.left.r, n.x = (n.left.x * (m - e) + n.right.x * (i - m)) * S, n.y = (n.left.y * (m - e) + n.right.y * (i - m)) * S, n.z = (n.left.z * (m - e) + n.right.z * (i - m)) * S;\n          }, t.prototype.calculateForces = function () {\n            var t = new Array(this.nodeCount),\n                e = 0,\n                i = 0;\n\n            for (null !== this.root.left ? (t[i] = this.root.left, i++, t[i] = this.root.right, i++, this.addForceLink(this.root.left, this.root.right)) : (t[i] = this.root, i++); e < i;) {\n              var n = t[e];\n              e++;\n              var r = 1 / n.r;\n\n              if (null !== n.left) {\n                this.processTreeNode(n, n.left), this.processTreeNode(n, n.right), t[i] = n.left, i++, t[i] = n.right, i++;\n                var s = n.left.r * r,\n                    a = n.repulsiveForceX * s,\n                    o = n.repulsiveForceY * s;\n                n.left.repulsiveForceX += a, n.left.repulsiveForceY += o, n.right.repulsiveForceX += n.repulsiveForceX - a, n.right.repulsiveForceY += n.repulsiveForceY - o, this.addForceLink(n.left, n.right);\n              } else for (var l = 0; l <= n.leafCount - 1; l++) {\n                var h = n.leaves[l];\n                this.processLeafNode(n, h);\n                var s = h.r * r;\n                h.repulsiveForceX += n.repulsiveForceX * s, h.repulsiveForceY += n.repulsiveForceY * s;\n\n                for (var u = l + 1; u <= n.leafCount - 1; u++) {\n                  var c = n.leaves[u];\n                  this.forceBetweenParticles(h, c);\n                }\n              }\n\n              n.forceLinkList.length = 0;\n            }\n          }, t.prototype.processTreeNode = function (t, e) {\n            for (var i = t.forceLinkList.length, n = 0; n < i; n++) {\n              var s = t.forceLinkList[n],\n                  a = e.x - s.x,\n                  o = e.y - s.y,\n                  l = a * a + o * o,\n                  h = e.sizeEstimate;\n\n              if (s instanceof r && (h += s.sizeEstimate), h < l) {\n                var u = e.r * s.r / (l * Math.sqrt(l)),\n                    c = a * u;\n                e.repulsiveForceX += c, s.repulsiveForceX -= c;\n                var d = o * u;\n                e.repulsiveForceY += d, s.repulsiveForceY -= d;\n              } else s instanceof r ? this.addForceLink(s, e) : this.addForceLink(e, s);\n            }\n          }, t.prototype.processLeafNode = function (t, e) {\n            for (var i = 0; i < t.forceLinkList.length; i++) {\n              var n = t.forceLinkList[i];\n\n              if (n instanceof r) {\n                var s = e.x - n.x,\n                    a = e.y - n.y,\n                    o = s * s + a * a,\n                    l = n.sizeEstimate;\n\n                if (l < o) {\n                  var h = e.r * n.r / (o * Math.sqrt(o)),\n                      u = s * h;\n                  e.repulsiveForceX += u, n.repulsiveForceX -= u;\n                  var c = a * h;\n                  e.repulsiveForceY += c, n.repulsiveForceY -= c;\n                } else this.addForceLink(n, e);\n              } else this.forceBetweenParticles(e, n);\n            }\n          }, t.prototype.forceBetweenParticles = function (t, e) {\n            var i,\n                n = t.x - e.x,\n                r = t.y - e.y,\n                s = t.z - e.z,\n                a = n * n + r * r + s * s,\n                o = t.r + e.r;\n            i = a * this.temperature < o ? .25 * this.temperature * Math.sqrt(this.temperature * o) : .25 * o * o / (a * Math.sqrt(a)), t.repulsiveForceX += n * i, e.repulsiveForceX -= n * i, t.repulsiveForceY += r * i, e.repulsiveForceY -= r * i, t.repulsiveForceZ += s * i, e.repulsiveForceZ -= s * i;\n          }, t;\n        }();\n\n        t.BHTree = s;\n\n        var a = function (t) {\n          function e(e) {\n            var i = t.call(this) || this;\n            return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1600, i.chart = e, i;\n          }\n\n          return n(e, t), e.ConstructLayout = function (t) {\n            switch (t.settings.layout.mode) {\n              case \"dynamic\":\n                return new y(t);\n\n              case \"radial\":\n                return new S(t);\n\n              case \"hierarchy\":\n                return new x(t);\n\n              case \"static\":\n                return new C(t);\n\n              default:\n                return t.error(\"Unknown layout mode: '\" + t.settings.layout.mode + \"'\"), new y(t);\n            }\n          }, e;\n        }(d.ChartElement);\n\n        t.LayoutBase = a;\n\n        var o = function () {\n          function t(t, e) {\n            this.strength = t, this.nodes = e;\n          }\n\n          return t.prototype.filterLockedNodes = function (t) {\n            for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) {\n              t[n].layerNode.locked && (e[i++] = t[n]);\n            }\n\n            return e.length = i, e;\n          }, t.prototype.filterUnlockedNodes = function (t) {\n            for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) {\n              t[n].layerNode.locked || (e[i++] = t[n]);\n            }\n\n            return e.length = i, e;\n          }, t;\n        }(),\n            l = function (t) {\n          function e(e, i) {\n            var n = t.call(this, e, i) || this;\n            return n.clusters = n.calculateClusters(i), n;\n          }\n\n          return n(e, t), e.prototype.calculateClusters = function (t) {\n            for (var e = [], i = new Array(t.length), n = new Object(null), r = 0; r < t.length; r++) {\n              var s = t[r],\n                  a = s.layerNode.id;\n\n              if (!n[a]) {\n                var o = [s];\n                e.push(o), n[a] = !0;\n                var l = 0,\n                    h = 0;\n\n                for (i[h] = s, h++; l < h;) {\n                  s = i[l], l++;\n\n                  for (var u = 0; u < s.edges.length; u++) {\n                    var c = s.edges[u],\n                        d = c.to,\n                        p = d.layerNode.id;\n                    n[p] || (n[p] = !0, o.push(d), i[h] = d, h++);\n                  }\n                }\n              }\n            }\n\n            return e;\n          }, e;\n        }(o),\n            h = function (t) {\n          function e(e, i, n, r) {\n            var s = t.call(this, e, i) || this;\n            return s.toCenter = n, s.lockedOnly = r, s;\n          }\n\n          return n(e, t), e.prototype.recalculate = function () {\n            for (var t = 0; t < this.clusters.length; t++) {\n              for (var e = this.clusters[t], i = this.lockedOnly ? this.toCenter(this.filterLockedNodes(e)) : this.toCenter(e), n = 0; n < e.length; n++) {\n                var r = e[n];\n                r.layerNode.userLock || (r.gravityForceX = (i.x - r.x) * this.strength, r.gravityForceY = (i.y - r.y) * this.strength);\n              }\n            }\n          }, e;\n        }(l),\n            u = function (t) {\n          function e(e, i, n, r) {\n            var s = t.call(this, e, i) || this;\n            return s.toCenter = n, s.lockedOnly = r, s;\n          }\n\n          return n(e, t), e.prototype.recalculate = function () {\n            for (var t = this.lockedOnly ? this.toCenter(this.filterLockedNodes(this.nodes)) : this.toCenter(this.nodes), e = 0; e < this.nodes.length; e++) {\n              var i = this.nodes[e];\n              i.layerNode.userLock || (i.gravityForceX = (t.x - i.x) * this.strength, i.gravityForceY = (t.y - i.y) * this.strength);\n            }\n          }, e;\n        }(o),\n            c = function (t) {\n          function e(e, i, n, r, s) {\n            var a = t.call(this, e, i) || this;\n            return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a;\n          }\n\n          return n(e, t), e.prototype.recalculate = function () {\n            for (var t = 0; t < this.clusters.length; t++) {\n              var e = this.clusters[t],\n                  i = this.filterUnlockedNodes(e);\n\n              if (!(i.length < 1)) {\n                var n = this.fromCenter(i),\n                    r = void 0;\n\n                if (this.lockedOnly) {\n                  var s = this.filterLockedNodes(e);\n                  r = s.length < 1 ? this.toCenter(e) : this.toCenter(s);\n                } else r = this.toCenter(e);\n\n                if (r.x !== n.x || r.y !== n.y) for (var a = Math.min(10, Math.sqrt(i.length)) * this.strength, o = (r.x - n.x) * a, l = (r.y - n.y) * a, h = 0; h < e.length; h++) {\n                  var u = e[h];\n                  u.gravityForceX = o, u.gravityForceY = l;\n                }\n              }\n            }\n          }, e;\n        }(l),\n            p = function (t) {\n          function e(e, i, n, r, s) {\n            var a = t.call(this, e, i) || this;\n            return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a;\n          }\n\n          return n(e, t), e.prototype.recalculate = function () {\n            var t;\n\n            if (this.lockedOnly) {\n              var e = this.filterLockedNodes(this.nodes);\n              t = e.length < 1 ? this.toCenter(this.nodes) : this.toCenter(e);\n            } else t = this.toCenter(this.nodes);\n\n            for (var i = 0; i < this.clusters.length; i++) {\n              var n = this.clusters[i],\n                  r = this.filterUnlockedNodes(n);\n\n              if (!(r.length < 1)) {\n                var s = this.fromCenter(r);\n                if (t.x !== s.x || t.y !== s.y) for (var a = Math.min(10, Math.sqrt(r.length)) * this.strength, o = (t.x - s.x) * a, l = (t.y - s.y) * a, h = 0; h < n.length; h++) {\n                  var u = n[h];\n                  u.gravityForceX = o, u.gravityForceY = l;\n                }\n              }\n            }\n          }, e;\n        }(l),\n            f = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.recalculate = function () {\n            for (var t = new Object(null), e = new Array(this.nodes.length), i = 0, n = 0, r = 0; r < this.nodes.length; r++) {\n              var s = this.nodes[r];\n              s.layerNode.userLock && (e[n++] = s, t[s.layerNode.id] = s);\n            }\n\n            for (; i < n;) {\n              for (var s = e[i++], a = t[s.layerNode.id], r = 0; r < s.edges.length; r++) {\n                var o = s.edges[r].to;\n                t[o.layerNode.id] || (t[o.layerNode.id] = a, e[n++] = o);\n              }\n            }\n\n            for (var l = null, r = 0; r < this.nodes.length; r++) {\n              var s = this.nodes[r];\n\n              if (!s.layerNode.userLock) {\n                var h = t[s.layerNode.id];\n                h ? (s.gravityForceX = (h.x - s.x) * this.strength, s.gravityForceY = (h.y - s.y) * this.strength) : (null == l && (l = d.Geometry.findWeightedCenter(this.nodes)), s.gravityForceX = (l.x - s.x) * this.strength, s.gravityForceY = (l.y - s.y) * this.strength);\n              }\n            }\n          }, e;\n        }(o),\n            g = function () {\n          function t(t) {\n            this._needsReset = !0, this._calculation = null, this._chart = t;\n          }\n\n          return t.prototype.reset = function () {\n            this._needsReset = !0;\n          }, t.prototype.guessBestMode = function (t) {\n            if (t.length < 1) return \"node\";\n            var e = new Object(null),\n                i = new Array(t.length),\n                n = 0,\n                r = 1;\n\n            for (e[t[0].layerNode.id] = !0, i[0] = t[0]; n < r;) {\n              for (var s = i[n++], a = 0; a < s.edges.length; a++) {\n                var o = s.edges[a].to;\n                e[o.layerNode.id] || (e[o.layerNode.id] = !0, i[r++] = o);\n              }\n            }\n\n            return r < t.length ? \"node\" : \"cluster\";\n          }, t.prototype.resetCalculation = function (t) {\n            var e = this._chart.settings.layout.gravity;\n\n            if (this._calculation = null, 0 !== e.strength) {\n              var i = e.from;\n              if (\"nearestLockedNode\" === e.to) return void (\"node\" !== i && \"auto\" !== i || (this._calculation = new f(e.strength, t)));\n              var n = \"weighted\" === e.toCenter ? d.Geometry.findWeightedCenter : d.Geometry.circumscribeCircle;\n\n              if (\"auto\" === i && (i = this.guessBestMode(t)), \"cluster\" === i) {\n                var r = \"weighted\" === e.fromCenter ? d.Geometry.findWeightedCenter : d.Geometry.circumscribeCircle;\n                \"cluster\" === e.to ? this._calculation = new c(e.strength, t, r, n, !1) : \"clusterLockedNodes\" === e.to ? this._calculation = new c(e.strength, t, r, n, !0) : \"graph\" === e.to ? this._calculation = new p(e.strength, t, r, n, !1) : \"graphLockedNodes\" === e.to && (this._calculation = new p(e.strength, t, r, n, !0));\n              } else \"node\" === i && (\"cluster\" === e.to ? this._calculation = new h(e.strength, t, n, !1) : \"clusterLockedNodes\" === e.to ? this._calculation = new h(e.strength, t, n, !0) : \"graph\" === e.to ? this._calculation = new u(e.strength, t, n, !1) : \"graphLockedNodes\" === e.to && (this._calculation = new u(e.strength, t, n, !0)));\n            }\n          }, t.prototype.recalculate = function (t) {\n            t.length < 2 || (this._needsReset && (this.resetCalculation(t), this._needsReset = !1), this._calculation && this._calculation.recalculate());\n          }, t;\n        }();\n\n        t.Gravity = g;\n\n        var v = function () {\n          function t(t, e, i) {\n            this.pair = null, this.K = null, this.len = null, this.strength = null, this.visibility = null, this.to = t, this.direction = e, this.links = i;\n          }\n\n          return t;\n        }(),\n            m = function () {\n          function t() {\n            this.layerNode = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.zattr = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0, this.gravityForceX = 0, this.gravityForceY = 0, this.forceX = null, this.forceY = null, this.forceZ = null, this.forceSum = null, this.oldForceX = null, this.oldForceY = null, this.oldForceZ = null, this.locked = !1, this.offsetX = 0, this.offsetY = 0, this.minr = 0, this.fsum = 0, this.edges = [];\n          }\n\n          return t;\n        }(),\n            y = function (t) {\n          function e(e) {\n            var i = t.call(this, e) || this;\n            return i.enableDebugState = !1, i.debugState = [], i.nodeRepulsionFactor = 15, i.linkForceFactor = .2, i.nodeDegreeModifier = 1, i.forceReductionFactor = 1, i.random = new d.Random(1), i.nodeCount = 0, i.nodes = [], i.edges = [], i.nodesAspect = 1, i.idToNode = {}, i.temperature = 0, i.unitTemperature = 0, i.randomLayoutRadius = 0, i.zAxisAttraction = 1, i.repulsiveForceTree = new s(), i.aspectRatio = null, i.idleSince = 0, i.noMovementSince = 0, i.layoutMovement = 0, i.gravity = null, i.gravity = new g(e), i;\n          }\n\n          return n(e, t), e.prototype.updateGraph = function (t, e, i) {\n            (i || t.length !== this.nodeCount) && (this.rebuildGraph(t, e), i = !0);\n\n            for (var n = 0; n < this.edges.length; n++) {\n              for (var r = this.edges[n], s = r.links, a = 0; a < s.length; a++) {\n                var o = s[a],\n                    l = o.targetStrength,\n                    h = o.targetLength,\n                    u = o.visibility;\n\n                if (o.added) {\n                  var c = o.from.links.length > 1 && o.to.links.length > 1,\n                      d = c || o.removed ? .2 : l;\n                  h = .2 + (h - .2) * u, l = l * u + d * (1 - u);\n                }\n\n                0 === a ? (r.strength = l, r.len = h, r.visibility = u) : (r.strength = Math.max(l, r.strength), r.len = Math.max(h, r.len), r.visibility = Math.max(u, r.visibility));\n              }\n\n              r.pair.strength = r.strength, r.pair.len = r.len, r.pair.visibility = r.visibility, r.K = r.pair.K = 0;\n            }\n\n            for (var p = this.chart.settings.layout.nodeSpacing / 2, n = 0; n < t.length; n++) {\n              var f = this.nodes[n],\n                  g = f.layerNode,\n                  v = g.outerBounds.w(),\n                  m = g.outerBounds.h();\n              f.offsetX = g.outerBounds.x0 + g.outerBounds.x1, f.offsetY = g.outerBounds.y0 + g.outerBounds.y1, f.x = g.x + f.offsetX, f.y = g.y + f.offsetY, f.zattr = g.visibility, f.locked = g.locked, f.forceX = 0, f.forceY = 0, f.forceZ = 0, f.forceSum = 0;\n\n              for (var y = 0, S = 0; S < f.edges.length; S++) {\n                var b = f.edges[S];\n                y += b.to.edges.length * b.visibility;\n              }\n\n              var x = Math.sqrt(y);\n              f.r = .5 * Math.max(1, v) + p, f.minr = Math.max(1, (m + .5 * v) / 3) + p, x > 4 && (f.r += (x - 4) * f.r / 4 * this.nodeDegreeModifier, f.minr += (x - 4) * f.minr / 4 * this.nodeDegreeModifier);\n            }\n\n            for (var C = 0, w = 0, L = 0, n = 0; n < this.nodes.length; n++) {\n              for (var f = this.nodes[n], T = 0, a = 0; a < f.edges.length; a++) {\n                var b = f.edges[a],\n                    k = b.to;\n\n                if (!(f.locked && k.locked || f === k)) {\n                  L++;\n                  var M = f.minr + k.minr;\n                  b.len > 0 ? (b.len = Math.max(1, M * b.len), b.K = 30 * Math.min(20, b.strength) / b.len, T += b.K, C += b.len) : (b.K = b.strength, T += b.K, C += M);\n                }\n              }\n\n              f.fsum = T, w += f.r * f.r;\n            }\n\n            L > 0 ? (this.randomLayoutRadius = Math.max(1, C / 10), this.unitTemperature = C / (50 * L)) : (this.randomLayoutRadius = Math.max(1, Math.sqrt(w)), this.unitTemperature = 1), i && this.saveDebugState(\"updateGraph: Graph rebuilt.\");\n          }, e.prototype.rebuildGraph = function (t, e) {\n            var i = this.idToNode;\n            this.nodeCount = t.length, this.nodes = new Array(this.nodeCount), this.idToNode = {};\n\n            for (var n = 0, r = 0, s = 0; s < t.length; s++) {\n              var a = t[s],\n                  o = a.id,\n                  l = new m();\n              l.layerNode = a;\n              var h = a.outerBounds.w(),\n                  u = a.outerBounds.h();\n\n              if (u > 0 && (n += u / h, r += 1), this.idToNode[o] = l, this.nodes[s] = l, d.Helpers.hasProperty(i, o)) {\n                var c = i[o];\n                l.z = c.z, l.oldForceX = c.oldForceX, l.oldForceY = c.oldForceY, l.oldForceZ = c.oldForceZ;\n              } else l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0;\n            }\n\n            r > 0 ? this.nodesAspect = Math.max(.3, n / r) : this.nodesAspect = 1;\n            var p = {},\n                f = {\n              U: \"D\",\n              null: null,\n              D: \"U\",\n              L: \"R\",\n              R: \"L\"\n            };\n            this.edges = [];\n\n            for (var s = 0; s < e.length; s++) {\n              var g = e[s],\n                  y = g.multiId;\n              if (d.Helpers.hasProperty(p, y)) p[y].push(g);else {\n                var S = this.idToNode[g.from.id],\n                    b = this.idToNode[g.to.id],\n                    x = [g],\n                    C = new v(b, g.direction, x),\n                    w = new v(S, f[g.direction], x);\n                C.pair = w, w.pair = C, p[y] = x, S.edges.push(C), b.edges.push(w), this.edges.push(C);\n              }\n            }\n\n            this.gravity.reset();\n          }, e.prototype.saveDebugState = function (t) {\n            this.enableDebugState && this.debugState.push({\n              extra: {\n                comment: t\n              },\n              nodes: this.nodes.map(function (t) {\n                return {\n                  id: t.layerNode.id,\n                  x: t.x - t.offsetX,\n                  y: t.y - t.offsetY,\n                  style: t.layerNode.data.style,\n                  extra: t.layerNode.data.extra,\n                  loaded: !0\n                };\n              }),\n              links: this.edges.map(function (t) {\n                return {\n                  from: t.to.layerNode.id,\n                  to: t.pair.to.layerNode.id\n                };\n              })\n            });\n          }, e.prototype.globalLayout = function (t, e) {\n            if (!(this.nodeCount <= 0)) {\n              if (e) {\n                if (1 === this.nodeCount) return this.nodes[0].locked || (this.nodes[0].layerNode.x = this.nodes[0].layerNode.y = 0), void this.saveDebugState(\"globalLayout: resetPositions\");\n                this.initialRandomLayout(), this.saveDebugState(\"globalLayout: resetPositions\");\n              }\n\n              for (var i = 0, n = 0; n < this.nodes.length; n++) {\n                var r = this.nodes[n];\n                r.locked || i++;\n              }\n\n              var s = Math.floor(Math.sqrt(i) + 10),\n                  a = 2 * s;\n              this.forceReductionFactor = 1, this.temperature = (2 * Math.sqrt(i) + 20) * this.unitTemperature, this.zAxisAttraction = .02;\n\n              for (var o = d.Helpers.performanceNow(), l = 3; this.temperature > this.unitTemperature && (a-- <= 0 && (a = 3 * s / l++, this.temperature = this.temperature / 1.5 - .5, this.temperature < 20 * this.unitTemperature && (this.zAxisAttraction = 1.5 * this.zAxisAttraction + .02)), this.randomnodesForRepulsion(), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.moveNodesGlobal(), this.saveDebugState(\"globalLayout: iteration\"), !(d.Helpers.performanceNow() > o + t));) {\n                ;\n              }\n\n              e && (this.centerNodes(), this.saveDebugState(\"globalLayout: centerNodes\")), this.storeNodes();\n            }\n          }, e.prototype.initialRandomLayout = function () {\n            for (var t = this.nodeCount, e = new Array(t), i = 0; i <= t - 1; i++) {\n              e[i] = this.nodes[i];\n            }\n\n            for (var i = 0; i < t; i++) {\n              var n = Math.floor(this.random.get() * (t - i)) + i,\n                  r = e[i];\n              e[i] = e[n], e[n] = r;\n            }\n\n            for (var s = this.randomLayoutRadius, a = 2 * Math.PI / this.nodeCount, o = 0; o < t; o++) {\n              var l = e[o];\n\n              if (l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0, l.z = this.random.get() - .5, !l.locked) {\n                var h = s + l.r;\n                l.x = h * Math.cos(o * a), l.y = h * Math.sin(o * a);\n              }\n            }\n          }, e.prototype.timedLayout = function (t) {\n            if (!(this.nodeCount <= 1) && t > 0) {\n              var e = 0;\n              t < .1 ? (e = 2, this.forceReductionFactor = Math.max(.002, Math.min(this.forceReductionFactor, 10 * t))) : e = Math.min(6, Math.round(2 + 10 * t)), this.zAxisAttraction = this.nodeRepulsionFactor / 28, this.temperature = this.unitTemperature;\n\n              for (var i = 0; i <= e - 1; i++) {\n                this.randomnodesForRepulsion(), this.applyAspect(1 / this.nodesAspect), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.applyAspect(this.nodesAspect), this.moveNodesIncremental(), this.saveDebugState(\"timedLayout: iteration\");\n              }\n\n              this.storeNodes();\n            }\n          }, e.prototype.prepareAspectRatio = function (t) {\n            for (var e, i, n, r, s, a, o, l = this.nodes, h = l[0].x, u = l[0].y, c = h, d = u, p = !0, f = 1; f <= this.nodeCount - 1; f++) {\n              h = Math.min(h, l[f].x), c = Math.max(c, l[f].x), u = Math.min(u, l[f].y), d = Math.max(d, l[f].y);\n            }\n\n            var g = (h + c) / 2,\n                v = (u + d) / 2,\n                m = c - h,\n                y = d - u;\n            return 0 === m || 0 === y ? p = !1 : (e = Math.sqrt(this.aspectRatio), i = Math.sqrt(m * y), n = i * e / m, r = i / e / y, n = t * n + (1 - t), r = t * r + (1 - t), s = g - g * n, a = v - v * r, o = 1 / this.forceReductionFactor), {\n              scaleX: n,\n              incX: s,\n              scaleY: r,\n              incY: a,\n              invForce: o,\n              aspectRatioPrepared: p\n            };\n          }, e.prototype.updateAspectRatioNode = function (t, e) {\n            e.forceX += (e.x * (t.scaleX - 1) + t.incX) * t.invForce, e.forceY += (e.y * (t.scaleY - 1) + t.incY) * t.invForce;\n          }, e.prototype.updateAspectRatio = function (t) {\n            for (var e = this.prepareAspectRatio(t), i = this.nodes, n = 0; n <= this.nodeCount - 1; n++) {\n              this.updateAspectRatioNode(e, i[n]);\n            }\n          }, e.prototype.moveNodesGlobal = function () {\n            this.gravity.recalculate(this.nodes);\n            var t,\n                e = .5 * this.temperature,\n                i = this.forceReductionFactor;\n            this.aspectRatio && (t = this.prepareAspectRatio(.005), t.aspectRatioPrepared || (this.aspectRatio = null));\n\n            for (var n = 0; n <= this.nodeCount - 1; n++) {\n              var r = this.nodes[n];\n\n              if (!r.locked) {\n                this.calculateForce(r, .5), this.aspectRatio && this.updateAspectRatioNode(t, r);\n                var s = r.oldForceX = r.forceX,\n                    a = r.oldForceY = r.forceY,\n                    o = r.oldForceZ = r.forceZ,\n                    l = r.forceSum;\n                s *= l, a *= l, o *= l;\n                var h = s * s + a * a + o * o;\n                h < this.temperature * this.temperature && h > .001 && (h = this.temperature / Math.sqrt(h), s *= h, a *= h, o *= h), r.x += s * i + (this.random.get() - .5) * e, r.y += a * i + (this.random.get() - .5) * e, r.z += o * i + (this.random.get() - .5) * e;\n              }\n            }\n          }, e.prototype.moveNodesIncremental = function () {\n            this.gravity.recalculate(this.nodes);\n\n            for (var t = 0; t <= this.nodeCount - 1; t++) {\n              this.nodes[t].locked || this.calculateForce(this.nodes[t], 0);\n            }\n\n            if (this.aspectRatio) {\n              var e = Math.min(.4, .5 / Math.pow(this.nodeCount, .5));\n              this.updateAspectRatio(e);\n            }\n\n            for (var i = 0, n = 0, r = 0, s = 0, a = new Array(this.nodeCount), t = 0; t <= this.nodeCount - 1; t++) {\n              var o = this.nodes[t];\n\n              if (!o.locked) {\n                var l = o.forceX,\n                    h = o.forceY,\n                    u = o.forceZ,\n                    c = o.forceSum,\n                    d = l * l + h * h + u * u;\n\n                if (d * c * c > this.unitTemperature * this.unitTemperature * .05 * .05) {\n                  s += d;\n                  var p = o.oldForceX * l + o.oldForceY * h + o.oldForceZ * u;\n                  r += p, p > 0 ? n += p : i -= p;\n                } else a[t] = !0;\n              }\n            }\n\n            this.layoutMovement = (n - 5 * i) / this.nodeCount, r > 1e-7 ? this.forceReductionFactor *= 1 + .4 / 1.618033989 : r < -1e-7 && (this.forceReductionFactor /= 1.4), this.forceReductionFactor = Math.min(1, this.forceReductionFactor), this.forceReductionFactor = Math.max(.002, this.forceReductionFactor);\n\n            for (var t = 0; t <= this.nodeCount - 1; t++) {\n              var f = this.nodes[t];\n\n              if (!f.locked && !a[t]) {\n                var c = f.forceSum * this.forceReductionFactor;\n                f.x += f.forceX * c, f.y += f.forceY * c, f.z += f.forceZ * c;\n              }\n\n              f.oldForceX = f.forceX, f.oldForceY = f.forceY, f.oldForceZ = f.forceZ;\n            }\n          }, e.prototype.applyAspect = function (t) {\n            for (var e = 0; e < this.nodes.length; e++) {\n              var i = this.nodes[e];\n              i.y *= t;\n            }\n          }, e.prototype.calculateForce = function (t, e) {\n            for (var i = t.oldForceX * e, n = t.oldForceY * e, r = t.oldForceZ * e, s = 0; s < t.edges.length; s++) {\n              var a = t.edges[s],\n                  o = a.to,\n                  l = a.len,\n                  h = t.x - t.offsetX - o.x + o.offsetX,\n                  u = t.y - t.offsetY - o.y + o.offsetY,\n                  c = t.z - o.z;\n              a.direction && (\"U\" === a.direction ? (u -= l, l = 0) : \"D\" === a.direction ? (u += l, l = 0) : \"L\" === a.direction ? (h -= l, l = 0) : \"R\" === a.direction && (h += l, l = 0));\n              var d = Math.sqrt(h * h + u * u + c * c);\n              d < .01 && (d = .01);\n              var p = (l - d) * a.K / d * this.linkForceFactor;\n              i += p * h, n += p * u, r += p * c;\n            }\n\n            i += t.repulsiveForceX * this.nodeRepulsionFactor, n += t.repulsiveForceY * this.nodeRepulsionFactor, r += t.repulsiveForceZ * this.nodeRepulsionFactor;\n            var f = t.zattr * this.zAxisAttraction;\n            if (r -= t.z * f, i += t.gravityForceX, n += t.gravityForceY, isNaN(i)) throw \"Internal error: Nan in layout\";\n            t.forceX = i, t.forceY = n, t.forceZ = r, t.fsum + f !== 0 && (t.forceSum = 1 / (t.fsum + f));\n          }, e.prototype.storeNodes = function () {\n            for (var t = 0; t <= this.nodeCount - 1; t++) {\n              var e = this.nodes[t];\n              e.locked || (e.layerNode.x = e.x - e.offsetX, e.layerNode.y = e.y - e.offsetY);\n            }\n          }, e.prototype.centerNodes = function () {\n            for (var t = new d.Random(243178931), e = this.nodes, i = e[0].x, n = i, r = e[0].y, s = r, a = 1; a <= this.nodeCount - 1; a++) {\n              i = Math.min(i, e[a].x), n = Math.max(n, e[a].x), r = Math.min(r, e[a].y), s = Math.max(s, e[a].y);\n            }\n\n            for (var o = (i + n) / 2, l = (r + s) / 2, a = 0; a <= this.nodeCount - 1; a++) {\n              var h = e[a];\n\n              if (h.x -= o, h.y -= l, !h.locked) {\n                var u = .3 * h.r;\n                h.x += t.get() * u, h.y += t.get() * u;\n              }\n            }\n          }, e.prototype.randomnodesForRepulsion = function () {\n            for (var t = 0; t <= this.nodeCount - 1; t++) {\n              var e = Math.floor(this.random.get() * (this.nodeCount - t)) + t,\n                  i = this.nodes[t];\n              this.nodes[t] = this.nodes[e], this.nodes[e] = i;\n            }\n          }, e.prototype.onSceneChange = function (t) {\n            var e = t.changes.settingsChanges;\n            if (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges()) for (var i = this.chart.layer, n = i.links(), r = 0; r < n.length; r++) {\n              var s = n[r];\n              s.background && (s.background = !1, i.touchLink(s));\n            }\n            e && e.layout && this.gravity.reset();\n          }, e.prototype.doAnimations = function (t) {\n            var e = this.chart.settings.layout,\n                i = this.chart.layer,\n                n = e.layoutFreezeTimeout,\n                r = e.layoutFreezeMinTimeout,\n                s = i.hasTopologyChanges(),\n                a = t.dtime;\n            (0 === this.idleSince || t.changes.dynamicLayout || s || t.changes.coordinates || t.changes.layout || t.changes.bounds) && (this.idleSince = t.timeStamp, this.noMovementSince = 0);\n            var o = 1;\n\n            if (!s) {\n              var l = t.timeStamp - this.idleSince;\n              if (this.layoutMovement < e.advanced.adaptiveFreezeTreshold) if (0 !== this.noMovementSince) {\n                var h = t.timeStamp - this.noMovementSince;\n                o = Math.min((r - h) / r, o);\n              } else this.noMovementSince = t.timeStamp;\n              o = Math.min((n - l) / n, o);\n            }\n\n            o > 0 && (this.doForceLayout(a * o, !1), t.animating = !0, t.changes.position = !0);\n          }, e.prototype.placeNewNodes = function () {\n            for (var t = {}, e = this.chart.layer, i = !1, n = 0, r = e.nodes(); n < r.length; n++) {\n              var s = r[n];\n              null !== s.x && null !== s.y || (t[s.id] = !0);\n            }\n\n            for (var n = 0, r = e.nodes(); n < r.length; n++) {\n              var s = r[n],\n                  a = 1;\n\n              if (t.hasOwnProperty(s.id)) {\n                var o = 0,\n                    l = 0,\n                    h = 0;\n                a = 1;\n\n                for (var u = void 0, c = 0; c < s.links.length; c++) {\n                  var d = s.links[c],\n                      p = d.otherEnd(s);\n                  t.hasOwnProperty(p.id) || (u = p, l += p.x, h += p.y, o += 1);\n                }\n\n                var f = void 0,\n                    g = void 0;\n                if (o > 1) f = l / o, g = h / o, a = .5;else if (1 === o) {\n                  for (var v = 0, m = 0, y = 0, c = 0; c < u.links.length; c++) {\n                    var d = u.links[c],\n                        S = d.otherEnd(u);\n                    S === s || t.hasOwnProperty(S.id) || (m += S.x - u.x, y += S.y - u.y, v += 1);\n                  }\n\n                  if (v > 0) {\n                    var b = Math.sqrt(m * m + y * y);\n\n                    if (b > 0) {\n                      var x = 1 / (b * v);\n                      m *= x, y *= x, f = u.x - m * u.hHeight * 1.2, g = u.y - y * u.hHeight * 1.2, a = .2;\n                    } else f = u.x, g = u.y;\n                  } else i = !0, f = u.x, g = u.y;\n                } else i = !0, f = 0, g = 0;\n                s.x = f + (this.random.get() - .5) * a * (s.hHeight + 1), s.y = g + (this.random.get() - .5) * a * (s.hHeight + 1);\n              }\n            }\n\n            return {\n              newNodes: t,\n              majorChanges: i\n            };\n          }, e.prototype.doForceLayout = function (t, e) {\n            var i,\n                n = this.chart.scene,\n                r = this.chart.layer,\n                s = this.chart.settings.layout,\n                a = r.nodes(),\n                o = r.links(),\n                l = {},\n                h = !1;\n\n            if (e) {\n              this.random = new d.Random(1);\n\n              for (var u = 0; u < a.length; u++) {\n                var c = a[u];\n                l[c.id] = !0, c.x = 0, c.y = 0, c.userLock = !1;\n              }\n\n              i = !0, h = !0;\n            } else if (r.hasTopologyChanges()) {\n              i = !0, this.random = new d.Random(1);\n              var p = this.placeNewNodes();\n              l = p.newNodes, h = p.majorChanges;\n            }\n\n            var f = (n.width + 1) / (n.height + 1);\n            f > 0 || (f = null);\n            var g = n.settings.layout.aspectRatio ? f : null;\n            this.aspectRatio = g;\n\n            for (var v = !1, u = 0; u < a.length; u++) {\n              var c = a[u];\n              c.locked = c.userLock || c.locks > 0, v = v || c.locked;\n            }\n\n            if (d.Helpers.hasProperties(l)) {\n              for (var u = 0; u < a.length; u++) {\n                var c = a[u];\n                c.locked = c.locked || !d.Helpers.hasProperty(l, c.id);\n              }\n\n              this.updateGraph(a, o, i), h || n.settings.layout.globalLayoutOnChanges ? (this.aspectRatio = f, this.globalLayout(h ? s.initialLayoutMaxTime : s.incrementalLayoutMaxTime, h && !v)) : this.timedLayout(.001 * t);\n            } else this.updateGraph(a, o, i), this.timedLayout(.001 * t);\n          }, e.prototype.resetLayout = function () {\n            this.doForceLayout(1, !0), this.idleSince = 0;\n          }, e;\n        }(a);\n\n        t.TimedSpringEmbedder = y;\n\n        var S = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.twoCircles = !1, e;\n          }\n\n          return n(e, t), e.getNodeSize = function (t) {\n            return Math.max(t.hHeight, t.hWidth) * t.visibility * 2;\n          }, e.getNodesBounds = function (t) {\n            if (t.length < 1) return new d.Rect(0, 0, 0, 0);\n\n            for (var e = t[0], i = new d.Rect(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight), n = 1; n < t.length; n++) {\n              e = t[n], i.addBounds(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight);\n            }\n\n            return i;\n          }, e.prototype.onSceneChange = function (t) {\n            var e = t.changes.settingsChanges;\n            (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.updateBackgroundLinks(this.chart.getLastFocusNode(), !1);\n          }, e.prototype.doAnimations = function (t) {\n            var e = t.changes.settingsChanges,\n                i = null != e && null != e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges(),\n                n = t.changes.position || t.changes.dynamicLayout;\n            (i || n) && (this.performLayout(i), t.changes.position = !0), t.changes.position = !0;\n          }, e.prototype.resetLayout = function () {\n            for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n              t[e].userLock = !1;\n            }\n\n            this.performLayout(!0);\n          }, e.prototype.performLayout = function (t) {\n            var i = [];\n            this.visitedNodes = {}, this.subnodes = {}, this.minAngle = {}, this.radiuses = [];\n            var n = this.chart.getLastFocusNode();\n\n            if (n) {\n              i.push(this.layoutCircle(n, t));\n\n              for (var r = this.chart.layer.nodes(), s = 0; s < r.length; s++) {\n                var a = r[s];\n                d.Helpers.hasProperty(this.visitedNodes, a.id) || i.push(this.layoutCircle(a, t));\n              }\n\n              if (i.length > 1) for (var o = 2 * this.chart.settings.layout.nodeSpacing, l = e.getNodesBounds(i[0]).x1 + o, s = 1; s < i.length; s++) {\n                var h = i[s];\n\n                if (!(h.length < 1)) {\n                  var u = e.getNodesBounds(h);\n                  l -= u.x0;\n\n                  for (var c = 0; c < h.length; c++) {\n                    h[c].x += l;\n                  }\n\n                  l += u.x1 + o;\n                }\n              }\n              this.updateBackgroundLinks(n, !0) && this.chart.events.notifySceneChanges({\n                highlight: !0\n              });\n            }\n          }, e.prototype.layoutCircle = function (t, e) {\n            var i = [];\n            return this.visitedNodes[t.id] = !0, this.computeMaxRadius(t, e), this.placeNodeRec(t, 0, .5 * -Math.PI, 2 * Math.PI, i), i;\n          }, e.prototype.updateBackgroundLinks = function (t, e) {\n            if (t) {\n              if (this.visitedNodes = {}, this.updateBackgroudLinkCircle(t, e) && e) return !0;\n\n              for (var i = this.chart.layer.nodes(), n = 0; n < i.length; n++) {\n                var r = i[n];\n                if (!d.Helpers.hasProperty(this.visitedNodes, r.id) && this.updateBackgroudLinkCircle(r, e) && e) return !0;\n              }\n\n              return !1;\n            }\n          }, e.prototype.updateBackgroudLinkCircle = function (t, e) {\n            var i = [t];\n            this.visitedNodes[t.id] = !0;\n\n            for (var n = {}, r = this.chart.layer; i.length > 0;) {\n              for (var s = [], a = 0; a < i.length; a++) {\n                for (var o = i[a], l = 0; l < o.links.length; l++) {\n                  var h = o.links[l];\n\n                  if (!d.Helpers.hasProperty(n, h.id)) {\n                    n[h.id] = !0;\n                    var u = h.otherEnd(o),\n                        c = !0;\n\n                    if (d.Helpers.hasProperty(this.visitedNodes, u.id) || (this.visitedNodes[u.id] = !0, s.push(u), c = !1), h.background !== c) {\n                      if (e) return !0;\n                      h.background = c, r.touchLink(h);\n                    }\n                  }\n                }\n              }\n\n              i = s;\n            }\n\n            return !1;\n          }, e.prototype.getSubnodes = function (t) {\n            var e = t.id;\n            if (this.subnodes[e]) return this.subnodes[e];\n\n            for (var i = [], n = 0; n < t.links.length; n++) {\n              var r = t.links[n],\n                  s = r.otherEnd(t);\n              d.Helpers.hasProperty(this.visitedNodes, s.id) || (i.push(s), this.visitedNodes[s.id] = !0);\n            }\n\n            return this.subnodes[e] = i, i;\n          }, e.prototype.computeMaxRadius = function (t, i) {\n            var n = this.chart.settings.layout.nodeSpacing,\n                r = 0;\n            this.radiuses[0] = r;\n\n            for (var s = 1, a = [t]; a.length > 0;) {\n              var o = void 0;\n\n              if (1 === s && this.chart.settings.layout.twoRingRadialLayout) {\n                t = a[0];\n                var l = e.getNodeSize(t);\n                o = this.getSubnodes(t);\n\n                for (var h = Math.floor(o.length / 2), u = new Array(h), c = new Array(o.length - h), d = 0; d < o.length; d++) {\n                  (d % 2 === 0 ? c : u)[Math.floor(d / 2)] = o[d];\n                }\n\n                for (var p = 0, f = 0, d = 0; d < u.length; d++) {\n                  var g = u[d],\n                      v = e.getNodeSize(g);\n                  p = Math.max(p, v), f += n + v;\n                }\n\n                for (var m = 0, y = 0, d = 0; d < c.length; d++) {\n                  var g = c[d],\n                      v = e.getNodeSize(g);\n                  m = Math.max(m, v), y += n + v;\n                }\n\n                var S = Math.max(.5 * (Math.max(p, m) + l) + n, (f + y) / (2 * Math.PI)),\n                    b = Math.max(.5 * (p + l) + n, f / (2 * Math.PI)),\n                    x = Math.max(b + .5 * (m + p), y / (2 * Math.PI));\n                i && (this.twoCircles = x < S), this.twoCircles ? (this.radiuses[1] = b, this.radiuses[2] = x) : (this.radiuses[1] = S, this.radiuses[2] = S), r = this.radiuses[2], s = 3;\n              } else {\n                var C = 0,\n                    w = 0;\n                o = [];\n\n                for (var L = 0; L < a.length; L++) {\n                  t = a[L];\n\n                  for (var l = e.getNodeSize(t), T = 0, k = this.getSubnodes(t); T < k.length; T++) {\n                    var g = k[T],\n                        v = e.getNodeSize(g);\n                    C = Math.max(C, v + l), w += n + v, o.push(g);\n                  }\n                }\n\n                var M = r + .5 * C + n,\n                    A = w / (2 * Math.PI),\n                    I = Math.max(M, A);\n                this.radiuses[s] = I, r = I, s += 1;\n              }\n\n              a = o;\n            }\n          }, e.prototype.computeMinAngle = function (t, i) {\n            var n = t.id;\n            if (d.Helpers.hasProperty(this.minAngle, n)) return this.minAngle[n];\n\n            for (var r = this.chart.settings.layout.nodeSpacing, s = this.radiuses[i], a = e.getNodeSize(t), o = (a + r) / s, l = 0, h = this.chart.settings.layout.twoRingRadialLayout && 1 === i ? 3 : i + 1, u = 0, c = this.getSubnodes(t); u < c.length; u++) {\n              var p = c[u];\n              l += this.computeMinAngle(p, h);\n            }\n\n            return o = Math.max(o, l), this.minAngle[n] = o, o;\n          }, e.prototype.placeNodeRec = function (t, e, i, n, r) {\n            var s = i + .5 * n,\n                a = this.radiuses[e];\n            t.userLock || (t.x = a * Math.cos(s), t.y = a * Math.sin(s), r.push(t));\n            var o = this.getSubnodes(t),\n                l = e + 1,\n                h = !1;\n\n            if (this.chart.settings.layout.twoRingRadialLayout && (0 === e ? h = !0 : 1 === e && (l = 3)), o.length > 0) {\n              for (var u = 0, c = 0; c < o.length; c++) {\n                var d = o[c];\n                u += this.computeMinAngle(d, h ? c % 2 === 0 ? 2 : 1 : l);\n              }\n\n              for (var p = n / u, f = i, c = 0; c < o.length; c++) {\n                var d = o[c];\n                h && (l = c % 2 === 0 ? 2 : 1);\n                var g = this.computeMinAngle(d, l) * p;\n                this.placeNodeRec(d, l, f, g, r), f += g;\n              }\n            }\n          }, e;\n        }(a);\n\n        t.RadialLayout = S;\n\n        var b = function () {\n          function t(t, e) {\n            this.children = [], this.parent = null, this.node = t, this.level = e, this.reset();\n          }\n\n          return t.prototype.reset = function () {\n            this.hWidth = this.node.hWidth, this.origX = this.node.x, this.shift = 0;\n          }, t;\n        }(),\n            x = function (t) {\n          function r() {\n            var e = t.apply(this, arguments) || this;\n            return e.forest = null, e;\n          }\n\n          return n(r, t), r.prototype.wrapNodes = function () {\n            for (var t = d.Helpers.clone(this.chart.layer.idToNode), e = [];;) {\n              var i = null;\n\n              for (var n in t) {\n                if (d.Helpers.hasProperty(t, n)) {\n                  i = t[n], delete t[n];\n                  break;\n                }\n              }\n\n              if (null == i) return e;\n              var r = {},\n                  s = [new b(i, 0)],\n                  a = 0,\n                  o = 0;\n              r[i.id] = s[0];\n\n              for (var l = {}, h = 0; h < s.length; h++) {\n                var u = s[h],\n                    c = u.node;\n                c.hierarchyLevel != -1 ? (u.level = c.hierarchyLevel, l[c.id] = u) : 0 != c.hierarchyOffset && (u.level += c.hierarchyOffset);\n\n                for (var p = 0; p < c.links.length; p++) {\n                  var f = c.links[p];\n                  if (f.definesLayout) if (f.to === c) {\n                    var g = void 0;\n                    d.Helpers.hasProperty(r, f.from.id) ? g = r[f.from.id] : (g = new b(f.from, u.level - 1), a === u.level && a--, r[f.from.id] = g, s.push(g)), null === u.parent && u.level === g.level + 1 && (u.parent = g, g.children.push(u));\n                  } else {\n                    var g = void 0;\n                    d.Helpers.hasProperty(r, f.to.id) ? g = r[f.to.id] : (g = new b(f.to, u.level + 1), o === u.level && o++, r[f.to.id] = g, s.push(g)), null === g.parent && g.level === u.level + 1 && (u.children.push(g), g.parent = u);\n                  }\n                }\n              }\n\n              for (var v in l) {\n                var u = l[v];\n                u.level += a;\n              }\n\n              for (var m = new Array(o - a + 1), h = 0; h < m.length; h++) {\n                m[h] = [];\n              }\n\n              for (var h = 0; h < s.length; h++) {\n                var u = s[h];\n                delete t[u.node.id], u.level -= a, null === u.parent && (u.levelIndex = m[u.level].length, m[u.level].push(u));\n              }\n\n              for (var y = 0; y < m.length; y++) {\n                for (var S = m[y], x = 0; x < S.length; x++) {\n                  for (var C = S[x], w = 0; w < C.children.length; w++) {\n                    var L = y + 1,\n                        T = C.children[w];\n                    T.level = L, T.levelIndex = m[L].length, m[L].push(T);\n                  }\n                }\n              }\n\n              e.push({\n                levels: m,\n                levelStarts: new Array(m.length),\n                levelEnds: new Array(m.length)\n              });\n            }\n          }, r.prototype.layoutNodes = function (t) {\n            var n = t.levels,\n                r = this.chart.settings.layout,\n                s = r.nodeSpacing,\n                a = null === r.groupSpacing ? 2 * s : r.groupSpacing,\n                o = null === r.rowSpacing ? s : r.rowSpacing;\n            i(n[n.length - 1], null, null, s, a);\n\n            for (var l = n.length - 2; l >= 0; l--) {\n              for (var h = n[l], u = null, c = void 0, d = 0; d < h.length; d++) {\n                if (h[d].children.length > 0) {\n                  c = h[d];\n                  break;\n                }\n              }\n\n              if (c.node.x = e(c), c.levelIndex > 0) {\n                i(h, null, c, s, a);\n                var p = h[c.levelIndex - 1],\n                    f = p.node.x + p.hWidth + s + c.hWidth;\n                f > c.node.x && (c.shift = f - c.node.x, c.node.x += c.shift);\n              }\n\n              for (;;) {\n                u = c, c = null;\n\n                for (var d = u.levelIndex + 1; d < h.length; d++) {\n                  if (h[d].children.length > 0) {\n                    c = h[d];\n                    break;\n                  }\n                }\n\n                if (null === c) break;\n                c.node.x = e(c) + u.shift, c.shift = u.shift;\n\n                for (var g = 0, v = 0, d = u.levelIndex + 1; d < c.levelIndex; d++) {\n                  g += 2 * h[d].hWidth, null != h[d].parent && h[d].parent === h[d - 1].parent || v++;\n                }\n\n                null != c.parent && c.parent === h[c.levelIndex - 1].parent || v++;\n                var m = c.levelIndex - u.levelIndex,\n                    y = u.hWidth + c.hWidth + g + (m - v) * s + v * a,\n                    S = c.node.x - u.node.x;\n\n                if (y > S) {\n                  var b = y - S;\n                  c.node.x += b, c.shift += b, S = y, i(h, u, c, s, a);\n                } else if (0 === v) {\n                  var x = (S - u.hWidth - c.hWidth - g) / (c.levelIndex - u.levelIndex);\n                  i(h, u, c, x, 0);\n                } else {\n                  var C = (S - u.hWidth - c.hWidth - g - (m - v) * s) / v;\n                  i(h, u, c, s, C);\n                }\n              }\n\n              i(h, u, null, s, a);\n            }\n\n            for (var w = 0, l = 0; l < n.length; l++) {\n              for (var h = n[l], L = 0, d = 0; d < h.length; d++) {\n                L = Math.max(L, 2 * h[d].node.hHeight);\n              }\n\n              w += L / 2, t.levelStarts[l] = h[0].node.x - h[0].hWidth, t.levelEnds[l] = h[h.length - 1].node.x + h[h.length - 1].hWidth;\n\n              for (var d = 0; d < h.length; d++) {\n                var T = h[d];\n                T.node.userLock ? T.node.x = T.origX : T.node.y = w;\n\n                for (var k = 0; k < T.children.length; k++) {\n                  var M = T.children[k];\n                  M.node.x += T.shift, M.shift += T.shift;\n                }\n              }\n\n              w += L / 2 + o;\n            }\n          }, r.prototype.layoutTrees = function (t) {\n            var e = this.chart.settings.layout;\n            t.sort(function (t, e) {\n              var i = e.levels.length - t.levels.length;\n              return 0 !== i ? i : t.levels[0][0].node.id.localeCompare(e.levels[0][0].node.id);\n            });\n\n            for (var i = t[0].levelEnds.slice(), n = null == e.groupSpacing ? 4 * e.nodeSpacing : 2 * e.groupSpacing, r = 1; r < t.length; r++) {\n              for (var s = t[r], a = 0, o = 0; o < s.levels.length; o++) {\n                var l = i[o] + n,\n                    h = a + s.levelStarts[o];\n                h < l && (a += l - h);\n              }\n\n              for (var o = 0; o < s.levels.length; o++) {\n                for (var u = s.levels[o], c = 0; c < u.length; c++) {\n                  var d = u[c];\n                  d.node.userLock || (d.node.x += a);\n                }\n\n                i[o] = a + s.levelEnds[o];\n              }\n            }\n\n            var p = (e.rotation || 0) % 360;\n\n            if (0 !== p) {\n              p = p * Math.PI / 180;\n\n              for (var f = Math.sin(p), g = Math.cos(p), v = this.chart.layer.nodes(), r = 0; r < v.length; r++) {\n                var d = v[r];\n\n                if (!d.userLock) {\n                  var c = d.x,\n                      o = d.y;\n                  d.x = c * g - o * f, d.y = c * f + o * g;\n                }\n              }\n            }\n          }, r.prototype.performLayout = function (t) {\n            if (t || null == this.forest) this.forest = this.wrapNodes();else for (var e = 0; e < this.forest.length; e++) {\n              for (var i = this.forest[e], n = 0; n < i.levels.length; n++) {\n                for (var r = i.levels[n], s = 0; s < r.length; s++) {\n                  r[s].reset();\n                }\n              }\n            }\n\n            if (!(this.forest.length < 1)) {\n              for (var e = 0; e < this.forest.length; e++) {\n                this.layoutNodes(this.forest[e]);\n              }\n\n              this.layoutTrees(this.forest), this.setBackgroundFlag(!0) && this.chart.events.notifySceneChanges({\n                highlight: !0\n              });\n            }\n          }, r.prototype.setBackgroundFlag = function (t) {\n            for (var e = d.Helpers.clone(this.chart.layer.idToNode);;) {\n              var i = null;\n\n              for (var n in e) {\n                if (d.Helpers.hasProperty(e, n)) {\n                  i = e[n], delete e[n];\n                  break;\n                }\n              }\n\n              if (null == i) return !1;\n              var r = {},\n                  s = {},\n                  a = [{\n                node: i,\n                level: 0,\n                hasParent: !1\n              }],\n                  o = this.chart.layer;\n              r[i.id] = a[0];\n\n              for (var l = 0; l < a.length; l++) {\n                for (var h = a[l], u = h.node, c = 0; c < u.links.length; c++) {\n                  var p = u.links[c];\n\n                  if (p.definesLayout && !d.Helpers.hasProperty(s, p.id)) {\n                    s[p.id] = !0;\n                    var f = !0;\n\n                    if (p.to === u) {\n                      var g = void 0;\n                      d.Helpers.hasProperty(r, p.from.id) ? g = r[p.from.id] : (g = {\n                        node: p.from,\n                        level: h.level - 1,\n                        hasParent: !1\n                      }, delete e[g.node.id], r[p.from.id] = g, a.push(g)), h.hasParent || h.level !== g.level + 1 || (h.hasParent = !0, f = !1);\n                    } else {\n                      var g = void 0;\n                      d.Helpers.hasProperty(r, p.to.id) ? g = r[p.to.id] : (g = {\n                        node: p.to,\n                        level: h.level + 1,\n                        hasParent: !1\n                      }, delete e[g.node.id], r[p.to.id] = g, a.push(g)), g.hasParent || g.level !== h.level + 1 || (g.hasParent = !0, f = !1);\n                    }\n\n                    if (p.background !== f) {\n                      if (t) return !0;\n                      p.background = f, o.touchLink(p);\n                    }\n                  }\n                }\n              }\n            }\n          }, r.prototype.onSceneChange = function (t) {\n            var e = t.changes.settingsChanges;\n            (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.setBackgroundFlag(!1);\n          }, r.prototype.doAnimations = function (t) {\n            var e = t.changes.settingsChanges,\n                i = this.chart.layer.hasTopologyChanges();\n            (e && e.layout || t.changes.navigation || i || t.changes.dynamicLayout) && (this.performLayout(i), t.changes.position = !0);\n          }, r.prototype.resetLayout = function () {\n            for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n              t[e].userLock = !1;\n            }\n\n            this.performLayout(!1);\n          }, r;\n        }(a);\n\n        t.HierarchyLayout = x;\n\n        var C = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.resetLayout = function () {\n            for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {\n              var i = t[e],\n                  n = i.data;\n              d.Helpers.isNumber(n.x) && (i.x = n.x), d.Helpers.isNumber(n.y) && (i.y = n.y), i.userLock = !1;\n            }\n          }, e;\n        }(a);\n\n        t.StaticLayout = C;\n      }(r = t.Layouts || (t.Layouts = {}));\n\n      var k = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 1800, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          var e = this.chart.layer;\n          e.updateStyle(t), e.postprocessStyle(t);\n        }, e.prototype.paintScene = function (t) {\n          d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);\n          var e = this.chart.layer;\n          e.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), e.paint(t), d.Graphics.popClip(t);\n        }, e.prototype.paintLinks = function (t, e, i, n) {\n          this.chart.layer.paintLinksImpl(t, e, i, n);\n        }, e.prototype.paintNodes = function (t, e, i, n) {\n          this.chart.layer.paintNodesImpl(t, e, i, n);\n        }, e.prototype.findObjectAt = function (t, e, i) {\n          return this.chart.layer.findObjectAt(t, e, i);\n        }, e;\n      }(d.ChartElement);\n\n      t.Renderer = k;\n\n      var M = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.dataFunction = null, e.preloaded = null, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsData);\n\n      t.SettingsData = M;\n\n      var A = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e, i) || this;\n          return n.nodes = {}, n.links = {}, n.nodeToLinks = {}, n.pendingNodes = {}, n.requestedNodes = {}, n.pendingAllData = !1, n.requestedAllData = !1, n.nextLinkId = 0, n.hasAllData = !n.hasDataFunc(), n;\n        }\n\n        return n(e, t), e.otherEnd = function (t, e) {\n          return e === t.from ? t.to : e === t.to ? t.from : null;\n        }, e.multiLinkId = function (t) {\n          return t.from < t.to ? t.from + d.Helpers.SeparatorChar + t.to : t.to + d.Helpers.SeparatorChar + t.from;\n        }, e.prototype.buildRequest = function () {\n          if (this.pendingAllData) return this.requestedAllData ? null : (this.requestedAllData = !0, {\n            nodes: []\n          });\n          var t = [];\n\n          for (var e in this.pendingNodes) {\n            if (t.push(e), delete this.pendingNodes[e], this.requestedNodes[e] = !0, t.length >= this.dataSettings.requestMaxUnits) break;\n          }\n\n          return 0 === t.length ? null : {\n            nodes: t\n          };\n        }, e.prototype.dataFunc = function (t, e, i) {\n          var n = this.dataSettings;\n          if (n.dataFunction) n.dataFunction(t.nodes || null, e, i);else if (n.url) {\n            var r = [];\n\n            if (t.nodes) {\n              for (var s = \"\", a = 0; a < t.nodes.length; a++) {\n                s.length && (s += \",\"), s += encodeURIComponent(t.nodes[a]);\n              }\n\n              r.push([\"nodes\", s]);\n            }\n\n            d.Data.doRequest(n.url, n, r, e, i);\n          } else i({\n            error: \"Chart configuration does not define data retrieval function\"\n          });\n        }, e.prototype.verifyData = function (t, e) {\n          d.Helpers.hasProperty(e, \"links\") || (e.links = []), d.Helpers.hasProperty(e, \"nodes\") || (e.nodes = []);\n          var i = !0;\n\n          if (!Array.isArray(e.nodes)) {\n            var n = e.nodes;\n            e.nodes = [];\n\n            for (var r = Object.keys(n), s = 0; s < r.length; s++) {\n              var a = r[s],\n                  o = n[a];\n              o.id = a, e.nodes.push(o);\n            }\n          }\n\n          if (!Array.isArray(e.links)) {\n            var l = e.links;\n            e.links = [];\n\n            for (var r = Object.keys(l), s = 0; s < r.length; s++) {\n              var a = r[s],\n                  h = l[a];\n              h.id = a, e.links.push(h);\n            }\n          }\n\n          for (var u = {}, c = !t && !this.hasDataFunc(), s = 0; s < e.nodes.length; s++) {\n            var o = e.nodes[s];\n            null == o.id ? (o.id = d.Helpers.getIdentifierStr(), d.Helpers.warn(\"Data response: `id` property is mandatory for all nodes in the NetChart data object.\", null, !0)) : o.id = o.id.toString(), u.hasOwnProperty(o.id) && d.Helpers.warn('Data response: Multiple nodes with the same ID: \"' + o.id + '\". Data will be merged.'), u[o.id] = !0, c ? o.loaded = !0 : d.Helpers.hasProperty(o, \"loaded\") ? o.loaded = !!o.loaded : (d.Helpers.warn('Data response: Node with ID \"' + o.id + '\" does not have the \"loaded\" flag. Assuming \"false\".'), o.loaded = !1), d.Helpers.hasProperty(o, \"className\") && null != o.className && !d.Helpers.isString(o.className) && (d.Helpers.warn('Data response: Node property \"className\" must be a string. Node ID: \"' + o.id + '\".'), o.className = \"\" + o.className), d.Helpers.hasProperty(o, \"error\") && null != o.error && !d.Helpers.isString(o.error) && (d.Helpers.warn('Data response: Node property \"error\" must be a string. Node ID: \"' + o.id + '\".'), o.error = \"\" + o.error), d.Helpers.hasProperty(o, \"x\") && null != o.x && !d.Helpers.isNumber(o.x) && (d.Helpers.warn('Data response: Node property \"x\" must be a number. Node ID: \"' + o.id + '\".'), o.x = d.Helpers.tryParseFloat(o.x, null)), d.Helpers.hasProperty(o, \"y\") && null != o.y && !d.Helpers.isNumber(o.y) && (d.Helpers.warn('Data response: Node property \"y\" must be a number. Node ID: \"' + o.id + '\".'), o.y = d.Helpers.tryParseFloat(o.y, null));\n          }\n\n          for (var p = {}, s = 0; s < e.links.length; s++) {\n            var h = e.links[s];\n            null != h.from ? (h.from = h.from.toString(), null != h.to ? (h.to = h.to.toString(), null == h.id ? (h.id = d.Helpers.SeparatorChar + this.nextLinkId, this.nextLinkId += 1) : h.id = h.id.toString(), p.hasOwnProperty(h.id) && d.Helpers.warn('Data response: Multiple links with the same ID: \"' + h.id + '\". Data will be merged.'), p[h.id] = !0, d.Helpers.hasProperty(h, \"className\") && null != h.className && !d.Helpers.isString(h.className) && (d.Helpers.warn('Data response: Link property \"className\" must be a string. Link ID: \"' + h.id + '\".'), h.className = \"\" + h.className), d.Helpers.hasProperty(h, \"error\") && null != h.error && !d.Helpers.isString(h.error) && (d.Helpers.warn('Data response: Link property \"error\" must be a string. Link ID: \"' + h.id + '\".'), h.error = \"\" + h.error), d.Helpers.hasProperty(this.nodes, h.from) || d.Helpers.hasProperty(u, h.from) || e.nodes.push({\n              id: h.from,\n              loaded: c\n            }), d.Helpers.hasProperty(this.nodes, h.to) || d.Helpers.hasProperty(u, h.to) || e.nodes.push({\n              id: h.to,\n              loaded: c\n            })) : d.Helpers.warn('Data response: Link missing property \"to\" and will be ignored. Link id: \"' + h.id + '\"')) : d.Helpers.warn('Data response: Link missing property \"from\" and will be ignored. Link id: \"' + h.id + '\"');\n          }\n\n          if (t ? this.chart.log(\"Got \" + e.nodes.length + \" nodes on [\" + t.nodes.join(\", \") + \"]\") : this.chart.log(\"Got \" + e.nodes.length + \" nodes on all nodes\"), t && t.nodes.length > 0) {\n            for (var f = !1, g = !1, v = 0; v < e.nodes.length; v++) {\n              var o = e.nodes[v];\n              t.nodes.indexOf(o.id) > -1 && (f = !0, g = g || o.loaded);\n            }\n\n            f ? g || (this.chart.error(\"Data response: loaded field was not set on any of the requested nodes!\"), i = !1) : (this.chart.error(\"Data response: Results set did not contain any of requested nodes!\", t.nodes), i = !1);\n          }\n\n          return i;\n        }, e.prototype.addVerifiedData = function (t, e) {\n          for (var i = this.updateGraph(e), n = 0; n < e.nodes.length; n++) {\n            var r = e.nodes[n];\n            (r.loaded || r.error) && (delete this.requestedNodes[r.id], delete this.pendingNodes[r.id]);\n          }\n\n          if (t) if (0 === t.nodes.length) this.hasAllData = !0, this.pendingAllData = !1, this.requestedAllData = !1;else for (var n = 0; n < t.nodes.length; n++) {\n            var s = t.nodes[n];\n            this.requestedNodes[s] && (this.pendingNodes[s] = !0, delete this.requestedNodes[s]);\n          }\n          return i;\n        }, e.prototype.requestFailedPermanently = function (t) {\n          if (t.nodes) {\n            for (var e = [], i = 0; i < t.nodes.length; i++) {\n              var n = t.nodes[i];\n              e.push({\n                id: n,\n                error: \"Bad response\",\n                loaded: !0\n              });\n            }\n\n            var r = this.addVerifiedData(t, {\n              nodes: e,\n              links: []\n            });\n            r.dataArrived || (r.dataArrived = {}), r.dataArrived[this.dataSettings.id] = !0, this.chart.events.notifySceneChanges(r);\n          }\n\n          this.chart.error(\"Failed data request, giving up on nodes: \", t.nodes);\n        }, e.prototype.removeData = function (t) {\n          var e = {},\n              i = [];\n          if (t.nodes) for (var n = 0; n < t.nodes.length; n++) {\n            var r = t.nodes[n];\n            e[r.id] = !0, i = this.removeNode(r.id, i);\n          }\n          if (t.links) for (var s = 0; s < t.links.length; s++) {\n            var a = t.links[s],\n                o = this.links[a.id];\n            o && (e[o.from] = !0, e[o.to] = !0, this.removeLink(o));\n          }\n\n          for (var l = 0; l < i.length; l++) {\n            var o = i[l];\n            e[o.from] = !0, e[o.to] = !0, this.removeLink(o);\n          }\n\n          var h = this.chart.createEventArguments(null, \"api\");\n          return h.dataArrived = null, h.dataRemoved = t, this.chart.notifyDataUpdated(h), {\n            netChartDataNodes: e\n          };\n        }, e.prototype.exportData = function () {\n          var t = [],\n              e = [];\n\n          for (var i in this.nodes) {\n            var n = this.nodes[i];\n            t.push(n);\n          }\n\n          for (var i in this.links) {\n            var r = this.links[i];\n            e.push(r);\n          }\n\n          return {\n            nodes: t,\n            links: e\n          };\n        }, e.prototype.applyPreloadedData = function () {\n          this.dataSettings.randomNodes > 0 ? this.addData(this.genRandomGraph(this.dataSettings)) : t.prototype.applyPreloadedData.call(this);\n        }, e.prototype.getNode = function (t, e, i) {\n          void 0 === e && (e = !0), void 0 === i && (i = null);\n          var n = d.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;\n\n          if (i && (i.loading = !1), n) {\n            if (this.settings.legend.enabled && !this.chart.legend.isNodeVisible(n)) return null;\n            var r = this.settings.filters.nodeFilter;\n\n            if (r) {\n              var s = d.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : null;\n              if (!r(n, s)) return null;\n            }\n\n            !n.loaded && e && (i && (i.loading = !0), this.requestNodeData(t));\n          } else e ? (i && (i.loading = !0), this.requestNodeData(t)) : i && (i.loading = this.isNodeLoading(t));\n\n          return n;\n        }, e.prototype.isNodeLoading = function (t) {\n          return this.pendingAllData || this.requestedAllData || d.Helpers.hasProperty(this.pendingNodes, t) || d.Helpers.hasProperty(this.requestedNodes, t);\n        }, e.prototype.getLinks = function (t, i) {\n          void 0 === i && (i = !0);\n          var n = this.settings.legend.enabled,\n              r = d.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;\n          if (!r) return i && this.requestNodeData(t), [];\n          if (n && !this.chart.legend.isNodeVisible(r)) return [];\n          var s = d.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : [],\n              a = this.settings.filters.nodeFilter;\n          if (a && !a(r, s)) return [];\n          !r.loaded && i && this.requestNodeData(t);\n          var o = this.settings.filters.linkFilter,\n              l = this.settings.filters.nodeLinksProcessor,\n              h = this.settings.filters.multilinkProcessor,\n              u = {};\n\n          if (u[t] = !0, s.length > 0 && (a || o || n)) {\n            for (var c = new Array(s.length), p = 0, f = 0; f < s.length; f++) {\n              var g = s[f],\n                  v = e.otherEnd(g, t);\n              if (null != v) {\n                if (d.Helpers.hasProperty(this.nodes, v)) {\n                  var m = this.nodes[v];\n                  if (a || n) if (d.Helpers.hasProperty(u, v)) {\n                    if (!u[v]) continue;\n                  } else {\n                    var y = !n || this.chart.legend.isNodeVisible(m);\n                    if (y && a && (y = a(m, d.Helpers.hasProperty(this.nodeToLinks, v) ? this.nodeToLinks[v] : null)), u[v] = y, !y) continue;\n                  }\n\n                  if (o || n) {\n                    var S = void 0,\n                        b = void 0;\n                    if (g.from === t ? (S = r, b = m) : (S = m, b = r), n && !this.chart.legend.isLinkVisible(g)) continue;\n                    if (o && !o(g, S, b)) continue;\n                    g = this.applyLinkHighlight(n, g);\n                  }\n\n                  c[p++] = g;\n                } else d.Helpers.error(\"Invalid situation: link data found from '\" + t + \"' to '\" + v + \"', but no node data found for '\" + v + \"'\");\n              } else d.Helpers.error(\"Invalid situation: link data found from '\" + g.from + \"' to '\" + g.to + \"' in the collection of links for '\" + t + \"'\");\n            }\n\n            c.length = p, s = c;\n          }\n\n          if (l && (s = l(r, s)), !Array.isArray(s)) return [];\n\n          if (h) {\n            for (var x = {}, C = !1, f = 0; f < s.length; f++) {\n              var w = e.otherEnd(s[f], t);\n\n              if (w) {\n                if (d.Helpers.hasProperty(x, w)) {\n                  C = !0;\n                  break;\n                }\n\n                x[w] = !0;\n              }\n            }\n\n            if (C) {\n              for (var c = [], L = {}, T = {}, f = 0; f < s.length; f++) {\n                var k = s[f],\n                    M = e.multiLinkId(k);\n                L.hasOwnProperty(M) ? T.hasOwnProperty(M) ? T[M].push(k) : T[M] = [L[M], k] : L[M] = k;\n              }\n\n              for (var f = 0; f < s.length; f++) {\n                var k = s[f],\n                    M = e.multiLinkId(k);\n                T.hasOwnProperty(M) || c.push(k);\n              }\n\n              for (var A = Object.keys(T), f = 0; f < A.length; f++) {\n                var I = T[A[f]],\n                    k = I[0],\n                    P = h(I, this.nodes[k.from], this.nodes[k.to]);\n                Array.isArray(P) ? c = c.concat(P) : P && c.push(P);\n              }\n\n              s = c;\n            }\n          }\n\n          return s;\n        }, e.prototype.applyLinkHighlight = function (t, e) {\n          if (t && this.chart.legend.isLinkHighlighted(e)) {\n            var i = d.Helpers.realClone(e);\n            i.style || (i.style = {}), i.style.shadowBlur = 10, i.style.shadowColor = \"black\", i.style.shadowOffsetX = 0, i.style.shadowOffsetY = 0, e = i;\n          }\n\n          return e;\n        }, e.prototype.getAllNodes = function (t) {\n          void 0 === t && (t = !0);\n\n          for (var e = this.settings.filters.nodeFilter, i = Object.keys(this.nodes), n = new Array(i.length), r = 0, s = 0; s < i.length; s++) {\n            var a = i[s],\n                o = this.nodes[a];\n            this.settings.legend.enabled && !this.chart.legend.isNodeVisible(o) || e && !e(o, d.Helpers.hasProperty(this.nodeToLinks, a) ? this.nodeToLinks[a] : null) || (o = this.applyNodeHighlight(o), n[r++] = o);\n          }\n\n          return n.length = r, this.hasAllData || this.pendingAllData || !t || (this.pendingAllData = !0, this.scheduleRequests()), n;\n        }, e.prototype.applyNodeHighlight = function (t) {\n          if (this.settings.legend.enabled && this.chart.legend.isNodeHighlighted(t)) {\n            var e = d.Helpers.realClone(t);\n            e.style || (e.style = {}), e.style.shadowBlur = 10, e.style.shadowColor = \"black\", e.style.shadowOffsetX = 0, e.style.shadowOffsetY = 0, t = e;\n          }\n\n          return t;\n        }, e.prototype.requestNodeData = function (t) {\n          return this.hasDataFunc() ? void (this.pendingNodes.hasOwnProperty(t) || this.requestedNodes.hasOwnProperty(t) || (this.pendingNodes[t] = !0, this.scheduleRequests())) : void this.chart.error(\"Cannot request node data! Please specify either data function or data URL in the settings!\");\n        }, e.prototype.hasDataFunc = function () {\n          return null != this.dataSettings.dataFunction || null != this.dataSettings.url;\n        }, e.prototype.updateGraph = function (t) {\n          for (var e = {}, i = 0; i < t.nodes.length; i++) {\n            var n = t.nodes[i];\n\n            if (d.Helpers.hasProperty(this.nodes, n.id)) {\n              var r = this.nodes[n.id];\n              n.error || r.loaded && !n.loaded || (d.Helpers.extendDataItem(r, n), r.resetCoordinates = (null != n.x || null != n.y) && null != r.x && null != r.y, r.resetLocked = null != n.locked, e[n.id] = !0);\n            } else {\n              var s = d.Helpers.extendDataItem({}, n);\n              s.resetCoordinates = null != s.x && null != s.y, s.resetLocked = null != s.locked, this.nodes[n.id] = s, this.nodeToLinks[n.id] = [], e[n.id] = !0;\n            }\n          }\n\n          for (var a = 0; a < t.links.length; a++) {\n            var o = t.links[a];\n\n            if (d.Helpers.hasProperty(this.links, o.id)) {\n              var r = this.links[o.id];\n\n              if (o.from && r.from !== o.from || o.to && r.to !== o.to) {\n                this.chart.error('Changing link from/to not supported. Link ignored. Link ID: \"' + o.id + '\"');\n                continue;\n              }\n\n              d.Helpers.extendDataItem(r, o);\n            } else {\n              if (!o.from || !o.to) continue;\n              this.links[o.id] = o, this.nodeToLinks[o.from].push(o), o.from !== o.to && this.nodeToLinks[o.to].push(o);\n            }\n\n            e[o.from] = !0, e[o.to] = !0;\n          }\n\n          return {\n            netChartDataNodes: e\n          };\n        }, e.prototype.removeNode = function (t, e) {\n          return delete this.pendingNodes[t], delete this.requestedNodes[t], d.Helpers.hasProperty(this.nodes, t) && delete this.nodes[t], d.Helpers.hasProperty(this.nodeToLinks, t) && (e = e.concat(this.nodeToLinks[t]), delete this.nodeToLinks[t]), e;\n        }, e.prototype.removeLink = function (t) {\n          delete this.links[t.id], d.Helpers.hasProperty(this.nodeToLinks, t.from) && d.Helpers.removeFromArrayHasty(this.nodeToLinks[t.from], t), d.Helpers.hasProperty(this.nodeToLinks, t.to) && d.Helpers.removeFromArrayHasty(this.nodeToLinks[t.to], t);\n        }, e.prototype.genRandomGraph = function (t) {\n          var e,\n              i = t.randomNodes,\n              n = t.randomLinks;\n          e = \"grid\" === t.random ? this.genRandomGrid(i, t.randomGridLinkProbability) : \"tree\" === t.random ? this.genRandomTree(i, t.randomTreeDensity) : this.genRandomUniform(i, n);\n\n          for (var r = 0; r < e.nodes.length; r++) {\n            var s = e.nodes[r];\n            s.style = {\n              label: \"Node \" + s.id\n            };\n          }\n\n          for (var a = 0; a < e.links.length; a++) {\n            var o = e.links[a];\n            o.style = {\n              label: \"Link \" + o.id\n            };\n          }\n\n          return e;\n        }, e.prototype.genRandomGrid = function (t, e) {\n          for (var i = [], n = [], r = 0; r <= t - 1; r++) {\n            var s = {\n              id: \"n\" + r,\n              loaded: !0\n            };\n            i.push(s);\n          }\n\n          for (var a = Math.ceil(Math.sqrt(t)), o = new d.Random(32131), l = 0; l <= a - 1; l++) {\n            for (var h = 0; h <= a - 1; h++) {\n              var u = h + l * a;\n              u >= t || (h > 0 && o.get() <= e && n.push({\n                from: \"n\" + u,\n                to: \"n\" + (u - 1)\n              }), l > 0 && o.get() <= e && n.push({\n                from: \"n\" + u,\n                to: \"n\" + (u - a)\n              }));\n            }\n          }\n\n          for (var c = 0; c < n.length; c++) {\n            var p = n[c];\n            p.id = \"\" + c;\n          }\n\n          return {\n            nodes: i,\n            links: n\n          };\n        }, e.prototype.genRandomUniform = function (t, e) {\n          for (var i = new d.Random(32131), n = [], r = [], s = 0; s < t; s++) {\n            var a = {\n              id: \"n\" + s,\n              loaded: !0\n            };\n\n            if (n.length > 0) {\n              var o = {\n                id: \"l\" + s,\n                from: a.id,\n                to: n[Math.floor(i.get() * n.length)].id\n              };\n              r.push(o);\n            }\n\n            n.push(a);\n          }\n\n          for (var s = r.length; s <= e - 1; s++) {\n            var o = {\n              id: \"l\" + (s + 1),\n              from: n[Math.floor(i.get() * n.length)].id,\n              to: n[Math.floor(i.get() * n.length)].id\n            };\n            r.push(o);\n          }\n\n          return {\n            nodes: n,\n            links: r\n          };\n        }, e.prototype.genRandomTree = function (t, e) {\n          for (var i = new d.Random(31927832), n = {\n            id: \"n0\",\n            loaded: !0\n          }, r = [n], s = [n], a = []; s.length < t;) {\n            var o = i.getArrayElement(r);\n            d.Helpers.removeFromArrayHasty(r, o);\n\n            for (var l = Math.max(1, Math.ceil(i.get() * e)), h = 0; h < l; h++) {\n              var u = {\n                id: \"n\" + s.length,\n                loaded: !0\n              },\n                  c = {\n                id: \"l\" + s.length,\n                from: o.id,\n                to: u.id\n              };\n              a.push(c), s.push(u), r.push(u);\n            }\n          }\n\n          return {\n            nodes: s,\n            links: a\n          };\n        }, e;\n      }(d.Data);\n\n      t.Data = A;\n\n      var I = function () {\n        function t(t) {\n          this.restoredState = {}, this.chart = t;\n        }\n\n        return t.prototype.exportCoordinates = function (t) {\n          for (var e = this.chart.layer.idToNode, i = 0; i < t.length; i++) {\n            var n = t[i],\n                r = n.id;\n\n            if (d.Helpers.hasProperty(e, r)) {\n              var s = e[r];\n              s.removed || (n.x = s.x, n.y = s.y);\n            }\n          }\n        }, t.prototype.save = function () {\n          for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n            var r = e[i[n]];\n            r.removed || (t[r.id] = {\n              x: r.x,\n              y: r.y,\n              r: r.hHeight,\n              w: r.hWidth\n            });\n          }\n\n          return t;\n        }, t.prototype.restore = function (t) {\n          this.restoredState = {};\n\n          for (var e = this.chart.layer.idToNode, i = Object.keys(t), n = 0; n < i.length; n++) {\n            var r = i[n],\n                s = t[r];\n\n            if (d.Helpers.hasProperty(e, r)) {\n              var a = e[r];\n              a.x = s.x, a.y = s.y, a.hHeight = s.r, a.hWidth = s.w ? s.w : s.r;\n            } else this.restoredState[r] = s;\n          }\n        }, t.prototype.applyRestoredCoordinates = function (t) {\n          if (d.Helpers.hasProperty(this.restoredState, t.id)) {\n            var e = this.restoredState[t.id];\n            delete this.restoredState[t.id], t.x = e.x, t.y = e.y, t.hHeight = e.r, t.hWidth = e.w ? e.w : e.r;\n          }\n        }, t.prototype.lockNode = function (t, e, i) {\n          void 0 === e && (e = null), void 0 === i && (i = null);\n          var n = this.chart.layer.idToNode;\n\n          if (d.Helpers.hasProperty(n, t)) {\n            var r = n[t];\n            r.userLock = !0, null !== e && null !== i && (r.x = e, r.y = i), this.chart.layer.touchNode(r);\n          } else this.chart.error(\"Locking nonexistant node: \" + t);\n        }, t.prototype.unlockNode = function (t) {\n          var e = this.chart.layer.idToNode;\n\n          if (d.Helpers.hasProperty(e, t)) {\n            var i = e[t];\n            i.userLock && (i.userLock = !1, this.chart.layer.touchNode(i), this.chart.events.notifySceneChanges({\n              dynamicLayout: !0\n            }));\n          } else this.chart.error(\"Unlocking nonexistant node: \" + t);\n        }, t.prototype.exportData = function () {\n          for (var t = this.chart.layer.idToNode, e = Object.keys(t), i = new Array(e.length), n = 0, r = 0; r < e.length; r++) {\n            var s = t[e[r]];\n            s.removed || (i[n++] = s.data);\n          }\n\n          i.length = n;\n          var a = this.chart.layer.idToLink;\n          e = Object.keys(a);\n          var o = new Array(e.length);\n          n = 0;\n\n          for (var r = 0; r < e.length; r++) {\n            var l = a[e[r]];\n            l.removed || (o[n++] = l.data);\n          }\n\n          return o.length = n, {\n            nodes: i,\n            links: o\n          };\n        }, t;\n      }();\n\n      t.Graph = I;\n\n      var P = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          i.numPointers = 0, i.resetZoom = !1, i.minimumAutoZoom = 1 / 0, i.animationOrder = 700, i.paintOrder = 20, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.layer = e.layer, i.events = e.events, i.settings = i.scene.settings;\n\n          var n = i._getInertiaAccelerations();\n\n          return i.inertiaX = new d.Inertia(n.x, 0), i.inertiaY = new d.Inertia(n.y, 0), i.inertiaZ = new d.Inertia(n.z, 1), i;\n        }\n\n        return n(e, t), e.prototype.setZoom = function (t, e) {\n          void 0 === e && (e = !0);\n          var i = 1 + this.scene.settings.interaction.zooming.sensitivity;\n          if (\"auto\" === t) this.scene.autoZoomMode = !0, this.autoZoom(e);else if (\"overview\" === t) this.scene.autoZoomMode = \"overview\", this.autoZoom(e);else {\n            var n = void 0;\n            \"in\" === t ? n = 1 / this.inertiaZ.getTargetValue() * i : \"out\" === t ? n = 1 / this.inertiaZ.getTargetValue() / i : null === (n = d.Helpers.tryParseFloat(t, null)) && (this.chart.error(\"Invalid zoom value: \" + t), n = 1 / this.inertiaZ.getTargetValue()), this.manualZoom(n / this.scene.zoom, void 0, void 0, e);\n          }\n          this.chart.events.notifySceneChanges({\n            position: !0\n          });\n        }, e.prototype.previewPointerDown = function () {\n          this.numPointers += 1;\n        }, e.prototype.previewPointerUp = function () {\n          this.numPointers -= 1;\n        }, e.prototype.previewPointerCancel = function () {\n          this.numPointers -= 1;\n        }, e.prototype.doAnimations = function (t) {\n          var e = t.changes.settingsChanges;\n\n          if (e && e.interaction && e.interaction.zooming) {\n            this.minimumAutoZoom = 1 / 0;\n            var i = e.interaction.zooming.initialAutoZoom;\n            \"true\" === i ? i = !0 : \"false\" === i && (i = !1), this.scene.autoZoomMode = i, i && this.autoZoom(!0);\n          }\n\n          if (this.resetZoom || t.changes.newGraph) this.resetZoom = !1, this.setZoom(\"overview\", !1);else if (0 === this.numPointers && this.layer.nodes().length > 0) {\n            this.scene.autoZoomMode && this.autoZoom(!0) && (t.changes.position = !0);\n            var n = t.timeStamp,\n                r = this.inertiaX.getValue(n),\n                s = this.inertiaY.getValue(n),\n                a = 1 / this.inertiaZ.getValue(n);\n            r === this.scene.centerX && s === this.scene.centerY && a === this.scene.zoom || (this.scene.centerX = r, this.scene.centerY = s, this.scene.zoom = a, t.changes.position = !0), this.inertiaX.finished(n) && this.inertiaY.finished(n) && this.inertiaZ.finished(n) || (t.animating = !0);\n          } else this.inertiaX.jump(this.scene.centerX), this.inertiaY.jump(this.scene.centerY), this.inertiaZ.jump(1 / this.scene.zoom);\n        }, e.prototype._getInertiaAccelerations = function () {\n          var t = this.scene.settings.interaction.zooming.autoZoomPositionElasticity,\n              e = .5 * (this.scene.width + this.scene.height) * t;\n          return {\n            x: e,\n            y: e,\n            z: 2 * t\n          };\n        }, e.prototype.autoZoom = function (t, e) {\n          var i = !1,\n              n = this.computeAutoZoom(\"overview\" === this.scene.autoZoomMode);\n          if (null == n) return !1;\n\n          var r = n.centerX,\n              s = n.centerY,\n              a = n.zoom,\n              o = .01,\n              l = 1 + o,\n              h = 1 - o,\n              u = 1 / this.inertiaZ.getTargetValue() / a,\n              c = this._getInertiaAccelerations();\n\n          (u > l || u < h) && (t ? this.inertiaZ.setTarget(1 / a, e, c.z) : (this.inertiaZ.jump(1 / a), this.scene.zoom = a), i = !0);\n          var d = this.scene.width,\n              p = (this.inertiaX.getTargetValue() - r) * a / d;\n          (p > o || p < -o) && (t ? this.inertiaX.setTarget(r, e, c.x) : (this.inertiaX.jump(r), this.scene.centerX = r), i = !0);\n          var f = this.scene.height,\n              g = (this.inertiaY.getTargetValue() - s) * a / f;\n          return (g > o || g < -o) && (t ? this.inertiaY.setTarget(s, e, c.y) : (this.inertiaY.jump(s), this.scene.centerY = s), i = !0), i;\n        }, e.prototype.computeAutoZoom = function (t, e, i) {\n          var n,\n              r = this.scene;\n          n = t ? this.layer.getGraphBounds(e) : this.layer.getNodeNeighborsBounds(r.lastClickedNode);\n          var s = n.x0,\n              a = n.y0,\n              o = n.x1,\n              l = n.y1;\n          if (0 === s && 0 === o && 0 === a && 0 === l) return null;\n          i && (n.y0 -= i[0], n.x1 += i[1], n.y1 += i[2], n.x0 -= i[3]);\n          var h = r.getVisibleBounds(),\n              u = r.settings.interaction.zooming,\n              c = (1 - u.autoZoomSize) / 2,\n              d = c * n.w(),\n              p = c * n.h(),\n              f = n.clone();\n          if (f.x0 -= d, f.x1 += d, f.y0 -= p, f.y1 += p, n.isInside(h) && !f.isInside(h)) return null;\n          var g = Math.min(r.width / f.w(), r.height / f.h()),\n              v = u.autoZoomExtent;\n          v && (g = Math.min(v[1], g), null === v[0] ? this.minimumAutoZoom = Math.min(g, this.minimumAutoZoom) : g = Math.max(v[0], g));\n          var m = (f.x0 + f.x1) / 2,\n              y = (f.y0 + f.y1) / 2,\n              S = (h.x0 + h.x1) / 2,\n              b = (h.y0 + h.y1) / 2;\n          return this.scene.zoom === g && Math.abs(m - S) <= d && Math.abs(y - b) <= p ? null : {\n            centerX: m,\n            centerY: y,\n            zoom: g\n          };\n        }, e.prototype.manualZoom = function (t, e, i, n) {\n          void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !1);\n          var r = this.scene,\n              s = this.settings.interaction.zooming.zoomExtent,\n              a = this.layer.getGraphBounds(),\n              o = a.x0,\n              l = a.y0,\n              h = a.x1,\n              c = a.y1,\n              d = r.zoom * t;\n          d = Math.min(d, Math.max(r.zoom, s[1])), d = Math.max(d, Math.min(r.zoom, Math.min(this.minimumAutoZoom, s[0]))), t = d / r.zoom;\n          var p, f;\n\n          if (null !== e && null !== i) {\n            var g = r.fromDisplay(e, i);\n            p = g.x, f = g.y;\n          } else if (r.selection.length > 0) {\n            for (var v = 0, m = 0, y = 0, S = 0; S < r.selection.length; S++) {\n              var b = r.selection[S];\n              b instanceof u.Node && (v += b.x, m += b.y, y += 1);\n            }\n\n            y > 0 && (p = v / y, f = m / y);\n          }\n\n          var x, C;\n          p && f ? (x = (r.centerX - p) / t + p, C = (r.centerY - f) / t + f) : (x = p = r.centerX, C = f = r.centerY);\n          var w = r.zoom * t,\n              L = r.getVisibleBounds();\n\n          if (p < o || p > h) {\n            var T = void 0;\n            T = L.x0 > o && L.x1 > h ? Math.max(h - L.x1, o - L.x0) : L.x1 < h && L.x0 < o ? Math.min(h - L.x1, o - L.x0) : 0, x += T;\n          }\n\n          if (f < l || f > c) {\n            var k = void 0;\n            k = L.y0 > l && L.y1 > c ? Math.max(c - L.y1, l - L.y0) : L.y1 < c && L.y0 < o ? Math.min(c - L.y1, l - L.y0) : 0, C += k;\n          }\n\n          if (n && w !== r.zoom ? this.inertiaZ.setTarget(1 / w) : (this.inertiaZ.jump(1 / w), r.zoom = w), !n || x === r.centerX && C === r.centerY) r.centerX = x, r.centerY = C, this.inertiaX.jump(x), this.inertiaY.jump(C);else {\n            var M = this._getInertiaAccelerations();\n\n            this.inertiaX.setTarget(x, null, M.x), this.inertiaY.setTarget(C, null, M.y);\n          }\n          r.autoZoomMode = !1;\n        }, e.prototype.scrollIntoView = function (t, e) {\n          if (t && t.length) {\n            var i = d.Helpers.performanceNow();\n            this.scene.autoZoomMode = !1;\n\n            var n = this._getInertiaAccelerations(),\n                r = this.computeAutoZoom(!0, t, e);\n\n            r && (this.inertiaX.setTarget(r.centerX, i, n.x), this.inertiaY.setTarget(r.centerY, i, n.y), this.inertiaZ.setTarget(1 / r.zoom, i, n.z), this.chart.events.notifySceneChanges({\n              position: !0\n            }));\n          }\n        }, e;\n      }(d.ChartElement);\n\n      t.AutoZoom = P;\n\n      var D = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.updateOrder = 150, i.chart = e, i;\n        }\n\n        return n(e, t), e.CreateNavigator = function (t) {\n          switch (t.settings.navigation.mode) {\n            case \"manual\":\n              return new N(t);\n\n            case \"showall\":\n              return new F(t);\n\n            case \"focusnodes\":\n              return new E(t);\n\n            default:\n              return t.error(\"Unknown navigation mode: '\" + t.settings.navigation.mode + \"'\"), new F(t);\n          }\n        }, e.prototype.updateGraphWithNewData = function (t, e) {\n          for (var i = this.chart.layer, n = this.chart.scene.mainData, r = i.idToNode, s = Object.keys(t ? t : r), a = {\n            loading: !1\n          }, o = 0; o < s.length; o++) {\n            var l = s[o];\n\n            if (d.Helpers.hasProperty(r, l)) {\n              var h = r[l];\n\n              if (!h.removed) {\n                var u = n.getNode(l, !1, a);\n                u ? (this.updateNodeWithNewData(h, u, n.getLinks(l, !1)), i.touchNode(h)) : a.loading ? h.loading || (h.loading = !0, i.touchNode(h)) : this.ensureNodeRemoved(h);\n              }\n            }\n          }\n        }, e.prototype.calcExpanded = function (t) {\n          var e = t.expanded;\n          if (t.links.length < t.dataLinks.length) return t.expanded = !1, e;\n\n          for (var i = 0; i < t.links.length; i++) {\n            if (t.links[i].removed) return t.expanded = !1, e;\n          }\n\n          return t.expanded = !0, !e;\n        }, e.prototype.syncNodeLinks = function (t) {\n          for (var e = this.chart.layer, i = t.links, n = t.dataLinks, r = {}, s = 0; s < n.length; s++) {\n            r[n[s].id] = n[s];\n          }\n\n          for (var a = 0; a < i.length; a++) {\n            var o = i[a];\n            o.removed || (d.Helpers.hasProperty(r, o.id) ? (o.data = r[o.id], e.touchLink(o), delete r[o.id]) : this.ensureLinkRemoved(o));\n          }\n\n          for (var l = Object.keys(r), h = t.id, s = 0; s < l.length; s++) {\n            var o = r[l[s]],\n                u = A.otherEnd(o, h);\n            d.Helpers.hasProperty(e.idToNode, u) && !e.idToNode[u].removed && this.ensureLink(o);\n          }\n\n          this.calcExpanded(t);\n        }, e.prototype.updateNodeWithNewData = function (t, e, i) {\n          t.data = e, e.resetCoordinates && (t.x = e.x, t.y = e.y, e.resetCoordinates = !1), e.resetLocked && (t.userLock = e.locked, e.resetLocked = !1), e.loaded && (t.loading = !1), t.dataLinks = i, this.syncNodeLinks(t);\n        }, e.prototype.ensureNode = function (t, e) {\n          var i = this.chart.layer,\n              n = d.Helpers.hasProperty(i.idToNode, t.id) ? i.idToNode[t.id] : null;\n          return !(n && !n.removed) && (n = i.addNode(t.id), null != t.x && (n.x = t.x), null != t.y && (n.y = t.y), null != t.locked && (n.userLock = t.locked), t.resetCoordinates = !1, n.loading = !t.loaded, n.data = t, n.dataLinks = e, this.chart.graph.applyRestoredCoordinates(n), this.syncNodeLinks(n), !0);\n        }, e.prototype.ensureLink = function (t) {\n          var e = this.chart.layer,\n              i = d.Helpers.hasProperty(e.idToLink, t.id) ? e.idToLink[t.id] : null;\n          if (i && !i.removed) return !1;\n          var n = d.Helpers.hasProperty(e.idToNode, t.from) ? e.idToNode[t.from] : null,\n              r = d.Helpers.hasProperty(e.idToNode, t.to) ? e.idToNode[t.to] : null;\n          return !(!n || n.removed || !r || r.removed) && (i = e.addLink(t.id, t.from, t.to), i.data = t, this.calcExpanded(n), this.calcExpanded(r), !0);\n        }, e.prototype.ensureNodeRemoved = function (t) {\n          if (!t || t.removed) return !1;\n\n          for (var e = this.chart.layer, i = t.links, n = i.length - 1; n >= 0; n--) {\n            var r = i[n];\n\n            if (!r.removed) {\n              var s = r.otherEnd(t);\n              s !== t && !s.removed && s.expanded && (s.expanded = !1, e.touchNode(s)), e.removeLink(r);\n            }\n          }\n\n          return e.removeNode(t), !0;\n        }, e.prototype.ensureLinkRemoved = function (t) {\n          if (!t || t.removed) return !1;\n          var e = this.chart.layer;\n          return !t.from.removed && t.from.expanded && (t.from.expanded = !1, e.touchNode(t.from)), !t.to.removed && t.to.expanded && (t.to.expanded = !1, e.touchNode(t.to)), e.removeLink(t), !0;\n        }, e;\n      }(d.Navigator);\n\n      t.Navigator = D;\n\n      var N = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.saveHack = null, e.retryList = [], e;\n        }\n\n        return n(e, t), e.prototype.executeAllSceneChanges = function (t) {\n          var e = this.retryList;\n          this.retryList = [];\n\n          for (var i = 0; i < e.length; i++) {\n            var n = e[i].fun(t);\n            null === n ? this.retryList.push(e[i]) : n && e[i].origin && this.chart.notifyChartUpdate(e[i].origin);\n          }\n        }, e.prototype.notifyNavigation = function (t, e) {\n          this.chart.events.notifySceneChanges({\n            navigation: !0\n          }), this.retryList.push({\n            fun: e,\n            origin: t\n          });\n        }, e.prototype.clearFocusNodes = function (t) {\n          var e = this;\n          this.notifyNavigation(t, function () {\n            for (var t = !1, i = e.chart.layer, n = i.idToNode, r = Object.keys(n), s = 0; s < r.length; s++) {\n              var a = n[r[s]];\n              a.focused && !a.removed && (t = !0, a.focused = !1, i.touchNode(a));\n            }\n\n            return t;\n          });\n        }, e.prototype.hideNode = function (t, e) {\n          var i = this;\n          this.notifyNavigation(e, function () {\n            return i.ensureNodeRemoved(d.Helpers.hasProperty(i.chart.layer.idToNode, t) ? i.chart.layer.idToNode[t] : null);\n          });\n        }, e.prototype.showNode = function (t, e) {\n          var i = this;\n          this.notifyNavigation(e, function () {\n            var e = {\n              loading: !1\n            },\n                n = i.chart.scene.mainData,\n                r = n.getNode(t, !0, e);\n            return r ? (i.ensureNode(r, n.getLinks(t)), !0) : !!e.loading && null;\n          });\n        }, e.prototype.collapseNode = function (t, e) {\n          var i = this;\n          this.notifyNavigation(e, function () {\n            var e = i.chart.layer,\n                n = d.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;\n            if (!n || n.removed) return !1;\n\n            for (var r = !1, s = 0; s < n.links.length; s++) {\n              var a = n.links[s];\n\n              if (!a.removed) {\n                var o = a.otherEnd(n);\n                o !== n && (r = i.ensureNodeRemoved(o) || r);\n              }\n            }\n\n            return i.canHideNode(n) && (r = i.ensureNodeRemoved(n) || r), r;\n          });\n        }, e.prototype.calculateCloseNodes = function (t) {\n          for (var e = {}, i = [], n = 0; n < t.links.length; n++) {\n            var r = t.links[n];\n\n            if (!r.removed) {\n              var s = r.otherEnd(t);\n              s === t || s.removed || (i.push(s), e[s.id] = !0);\n            }\n          }\n\n          e[t.id] = !0;\n\n          for (var a = [], n = 0; n < i.length; n++) {\n            for (var o = i[n], l = !0, h = 0; h < o.links.length; h++) {\n              var s = o.links[h].otherEnd(o);\n\n              if (!d.Helpers.hasProperty(e, s.id)) {\n                l = !1;\n                break;\n              }\n            }\n\n            l && a.push(o);\n          }\n\n          return a;\n        }, e.prototype.closeNode = function (t, e) {\n          var i = this;\n          this.notifyNavigation(e, function () {\n            var e = i.chart.layer,\n                n = d.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;\n            if (!n || n.removed) return !1;\n\n            for (var r = !1, s = i.calculateCloseNodes(n), a = 0; a < s.length; a++) {\n              r = i.ensureNodeRemoved(s[a]) || r;\n            }\n\n            return r;\n          });\n        }, e.prototype.focusNode = function (t, e, i) {\n          var n = this;\n          this.chart.settings.navigation.autoUnfocus && this.clearFocusNodes(\"single\"), this.notifyNavigation(i, function () {\n            var e = n.chart.layer.idToNode[t];\n            return e instanceof u.Node && !e.removed && !e.focused && (e.focused = !0, n.chart.layer.touchNode(e), !0);\n          });\n        }, e.prototype.expandNode = function (t, e) {\n          var i = this,\n              n = {},\n              r = !1;\n          this.notifyNavigation(e, function () {\n            var e = i.chart.layer,\n                s = e.idToNode[t];\n            if (!(s instanceof u.Node) || s.removed) return !1;\n            var a = i.chart.scene.mainData,\n                o = s.dataLinks;\n            if (null != o) for (var l = 0; l < o.length; l++) {\n              var h = o[l];\n\n              if (!d.Helpers.hasProperty(n, h.id)) {\n                n[h.id] = !0;\n                var c = d.Helpers.hasProperty(e.idToLink, h.id) ? e.idToLink[h.id] : null;\n\n                if (!c || c.removed) {\n                  var p = A.otherEnd(h, t);\n\n                  if (p !== t) {\n                    var f = d.Helpers.hasProperty(e.idToNode, p) ? e.idToNode[p] : null;\n\n                    if (!f || f.removed) {\n                      var g = a.getNode(p);\n                      if (!g) continue;\n                      i.ensureNode(g, a.getLinks(p));\n                    }\n                  }\n\n                  r = !0;\n                }\n              }\n            }\n            return s.data.loaded ? r : null;\n          });\n        }, e.prototype.unfocusNode = function (t, e) {\n          var i = this;\n          this.notifyNavigation(e, function () {\n            var e = i.chart.layer.idToNode[t];\n            return e instanceof u.Node && !e.removed && !!e.focused && (e.focused = !1, i.chart.layer.touchNode(e), !0);\n          });\n        }, e.prototype.save = function () {\n          if (this.saveHack) return this.saveHack;\n\n          for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n            var r = e[i[n]];\n            r.removed || (t[r.id] = r.focused);\n          }\n\n          return t;\n        }, e.prototype.restore = function (t) {\n          var e = this,\n              i = t;\n\n          if (i) {\n            this.saveHack = i, this.chart.notifyChartUpdate(\"restore\"), this.saveHack = null;\n            var n = {},\n                r = !1,\n                s = !1;\n            this.notifyNavigation(null, function () {\n              var t,\n                  a = e.chart.layer,\n                  o = e.chart.scene.mainData,\n                  l = !1,\n                  h = {\n                loading: !1\n              },\n                  u = a.idToNode;\n\n              if (!s) {\n                t = Object.keys(u);\n\n                for (var c = 0; c < t.length; c++) {\n                  var p = t[c];\n                  d.Helpers.hasProperty(i, p) || u[p].removed || (r = e.ensureNodeRemoved(u[p]) || r);\n                }\n\n                s = !0;\n              }\n\n              t = Object.keys(i);\n\n              for (var c = 0; c < t.length; c++) {\n                var p = t[c];\n\n                if (!d.Helpers.hasProperty(n, p)) {\n                  var f = d.Helpers.hasProperty(a.idToNode, p) ? a.idToNode[p] : null;\n\n                  if (!f || f.removed) {\n                    var g = o.getNode(p, !0, h);\n\n                    if (!g) {\n                      h.loading ? l = !0 : n[p] = !0;\n                      continue;\n                    }\n\n                    e.ensureNode(g, o.getLinks(p)), a.idToNode[p].focused = i[p], r = !0;\n                  } else f && f.focused !== i[p] && (f.focused = i[p], a.touchNode(f), r = !0);\n\n                  n[p] = !0;\n                }\n              }\n\n              return l ? null : r;\n            });\n          }\n        }, e.prototype.onNewDataObject = function () {\n          for (var t = this, e = this.save(), i = this.chart.scene.mainData, n = Object.keys(e), r = 0; r < n.length; r++) {\n            i.getNode(n[r]);\n          }\n\n          this.notifyNavigation(null, function () {\n            var n,\n                r = t.chart.layer,\n                s = r.idToNode,\n                a = {\n              loading: !1\n            };\n            n = Object.keys(e);\n\n            for (var o = 0; o < n.length; o++) {\n              var l = n[o];\n\n              if (d.Helpers.hasProperty(s, l) && !s[l].removed) {\n                var h = i.getNode(l, !0, a);\n                if (h) delete e[l];else if (a.loading) return null;\n              } else delete e[l];\n            }\n\n            return !0;\n          });\n        }, e.prototype.showInitialNodes = function () {\n          var t = this,\n              e = !1,\n              i = this.chart.settings.navigation.initialNodes,\n              n = !1,\n              r = !1;\n          this.retryList = [], this.notifyNavigation(\"init\", function (s) {\n            var a = t.chart.layer;\n            if (e || (d.Helpers.hasProperties(a.nodes) && (a.clearObjects(), n = !0), e = !0), null == i || i.length < 1) return n;\n            var o = {\n              loading: !1\n            },\n                l = t.chart.scene.mainData,\n                h = !1,\n                u = i;\n            i = [];\n\n            for (var c = 0; c < u.length; c++) {\n              var p = u[c],\n                  f = l.getNode(p, !0, o);\n              f ? (n = t.ensureNode(f, l.getLinks(p)) || n, r || (r = !0, s.changes.newGraph = !0)) : o.loading && (i.push(p), h = !0);\n            }\n\n            return h ? null : n;\n          });\n        }, e.prototype.onSceneChange = function (t) {\n          t.changes.filters ? this.updateGraphWithNewData(null, t) : (t.changes.dataArrived || t.changes.data) && this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.retryList.length > 0 && (t.changes.navigation || t.changes.dataArrived) && this.executeAllSceneChanges(t);\n        }, e.prototype.canFocusNode = function (t) {\n          return !t.focused;\n        }, e.prototype.canUnfocusNode = function (t) {\n          return t.focused;\n        }, e.prototype.canExpandNode = function (t) {\n          return !t.expanded;\n        }, e.prototype.canCollapseNode = function (t) {\n          return this.canHideNode(t);\n        }, e.prototype.canHideNode = function (t) {\n          for (var e = this.chart.layer, i = Object.keys(e.idToNode), n = 0; n < i.length; n++) {\n            var r = e.idToNode[i[n]];\n            if (r !== t && !r.removed) return !0;\n          }\n\n          return !1;\n        }, e.prototype.canCloseNode = function (t) {\n          return this.calculateCloseNodes(t).length > 0;\n        }, e;\n      }(D);\n\n      t.ManualNavigator = N;\n\n      var F = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.hiddenNodes = {}, e.isInitialized = !1, e;\n        }\n\n        return n(e, t), e.prototype.showNode = function (e, i) {\n          delete this.hiddenNodes[e], t.prototype.showNode.call(this, e, i);\n        }, e.prototype.hideNode = function (e, i) {\n          var n = this.chart.layer.idToNode;\n          d.Helpers.hasProperty(n, e) && (this.hiddenNodes[e] = !0, t.prototype.hideNode.call(this, e, i));\n        }, e.prototype.collapseNode = function (e, i) {\n          var n = this.chart.layer.idToNode;\n\n          if (d.Helpers.hasProperty(n, e)) {\n            this.hiddenNodes[e] = !0;\n\n            for (var r = n[e], s = 0; s < r.links.length; s++) {\n              var a = r.links[s];\n\n              if (!a.removed) {\n                var o = a.otherEnd(r);\n                o !== r && (this.hiddenNodes[o.id] = !0);\n              }\n            }\n\n            t.prototype.collapseNode.call(this, e, i);\n          }\n        }, e.prototype.closeNode = function (e, i) {\n          var n = this.chart.layer.idToNode;\n\n          if (d.Helpers.hasProperty(n, e)) {\n            for (var r = this.calculateCloseNodes(n[e]), s = 0; s < r.length; s++) {\n              this.hiddenNodes[r[s].id] = !0;\n            }\n\n            t.prototype.closeNode.call(this, e, i);\n          }\n        }, e.prototype.save = function () {\n          if (this.saveHack) return this.saveHack;\n          var t;\n          t = [];\n\n          for (var e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {\n            var r = e[i[n]];\n            !r.removed && r.focused && t.push(r.id);\n          }\n\n          return {\n            hidden: Object.keys(this.hiddenNodes),\n            focused: t\n          };\n        }, e.prototype.restore = function (t) {\n          var e = this,\n              i = t;\n          this.hiddenNodes = {};\n\n          for (var n = 0; n < i.hidden.length; n++) {\n            this.hiddenNodes[i.hidden[n]] = !0;\n          }\n\n          this.saveHack = i, this.chart.notifyChartUpdate(\"restore\"), this.saveHack = null, this.notifyNavigation(null, function (t) {\n            e.updateGraphWithNewData(null, t);\n\n            for (var n = {}, r = 0; r < i.focused.length; r++) {\n              n[i.focused[r]] = !0;\n            }\n\n            for (var s = e.chart.layer, a = s.idToNode, o = Object.keys(a), r = 0; r < o.length; r++) {\n              var l = a[o[r]],\n                  h = d.Helpers.hasProperty(n, o[r]);\n              l.removed || l.focused === h || (l.focused = h, s.touchNode(l));\n            }\n\n            return !1;\n          });\n        }, e.prototype.expandNode = function (e, i) {\n          var n = this.chart.layer.idToNode;\n\n          if (d.Helpers.hasProperty(n, e)) {\n            for (var r = n[e], s = 0; s < r.dataLinks.length; s++) {\n              var a = r.dataLinks[s],\n                  o = A.otherEnd(a, e);\n              o !== e && delete this.hiddenNodes[o];\n            }\n\n            t.prototype.expandNode.call(this, e, i);\n          }\n        }, e.prototype.showInitialNodes = function () {\n          var t = this;\n          this.retryList = [], this.notifyNavigation(\"init\", function (e) {\n            var i = t.chart.layer,\n                n = t.chart.scene.mainData;\n            t.hiddenNodes = {}, i.clearObjects(), t.isInitialized = !0;\n            var r,\n                s = t.chart.settings.navigation.initialNodes,\n                a = {};\n\n            if (null == s || s.length < 1) {\n              r = n.getAllNodes();\n\n              for (var o = 0; o < r.length; o++) {\n                a[r[o].id] = !0;\n              }\n            } else {\n              r = n.getAllNodes(!1);\n\n              for (var o = 0; o < r.length; o++) {\n                a[r[o].id] = !0;\n              }\n\n              for (var o = 0; o < s.length; o++) {\n                var l = s[o];\n\n                if (!d.Helpers.hasProperty(a, l)) {\n                  var h = n.getNode(l);\n                  h && (r.push(h), a[l] = !0);\n                }\n              }\n            }\n\n            for (var o = 0; o < r.length; o++) {\n              var u = r[o],\n                  c = n.getLinks(u.id);\n              t.ensureNode(u, c);\n\n              for (var p = 0; p < c.length; p++) {\n                var f = A.otherEnd(c[p], u.id);\n\n                if (f && f !== u.id && !d.Helpers.hasProperty(a, f)) {\n                  a[f] = !0;\n                  var g = n.getNode(f);\n                  g && r.push(g);\n                }\n              }\n            }\n\n            return r.length > 0 && (e.changes.newGraph = !0), !0;\n          });\n        }, e.prototype.onNewDataObject = function () {\n          var t = this,\n              e = this.chart.settings.navigation.initialNodes;\n          (null == e || e.length < 1) && this.chart.scene.mainData.getAllNodes(), this.notifyNavigation(null, function (e) {\n            return t.updateGraphWithNewData(null, e), !1;\n          });\n        }, e.prototype.updateGraphWithNewData = function (t, e) {\n          if (this.isInitialized) {\n            var i,\n                n = this.chart.layer,\n                r = this.chart.scene.mainData,\n                s = n.idToNode,\n                a = {};\n\n            if (t) {\n              i = Object.keys(t);\n\n              for (var o = 0; o < i.length; o++) {\n                a[i[o]] = r.getNode(i[o], !1);\n              }\n            } else {\n              for (var l = r.getAllNodes(!1), o = 0; o < l.length; o++) {\n                a[l[o].id] = l[o];\n              }\n\n              for (var h = Object.keys(s), o = 0; o < h.length; o++) {\n                d.Helpers.hasProperty(a, h[o]) || (a[h[o]] = null);\n              }\n\n              h = Object.keys(this.hiddenNodes);\n\n              for (var o = 0; o < h.length; o++) {\n                d.Helpers.hasProperty(a, h[o]) || (a[h[o]] = null);\n              }\n\n              i = Object.keys(a);\n            }\n\n            for (var u = !1, c = Object.keys(s), o = 0; o < c.length; o++) {\n              if (!s[c[o]].removed) {\n                u = !0;\n                break;\n              }\n            }\n\n            for (var p = !1, o = 0; o < i.length; o++) {\n              var f = i[o],\n                  g = a[f],\n                  v = d.Helpers.hasProperty(s, f) ? s[f] : null;\n\n              if (g) {\n                if (d.Helpers.hasProperty(this.hiddenNodes, f)) {\n                  this.ensureNodeRemoved(v);\n                  continue;\n                }\n\n                var m = r.getLinks(f, !1);\n                v && !v.removed ? (this.updateNodeWithNewData(v, g, m), n.touchNode(v)) : (this.ensureNode(g, m), v = s[f], p = !0);\n\n                for (var y = 0; y < m.length; y++) {\n                  var S = A.otherEnd(m[y], f);\n\n                  if (S && S !== f && !d.Helpers.hasProperty(this.hiddenNodes, S)) {\n                    var b = d.Helpers.hasProperty(s, S) ? s[S] : null;\n\n                    if (!b || b.removed) {\n                      var x = r.getNode(S);\n                      x && this.ensureNode(x, r.getLinks(S));\n                    }\n                  }\n                }\n              } else r.isNodeLoading(f) ? v && !v.loading && (v.loading = !0, n.touchNode(v)) : (this.ensureNodeRemoved(v), delete this.hiddenNodes[f]);\n            }\n\n            !u && p && (e.changes.newGraph = !0);\n          }\n        }, e;\n      }(N);\n\n      t.ShowAllNavigator = F;\n      var O;\n      !function (t) {\n        t[t.Hidden = 1] = \"Hidden\", t[t.Expanded = 2] = \"Expanded\";\n      }(O || (O = {}));\n\n      var E = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.focusNodes = [], e.extraFlags = {}, e.needsFullRecalculate = !1, e.wasReset = !1, e;\n        }\n\n        return n(e, t), e.prototype.expandNode = function (t, e) {\n          var i = this.chart.layer.idToNode,\n              n = d.Helpers.hasProperty(i, t) ? i[t] : null,\n              r = !1;\n\n          if (n && !n.removed) {\n            n.relevance < 2 && (this.extraFlags[t] = O.Expanded, r = !0);\n\n            for (var s = 0; s < n.dataLinks.length; s++) {\n              var a = A.otherEnd(n.dataLinks[s], t);\n              a && a !== t && d.Helpers.hasProperty(this.extraFlags, a) && this.extraFlags[a] === O.Hidden && (delete this.extraFlags[a], r = !0);\n            }\n\n            r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e));\n          }\n        }, e.prototype.collapseNode = function (t, e) {\n          var i = this.chart.layer.idToNode,\n              n = d.Helpers.hasProperty(i, t) ? i[t] : null,\n              r = !1;\n\n          if (n && !n.removed) {\n            d.Helpers.hasProperty(this.extraFlags, t) && (delete this.extraFlags[t], r = !0);\n\n            for (var s = 0; s < n.links.length; s++) {\n              var a = n.links[s].otherEnd(n);\n              a && a !== n && !a.removed && a.baseRelevance < n.baseRelevance && (this.extraFlags[a.id] = O.Hidden, r = !0);\n            }\n\n            r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e));\n          }\n        }, e.prototype.closeNode = function (t, e) {}, e.prototype.focusNode = function (t, e, i) {\n          for (var n = 0; n < this.focusNodes.length; n++) {\n            if (this.focusNodes[n].id === t) return;\n          }\n\n          if (this.focusNodes.length >= this.chart.settings.navigation.numberOfFocusNodes) {\n            if (!this.chart.settings.navigation.autoUnfocus) return;\n            this.focusNodes.pop();\n          }\n\n          this.focusNodes.unshift({\n            id: t,\n            assignedRelevance: e,\n            calculatedRelevance: null\n          }), d.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === O.Hidden && delete this.extraFlags[t];\n          var r = this.chart.scene.mainData.getLinks(t, !1);\n          if (r) for (var n = 0; n < r.length; n++) {\n            var s = A.otherEnd(r[n], t);\n            s && s !== t && d.Helpers.hasProperty(this.extraFlags, s) && this.extraFlags[s] === O.Hidden && delete this.extraFlags[s];\n          }\n          this.chart.notifyChartUpdate(i), this.scheduleFullRecalculate();\n        }, e.prototype.unfocusNode = function (t, e) {\n          if (!(this.focusNodes.length <= Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1))) for (var i = 0; i < this.focusNodes.length; i++) {\n            if (this.focusNodes[i].id === t) return this.focusNodes.splice(i, 1), this.chart.notifyChartUpdate(e), void this.scheduleFullRecalculate();\n          }\n        }, e.prototype.clearFocusNodes = function (t) {\n          this.focusNodes = [], this.extraFlags = {}, this.wasReset = !0, this.chart.notifyChartUpdate(t), this.scheduleFullRecalculate();\n        }, e.prototype.hideNode = function (t, e) {\n          var i = this.chart.layer.idToNode,\n              n = d.Helpers.hasProperty(i, t) ? i[t] : null;\n          n && !n.removed && this.canHideNode(n) && (this.extraFlags[t] = O.Hidden, this.chart.notifyChartUpdate(e), this.scheduleFullRecalculate());\n        }, e.prototype.showNode = function (t, e) {\n          d.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === O.Hidden && (delete this.extraFlags[t], this.scheduleFullRecalculate());\n        }, e.prototype.showInitialNodes = function () {\n          this.extraFlags = {};\n          var t = this.chart.settings.navigation.initialNodes;\n\n          if (t) {\n            var e = {};\n            this.focusNodes = new Array(t.length);\n\n            for (var i = 0, n = 0; n < t.length; n++) {\n              var r = t[n];\n              d.Helpers.hasProperty(e, r) || (e[r] = !0, this.focusNodes[i++] = {\n                id: r,\n                assignedRelevance: -1,\n                calculatedRelevance: null\n              });\n            }\n\n            i < this.chart.settings.navigation.minNumberOfFocusNodes && this.chart.error(\"Too few initialNodes. minNumberOfFocusNodes is \" + this.chart.settings.navigation.minNumberOfFocusNodes + \" but there are only \" + i + \" nodes in initialNodes\"), i > this.chart.settings.navigation.numberOfFocusNodes && (this.chart.error(\"Too many initialNodes. numberOfFocusNodes is \" + this.chart.settings.navigation.numberOfFocusNodes + \" but there are \" + i + \" nodes in initialNodes. Discarding excess focus nodes.\"), i = this.chart.settings.navigation.numberOfFocusNodes), this.focusNodes.length = i;\n          } else this.focusNodes = [];\n\n          this.wasReset = !0, this.chart.notifyChartUpdate(\"init\"), this.scheduleFullRecalculate();\n        }, e.prototype.save = function () {\n          return {\n            focusNodes: this.focusNodes,\n            extraFlags: this.extraFlags\n          };\n        }, e.prototype.restore = function (t) {\n          this.focusNodes = d.Helpers.realClone(t.focusNodes), this.extraFlags = d.Helpers.clone(t.extraFlags), this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(\"restore\");\n        }, e.prototype.onNewDataObject = function () {\n          for (var t = this.chart.scene.mainData, e = Object.keys(this.chart.layer.idToNode), i = 0; i < e.length; i++) {\n            t.getNode(e[i]);\n          }\n        }, e.prototype.onSceneChange = function (t) {\n          t.changes.filters ? (this.updateGraphWithNewData(null, t), this.needsFullRecalculate = !0) : t.changes.dataArrived || t.changes.data ? (this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.needsFullRecalculate = !0) : t.changes.settings && t.changes.settingsChanges.navigation && (this.needsFullRecalculate = !0), this.needsFullRecalculate && (this.needsFullRecalculate = !1, this.fullRecalculate(t.timeStamp, t));\n        }, e.prototype.scheduleFullRecalculate = function () {\n          this.needsFullRecalculate = !0, this.chart.events.notifySceneChanges({\n            navigation: !0\n          });\n        }, e.prototype.fullRecalculate = function (t, e) {\n          var i = this,\n              n = this.chart.settings.navigation,\n              r = this.chart.layer,\n              s = this.chart.scene.mainData;\n          if (this.focusNodes.length < 1) return r.clearObjects(), this.wasReset && (e.changes.newGraph = !0), void (this.wasReset = !1);\n\n          for (var a = t - this.chart.settings.navigation.expandDelay, o = r.idToNode, l = Object.keys(o), h = r.idToLink, u = 0; u < l.length; u++) {\n            var c = o[l[u]];\n            c.baseRelevance = -(1 / 0), c.relevance = -(1 / 0), c.focused = !1, r.touchNode(c);\n          }\n\n          if (n.numberOfFocusNodes > 1) for (var p = null == n.focusNodeTailExpansionRadius ? n.focusNodeExpansionRadius : n.focusNodeTailExpansionRadius, f = Math.max(n.focusNodeExpansionRadius + 1, 1), g = Math.max(p + 1, 1), v = (f - g) / (n.numberOfFocusNodes - 1), u = 0; u < this.focusNodes.length; u++) {\n            this.focusNodes[u].calculatedRelevance = f - u * v;\n          } else this.focusNodes[0].calculatedRelevance = Math.max(n.focusNodeExpansionRadius + 1, 1);\n\n          for (var m = [], y = {}, S = {}, u = 0; u < this.focusNodes.length; u++) {\n            var b = this.focusNodes[u],\n                c = d.Helpers.hasProperty(o, b.id) ? o[b.id] : null;\n\n            if (!c || c.removed) {\n              var x = s.getNode(b.id);\n              if (!x) continue;\n              this.ensureNode(x, s.getLinks(b.id)), c = o[b.id];\n            }\n\n            c.focused = !0, c.baseRelevance = b.assignedRelevance >= 1 ? b.assignedRelevance : b.calculatedRelevance, c.relevance = c.baseRelevance, c.showTimestamp = -(1 / 0), m.push(c), y[b.id] = !0, S[b.id] = !0, this.wasReset && (this.wasReset = !1, e.changes.newGraph = !0);\n          }\n\n          for (var C = Object.keys(this.extraFlags), u = 0; u < C.length; u++) {\n            var w = C[u],\n                c = d.Helpers.hasProperty(o, w) ? o[w] : null;\n            if (c && !c.removed) if (this.extraFlags[w] === O.Hidden) c.relevance = -100;else if (c.relevance < 2) {\n              c.relevance = 2;\n\n              for (var L = 0; L < c.links.length; L++) {\n                var T = c.links[L].otherEnd(c);\n                T && T !== c && T.relevance < 1 && T.relevance !== -100 && (T.relevance = 1);\n              }\n            } else delete this.extraFlags[w];\n          }\n\n          for (var k = 1 / 0, u = 0; u < m.length; u++) {\n            var c = m[u];\n            delete y[c.id];\n\n            for (var w = c.id, M = c.baseRelevance - 1, I = c.relevance - 1, P = d.Helpers.hasProperty(S, w) && c.relevance > 0, L = 0; L < c.dataLinks.length; L++) {\n              var D = c.dataLinks[L],\n                  N = A.otherEnd(D, w);\n\n              if (N && N !== w) {\n                P && (S[N] = !0);\n                var F = d.Helpers.hasProperty(this.extraFlags, N) ? this.extraFlags[N] : null;\n\n                if (F !== O.Hidden) {\n                  var E = I;\n                  F === O.Expanded && I >= 2 && delete this.extraFlags[N];\n                  var T = d.Helpers.hasProperty(o, N) ? o[N] : null,\n                      R = !1;\n\n                  if (!T || T.removed) {\n                    if (E <= 0) continue;\n                    var x = s.getNode(N);\n                    if (!x) continue;\n\n                    if (c.showTimestamp > a) {\n                      k > c.showTimestamp && (k = c.showTimestamp);\n                      continue;\n                    }\n\n                    this.ensureNode(x, s.getLinks(N)), T = o[N], T.relevance = E, T.baseRelevance = M, T.showTimestamp = t, R = !0;\n                  } else T.relevance < E && (T.relevance = E, r.touchNode(T), R = !0), T.baseRelevance < M && (T.baseRelevance = M, r.touchNode(T), R = !0);\n\n                  var H = h[D.id],\n                      z = Math.min(c.relevance, T.relevance);\n                  H.relevance !== z && (H.relevance = z, r.touchLink(H)), R && !d.Helpers.hasProperty(y, N) && (y[N] = !0, m.push(T));\n                }\n              }\n            }\n          }\n\n          for (var u = 0; u < l.length; u++) {\n            var w = l[u],\n                c = o[w];\n            c.removed || (d.Helpers.hasProperty(S, w) ? c.relevance <= 0 && this.ensureNodeRemoved(c) : (this.ensureNodeRemoved(c), delete this.extraFlags[w]));\n          }\n\n          k < 1 / 0 && window.setTimeout(function () {\n            return i.scheduleFullRecalculate();\n          }, k + this.chart.settings.navigation.expandDelay - t);\n        }, e.prototype.canFocusNode = function (t) {\n          return !t.focused && (this.focusNodes.length < this.chart.settings.navigation.numberOfFocusNodes || this.chart.settings.navigation.autoUnfocus);\n        }, e.prototype.canUnfocusNode = function (t) {\n          return t.focused && this.focusNodes.length > Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1);\n        }, e.prototype.canExpandNode = function (t) {\n          return !t.expanded;\n        }, e.prototype.canCollapseNode = function (t) {\n          for (var e = 0; e < t.links.length; e++) {\n            var i = t.links[e].otherEnd(t);\n            if (i && i !== t && !i.removed && i.baseRelevance < t.baseRelevance) return !0;\n          }\n\n          return !1;\n        }, e.prototype.canHideNode = function (t) {\n          return !t.focused || this.canUnfocusNode(t);\n        }, e.prototype.canCloseNode = function (t) {\n          return !1;\n        }, e;\n      }(D);\n\n      t.FocusNodesNavigator = E, function (t) {\n        var e = function () {\n          function t(t) {\n            this.pointers = [], this.manager = t;\n          }\n\n          return t.prototype.addPointer = function (t, e) {\n            this.pointers.push(t.identifier), t.consumed = !0;\n          }, t.prototype.removePointer = function (t) {\n            d.Helpers.removeFromArrayHasty(this.pointers, t.identifier), t.consumed = !0;\n          }, t.prototype.movePointer = function (t) {\n            t.consumed = !0;\n          }, t;\n        }();\n\n        t.Gesture = e;\n\n        var i = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.startX = 0, e.startY = 0, e.lastX = 0, e.lastY = 0, e.selectedNodes = null, e;\n          }\n\n          return n(e, t), e.prototype.addPointer = function (e, i) {\n            t.prototype.addPointer.call(this, e, i), this.startX = this.lastX = e.x, this.startY = this.lastY = e.y, this.selectedNodes = new Object(null), e.cursor = \"crosshair\";\n            var n = this.manager.chart.scene;\n            n.disableSelectionChangeNotification();\n            var r = n.selection.filter(function (t) {\n              return t.dragging;\n            });\n            r.length !== n.selection.length && n.setSelection(r), this.manager.chart.events.requestPaint();\n          }, e.prototype.movePointer = function (e) {\n            t.prototype.movePointer.call(this, e), this.lastX = e.x, this.lastY = e.y, this.manager.chart.events.requestPaint(), e.cursor = \"crosshair\", this.updateSelection();\n          }, e.prototype.removePointer = function (e) {\n            t.prototype.removePointer.call(this, e);\n\n            for (var i in this.selectedNodes) {\n              this.selectedNodes[i].selectionLock = !1;\n            }\n\n            this.manager.chart.scene.enableSelectionChangeNotification(), this.manager.chart.scene.notifySelectionChangesIfNeeded(this.manager.chart, \"user\"), this.manager.chart.events.requestPaint();\n          }, e.prototype.doAnimations = function (t) {\n            this.pointers.length > 0 && (t.changes.position || t.changes.selection || this.manager.chart.layer.hasTopologyChanges()) && this.updateSelection();\n          }, e.prototype.updateSelection = function () {\n            for (var t = this.manager.chart.layer.nodes(), e = this.manager.chart.scene, i = e.fromDisplay(this.startX, this.startY), n = e.fromDisplay(this.lastX, this.lastY), r = Math.min(i.x, n.x), s = Math.min(i.y, n.y), a = Math.max(i.x, n.x), o = Math.max(i.y, n.y), l = 0; l < t.length; l++) {\n              var h = t[l];\n              h.removed ? this.selectedNodes[h.id] && delete this.selectedNodes[h.id] : h.dragging || (h.x >= r && h.x <= a && h.y >= s && h.y <= o ? this.selectedNodes[h.id] || (this.selectedNodes[h.id] = h, h.selectionLock = !0, h.selected || e.addToSelection(h)) : this.selectedNodes[h.id] && (delete this.selectedNodes[h.id], h.selectionLock = !1, h.selected && e.removeFromSelection(h)));\n            }\n          }, e.prototype.paintScene = function (t) {\n            if (this.pointers.length > 0) {\n              var e = this.manager.chart.settings.style.dragSelection,\n                  i = d.Graphics.beginStrokeAndFill(t.context, e);\n              i.rect(this.startX - .5, this.startY - .5, this.lastX - this.startX, this.lastY - this.startY), d.Graphics.endStrokeAndFill(t.context, i, e);\n            }\n          }, e;\n        }(e);\n\n        t.MultiSelectGesture = i;\n\n        var r = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.dragPointers = {}, e;\n          }\n\n          return n(e, t), e.prototype.addPointer = function (e, i) {\n            t.prototype.addPointer.call(this, e, i);\n            var n = this.manager.chart.scene.selection.filter(function (t) {\n              return !t.dragging;\n            });\n            n.indexOf(i.object) < 0 && n.push(i.object);\n\n            for (var r = n.filter(function (t) {\n              return t instanceof u.Node;\n            }), s = 0; s < r.length; s++) {\n              r[s].locks++;\n            }\n\n            for (var s = 0; s < n.length; s++) {\n              n[s].dragging = !0;\n            }\n\n            var a = this.manager.chart.scene.fromDisplay(e.x, e.y);\n            this.dragPointers[e.identifier] = {\n              nodes: r,\n              all: n,\n              mainNode: i.object,\n              startPointerX: e.x,\n              startPointerY: e.y,\n              lastPointerX: e.x,\n              lastPointerY: e.y,\n              lastSceneX: a.x,\n              lastSceneY: a.y\n            };\n          }, e.prototype.removePointer = function (e) {\n            t.prototype.removePointer.call(this, e);\n            var i = this.dragPointers[e.identifier];\n            delete this.dragPointers[e.identifier];\n\n            for (var n = 0; n < i.nodes.length; n++) {\n              i.nodes[n].locks--;\n            }\n\n            for (var n = 0; n < i.all.length; n++) {\n              i.all[n].dragging = !1;\n            }\n\n            this.manager.autoZoomIn(e, i.mainNode);\n          }, e.prototype.movePointer = function (e) {\n            t.prototype.movePointer.call(this, e);\n            var i = this.dragPointers[e.identifier];\n            i.lastPointerX = e.x, i.lastPointerY = e.y;\n            var n = this.manager.chart.settings.interaction.selection,\n                r = this.manager.chart.scene,\n                s = r.fromDisplay(e.x, e.y),\n                a = s.x - i.lastSceneX,\n                o = s.y - i.lastSceneY;\n\n            if (0 !== a || 0 !== o) {\n              i.lastSceneX = s.x, i.lastSceneY = s.y;\n              var l = n.lockNodesOnMove;\n\n              if (l) {\n                var h = e.x - i.startPointerX,\n                    u = e.y - i.startPointerY,\n                    c = this.manager.chart.settings.advanced.pointer,\n                    d = Math.max(c.clickSensitivity, c.longPressSensitivity);\n                l = h * h + u * u > d * d;\n              }\n\n              this.moveNodes(i.nodes, a, o, l), this.manager.chart.events.notifySceneChanges({\n                coordinates: !0\n              });\n            }\n          }, e.prototype.moveNodes = function (t, e, i, n) {\n            for (var r = this.manager.chart.scene, s = r.getVisibleBounds(), a = r.zoom, o = this.manager.chart.settings.interaction.selection.allowMoveNodesOffscreen, l = this.manager.chart.layer, h = 0; h < t.length; h++) {\n              var u = t[h];\n\n              if (u.x += e, u.y += i, n && !u.userLock && (u.userLock = !0, l.touchNode(u)), !o) {\n                var c = 1.2 * u.renderHwidth / a,\n                    d = 1.2 * u.renderHheight / a;\n                u.x = Math.min(Math.max(u.x, s.x0 + c), s.x1 - c), u.y = Math.min(Math.max(u.y, s.y0 + d), s.y1 - d);\n              }\n            }\n          }, e.prototype.doAnimations = function (t) {\n            for (var e = this.manager.chart.scene, i = 0; i < this.pointers.length; i++) {\n              var n = this.dragPointers[this.pointers[i]],\n                  r = e.fromDisplay(n.lastPointerX, n.lastPointerY),\n                  s = r.x - n.lastSceneX,\n                  a = r.y - n.lastSceneY;\n              0 === s && 0 === a || (n.lastSceneX = r.x, n.lastSceneY = r.y, this.moveNodes(n.nodes, s, a, !1), t.changes.coordinates = !0);\n            }\n          }, e;\n        }(e);\n\n        t.NodeDragGesture = r;\n\n        var s = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.pinnedSceneX = 0, e.pinnedSceneY = 0, e;\n          }\n\n          return n(e, t), e.prototype.addPointer = function (e, i) {\n            t.prototype.addPointer.call(this, e, i);\n            var n = this.manager.chart.scene.fromDisplay(e.x, e.y);\n            this.pinnedSceneX = n.x, this.pinnedSceneY = n.y;\n          }, e.prototype.movePointer = function (e) {\n            t.prototype.movePointer.call(this, e);\n            var i = this.manager.chart.scene;\n            i.autoZoomMode = !1;\n            var n = i.fromDisplay(e.x, e.y);\n            i.centerX += this.pinnedSceneX - n.x, i.centerY += this.pinnedSceneY - n.y, e.changes.position = !0;\n          }, e;\n        }(e);\n\n        t.PanGesture = s;\n\n        var a = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.x1 = 0, e.y1 = 0, e.x2 = 0, e.y2 = 0, e.centerX = 0, e.centerY = 0, e.centerDistance = 0, e;\n          }\n\n          return n(e, t), e.prototype.addPointer = function (e, i) {\n            if (t.prototype.addPointer.call(this, e, i), 1 === this.pointers.length) this.x1 = e.x, this.y1 = e.y;else {\n              this.x2 = e.x, this.y2 = e.y;\n              var n = this.manager.chart.scene,\n                  r = n.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n              this.centerX = r.x, this.centerY = r.y;\n              var s = this.x1 - this.x2,\n                  a = this.y1 - this.y2,\n                  o = Math.sqrt(s * s + a * a);\n              this.centerDistance = o / n.zoom;\n            }\n          }, e.prototype.movePointer = function (e) {\n            t.prototype.movePointer.call(this, e), e.identifier === this.pointers[0] ? (this.twoFingerDrag(e.x, e.y, this.x2, this.y2), this.x1 = e.x, this.y1 = e.y) : (this.twoFingerDrag(this.x1, this.y1, e.x, e.y), this.x2 = e.x, this.y2 = e.y), e.changes.position = !0;\n          }, e.prototype.twoFingerDrag = function (t, e, i, n) {\n            var r = this.manager.chart.settings.interaction,\n                s = this.manager.chart.scene;\n            s.autoZoomMode = !1;\n            var a = i - t,\n                o = n - e,\n                l = this.manager.chart.settings.layout.mode;\n            !r.rotation.fingers || \"static\" !== l && \"dynamic\" !== l || this._twoFingerRotation(t, e, i, n);\n            var h = Math.sqrt(a * a + o * o) / s.zoom,\n                u = (i + t) / 2,\n                c = (n + e) / 2;\n\n            if (!r.rotation.fingers && r.panning.enabled) {\n              var d = s.fromDisplay(u, c);\n              s.centerX += this.centerX - d.x, s.centerY += this.centerY - d.y;\n            }\n\n            if (r.zooming.fingers) {\n              var p = h / this.centerDistance;\n              this.manager.chart.autoZoom.manualZoom(p, u, c);\n            }\n          }, e.prototype._twoFingerRotation = function (t, e, i, n) {\n            var r = i - t,\n                s = n - e,\n                a = Math.atan2(s, r),\n                o = Math.atan2(this.y2 - this.y1, this.x2 - this.x1),\n                l = a - o;\n            if (0 === l) return !1;\n            var h,\n                u,\n                c,\n                p,\n                f,\n                g = t - this.x1,\n                v = e - this.y1,\n                m = i - this.x2,\n                y = n - this.y2,\n                S = g * g + v * v,\n                b = m * m + y * y;\n            S >= b ? (h = this.x1, u = this.y1, c = t, p = e, f = Math.sqrt(S)) : (h = this.x2, u = this.y2, c = i, p = n, f = Math.sqrt(b));\n            var x = c - h,\n                C = p - u,\n                w = x / f,\n                L = C / f,\n                T = (Math.PI + l) / 2,\n                k = Math.PI - T,\n                M = d.Geometry.rotateVector(w, L, Math.sin(k), Math.cos(k)),\n                A = d.Geometry.rotateVector(w, L, Math.sin(T), Math.cos(T)),\n                I = d.Geometry.lineIntersectsLine(0, 0, M.x, M.y, x, C, x + A.x, C + A.y);\n            if (I === 1 / 0) return !1;\n\n            for (var P, D = h + M.x * I, N = u + M.y * I, F = this.manager.chart.scene.fromDisplay(D, N), O = F.x, E = F.y, R = this.manager.chart.layer.nodes(), H = Math.sin(l), z = Math.cos(l), B = 0; B < R.length; B++) {\n              var U = R[B];\n              U.dragging || (P = d.Geometry.rotateVector(U.x - O, U.y - E, H, z), U.x = O + P.x, U.y = E + P.y);\n            }\n\n            return !0;\n          }, e;\n        }(e);\n\n        t.TwoFingerGesture = a;\n\n        var o = {\n          object: null,\n          details: null\n        },\n            l = function (t) {\n          function l(n) {\n            var o = t.call(this) || this;\n            return o.animationOrder = 2e3, o.updateOrder = 1100, o.paintOrder = 37, o.hoverPointer = null, o.ignoreGesture = new e(o), o.postponeGesture = new e(o), o.multiSelectGesture = new i(o), o.nodeDragGesture = new r(o), o.panGesture = new s(o), o.twoFingerGesture = new a(o), o.pointerMap = {}, o.chart = n, o;\n          }\n\n          return n(l, t), l.prototype.findObject = function (t) {\n            var e = this.chart.renderer.findObjectAt(t.x, t.y, this.chart.settings.interaction.selection.tolerance);\n            return e || o;\n          }, l.prototype.assignPointer = function (t, e, i) {\n            var n = this.pointerMap[t.identifier];\n            return n ? (n.gesture.removePointer(t), n.gesture = i) : n = this.pointerMap[t.identifier] = {\n              gesture: i,\n              lastX: t.x,\n              lastY: t.y,\n              longPressGesture: null\n            }, i.addPointer(t, e), n;\n          }, l.prototype.reassignToTwoFinger = function (t, e, i) {\n            var n = this.pointerMap[t],\n                r = new d.MouseEvent(n.lastX, n.lastY, e.timeStamp, t);\n            n.longPressGesture = null, this.assignPointer(r, o, this.twoFingerGesture), this.assignPointer(e, i, this.twoFingerGesture);\n          }, l.prototype.assignUnknownPointer = function (t, e) {\n            e.object instanceof u.Node && this.chart.settings.interaction.nodesMovable && e.object.draggable ? this.assignNodePointer(t, e) : this.assignEmptyPointer(t, e);\n          }, l.prototype.assignEmptyPointer = function (t, e) {\n            var i = this.chart.settings.interaction,\n                n = i.rotation.fingers || i.zooming.fingers,\n                r = i.selection.enabled && i.selection.dragSelect;\n\n            if (this.twoFingerGesture.pointers.length > 0) {\n              var s = this.assignPointer(t, e, this.ignoreGesture);\n              r && (s.longPressGesture = this.multiSelectGesture);\n            } else if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);else if (n && this.postponeGesture.pointers.length > 0) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);else if (n && this.nodeDragGesture.pointers.length > 0) this.reassignToTwoFinger(this.nodeDragGesture.pointers[0], t, e);else {\n              var s = this.assignPointer(t, e, i.panning.enabled && this.panGesture.pointers.length < 1 ? this.panGesture : this.postponeGesture);\n              r && (s.longPressGesture = this.multiSelectGesture);\n            }\n          }, l.prototype.assignNodePointer = function (t, e) {\n            var i = this.chart.settings.interaction,\n                n = i.rotation.fingers || i.zooming.fingers;\n            if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);else if (n && this.postponeGesture.pointers.length > 0 && this.twoFingerGesture.pointers.length < 1) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);else if (e.object.dragging) {\n              var r = this.assignPointer(t, e, this.postponeGesture);\n              r.longPressGesture = this.ignoreGesture;\n            } else {\n              var r = this.assignPointer(t, e, this.nodeDragGesture);\n              r.longPressGesture = this.ignoreGesture;\n            }\n          }, l.prototype.updateSelection = function (t, e) {\n            var i = this.chart.settings.interaction.selection;\n\n            if (i.enabled && (e.object instanceof u.Node && i.nodesSelectable || e.object instanceof u.Link && i.linksSelectable) && !e.object.selectionLock && !e.object.dragging) {\n              var n = !1;\n              if (t.shiftKey || t.ctrlKey) n = e.object.selected ? this.chart.scene.removeFromSelection(e.object) : this.chart.scene.addToSelection(e.object);else if (!e.object.selected) {\n                var r = this.chart.scene.selection.filter(function (t) {\n                  return t.dragging || t.selectionLock;\n                });\n                r.push(e.object), n = this.chart.scene.setSelection(r);\n              }\n              n && this.chart.scene.notifySelectionChangesIfNeeded(this.chart, \"user\");\n            }\n          }, l.prototype.onPointerDown = function (t) {\n            var e = this.findObject(t);\n            this.chart.notifyPointerDown(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0), this.updateSelection(t, e), this.assignUnknownPointer(t, e);\n          }, l.prototype.onPointerUp = function (t) {\n            this.chart.notifyPointerUp(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n            var e = this.pointerMap[t.identifier];\n\n            if (e.gesture.removePointer(t), delete this.pointerMap[t.identifier], e.gesture === this.twoFingerGesture) {\n              var i = this.twoFingerGesture.pointers[0],\n                  n = this.pointerMap[i];\n              delete this.pointerMap[i];\n              var r = new d.MouseEvent(n.lastX, n.lastY, t.timeStamp, i);\n              this.twoFingerGesture.removePointer(r), this.assignPointer(r, o, this.chart.settings.interaction.panning.enabled ? this.panGesture : this.postponeGesture);\n            }\n          }, l.prototype.onPointerDrag = function (t) {\n            this.chart.notifyPointerDrag(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n            var e = this.findObject(t);\n            t.cursor = e.object && e.object.cursor || \"default\";\n            var i = this.pointerMap[t.identifier];\n            i.lastX = t.x, i.lastY = t.y, i.gesture.movePointer(t);\n          }, l.prototype.onPointerCancel = function (t) {\n            this.onPointerUp(t);\n          }, l.prototype.onInstantClick = function (t) {\n            if (!t.shiftKey && !t.ctrlKey && !this.findObject(t).object) {\n              var e = this.chart.scene.selection.filter(function (t) {\n                return t.dragging || t.selectionLock;\n              });\n              e.length !== this.chart.scene.selection.length && (this.chart.scene.setSelection(e), this.chart.scene.notifySelectionChangesIfNeeded(this.chart, \"user\"));\n            }\n          }, l.prototype.doAnimations = function (t) {\n            this.nodeDragGesture.doAnimations(t), this.multiSelectGesture.doAnimations(t);\n          }, l.prototype.paintScene = function (t) {\n            this.multiSelectGesture.paintScene(t);\n          }, l.prototype.buildClickEventArgs = function (t) {\n            var e = this.chart.createEventArguments(t, \"user\"),\n                i = this.findObject(t);\n            e.clickItem = i.details;\n            var n = i.object;\n            return n instanceof u.Node ? (e.clickNode = n, this.autoZoomIn(t, n)) : e.clickLink = n, e;\n          }, l.prototype.updateHover = function (t, e) {\n            t.changes.current = !0, this.chart.scene.setActiveObject(e.object, e.details), this.chart.notifyHoverChanged(t, this.chart.createEventArguments(null, \"api\"));\n          }, l.prototype.autoZoomIn = function (t, e) {\n            this.chart.scene.lastClickedNode = e, this.chart.settings.interaction.zooming.autoZoomAfterClick && (this.chart.scene.autoZoomMode = !0, t.changes.zoom = !0);\n          }, l.prototype.onPointerMove = function (t) {\n            if (this.chart.notifyPointerMove(t, this.chart.createEventArguments(null, \"user\")), t.defaultPrevented && (t.consumed = !0), !this.chart.scene.xyInChart(t.x, t.y)) return void this.onPointerOut(t);\n            this.hoverPointer = t.identifier;\n            var e = this.findObject(t);\n            t.cursor = e.object && e.object.cursor || \"default\", e.object === (this.chart.scene.hoverLink || this.chart.scene.hoverNode) && e.details === this.chart.scene.hoverItem || this.updateHover(t, e);\n          }, l.prototype.onPointerOut = function (t) {\n            this.hoverPointer === t.identifier && (this.hoverPointer = null, this.updateHover(t, o)), this.pointerMap[t.identifier] && this.onPointerUp(t);\n          }, l.prototype.onWheel = function (t) {\n            if (this.chart.scene.xyInChart(t.x, t.y) && this.chart.settings.interaction.zooming.wheel) {\n              var e = Math.pow(1 + this.chart.settings.interaction.zooming.sensitivity, .004 * t.wheely);\n              this.chart.autoZoom.manualZoom(e, t.x, t.y), t.consumed = !0, t.changes.position = !0;\n            }\n          }, l.prototype.onClick = function (t) {\n            this.chart.notifyClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);\n          }, l.prototype.onRightClick = function (t) {\n            this.chart.scene.xyInChart(t.x, t.y) && (this.chart.notifyRightClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n          }, l.prototype.onLongPress = function (t) {\n            if (this.chart.scene.xyInChart(t.x, t.y)) {\n              var e = this.pointerMap[t.identifier];\n              e && (e.longPressGesture && (e.longPressGesture === this.multiSelectGesture && this.multiSelectGesture.pointers.length > 0 && (e.longPressGesture = this.ignoreGesture), this.assignPointer(t, o, e.longPressGesture), e.longPressGesture = null), t.consumed = e.gesture !== this.ignoreGesture);\n            }\n          }, l.prototype.onDoubleClick = function (t) {\n            if (this.chart.scene.xyInChart(t.x, t.y)) if (this.chart.notifyDoubleClick(t, this.buildClickEventArgs(t)), t.defaultPrevented) t.consumed = !0;else {\n              var e = this.chart.settings.interaction.zooming.doubleClickZoom;\n              e && this.chart.settings.interaction.zooming.zoomInOnDoubleClick && (this.chart.autoZoom.manualZoom(e, t.x, t.y), t.changes.position = !0, t.consumed = !0);\n            }\n          }, l;\n        }(d.ChartElement);\n\n        t.GestureManager = l;\n      }(i = t.Gestures || (t.Gestures = {}));\n\n      var R = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e.prototype.showHide = function (t, e) {\n          t.style.display = e ? \"\" : \"none\";\n        }, e.prototype.btnExpand = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-expand\", this.scene.settings.localization.menu.expand, this.scene.settings.localization.menu.expand, null, function (t, i) {\n            e.chart.expandNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canExpandNode(t));\n          });\n        }, e.prototype.btnCollapse = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-collapse\", this.scene.settings.localization.menu.collapse, this.scene.settings.localization.menu.collapse, null, function (t, i) {\n            e.chart.collapseNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canCollapseNode(t));\n          });\n        }, e.prototype.btnClose = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-collapse\", this.scene.settings.localization.menu.close, this.scene.settings.localization.menu.close, null, function (t, i) {\n            e.chart.closeNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canCloseNode(t));\n          });\n        }, e.prototype.btnFocus = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-focus\", this.scene.settings.localization.menu.focus, this.scene.settings.localization.menu.focus, null, function (t, i) {\n            e.chart.addFocusNode(t.id, -1);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canFocusNode(t));\n          });\n        }, e.prototype.btnUnfocus = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-unfocus\", this.scene.settings.localization.menu.unfocus, this.scene.settings.localization.menu.unfocus, null, function (t, i) {\n            e.chart.removeFocusNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canUnfocusNode(t));\n          });\n        }, e.prototype.btnLock = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-lock\", this.scene.settings.localization.menu.fixed, this.scene.settings.localization.menu.fixed, null, function (t, i) {\n            e.chart.unlockNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, t.userLock);\n          });\n        }, e.prototype.btnUnlock = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-unlock\", this.scene.settings.localization.menu.dynamic, this.scene.settings.localization.menu.dynamic, null, function (t, i) {\n            e.chart.lockNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, !t.userLock);\n          });\n        }, e.prototype.btnHide = function (t) {\n          var e = this;\n          this.buildButton(t, \"DVSL-NC-button-hide\", this.scene.settings.localization.menu.hide, this.scene.settings.localization.menu.hide, null, function (t, i) {\n            e.chart.hideNode(t.id);\n          }, function (t, i) {\n            e.showHide(i, e.chart.navigator.canHideNode(t));\n          });\n        }, e.prototype.buildDefaultButton = function (t, e) {\n          if (t instanceof u.Node) switch (e) {\n            case \"btn:expand\":\n              this.btnExpand(t);\n              break;\n\n            case \"btn:collapse\":\n              this.btnCollapse(t);\n              break;\n\n            case \"btn:close\":\n              this.btnClose(t);\n              break;\n\n            case \"btn:focus\":\n              this.btnFocus(t);\n              break;\n\n            case \"btn:unfocus\":\n              this.btnUnfocus(t);\n              break;\n\n            case \"btn:lock\":\n              this.btnLock(t);\n              break;\n\n            case \"btn:unlock\":\n              this.btnUnlock(t);\n              break;\n\n            case \"btn:hide\":\n              this.btnHide(t);\n              break;\n\n            case \"expand\":\n              this.btnExpand(t), this.btnCollapse(t), this.btnClose(t);\n              break;\n\n            case \"focus\":\n              this.btnFocus(t), this.btnUnfocus(t);\n              break;\n\n            case \"lock\":\n              this.btnLock(t), this.btnUnlock(t);\n              break;\n\n            case \"hide\":\n              this.btnHide(t);\n              break;\n\n            default:\n              this.chart.error(\"The node menu button with name `\" + e + \"` was not recognized.\");\n          } else this.chart.error(\"The link menu does not support any named buttons.\");\n        }, e;\n      }(u.Menu);\n\n      t.Menu = R;\n\n      var H = function (e) {\n        function s(n, s) {\n          var a = e.call(this, new f(n), new T(), s) || this;\n          a.isLayoutFrozen = !1, a.focusNodeStack = [];\n          var o = \"focusnodes\" === a.settings.navigation.mode && a.settings.navigation.focusAutoFadeout;\n          return a.layer = new u.NodesLayer(a, a.settings, o), a.graph = new I(a), a.navigator = a.events.addElement(D.CreateNavigator(a)), a.gestures = a.events.addElement(new i.GestureManager(a)), a.layout = a.events.addElement(r.LayoutBase.ConstructLayout(a)), a.info = a.events.addElement(new u.InfoPopup(a)), a.menu = a.events.addElement(new t.Menu(a)), a.autoZoom = a.events.addElement(new P(a)), a.renderer = a.events.addElement(new k(a)), a.legend = a.events.addElement(new p(a)), a.autoZoom.resetZoom = !0, a.scene.loading = !1, a.navigator.showInitialNodes(), a.finalInitialize(), a;\n        }\n\n        return n(s, e), s.prototype.createDataObj = function (t) {\n          return new A(this, t);\n        }, s.prototype.getData = function (t) {\n          return e.prototype.getData.call(this, t);\n        }, s.prototype.onSettingsChanged = function (t) {\n          var e = {};\n          this.layer.onSettingsChanged(t), t.navigation && t.navigation.mode && (this.events.removeElement(this.navigator), this.navigator = D.CreateNavigator(this), this.events.addElement(this.navigator));\n          var i = !(!t.navigation || !t.navigation.mode && !t.navigation.initialNodes);\n\n          if (t.data && t.data.length) {\n            var n = t.data[0];\n            (n.dataFunction || n.format || n.preloaded || n.url || n.randomNodes) && (i = !0);\n          }\n\n          i && (this.navigator.showInitialNodes(), this.autoZoom.resetZoom = !0), t.filters && (e.filters = !0), t.style && (e.style = !0), t.layout && t.layout.mode && (this.events.removeElement(this.layout), this.layout = r.LayoutBase.ConstructLayout(this), this.events.addElement(this.layout), this.isLayoutFrozen = !1), this.events.notifySceneChanges(e);\n        }, s.prototype.save = function () {\n          var t = this.graph.save(),\n              e = this.navigator.save();\n          return JSON.stringify({\n            xy: t,\n            nav: e\n          });\n        }, s.prototype.restore = function (t, e) {\n          if (t) {\n            var i = JSON.parse(t),\n                n = i.xy,\n                r = i.nav;\n            r && this.navigator.restore(r), n && this.graph.restore(n), this.autoZoom.resetZoom = !0;\n          }\n        }, s.prototype.saveNavigation = function () {\n          var t = JSON.stringify(this.navigator.save());\n          return \"{}\" === t ? null : t;\n        }, s.prototype.restoreNavigation = function (t) {\n          this.navigator.restore(JSON.parse(t));\n        }, s.prototype.getCurrentNodes = function () {\n          for (var t = [], e = 0, i = this.layer.nodes(); e < i.length; e++) {\n            var n = i[e];\n            n.removed || t.push(n);\n          }\n\n          return t;\n        }, s.prototype.getCurrentLinks = function () {\n          for (var t = [], e = 0, i = this.layer.links(); e < i.length; e++) {\n            var n = i[e];\n            n.removed || t.push(n);\n          }\n\n          return t;\n        }, s.prototype.getNodeDimensions = function (t) {\n          var e;\n          if (e = d.Helpers.isString(t) ? this.getNode(t) : t, !e) return null;\n          var i = this.scene.toDisplay(e.x, e.y),\n              n = i.x,\n              r = i.y,\n              s = e.hHeight * this.scene.zoom,\n              a = e.hWidth * this.scene.zoom;\n          return {\n            x: n,\n            y: r,\n            radius: s,\n            hwidth: a\n          };\n        }, s.prototype.lockNode = function (t, e, i) {\n          void 0 === e && (e = null), void 0 === i && (i = null), d.Helpers.isObjectOrArray(t) && (t = t.id), this.graph.lockNode(t, e, i);\n        }, s.prototype.unlockNode = function (t) {\n          t.id && (t = t.id), this.graph.unlockNode(t);\n        }, s.prototype.addFocusNode = function (t, e) {\n          return t.id && (t = t.id), this.settings.navigation.autoZoomOnFocus && (this.scene.autoZoomMode = !0), this.focusNodeStack.push(t), this.navigator.focusNode(t, e, \"api\");\n        }, s.prototype.getLastFocusNode = function () {\n          for (; this.focusNodeStack.length > 0;) {\n            var t = this.focusNodeStack[this.focusNodeStack.length - 1],\n                e = d.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null;\n            if (e && e.focused) return e;\n            this.focusNodeStack.pop();\n          }\n\n          if (this.settings.navigation.initialNodes) for (var i = 0; i < this.settings.navigation.initialNodes.length; i++) {\n            var t = this.settings.navigation.initialNodes[i],\n                e = d.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null;\n            if (e) return e;\n          }\n          var n = this.layer.nodes();\n          return n.length > 0 ? n[0] : null;\n        }, s.prototype.clearFocus = function () {\n          this.navigator.clearFocusNodes(\"api\");\n        }, s.prototype.removeFocusNode = function (t) {\n          return t.id && (t = t.id), this.navigator.unfocusNode(t, \"api\");\n        }, s.prototype.expandNode = function (t) {\n          return t.id && (t = t.id), this.navigator.expandNode(t, \"api\");\n        }, s.prototype.collapseNode = function (t) {\n          return t.id && (t = t.id), this.navigator.collapseNode(t, \"api\");\n        }, s.prototype.closeNode = function (t) {\n          return t.id && (t = t.id), this.navigator.closeNode(t, \"api\");\n        }, s.prototype.hideNode = function (t) {\n          return t.id && (t = t.id), this.navigator.hideNode(t, \"api\");\n        }, s.prototype.showNode = function (t) {\n          return this.navigator.showNode(t, \"api\");\n        }, s.prototype.getNode = function (t) {\n          return this.layer.idToNode[t];\n        }, s.prototype.getLink = function (t) {\n          return this.layer.idToLink[t];\n        }, s.prototype.touchObjects = function (t) {\n          for (var e = 0; e < t.length; e++) {\n            var i = this.layer,\n                n = i.findObjectById(t[e]);\n            n && i.touchNodeOrLink(n);\n          }\n        }, s.prototype.setZoom = function (t, e) {\n          this.autoZoom.setZoom(t, e);\n        }, s.prototype.resetLayout = function () {\n          this.layout.resetLayout(), this.autoZoom.setZoom(\"overview\", !1), this.events.notifySceneChanges({\n            layout: !0\n          });\n        }, s.prototype.removeData = function (t, e) {\n          if (void 0 === e && (e = \"default\"), null == e && (e = \"default\"), !this.removed) {\n            var i = this.getData(e),\n                n = i.removeData(t);\n            n.data = {}, n.data[e] = !0, this.events.notifySceneChanges(n);\n          }\n        }, s.prototype.exportData = function (t, e) {\n          var i;\n          return i = t ? this.graph.exportData() : this.scene.mainData.exportData(), e && this.graph.exportCoordinates(i.nodes), i;\n        }, s.prototype.hideMenu = function () {\n          this.menu.hideMenu();\n        }, s.prototype.showNodeMenu = function (t) {\n          this.menu.showNodeMenu(t);\n        }, s.prototype.createEventArguments = function (t, i) {\n          var n = e.prototype.createEventArguments.call(this, t, i),\n              r = this.layer;\n          return r && (n.nodes = r.nodes(), n.links = r.links()), n;\n        }, s.prototype.defaultClick = function (t, e) {\n          if (!t.shiftKey && !t.ctrlKey) {\n            var i = e.clickNode;\n            i && this.scene.settings.navigation.expandOnClick && (i.expanded || (this.expandNode(i.id), t.preventDefault()));\n          }\n        }, s.prototype.defaultRightClick = function (t, e) {\n          e.clickNode && (this.scene.mainData.getLinks(e.clickNode.id), this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault());\n        }, s.prototype.defaultDoubleClick = function (t, e) {\n          var i = e.clickNode;\n          i && (this.addFocusNode(i.id, -1), t.preventDefault());\n        }, s.prototype.scrollIntoView = function (t, e) {\n          for (var i, n = [], r = 0; r < t.length; r++) {\n            var s = t[r];\n            s instanceof u.Node ? n.push(s) : d.Helpers.isString(s) && (i = this.getNode(s)) ? n.push(i) : this.error(\"scrollIntoView: the argument is not a node or the ID cannot be found: `\" + s + \"`.\");\n          }\n\n          this.autoZoom.scrollIntoView(n, e);\n        }, s.prototype.freezeLayout = function () {\n          this.isLayoutFrozen || (this.events.removeElement(this.layout), this.isLayoutFrozen = !0, this.events.notifySceneChanges({\n            layout: !0\n          }));\n        }, s.prototype.unfreezeLayout = function () {\n          this.isLayoutFrozen && (this.events.addElement(this.layout), this.isLayoutFrozen = !1, this.events.notifySceneChanges({\n            layout: !0\n          }));\n        }, s.prototype.remove = function () {\n          e.prototype.remove.call(this), this.info.remove(), this.menu.remove();\n        }, s;\n      }(u.Impl);\n\n      t.Impl = H;\n    }(h = i.NetChart || (i.NetChart = {})), function (t) {\n      var e = t.Bar || (t.Bar = {}),\n          i = t.Series || (t.Series = {}),\n          r = t.Renderers || (t.Renderers = {}),\n          s = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.panel = new d.SettingsLegendPanel(\"bottom\", \"left\", void 0, 95), e.advanced = new o(), e.marker = new a(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegend);\n\n      t.SettingsLegend = s;\n\n      var a = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.shape = null, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegendMarker);\n\n      t.SettingsLegendMarker = a;\n\n      var o = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.disabledSeries = {\n            fillColor: \"rgba(191,187,185,0.3)\",\n            lineColor: \"rgba(64,62,62,0.3)\",\n            textColor: \"rgba(64,62,62,0.3)\"\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegendAdvanced);\n\n      t.SettingsLegendAdvanced = o;\n\n      var l = function (t) {\n        function e(e, i, n, r, s, a, o) {\n          var l = t.call(this, i, n, r, s) || this;\n          return l.seriesHovered = !1, l.disabledSeries = o, l.series = e, l.enabled = a, l;\n        }\n\n        return n(e, t), e.prototype.isHovered = function () {\n          return this.hoverCount > 0 || this.seriesHovered;\n        }, e;\n      }(d.LegendEntry),\n          h = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.paintOrder = 75, i.updateOrder = 100, i;\n        }\n\n        return n(e, t), e.prototype.notifyHoveredSeries = function (t) {\n          for (var e = 0; e < this.entries.length; e++) {\n            var i = this.entries[e];\n            i.seriesHovered = i.series.indexOf(t) >= 0;\n          }\n        }, e.prototype.getLastHoveredSeries = function () {\n          var t = this.getLastHoveredEntry();\n          return t ? t.series[0] : null;\n        }, e.prototype.onSceneChange = function (e) {\n          t.prototype.onSceneChange.call(this, e);\n          var i = e.changes;\n          i.linearChartSeries && (this.rebuildItems(e), i.bounds = !0);\n        }, e.prototype.paintMarker = function (t, e, i, n, s) {\n          var a = t.context,\n              o = s.isEnabled() ? s.series[0] : s.disabledSeries,\n              l = this.settings.marker,\n              h = o.style.legend.marker,\n              u = h.shape || l.shape;\n\n          if (a.beginPath(), u) {\n            var c = {\n              fillColor: h.fillColor || o.style.fillColor || o.style.lineColor,\n              lineColor: h.lineColor || l.lineColor,\n              lineWidth: h.lineWidth || 1\n            };\n            null != h.width && (n = h.width / 2), d.Graphics.strokeMarker(a, u, e, i, n), d.Graphics.paint(a, c);\n          } else {\n            var p = l.size,\n                f = e - p / 2,\n                g = e,\n                v = e + p / 2,\n                m = p / 2.1,\n                y = p / 2,\n                S = 3 * p / 4,\n                b = i + p / 2;\n\n            if (o instanceof C) {\n              var L = o.style.marker.width;\n              o.style.marker.width *= .8;\n              var T = [[m, y, S]],\n                  k = [f, g, v],\n                  M = [k, [b - m, b - y, b - S]],\n                  A = b - y,\n                  I = new r.Line(null, [o]);\n              I.paintLines(a, [o], [{\n                markerY: null,\n                segments: M\n              }], k, [null], T, b), I.paintMarkers(a, o, [g], [y], [A]), o.style.marker.width = L;\n            } else if (o instanceof x) {\n              var T = [p, p],\n                  P = new r.Columns(this.chart.scene, [o]);\n              P.paintStack(t, [e], [p / 2], [T], [null], b, !1);\n            } else if (o instanceof w) {\n              var D = new r.Candlestick(this.chart.scene, [o]),\n                  N = [[0], [p / 3], [2 * p / 3], [p]];\n              D.paintStack(t, [e], [p / 2], N, [null], b, !1);\n            }\n          }\n        }, e.prototype.rebuildItems = function (t) {\n          for (var e = [], n = this.chart.scene.settings._computedSeries, r = this.settings.advanced.disabledSeries, s = {}, a = this.settings.text.fillColor, o = 0; o < n.length; o++) {\n            var h = n[o];\n\n            if (h.showInLegend) {\n              var u = void 0;\n\n              if (h instanceof w) {\n                if (d.Helpers.hasProperty(s, h.stack)) {\n                  s[h.stack].push(h);\n                  continue;\n                }\n\n                u = [h], s[h.stack] = u;\n              } else u = [h];\n\n              var c = h.nameLegend || h.name || this.chart.settings.localization.unnamedSeries,\n                  p = d.Helpers.realClone(h),\n                  f = p.style;\n              f.fillColor = f._currentFillStyle = f.fillColor && r.fillColor, f._currentFillStyleKey = null, f.fillPattern && (f._fillPatternOpacity = .3, i.Stack.computeFillPattern(this.chart, t.context, f)), f.lineColor = r.lineColor;\n              var g = f.legend.marker;\n              g.fillColor = g.fillColor && r.fillColor, g.lineColor = g.lineColor && r.lineColor, e.push(new l(u, c, h.style.legend.textColor || a, r.textColor, h.legendGroupId, h.enabled, p));\n            }\n          }\n\n          this.resetEntries(e);\n        }, e.prototype.itemClicked = function (e, i) {\n          t.prototype.itemClicked.call(this, e, i);\n\n          for (var n = 0; n < this.entries.length; n++) {\n            for (var r = this.entries[n], s = 0; s < r.series.length; s++) {\n              r.series[s].enabled = r.enabled;\n            }\n          }\n\n          this.chart.events.notifySceneChanges({\n            linearChartSeries: !0\n          });\n        }, e;\n      }(d.Legend);\n\n      t.Legend = h, function (t) {\n        var e = function () {\n          function t(t, e, i, n, r) {\n            this.topStyle = t, this.bottomStyle = t, this.ctop = e, this.cFillHeight = i, this.cleft = n, this.cwidth = r;\n          }\n\n          return Object.defineProperty(t.prototype, \"cbottom\", {\n            get: function get() {\n              return this.ctop + this.cFillHeight;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"cright\", {\n            get: function get() {\n              return this.cleft + this.cwidth;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"ccenterX\", {\n            get: function get() {\n              return this.cleft + this.cwidth / 2;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), t.prototype.ensureRange = function (t, e, i, n, r) {\n            var s = e + i,\n                a = this.ctop,\n                o = this.cbottom;\n            e < a && (a = e, this.ctop = e, this.topStyle = t, this.cleft = n, this.cwidth = r), s > o && (o = s, this.bottomStyle = t, this.cleft = n, this.cwidth = r), this.ctop = a, this.cFillHeight = o - a;\n          }, t;\n        }(),\n            i = function () {\n          function t(t, e) {\n            this.series = e, this.scene = t, this.prevys = [];\n          }\n\n          return t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n            var l = t.length;\n            if (!(l > 1)) return {\n              result: null,\n              distance: 1 / 0\n            };\n            var h = this.series,\n                u = d.Helpers.binSearch(t, s),\n                c = t[u] - e[u],\n                p = t[u] + e[u];\n\n            if (u > 0) {\n              var f = t[u - 1] - e[u - 1],\n                  g = t[u - 1] + e[u - 1];\n              (g > s || Math.abs(g - s) < Math.abs(c - s)) && (u -= 1, c = f, p = g);\n            }\n\n            for (var v = null, m = 1 / 0, y = r, S = 0; S < h.length; S++) {\n              var b = i[S][u];\n\n              if (d.Helpers.isNumber(b)) {\n                var x = y - b,\n                    C = Math.min(y, x),\n                    w = Math.max(y, x),\n                    L = d.Geometry.distanceToRect(s, a, c, C, p, w);\n                L <= m && (m = L, v = {\n                  x0: c,\n                  y0: C,\n                  x1: p,\n                  y1: w,\n                  seriesIndex: S,\n                  isMarker: !1\n                }), y = x;\n              }\n            }\n\n            return {\n              result: v,\n              distance: m\n            };\n          }, t.prototype.paintStack = function (t, e, i, n, r, s, a, o) {\n            if (this.zeroY = s, e.length > 0) {\n              var l = this.series;\n              this.initPrevYs(l, e.length, s), this.computeBaseYs(l, e.length, n), this.connectorLines = {}, this.drawStackedColumns(l, r, o, t, e, i, n, a), this.drawConnectorLines(t.context);\n            }\n          }, t.prototype.computeBaseYs = function (t, e, i) {\n            for (var n = 1; n < t.length; n++) {\n              for (var r = i[n - 1], s = this.prevys[n - 1], a = this.prevys[n], o = 0; o < e; o++) {\n                a[o] = s[o];\n                var l = r[o];\n\n                if (d.Helpers.isNumber(l)) {\n                  var h = s[o],\n                      u = h - l;\n                  a[o] = u;\n                }\n              }\n            }\n          }, t.prototype.initPrevYs = function (t, e, i) {\n            if (this.prevys.length < t.length) {\n              this.prevys = new Array(t.length);\n\n              for (var n = 0; n < this.prevys.length; n++) {\n                this.prevys[n] = new Array(t.length);\n              }\n            }\n\n            for (var n = 0; n < t.length; n++) {\n              this.prevys[n].length < e && (this.prevys[n] = new Array(e));\n            }\n\n            if (t.length > 0) for (var n = 0; n < t.length; n++) {\n              for (var r = 0; r < e; r++) {\n                this.prevys[n][r] = i;\n              }\n            }\n          }, t.prototype.drawStackedColumns = function (t, e, i, n, r, s, a, o) {\n            for (var l = t.length - 1; l >= 0; l--) {\n              var h = t[l],\n                  u = e[l],\n                  c = i && i.length ? i[l] : null;\n              this.plainColumns(n, h.style, r, s, this.prevys[l], a, u, l, o, c);\n            }\n          }, t.prototype.drawConnectorLines = function (t) {\n            for (var e in this.connectorLines) {\n              for (var i = this.connectorLines[e], n = null, r = 0; r < i.length; r++) {\n                var s = i[r];\n                null !== s && (null !== n && this.drawConnectorLine(t, n, s), n = s);\n              }\n            }\n          }, t.prototype.drawConnectorLine = function (t, e, i) {\n            var n = this.determineConnectorLineYAndStyle(e, i, e.ccenterX, i.ccenterX),\n                r = n.startY,\n                s = n.endY,\n                a = n.style1,\n                o = n.style2,\n                l = this.selectConnectorLineXPosition(a.connectorLinePositionX, e.cright, e.ccenterX, e.cleft),\n                h = this.selectConnectorLineXPosition(o.connectorLinePositionX, i.cleft, i.ccenterX, i.cright),\n                u = (l + h) / 2,\n                c = (r + s) / 2;\n            this.drawLine(t, a, l, r, u, c), this.drawLine(t, o, u, c, h, s);\n          }, t.prototype.selectConnectorLineXPosition = function (t, e, i, n) {\n            var r = e;\n\n            switch (t) {\n              case \"edge\":\n                r = e;\n                break;\n\n              case \"center\":\n                r = i;\n                break;\n\n              case \"full\":\n                r = n;\n                break;\n\n              default:\n                d.Helpers.warn(\"Warning: \" + t + \" is not a valid connector line position.\");\n            }\n\n            return r;\n          }, t.prototype.drawLine = function (t, e, i, n, r, s) {\n            var a = d.Graphics.beginStroke(t, e);\n            a.moveTo(i, n), a.lineTo(r, s), d.Graphics.endStroke(t, a, e);\n          }, t.prototype.determineConnectorLineYAndStyle = function (t, e, i, n) {\n            for (var r = t.ctop, s = t.cbottom, a = e.ctop, o = e.cbottom, l = t.topStyle, h = t.bottomStyle, u = e.topStyle, c = e.bottomStyle, d = [[this.distSq(i, n, r, a), r, a, l, u], [this.distSq(i, n, r, o), r, o, l, c], [this.distSq(i, n, s, a), s, a, h, u], [this.distSq(i, n, s, o), s, o, h, c]], p = Number.POSITIVE_INFINITY, f = 0, g = Number.NEGATIVE_INFINITY, v = 0; v < d.length; v++) {\n              var m = d[v][0];\n\n              if (m <= p) {\n                var y = d[v][1] + d[v][2];\n                if (m === p && y < g) continue;\n                f = v, p = m, g = y;\n              }\n            }\n\n            var S = d[f],\n                b = S[1],\n                x = S[2],\n                C = S[3],\n                w = S[4];\n            return {\n              startY: b,\n              endY: x,\n              style1: C,\n              style2: w\n            };\n          }, t.prototype.distSq = function (t, e, i, n) {\n            var r = e - t,\n                s = n - i;\n            return r * r + s * s;\n          }, t.prototype.plainColumns = function (t, e, i, n, r, s, a, o, l, h) {\n            for (var u, c, p, f, g, v = t.context, m = this.scene.y0, y = this.scene.height, S = e.minHeight, b = m + y, x = s[o], C = null, w = 0; w < i.length; w++) {\n              var L = i[w],\n                  T = x[w];\n\n              if (d.Helpers.isNumber(T)) {\n                var k = n[w],\n                    M = r[w],\n                    A = M - T,\n                    I = L - k,\n                    P = k + k,\n                    D = void 0,\n                    N = void 0,\n                    F = void 0,\n                    O = void 0,\n                    E = !0,\n                    R = M == A && l;\n\n                if (M < A) {\n                  E = !1, D = Math.max(A - M, S), F = l ? this.zeroY : M, N = l ? D + (M - this.zeroY) : D;\n\n                  for (var H = !0, z = o - 1; z > 0;) {\n                    if (null !== s[z][w]) {\n                      H = !1;\n                      break;\n                    }\n\n                    z--;\n                  }\n\n                  O = H;\n                } else {\n                  if (!(M > A || R)) continue;\n                  D = R ? 0 : Math.max(M - A, S), F = M - D, N = l ? this.zeroY - F : D;\n\n                  for (var B = !0, z = o + 1; z < s.length;) {\n                    if (null !== s[z][w]) {\n                      B = !1;\n                      break;\n                    }\n\n                    z++;\n                  }\n\n                  O = B;\n                }\n\n                U = this.determineItemStyle(a, w, e, C, g, c, u, p, f, v, b, y, P, L, D, F), C = U.curStyle, g = U.strokeWidth, c = U.shadowColor, u = U.depth, p = U.fillStyle, f = U.depthColor, I += P / 2, P *= Math.min(Math.max(C.widthScale, 0), 1), I -= P / 2, this.paintDepthShade(f, v, C, O, I, P, F, u, D, p, c), this.buildConnectionLines(C, i, w, F, N, I, P), this.fill(p, C, E, v, N, P, I, F, f, c), G = this.stroke(g, F, I, P, D, v, C, E, M, L, p, f, c), F = G.ctop, I = G.cleft, P = G.cwidth, D = G.cheight, T = this.paintPreview(C, h, w, v, A, M, T, I, P);\n              }\n            }\n\n            var U, G;\n          }, t.prototype.buildConnectionLines = function (t, i, n, r, s, a, o) {\n            if (null !== t.connectorLineID) {\n              var l = this.getConnectorArray(t.connectorLineID, i),\n                  h = l[n];\n              null === h ? l[n] = new e(t, r, s, a, o) : h.ensureRange(t, r, s, a, o);\n            }\n          }, t.prototype.getConnectorArray = function (t, e) {\n            var i = this.connectorLines[t];\n\n            if (void 0 === i) {\n              i = new Array(e.length);\n\n              for (var n = 0; n < i.length; n++) {\n                i[n] = null;\n              }\n\n              this.connectorLines[t] = i;\n            }\n\n            return i;\n          }, t.prototype.determineItemStyle = function (t, e, i, n, r, s, a, o, l, h, u, c, p, f, g, v) {\n            var m = t ? t[e] || i : i;\n\n            if (n !== m) {\n              n = m, r = n.enableOutlineLines && n.lineColor ? n.lineWidth : 0, s = n.shadowColor, a = n.depth, o = n._currentFillStyle;\n              var y = n.gradient,\n                  S = d.Helpers.isString(o);\n\n              if (S && a ? (l = n.fillColor, d.Helpers.isNumber(n.depthBrightness) && (l = d.Colors.derive(l, n.depthBrightness, 1))) : l = null, y && 1 !== y && S) {\n                var b = h.createLinearGradient(0, u, 0, u - 2 * c / 3);\n                b.addColorStop(0, d.Colors.derive(o, y, 1)), b.addColorStop(1, o), o = b;\n              }\n\n              h.fillStyle = o;\n            }\n\n            if (n.fillGradientMode) {\n              var x = n.fillGradient ? n.fillGradient : [],\n                  C = this.determineBarGradient(n, p, h, f, g, v);\n\n              if (\"cylinder\" === n.fillGradientType) {\n                var w = d.Colors.parse(n.fillColor);\n                x.push([0, d.Colors.format(d.Colors.derive(w, .6, 1))]), x.push([.25, d.Colors.format(d.Colors.derive(w, .8, 1))]), x.push([.75, d.Colors.format(d.Colors.derive(w, 1.1, 1))]), x.push([1, d.Colors.format(d.Colors.derive(w, .8, 1))]);\n              }\n\n              if (C) {\n                for (var L = 0, T = x; L < T.length; L++) {\n                  var k = T[L];\n                  C.addColorStop(k[0], k[1]);\n                }\n\n                h.fillStyle = C;\n              }\n            }\n\n            return {\n              curStyle: n,\n              strokeWidth: r,\n              shadowColor: s,\n              depth: a,\n              fillStyle: o,\n              depthColor: l\n            };\n          }, t.prototype.determineBarGradient = function (t, e, i, n, r, s) {\n            return \"horizontal\" === t.fillGradientMode && e > 2 ? i.createLinearGradient(n - e / 2, 0, n + e / 2, 0) : \"vertical\" === t.fillGradientMode && r > 2 ? i.createLinearGradient(0, s, 0, s + r) : null;\n          }, t.prototype.paintDepthShade = function (t, e, i, n, r, s, a, o, l, h, u) {\n            t && (e.beginPath(), d.Graphics.applyShadow(e, i), n ? (e.moveTo(r + o, a - o), e.lineTo(r + s + o, a - o), e.lineTo(r + s + o, a + l - o), e.lineTo(r + s, a + l), e.lineTo(r + s, a), e.lineTo(r, a)) : (e.moveTo(r + s, a), e.lineTo(r + s + o, a - o), e.lineTo(r + s + o, a + l - o), e.lineTo(r + s, a + l), e.lineTo(r + s, a)), e.closePath(), e.fillStyle = t, e.fill(), d.Graphics.clearShadow(e), e.fillStyle = h), !t && u && d.Graphics.applyShadow(e, i);\n          }, t.prototype.fill = function (t, e, i, n, r, s, a, o, l, h) {\n            if (t) {\n              var u = e.radius;\n\n              if (u[0] || u[1] || u[2] || u[3]) {\n                var c = [];\n                i ? c = u : (c[0] = u[2], c[1] = u[3], c[2] = u[0], c[3] = u[1]), n.beginPath();\n                var p = r / 2,\n                    f = s / 2;\n                c[0] ? (n.moveTo(a, o + Math.min(p, c[0])), n.quadraticCurveTo(a, o, a + Math.min(f, c[0]), o)) : n.moveTo(a, o), c[1] ? (n.lineTo(a + s - Math.min(c[1], f), o), n.quadraticCurveTo(a + s, o, a + s, o + Math.min(c[1], p))) : n.lineTo(a + s, o), c[2] ? (n.lineTo(a + s, o + r - Math.min(c[2], p)), n.quadraticCurveTo(a + s, o + r, a + s - Math.min(c[2], f), o + r)) : n.lineTo(a + s, o + r), c[3] ? (n.lineTo(a + Math.min(f, c[3]), o + r), n.quadraticCurveTo(a, o + r, a, o + r - Math.min(p, c[2]))) : n.lineTo(a, o + r), n.closePath(), n.fill();\n              } else n.fillRect(a, o, s, r);\n\n              !l && h && d.Graphics.clearShadow(n);\n            }\n          }, t.prototype.stroke = function (t, e, i, n, r, s, a, o, l, h, u, c, p) {\n            if (t > 0) {\n              e += t / 2, i += t / 2, n -= t, r -= t;\n              var f = r / 2,\n                  g = n / 2,\n                  v = d.Graphics.beginStroke(s, a);\n              if (n > 0) {\n                if (r > 0) {\n                  var m = a.radius,\n                      y = [];\n                  o ? y = m : (y[0] = m[2], y[1] = m[3], y[2] = m[0], y[3] = m[1]), y[0] ? (v.moveTo(i, e + Math.min(f, y[0])), v.quadraticCurveTo(i, e, i + Math.min(g, y[0]), e)) : v.moveTo(i, e), y[1] ? (v.lineTo(i + n - Math.min(y[1], g), e), v.quadraticCurveTo(i + n, e, i + n, e + Math.min(y[1], f))) : v.lineTo(i + n, e), y[2] ? (v.lineTo(i + n, e + r - Math.min(y[2], f)), v.quadraticCurveTo(i + n, e + r, i + n - Math.min(y[2], g), e + r)) : v.lineTo(i + n, e + r), y[3] ? (v.lineTo(i + Math.min(g, y[3]), e + r), v.quadraticCurveTo(i, e + r, i, e + r - Math.min(f, y[2]))) : v.lineTo(i, e + r), v.closePath();\n                } else t > 0 && (s.moveTo(i, l), s.lineTo(i + n, l));\n              } else t > 0 && (s.moveTo(h, e), s.lineTo(h, e + r));\n              d.Graphics.endStroke(s, v, a);\n            }\n\n            return u || c || !p || d.Graphics.clearShadow(s), {\n              ctop: e,\n              cleft: i,\n              cwidth: n,\n              cheight: r\n            };\n          }, t.prototype.paintPreview = function (t, e, i, n, r, s, a, o, l) {\n            if (!e || !e[i]) return a;\n            var h = t.previewLineColor;\n            n.beginPath();\n\n            for (var u = 0, c = r - s, d = e[i], p = 0; p < d.length; p++) {\n              var f = d[p];\n              u += f, a = s + u * c, n.moveTo(o, a), n.lineTo(o + l, a);\n            }\n\n            return n.lineWidth = 1, n.strokeStyle = h, n.stroke(), a;\n          }, t;\n        }();\n\n        t.Columns = i;\n\n        var n = function () {\n          function t(t, e) {\n            this.stack = t, this.series = e, this.seriesData = [];\n\n            for (var i = 0; i < e.length; i++) {\n              this.seriesData.push({\n                markerY: [],\n                segments: []\n              });\n            }\n\n            this.prevyL = [], this.prevyR = [];\n          }\n\n          return t.prototype.paintStack = function (t, e, i, n, r, s, a) {\n            if (0 !== e.length) {\n              var o = t.context;\n              this.paintLines(o, this.series, this.seriesData, e, i, n, s);\n\n              for (var l = 0; l < this.series.length; l++) {\n                var h = this.series[l];\n                h.style.markerStyleFunction ? this.paintCustomMarkers(o, h, e, n[l], this.seriesData[l].markerY) : this.paintMarkers(o, h, e, n[l], this.seriesData[l].markerY);\n              }\n            }\n          }, t.prototype.paintLines = function (t, e, i, n, r, s, a) {\n            this.computeLineSegments(n, r, a, s);\n\n            for (var o = [[-(1 / 0), 0, 1 / 0], [a, a, a]], l = 0; l < e.length; l++) {\n              var h = e[l];\n              this.paintLine(t, h.style, o, i[l].segments, a), l < e.length - 1 && (o = this.mergePreviousSegments(o, this.seriesData[l].segments));\n            }\n          }, t.prototype.mergePreviousSegments = function (t, e) {\n            for (var i = [], n = [], r = 0, s = t[0], a = t[1], o = 0; o < e.length; o += 2) {\n              for (var l = e[o], h = e[o + 1]; s[r] <= l[0];) {\n                i.push(s[r]), n.push(a[r]), r++;\n              }\n\n              for (s[r - 1] !== l[0] && (i.push(l[0]), n.push(a[r - 1])), i.push.apply(i, l), n.push.apply(n, h); s[r] < l[l.length - 1];) {\n                r++;\n              }\n\n              l[l.length - 1] !== s[r] && (i.push(l[l.length - 1]), n.push(a[r]));\n            }\n\n            for (; r < s.length;) {\n              i.push(s[r]), n.push(a[r]), r++;\n            }\n\n            return [i, n];\n          }, t.prototype.paintCustomMarkers = function (t, e, i, n, r) {\n            var s = e.style.markerStyleFunction(this.stack.externalItems(), n);\n            if (!s || s.length !== n.length) return void d.Helpers.error(\"markerStyleFunction() must return an array with the same number of elements as the input arrays.\");\n\n            for (var a = e.style.marker, o = 0; o < n.length; o++) {\n              var l = s[o];\n              l && l.shape && (l.fillColor || (l.fillColor = a.fillColor || e.style.lineColor || e.style.fillColor), l.width || (l.width = a.width || 10), t.beginPath(), d.Graphics.strokeMarker(t, l.shape, i[o], r[o], l.width / 2), d.Graphics.paint(t, l));\n            }\n          }, t.prototype.paintMarkers = function (t, e, i, n, r) {\n            var s = e.style.marker;\n\n            if (s.shape) {\n              var a = {\n                fillColor: s.fillColor || e.style.lineColor || e.style.fillColor,\n                lineColor: s.lineColor,\n                lineWidth: s.lineWidth\n              },\n                  o = s.width / 2,\n                  l = s.shape;\n              t.beginPath();\n\n              for (var h = 0; h < n.length; h++) {\n                var u = n[h];\n                null !== u && d.Graphics.strokeMarker(t, l, i[h], r[h], o);\n              }\n\n              d.Graphics.paint(t, a);\n            }\n          }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n            var l = this.series,\n                h = t.length;\n            if (0 === h) return {\n              result: null,\n              distance: 1 / 0\n            };\n\n            for (var u = Math.min(d.Helpers.binSearch(t, s), h - 2), c = null, p = 1 / 0, f = r - a, g = 0; g < l.length; g++) {\n              for (var v = l[g], m = v.style, y = this.seriesData[g], S = Math.max(0, u - 2); S < Math.min(h, u + 3); S++) {\n                var b = i[g][S];\n\n                if (null !== b && m.marker) {\n                  var x = t[S],\n                      C = y.markerY[S],\n                      w = m.marker.width / 2,\n                      L = s - x,\n                      T = a - C,\n                      k = Math.sqrt(L * L + T * T);\n                  k < w + o && p > k - w && (p = k - w, c = {\n                    x0: x,\n                    y0: C,\n                    x1: x,\n                    y1: C,\n                    seriesIndex: g,\n                    isMarker: !0\n                  });\n                }\n              }\n\n              for (var M = null, A = y.segments, S = 0; S < A.length; S += 2) {\n                for (var I = A[S], P = A[S + 1], D = I[0], N = 1; N < I.length; N++) {\n                  var F = I[N];\n\n                  if (D <= s + o && F >= s - o) {\n                    var O = P[N - 1],\n                        E = P[N],\n                        R = Math.sqrt(d.Geometry.distanceToSegmentSq(D, O, F, E, s, a));\n                    R < o && R <= p && (p = R, c = {\n                      x0: D,\n                      y0: O,\n                      x1: F,\n                      y1: E,\n                      seriesIndex: g,\n                      isMarker: !1\n                    });\n                  }\n\n                  if (D <= s && F >= s) {\n                    var O = P[N - 1],\n                        E = P[N],\n                        H = d.Geometry.lineIntersectsSegment(s, a, 0, 1, D, O, F, E);\n                    H !== 1 / 0 && (M = H);\n                  }\n\n                  D = F;\n                }\n              }\n\n              null !== M && (d.Helpers.sign(M) !== d.Helpers.sign(f) && (m.fillColor || m.fillGradient) && p >= 0 && (p = 0, c = {\n                x0: 0,\n                y0: 0,\n                x1: 1,\n                y1: 1,\n                seriesIndex: g,\n                isMarker: !1\n              }), f = M);\n            }\n\n            return {\n              result: c,\n              distance: Math.max(p, 0)\n            };\n          }, t.prototype.computeLineSegments = function (t, e, i, n) {\n            var r = t.length,\n                s = this.prevyL,\n                a = this.prevyR;\n            s.length < r && (s.length = r, a.length = r);\n\n            for (var o = 0; o < r; o++) {\n              s[o] = i, a[o] = i;\n            }\n\n            for (var l = s, h = 0; h < this.series.length; h++) {\n              var u = this.series[h],\n                  c = this.seriesData[h];\n\n              if (c.segments.length = 0, c.markerY.length < r && (c.markerY.length = r), u.style.steps) {\n                var d = this.buildStepSegments(t, e, i, s, a, l, n[h], u.data.noDataPolicy);\n                c.segments = d.segments, c.markerY = d.markerY;\n              } else {\n                var p = this.buildLineSegments(t, i, s, a, l, n[h], u.data.noDataPolicy);\n                if (c.segments = p.segments, c.markerY = p.markerY, u.style.smoothing) for (var f = 0; f < c.segments.length; f += 2) {\n                  var g = this.smoothLine(c.segments[f], c.segments[f + 1]);\n                  c.segments[f] = g.x, c.segments[f + 1] = g.y;\n                }\n              }\n\n              l = c.markerY;\n            }\n          }, t.prototype.buildLineSegments = function (t, e, i, n, r, s, a) {\n            var o = [],\n                l = [],\n                h = [];\n\n            if (\"zero\" === a) {\n              for (var u = 0; u < t.length; u++) {\n                var c = t[u],\n                    d = s[u],\n                    p = i[u],\n                    f = n[u];\n                null !== d ? (o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d) : (o.push(r[u]), p !== f ? (h.push(p), h.push(f), l.push(c), l.push(c)) : (h.push(p), l.push(c)));\n              }\n\n              return {\n                segments: [l, h],\n                markerY: o\n              };\n            }\n\n            if (\"join\" === a) {\n              for (var g = null, u = 0; u < t.length; u++) {\n                var c = t[u],\n                    d = s[u],\n                    p = i[u],\n                    f = n[u];\n\n                if (null !== d) {\n                  if (null === g) o.push(r[u] - d), l.push(c), h.push(f - d), n[u] -= d;else {\n                    if (g < u - 1) for (var v = s[g], m = t[g], y = (d - v) / (c - m), S = g + 1; S < u; S++) {\n                      var b = t[S],\n                          x = v + y * (b - m);\n                      o.push(r[S] - x);\n                      var C = i[S],\n                          w = n[S];\n                      l.push(b), h.push(C - x), C !== w && (l.push(b), h.push(w - x)), i[S] -= x, n[S] -= x;\n                    }\n                    o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d;\n                  }\n                  g = u;\n                } else null === g && o.push(r[u]);\n              }\n\n              return l.length > 2 && l[l.length - 1] === l[l.length - 2] && (l.pop(), h.pop()), {\n                segments: [l, h],\n                markerY: o\n              };\n            }\n\n            for (var L = !1, T = [], u = 0; u < t.length; u++) {\n              var c = t[u],\n                  d = s[u],\n                  p = i[u],\n                  f = n[u];\n              null !== d ? (o.push(r[u] - d), L ? (l.length > 1 && i[u - 1] !== n[u - 1] && (l.push(t[u - 1]), h.push(n[u - 1])), l.push(c), h.push(p - d), i[u] -= d, n[u] -= d) : (l.push(c), h.push(f - d), n[u] -= d), L = !0) : (o.push(r[u]), L && (l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h), l = [], h = []), n[u - 1] += s[u - 1]), L = !1);\n            }\n\n            return l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h)), {\n              segments: T,\n              markerY: o\n            };\n          }, t.prototype.buildStepSegments = function (t, e, i, n, r, s, a, o) {\n            for (var l = [], h = [], u = [], c = [], d = null, p = 0, f = 0; f < t.length; f++) {\n              var g = t[f] - e[f],\n                  v = a[f];\n\n              if (null !== v) {\n                null !== d && (u.push(g), c.push(d));\n                var m = s[f] - v;\n                u.push(g), c.push(m), d = m, p = g + 2 * e[f], h.push(m), n[f] = r[f] = m;\n              } else if (\"zero\" === o) {\n                var m = s[f];\n                h.push(m), r[f] = n[f] = m, null !== d && (u.push(p), c.push(d)), u.push(g), c.push(m), d = m, p = g + 2 * e[f];\n              } else if (\"join\" === o) {\n                var m = null !== d ? d : s[f];\n                h.push(m), r[f] = n[f] = m;\n              } else {\n                var m = s[f];\n                h.push(m), r[f] = n[f] = m, u.length > 0 && (null !== d && (u.push(p), c.push(d)), d = null, l.push(u, c), u = [], c = []);\n              }\n            }\n\n            return u.length > 0 && (null !== d && (u.push(p), c.push(d)), l.push(u, c)), {\n              segments: l,\n              markerY: h\n            };\n          }, t.prototype.smoothLine = function (t, e) {\n            var i = t[0],\n                n = t[t.length - 1],\n                r = (n - i) / t.length;\n            if (r < 2) return {\n              x: t,\n              y: e\n            };\n            var s = [],\n                a = [];\n            s.push(i), a.push(e[0]);\n\n            for (var o = 0; o + 1 < t.length;) {\n              var l = o + 1;\n              if (t[o] !== t[l]) for (; l + 1 < t.length && t[l] !== t[l + 1];) {\n                l += 1;\n              }\n              if (l - o === 1) s.push(t[l]), a.push(e[l]);else {\n                var h = new d.MonotoneCurve(t, e, o, l + 1);\n                n = t[o];\n\n                for (var u = o + 1; u <= l; u++) {\n                  i = n, n = t[u];\n                  var c = e[u];\n                  r = n - i;\n\n                  for (var p = Math.ceil(Math.min(50, Math.max(2, r / 3))), f = r / p, g = s.length; (i += f) < n;) {\n                    s.push(i);\n                  }\n\n                  h.interpolateArray(u - 1, s, g, s.length, a), s.push(n), a.push(c);\n                }\n\n                h.clear();\n              }\n              o = l;\n            }\n\n            return t.length = 0, e.length = 0, {\n              x: s,\n              y: a\n            };\n          }, t.prototype.paintLine = function (t, e, i, n, r) {\n            if (e._currentFillStyle) {\n              e.shadowColor && d.Graphics.applyShadow(t, e), t.fillStyle = e._currentFillStyle, t.beginPath();\n\n              for (var s = 0; s < n.length; s += 2) {\n                this.paintArea(t, n[s], n[s + 1], i, r);\n              }\n\n              t.fill(), e.shadowColor && d.Graphics.clearShadow(t);\n            }\n\n            if (e.lineColor) {\n              !e.fillColor && e.shadowColor && d.Graphics.applyShadow(t, e);\n\n              for (var a = d.Graphics.beginStroke(t, e), s = 0; s < n.length; s += 2) {\n                var o = n[s],\n                    l = n[s + 1];\n                a.moveTo(o[0], l[0]);\n\n                for (var h = 1; h < o.length; h++) {\n                  a.lineTo(o[h], l[h]);\n                }\n              }\n\n              d.Graphics.endStroke(t, a, e), !e.fillColor && e.shadowColor && d.Graphics.clearShadow(t);\n            }\n          }, t.prototype.paintArea = function (t, e, i, n, r) {\n            t.moveTo(e[0], i[0]);\n\n            for (var s = 1; s < e.length; s++) {\n              t.lineTo(e[s], i[s]);\n            }\n\n            for (var a = e[0], o = e[e.length - 1], l = r, h = o, u = n.length - 2; u >= 0; u += -2) {\n              var c = n[u],\n                  d = n[u + 1];\n\n              if (!(c.length < 2 || c[0] > h || c[c.length - 1] < a)) {\n                var p = c.length - 1,\n                    f = c[p];\n                f < h && (t.lineTo(h, l), t.lineTo(f, l), h = f);\n                var s = void 0,\n                    g = void 0;\n\n                for (s = p; s >= 0; s--) {\n                  if (g = c[s], h === f) t.lineTo(f, d[s + 1]), h = g;else if (h < f && h > g) {\n                    var v = d[s],\n                        m = d[s + 1],\n                        y = (h - g) / (f - g),\n                        S = v + y * (m - v);\n                    t.lineTo(h, S), h = g;\n                  }\n\n                  if (h <= a) {\n                    h = a;\n                    var v = d[s],\n                        m = d[s + 1],\n                        y = (h - g) / (f - g),\n                        S = v + y * (m - v);\n                    t.lineTo(h, S);\n                    break;\n                  }\n\n                  f = g;\n                }\n\n                s === -1 && h === g && t.lineTo(h, d[0]);\n              }\n            }\n\n            h !== a && (t.lineTo(h, l), t.lineTo(a, l)), t.closePath();\n          }, t;\n        }();\n\n        t.Line = n;\n\n        var r = function () {\n          function t(t, e) {\n            this.series = e, this.scene = t, this.prevy = [];\n          }\n\n          return t.prototype.paintStack = function (t, e, i, n, r, s, a) {\n            if (e.length > 0) {\n              var o = this.series[0];\n              this.seriesEnabled = o.enabled;\n              var l = this.prevy;\n              l.length < e.length && (l = this.prevy = new Array(e.length));\n\n              for (var h = 0; h <= e.length - 1; h++) {\n                l[h] = s;\n              }\n\n              this.plainBar(t.context, o.style, e, i, l, n);\n            }\n          }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {\n            var l = t.length;\n            if (!(l > 1)) return {\n              result: null,\n              distance: 1 / 0\n            };\n            var h = this.series,\n                u = d.Helpers.binSearch(t, s),\n                c = t[u] - e[u],\n                p = t[u] + e[u];\n\n            if (c > s && u > 0) {\n              var f = t[u - 1] - e[u - 1],\n                  g = t[u - 1] + e[u - 1];\n              (g > s || Math.abs(g - s) < Math.abs(c - s)) && (u -= 1, c = f, p = g);\n            }\n\n            for (var v = null, m = 1 / 0, y = r, S = 0; S < h.length; S++) {\n              var b = i[S][u];\n\n              if (null !== b) {\n                var x = y - b,\n                    C = Math.min(y, x),\n                    w = Math.max(y, x),\n                    L = d.Geometry.distanceToRect(s, a, c, C, p, w);\n                L < m && (m = L, v = {\n                  x0: c,\n                  y0: C,\n                  x1: p,\n                  y1: w,\n                  seriesIndex: S,\n                  isMarker: !1\n                }), y = x;\n              }\n            }\n\n            return {\n              result: v,\n              distance: m\n            };\n          }, t.prototype.plainBar = function (t, e, i, n, r, s) {\n            for (var a = 0; a < i.length; a++) {\n              var o = i[a],\n                  l = r[a],\n                  h = s[0][a],\n                  u = s[1][a],\n                  c = s[2][a],\n                  p = s[3][a];\n\n              if (void 0 !== p && null !== p || void 0 !== h && null !== h || void 0 !== u && null !== u || void 0 !== c && null !== c) {\n                var f = (o - n[a] || 0) + .5,\n                    g = (o + n[a] || 0) + .5,\n                    v = (l - p || 0) + .5,\n                    m = (l - h || 0) + .5,\n                    y = (l - u || 0) + .5,\n                    S = (l - c || 0) + .5,\n                    b = this.applyPatternStyle(t, e, y, S);\n\n                if (\"bar\" === e.pattern) {\n                  var x = d.Graphics.beginStroke(t, b);\n                  x.moveTo(o, m), x.lineTo(o, v), x.moveTo(f, y), x.lineTo(o, y), x.moveTo(g, S), x.lineTo(o, S), d.Graphics.endStroke(t, x, b);\n                } else {\n                  var x = d.Graphics.beginStroke(t, b);\n                  x.moveTo(o, m), x.lineTo(o, y), x.moveTo(o, S), x.lineTo(o, v), d.Graphics.endStroke(t, x, b), x = d.Graphics.beginStroke(t, b, !0), x.moveTo(f, y), x.lineTo(g, y), x.lineTo(g, S), x.lineTo(f, S), x.closePath(), d.Graphics.endStroke(t, x, b, !0);\n                }\n\n                e.shadowColor && d.Graphics.clearShadow(t);\n              }\n            }\n          }, t.prototype.applyPatternStyle = function (t, e, i, n) {\n            var r = i >= n ? e.increase : e.decrease,\n                s = \"candlestick\" === e.pattern ? r.candlestick : r.bar,\n                a = s;\n\n            if (!this.seriesEnabled) {\n              a = d.Helpers.realClone(s);\n              var o = this.scene.settings.legend.advanced.disabledSeries;\n              a.lineColor = o.lineColor, void 0 !== a.fillColor && (a.fillColor = o.fillColor);\n            }\n\n            return e.lineColor && e.shadowColor && d.Graphics.applyShadow(t, e), a;\n          }, t;\n        }();\n\n        t.Candlestick = r;\n      }(r = t.Renderers || (t.Renderers = {}));\n\n      var u = function () {\n        function t(t, e, i) {\n          this.scene = e, this.chart = t, this.valueAxis = i;\n        }\n\n        return t.prototype.setSeriesFont = function (t, e, i, n, r, s) {\n          var a = this.scene.dataLabels.metaData,\n              o = 2 * n[0];\n          null === a.styles && (a.styles = {});\n\n          for (var l = 0; l < i.length; l++) {\n            var h = i[l],\n                u = this.getLongestNumber(r[l]);\n            if (a.styles[h.id] = null, u.max === -(1 / 0)) break;\n            var c = this.createContent(u.max, s[u.index], h.valueLabels.contentsFunction) || \"\",\n                d = this.reduceFontWidth(t, e, h.id, h.valueLabels, o, c);\n            d && (a.styles[h.id] = d);\n          }\n        }, t.prototype.scanValueLabels = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = this.chart.shell.getChartInnerArea(), u = this.chart.getBottomHeight(), c = 0; c < 2; c++) {\n            var d = 0 === c ? s : a;\n            if (null !== d) for (var p = 0; p < n.length; p++) {\n              for (var f = n[p], g = this.valueAxis.zeroY, v = 0, m = 0; m < d.length; m++) {\n                var y = o[m][p],\n                    S = d[m][p];\n\n                if (null !== S && null !== y) {\n                  v += y, g -= S;\n                  var b = r[m];\n\n                  if (b.valueLabels && b.valueLabels.enabled) {\n                    var C = b.valueLabels.useStackedValue,\n                        w = this.chart.settings._computedStacks[b.stack],\n                        L = w && \"based\" === w.type;\n\n                    if (null === C && (C = !L), !L || 0 !== S || 0 === v) {\n                      var T = i[0];\n\n                      if (b instanceof x) {\n                        var k = S >= 0 ? 1 : -1,\n                            M = b.style.minHeight;\n                        M && (S = S * k < M ? M * k : S), T *= Math.max(Math.min(b.style.widthScale, 1), 0);\n                      }\n\n                      this.createDrawingSpots(t, h, S, g + S, f, b, C ? v : y, u, T, l[p]);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          this.paintDataLabels(t, e, i[0], r.length);\n        }, t.prototype.createDrawingSpots = function (t, e, i, n, r, s, a, o, l, h) {\n          var u = s.id,\n              c = s.valueLabels.position,\n              p = s.valueLabels.xPosition,\n              f = this.scene.dataLabels,\n              g = r.toFixed(1),\n              v = this.scene.dataLabels.spots[g];\n\n          if (null !== f.metaData.styles[u]) {\n            var m = this.createContent(a, h, s.valueLabels.contentsFunction);\n\n            if (null != m) {\n              var y = new d.LabelLayoutBase().totalPadding(s.valueLabels.style);\n              i = Math.abs(i);\n              var S = this.getPositionVerticalDimensions(t, a, n, i, f.metaData.styles[u], s.valueLabels.minFontSize, c, y);\n\n              if (null !== S) {\n                var b = S.min,\n                    x = S.max,\n                    C = e.findTopPosition(r, Math.min(r + l, this.scene.x0 + this.scene.width));\n                C > b && (x = x - b + C, b = C);\n                var w = this.scene.chartTop + this.scene.chartHeight - this.scene.bottomAxisSize;\n                if (x > w && (b = b - x + w, x = w), v && !s.valueLabels.allowOverlap) for (var L = 0; L < v.length; L++) {\n                  var T = v[L];\n\n                  if (null != T) {\n                    var k = T.edges[0],\n                        M = T.edges[1];\n\n                    if (b < M && x > k) {\n                      if (!(s.type === T.type && a > T.value)) return;\n                      v[L] = null;\n                    }\n                  }\n                }\n                v || (v = this.scene.dataLabels.spots[g] = []);\n                var A = 0;\n\n                switch (p) {\n                  case \"center\":\n                    A = 0;\n                    break;\n\n                  case \"insideRight\":\n                    A = l;\n                    break;\n\n                  case \"centerRight\":\n                    A = 0;\n                    break;\n\n                  case \"outsideRight\":\n                    A = l;\n                    break;\n\n                  case \"insideLeft\":\n                    A = -l;\n                    break;\n\n                  case \"centerLeft\":\n                    A = 0;\n                    break;\n\n                  case \"outsideLeft\":\n                    A = -l;\n                    break;\n\n                  case \"right\":\n                    A = l;\n                    break;\n\n                  case \"left\":\n                    A = -l;\n                    break;\n\n                  default:\n                    d.Helpers.warn(\"Invalid xPosition: '\" + p + \"'. Possible values: center, right, left, insideRight, centerRight, outsideRight, insideLeft, centerLeft, outsideLeft\"), A = 0;\n                }\n\n                this.shouldShowValue(a, s.valueLabels) && v.push({\n                  value: a,\n                  type: s.type,\n                  edges: [b, x],\n                  x: parseInt(g, 10) + A,\n                  y: b + S.fontHeight / 2,\n                  font: S.font,\n                  id: u,\n                  xPosition: p,\n                  style: s.valueLabels.style,\n                  function: s.valueLabels.contentsFunction,\n                  timestamp: h\n                });\n              }\n            }\n          }\n        }, t.prototype.shouldShowValue = function (t, e) {\n          var i = null !== t && void 0 !== t,\n              n = 0 === t;\n          return !(!e.showNullData && !i) && !(!e.showZeroData && n);\n        }, t.prototype.reduceFontSize = function (t, e, i, n, r) {\n          var s = e.match(/^([^\\\"\\d]*)(\\d+\\.?\\d*)(.*)$/i);\n          if (!s) return d.Helpers.warn(\"Could not parse the font size from the value `\" + e + \"`.\"), {\n            font: e,\n            value: n(e)\n          };\n\n          for (var a = s[2], o = s[1], l = s[3], h = parseFloat(a); h >= i;) {\n            var u = o + h + l,\n                c = n(u);\n            if (c <= r) return {\n              font: u,\n              value: c\n            };\n            if (h === i) break;\n            h = Math.round((h - 1) * r / c * 100) / 100, h < i && (h = i);\n          }\n\n          return null;\n        }, t.prototype.getPositionVerticalDimensions = function (t, e, i, n, r, s, a, o) {\n          var l = e >= 0 ? -1 : 1,\n              h = null,\n              u = null,\n              c = l * n,\n              p = d.Graphics.getTextHeight(t, r) + 2 * o + 4,\n              f = p < n;\n\n          if (!f && (\"insideTop\" === a || \"insideCenter\" === a || \"insideBase\" === a)) {\n            var g = this.reduceFontSize(t, r, s, function (e) {\n              return d.Graphics.getTextHeight(t, e);\n            }, n);\n            if (!g) return null;\n            r = g.font, p = g.value + 2 * o + 4;\n          }\n\n          switch (a) {\n            case \"outsideBottom\":\n              e < 0 ? (h = i + n, u = h + p) : (h = i, u = h + p);\n              break;\n\n            case \"outsideTop\":\n              e >= 0 ? (h = i - n, u = h - p) : (h = i, u = h - p);\n              break;\n\n            case \"outside\":\n              h = i + c, u = h + l * p;\n              break;\n\n            case \"insideTop\":\n              h = i + c, u = h - l * p;\n              break;\n\n            case \"insideCenter\":\n              h = i + c / 2 + p / 2, u = h - p;\n              break;\n\n            case \"insideBase\":\n              h = i + l * p, u = i;\n              break;\n\n            case \"aboveValue\":\n              h = i + c, u = h - p;\n              break;\n\n            case \"belowValue\":\n              h = i + c, u = h + p;\n              break;\n\n            case \"insideTopAuto\":\n              f ? (h = i + c, u = h - l * p) : (h = i + c, u = h + l * p);\n              break;\n\n            case \"value\":\n              f && (h = i + c - p / 2, u = h + p);\n              break;\n\n            default:\n              d.Helpers.warn(\"Invalid position: '\" + a + \"'. Possible values: outside, insideTop, insideCenter, insideBase, aboveValue, belowValue, belowValueAuto, value.\"), h = i + c, u = h + l * p;\n          }\n\n          return null === h ? null : h > u ? {\n            min: u,\n            max: h,\n            font: r,\n            fontHeight: p\n          } : {\n            min: h,\n            max: u,\n            font: r,\n            fontHeight: p\n          };\n        }, t.prototype.reduceFontWidth = function (t, e, i, n, r, s) {\n          var a = this.scene.dataLabels.fontWidths,\n              o = n.style.textStyle;\n          if (s = s.replace(/\\d/g, \"9\"), (a[o.font + \";\" + s] || 1 / 0) <= r) return o.font;\n          var l = new d.Label(n.style),\n              h = l.style.textStyle,\n              u = h.font;\n          l.text = s;\n          var c = this.reduceFontSize(t, u, n.minFontSize, function (i) {\n            var n = a[i + \";\" + s];\n            return n || (h.font = i, e.labelRenderer.measure(t, l), a[i + \";\" + s] = n = 2 * l.hwidth), n;\n          }, r);\n          return c ? c.font : null;\n        }, t.prototype.getLongestNumber = function (t) {\n          for (var e = 0, i = -1, n = 0; n < t.length; n++) {\n            var r = t[n];\n            r < 0 && (r *= -10), e <= r && null !== r && (e = r, i = n);\n          }\n\n          return {\n            max: i === -1 || null === t[i] ? -(1 / 0) : t[i],\n            index: i\n          };\n        }, t.prototype.createContent = function (t, e, i) {\n          if (i) {\n            var n = i.call(this.chart.api, t, e) || null;\n            return null != n && \"string\" != typeof n ? void d.Helpers.warn(\"`valueLabels.contentsFunction` has to return `null` or a string value.\") : n;\n          }\n\n          return t === d.Helpers.trunc(t) ? t.toFixed(0) : t.toFixed(2);\n        }, t.prototype.paintDataLabels = function (t, e, i, n) {\n          for (var r = this.scene, s = r.dataLabels.metaData, a = 2 * i, o = s.availableWidth !== a, l = r.dataLabels.spots, h = Object.keys(l), u = 0, c = h.length; u < c; u++) {\n            var p = l[h[u]];\n            if (p) for (var f = 0; f < p.length; f++) {\n              var g = p[f];\n\n              if (null != g) {\n                var v = new d.Label(g.style);\n                v.text = this.createContent(g.value, g.timestamp, g.function), v.style.textStyle.font = g.font, e.labelRenderer.measure(t, v);\n                var m = g.xPosition,\n                    y = 0;\n\n                switch (m) {\n                  case \"center\":\n                    y = 0;\n                    break;\n\n                  case \"right\":\n                    y = 0;\n                    break;\n\n                  case \"left\":\n                    y = 0;\n                    break;\n\n                  case \"insideRight\":\n                    y = -v.hwidth;\n                    break;\n\n                  case \"centerRight\":\n                    y = v.hwidth;\n                    break;\n\n                  case \"outsideRight\":\n                    y = v.hwidth;\n                    break;\n\n                  case \"insideLeft\":\n                    y = v.hwidth;\n                    break;\n\n                  case \"centerLeft\":\n                    y = -v.hwidth;\n                    break;\n\n                  case \"outsideLeft\":\n                    y = 1 - v.hwidth;\n                    break;\n\n                  default:\n                    d.Helpers.warn(\"Invalid xPosition: '\" + m + \"'. Possible values: center, right, left, insideRight, centerRight, outsideRight, insideLeft, centerLeft, outsideLeft\"), y = 0;\n                }\n\n                e.labelRenderer.paint(t, g.x + y, g.y, 1, v);\n              }\n            }\n          }\n\n          r.dataLabels.spots = {}, o && (s.availableWidth = a);\n        }, t;\n      }();\n\n      t.ValueLabels = u, function (t) {\n        var e = function () {\n          function t() {\n            this._min = Number.POSITIVE_INFINITY, this._sum = 0, this._count = 0, this._max = Number.NEGATIVE_INFINITY;\n          }\n\n          return Object.defineProperty(t.prototype, \"min\", {\n            get: function get() {\n              return this._min;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"max\", {\n            get: function get() {\n              return this._max;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"sum\", {\n            get: function get() {\n              return this._sum;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"count\", {\n            get: function get() {\n              return this._count;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), Object.defineProperty(t.prototype, \"avg\", {\n            get: function get() {\n              return 0 === this._count ? null : this._sum / this._count;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), t.prototype.aggregateValues = function (t, e) {\n            for (var i = 0; i < t.length; i++) {\n              this.aggregate(t[i], e[i]);\n            }\n\n            return this;\n          }, t.prototype.aggregate = function (t, e) {\n            return void 0 === t || null === t ? this : (this._min = Math.min(t, this._min), this._max = Math.max(t, this._max), this._sum += t * e, this._count += e, this);\n          }, t;\n        }(),\n            i = function (t) {\n          function e(e, i) {\n            var n = t.call(this) || this;\n            n.aggregateValues(e, i);\n            var r = n.computePercentiles(n.min, n.count, e, i);\n            return n.first = d.Helpers.firstNonNullInArray(e), n.last = d.Helpers.lastNonNullInArray(e), n.percentiles = r, n;\n          }\n\n          return n(e, t), e.prototype.computePercentiles = function (t, e, i, n) {\n            return e <= 0 ? null : this.computePercentilesFromMatrix(t, e, this.toValueCountMatrix(i, n));\n          }, e.prototype.toValueCountMatrix = function (t, e) {\n            return d.Helpers.transposeMatrix(d.Helpers.arraysToMatrix(t, e));\n          }, e.prototype.computePercentilesFromMatrix = function (t, e, i) {\n            if (e <= 0) return null;\n            i.sort(function (t, e) {\n              return t[0] - e[0];\n            });\n\n            for (var n = e / 100, r = [t], s = 0, a = n, o = 0; o < i.length; o++) {\n              var l = i[o][0],\n                  h = i[o][1];\n              u = this.collectPercentiles(l, h, s, a, r, n), s = u.currentCount, a = u.currentThreshold;\n            }\n\n            return r;\n            var u;\n          }, e.prototype.collectPercentiles = function (t, e, i, n, r, s) {\n            if (void 0 === t || null === t || void 0 === e || null === e) return {\n              currentCount: i,\n              currentThreshold: n\n            };\n\n            for (i += e; i >= n;) {\n              r.push(t), n += s;\n            }\n\n            return {\n              currentCount: i,\n              currentThreshold: n\n            };\n          }, e.prototype.selectSeriesAggregate = function (t, e, i) {\n            switch (e) {\n              case \"first\":\n                t = this.first;\n                break;\n\n              case \"last\":\n                t = this.last;\n                break;\n\n              case \"minimum\":\n                t = this.min;\n                break;\n\n              case \"maximum\":\n                t = this.max;\n                break;\n\n              case \"median\":\n                t = null === this.percentiles ? null : this.percentiles[50];\n                break;\n\n              case \"average\":\n                t = this.avg;\n                break;\n\n              case \"percentile\":\n                t = null === this.percentiles ? null : this.percentiles[i];\n                break;\n\n              default:\n                d.Helpers.warn(\"Warning: Invalid threshold type '\" + e + \"'\");\n            }\n\n            return t;\n          }, e;\n        }(e);\n\n        t.StackSeriesAggregates = i;\n\n        var s = function () {\n          function t(t, e, i, n, r) {\n            this.series = [], this.seriesId = [], this.min = 0, this.max = 0, this.renderingType = null, this.needsAfterProcess = !1, this.paddingLeft = 0, this.paddingRight = 0, this.clusterPaddingLeft = 0, this.clusterPaddingRight = 0, this.centers = [], this.radii = [], this.vstack = [], this.seriesAggregates = {}, this.countStack = [], this.ystack = [], this.xes = [], this.times = [], this.styles = [], this.previewData = [], this.calculatedDepth = 0, this.ystackNegative = null, this.valueLabels = null, this.externalItems = null, this.externalItemsCache = null, this.va = r, this.options = n, this.cluster = i, this.scene = e, this.chart = t, this.va.series++;\n          }\n\n          return t.computeFillPattern = function (t, e, i) {\n            var n = i.fillPattern,\n                r = i._currentFillStyleKey,\n                s = i.fillColor,\n                a = s + \"|\" + n;\n\n            if (!r || r.pattern !== a) {\n              var o,\n                  l,\n                  h = t.assetsLoader.getAssetImage(i.fillPattern);\n\n              if (h) {\n                var u = i._fillPatternOpacity;\n\n                if (s || u) {\n                  var c = document.createElement(\"canvas\");\n                  c.width = h.width, c.height = h.height;\n                  var d = c.getContext(\"2d\");\n                  s && (d.fillStyle = s, d.fillRect(0, 0, h.width, h.height)), d.globalAlpha = i._fillPatternOpacity, d.drawImage(h, 0, 0), h = c;\n                }\n\n                o = e.createPattern(h, \"repeat\"), l = {\n                  pattern: a\n                };\n              } else o = s || null, l = null;\n\n              i._currentFillStyle = o, i._currentFillStyleKey = l;\n            }\n          }, t.prototype.addSeries = function (t, e) {\n            this.renderingType || (this.renderingType = e.type), this.series.push(e), this.seriesId.push(t);\n            var i = e;\n            this.calculatedDepth = Math.max(this.calculatedDepth, i.style.depth), \"columns\" === this.renderingType && this.aggregatePadding(i);\n          }, t.prototype.aggregatePadding = function (t) {\n            this.paddingLeft = Math.max(this.paddingLeft, t.style.padding[0]), this.paddingRight = Math.max(this.paddingRight, t.style.padding[1]), this.clusterPaddingLeft = Math.max(this.clusterPaddingLeft, t.style.clusterPadding[0]), this.clusterPaddingRight = Math.max(this.clusterPaddingRight, t.style.clusterPadding[1]);\n          }, t.prototype.afterInit = function () {\n            \"line\" === this.renderingType ? this.renderer = new r.Line(this, this.series) : \"columns\" === this.renderingType ? this.renderer = new r.Columns(this.scene, this.series) : \"candlestick\" === this.renderingType && (this.candleStacks = !0, this.renderer = new r.Candlestick(this.scene, this.series));\n          }, t.prototype.process = function (t) {\n            this.processData(t), this.computeMinMax();\n            var e = this.addLeads(t);\n            this.computeSeriesAggregates(t, e), this.sendMinMaxToValueAxis(this.min, this.max), this.needsAfterProcess = !0;\n          }, t.prototype.afterProcess = function () {\n            if (this.needsAfterProcess || this.va.axisChanged) return this.needsAfterProcess = !1, this.computeY();\n          }, t.prototype.paint = function (t, e) {\n            if (0 !== this.ystack.length && !isNaN(this.radii[0])) {\n              for (var i = 0; i < this.series.length; i++) {\n                var n = this.series[i];\n                this.computeFillStyle(e, n.style), this.chart.assetsLoaded && n.valueLabels && n.valueLabels.enabled && (null === this.valueLabels && (this.valueLabels = new u(this.chart, this.scene, this.va)), this.valueLabels.setSeriesFont(e, t, this.series, this.radii, this.vstack, this.times));\n              }\n\n              var r = this.styles;\n              if (r) for (var s = 0; s < r.length; s++) {\n                var a = r[s];\n                if (a) for (var o = 0; o < a.length; o++) {\n                  this.computeFillStyle(e, a[o]);\n                }\n              }\n              var l = null === this.options.drawFullArea ? \"based\" === this.options.type : this.options.drawFullArea;\n              this.ystackNegative && this.renderer.paintStack(t, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, l, this.previewData), this.renderer.paintStack(t, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, l, this.previewData);\n            }\n          }, t.prototype.paintValueLabels = function (t, e) {\n            null !== this.valueLabels && this.valueLabels.scanValueLabels(e, t, this.radii, this.centers, this.series, this.ystack, this.ystackNegative, this.vstack, this.times);\n          }, t.prototype.hitTestStack = function (t, e) {\n            var i = d.Helpers.binSearch(this.centers, t),\n                n = this.centers[i] - this.radii[i],\n                r = this.centers[i] + this.radii[i];\n\n            if (n > t && i > 0) {\n              var s = this.centers[i - 1] - this.radii[i - 1],\n                  a = this.centers[i - 1] + this.radii[i - 1];\n              (a > t || Math.abs(a - t) < Math.abs(n - t)) && (i -= 1, n = s, r = a);\n            }\n\n            return {\n              result: {\n                x0: n,\n                y0: 0,\n                x1: r,\n                y1: 0,\n                seriesIndex: null,\n                isMarker: !1,\n                stack: this\n              },\n              distance: d.Geometry.distanceToRect(t, 0, n, 0, r, 0)\n            };\n          }, t.prototype.hitTest = function (t, e, i) {\n            var n = this.renderer.hitTest(this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, t, e, i),\n                r = n.result,\n                s = n.distance;\n            return this.ystackNegative && (n = this.renderer.hitTest(this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, t, e, i), n.distance < s && (r = n.result, s = n.distance)), null !== r && (r.seriesIndex = this.seriesId[r.seriesIndex], r.stack = this), {\n              result: r,\n              distance: s\n            };\n          }, t.prototype.computeFillStyle = function (e, i) {\n            if (i) if (i.fillPattern) t.computeFillPattern(this.chart, e, i);else {\n              if (i.fillGradient) return void this.computeFillGradient(e, i);\n              i._currentFillStyle = i.fillColor || null, i._currentFillStyleKey = null;\n            }\n          }, t.prototype.computeFillGradient = function (t, e) {\n            var i = e.fillGradient,\n                n = this.va,\n                r = n.zeroY,\n                s = this.scene.y0,\n                a = this.scene.x0,\n                o = this.scene.height,\n                l = this.scene.width,\n                h = e._currentFillStyleKey,\n                u = n.scale + \"|\" + r + \"|\" + s + \"|\" + a + \"|\" + o + \"|\" + r;\n\n            if (!h || !e._currentFillStyle || i !== h.gradient || u !== h.hash) {\n              var c = null;\n              c = \"horizontal\" == e.fillGradientMode ? t.createLinearGradient(a, s, a + l, s) : \"vertical\" == e.fillGradientMode ? t.createLinearGradient(a, s + o, a, s) : t.createLinearGradient(a, s, a, s + o);\n              var p = null,\n                  f = [];\n\n              if (null == e.fillGradientMode) {\n                for (var g = 0; g < i.length; g++) {\n                  var v = i[g],\n                      m = r - n.valueToRelativeY(v[0]),\n                      y = (m - s) / o;\n                  f.push([y, v[1]]);\n                }\n\n                f.sort(function (t, e) {\n                  return t[0] - e[0];\n                });\n\n                for (var S = 0; S < f.length; S++) {\n                  var b = f[S],\n                      x = b[0],\n                      C = b[1];\n\n                  if (x > 0) {\n                    if (p && p[0] < 0 && c.addColorStop(0, d.Colors.blend(p[1], C, (0 - p[0]) / (x - p[0]), !1)), x > 1) {\n                      p && c.addColorStop(1, d.Colors.blend(p[1], C, (1 - p[0]) / (x - p[0]), !1));\n                      break;\n                    }\n\n                    c.addColorStop(x, C);\n                  }\n\n                  p = b;\n                }\n              } else for (var w = 0; w < i.length; w++) {\n                var L = i[w];\n                c.addColorStop(L[0], L[1]);\n              }\n\n              e._currentFillStyle = c, e._currentFillStyleKey = {\n                hash: u,\n                gradient: i\n              };\n            }\n          }, t.generateAggregateOffsetVisitor = function (t, e, i, n) {\n            return function (r, s) {\n              if (d.Helpers.nonNull(s) && n(s, t)) return e * r + i;\n            };\n          }, t.prototype.computeSeriesAggregates = function (e, n) {\n            var r = this.scene.x0,\n                s = this.scene.x0 + this.scene.width,\n                a = t.generateAggregateOffsetVisitor(r, 1, 0, function (t, e) {\n              return t >= e;\n            }),\n                o = d.Helpers.visitArrayForwards(this.centers, a),\n                l = t.generateAggregateOffsetVisitor(s, -1, this.centers.length, function (t, e) {\n              return t < e;\n            }),\n                h = d.Helpers.visitArrayBackwards(this.centers, l);\n            this.seriesAggregates = {};\n\n            for (var u = 0; u < this.seriesId.length; u++) {\n              var c = e[this.seriesId[u]],\n                  p = c.fromIndex + o,\n                  f = c.toIndex - h;\n              this.seriesAggregates[this.series[u].id] = new i(c.values.slice(p, f), c.counts.slice(p, f));\n            }\n          }, t.prototype.processData = function (t) {\n            var e = this;\n            this.vstack = [], this.countStack = [], this.styles = [];\n            var i = t[this.seriesId[0]];\n\n            if (0 !== i.times.length) {\n              this.xes = i.xes.slice(i.fromIndex, i.toIndex), this.times = i.times.slice(i.fromIndex, i.toIndex), this.centers = new Array(this.xes.length - 1), this.radii = new Array(this.xes.length - 1), this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii), this.externalItemsCache = null, this.externalItems = function () {\n                var t = e.externalItemsCache;\n                return null === t && (t = e.externalItemsCache = i.externalItems(i.fromIndex, i.toIndex - 1)), t;\n              }, this.previewData = [];\n\n              for (var n = 0; n < this.seriesId.length; n++) {\n                var r = this.seriesId[n];\n\n                if (i = t[r], this.vstack.push(i.values.slice(i.fromIndex, i.toIndex - 1)), this.countStack.push(i.counts.slice(i.fromIndex, i.toIndex - 1)), i.config) {\n                  for (var s = [], a = [], o = i.fromIndex; o < i.toIndex - 1; o++) {\n                    var l = i.config[o];\n                    l && (s.push(l.style), a.push(l.previewData));\n                  }\n\n                  this.styles.push(s), this.previewData.push(a);\n                } else this.styles.push(null);\n              }\n            }\n          }, t.prototype.addLeads = function (t) {\n            for (var e = [], i = 0; i < this.seriesId.length; i++) {\n              var n = this.seriesId[i],\n                  r = t[n];\n              r.leadIn && e.push(this.injectLead(r.leadIn, i)), r.leadOut && e.push(this.injectLead(r.leadOut, i));\n            }\n\n            return e.sort(function (t, e) {\n              return t - e;\n            }), e;\n          }, t.prototype.injectLead = function (t, e) {\n            var i = this.series.length,\n                n = t.values[0],\n                r = t.times[0],\n                s = [0],\n                a = [0];\n            this.cluster.computeStackCenterRadius(this, t.xes, s, a);\n            var o = s[0],\n                l = a[0],\n                h = d.Helpers.firstIndexLessThanInArray(this.centers, o);\n\n            if (null === h && (h = this.centers.length), h === this.centers.length || this.centers[h] > o) {\n              this.centers.splice(h, 0, o), this.radii.splice(h, 0, l), this.times.splice(h, 0, r);\n\n              for (var u = 0; u <= i - 1; u++) {\n                this.vstack[u].splice(h, 0, null), this.countStack[u].splice(h, 0, null), this.styles[u] && this.styles[u].splice(h, 0, null);\n              }\n            }\n\n            return this.vstack[e][h] = n, this.countStack[e][h] = t.counts[0], h;\n          }, t.prototype.getSeparateNegative = function () {\n            var t = this.options.separateNegativeValues;\n            return null === t && (t = \"line\" !== this.renderingType), t;\n          }, t.prototype.computeMinMax = function () {\n            var t = 1 / 0,\n                e = -(1 / 0);\n\n            if (this.vstack.length > 0) {\n              for (var i = this.vstack, n = i[0].length, r = i.length, s = this.options.type, a = this.getSeparateNegative(), o = this.scene.x0, l = o + this.scene.width, h = 0, u = n - 1; h < n && this.centers[h] + this.radii[h] < o;) {\n                h += 1;\n              }\n\n              for (; u >= h && this.centers[u] - this.radii[u] > l;) {\n                u -= 1;\n              }\n\n              if (\"proportional\" === s) t = 0, e = 100;else if (this.candleStacks) for (var c = h; c <= u; c++) {\n                for (var p = 0; p <= r - 1; p++) {\n                  var f = i[p][c];\n                  d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n                }\n              } else if (1 === r) for (var g = i[0], c = h; c <= u; c++) {\n                var f = g[c];\n                d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n              } else if (\"based\" === s) for (var c = h; c <= u; c++) {\n                for (var p = 0; p <= r - 1; p++) {\n                  var f = i[p][c];\n                  d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f));\n                }\n              } else if (\"normal\" !== s || a) {\n                if (\"normal\" !== s) throw \"stack.type unknown value: \" + s;\n\n                for (var c = h; c <= u; c++) {\n                  for (var v = 0, m = 0, p = 0; p <= r - 1; p++) {\n                    var f = i[p][c];\n                    d.Helpers.isNumber(f) && (f > 0 ? m += f : f < 0 && (v += f), t = Math.min(t, v), e = Math.max(e, m));\n                  }\n                }\n              } else for (var c = h; c <= u; c++) {\n                for (var y = 0, p = 0; p <= r - 1; p++) {\n                  var f = i[p][c];\n                  d.Helpers.isNumber(f) && (null !== f && (y += f), t = Math.min(t, y), e = Math.max(e, y));\n                }\n              }\n            }\n\n            this.min = t, this.max = e;\n          }, t.prototype.sendMinMaxToValueAxis = function (t, e) {\n            t <= e ? this.va.receiveSeriesGeometry(t, e, this.calculatedDepth, this.seriesAggregates) : this.va.receiveSeriesGeometry(void 0, void 0, this.calculatedDepth, this.seriesAggregates);\n          }, t.prototype.computeY = function () {\n            var t = this.vstack,\n                e = t.length;\n\n            if (0 !== e) {\n              var i,\n                  n = this.options.type,\n                  r = this.getSeparateNegative(),\n                  s = t[0].length,\n                  a = this.va,\n                  o = null;\n\n              if (\"proportional\" === n) {\n                i = t.map(function () {\n                  return [];\n                }), a.options.scaleAdjustmentTolerance = 0;\n\n                for (var l = 0; l <= s - 1; l++) {\n                  for (var h = 0, u = 0; u <= e - 1; u++) {\n                    var c = t[u][l];\n                    null !== c && (h += Math.abs(c));\n                  }\n\n                  if (h > 0) {\n                    h *= .01;\n\n                    for (var u = 0; u <= e - 1; u++) {\n                      var c = t[u][l];\n                      null !== c ? i[u].push(a.valueToRelativeY(Math.abs(c) / h)) : i[u].push(null);\n                    }\n                  } else for (var u = 0; u <= e - 1; u++) {\n                    i[u].push(null);\n                  }\n                }\n              } else if (\"based\" === n || 1 === e) {\n                i = [];\n\n                for (var d = t[0].map(function () {\n                  return 0;\n                }), p = 0; p < t.length; p++) {\n                  for (var f = t[p], g = new Array(s), v = 0; v < f.length; v++) {\n                    var c = f[v];\n\n                    if (null !== c) {\n                      var m = a.valueToRelativeY(c),\n                          y = d[v];\n                      g[v] = m - y, d[v] = m;\n                    } else g[v] = null;\n                  }\n\n                  i.push(g);\n                }\n              } else if (\"normal\" === n && r && this.min < 0 && this.max > 0) {\n                i = t.map(function () {\n                  return [];\n                }), o = t.map(function () {\n                  return [];\n                });\n\n                for (var l = 0; l <= s - 1; l++) {\n                  for (var u = 0; u <= e - 1; u++) {\n                    var c = t[u][l];\n                    c > 0 ? (i[u].push(a.valueToRelativeY(c)), o[u].push(null)) : c < 0 ? (i[u].push(null), o[u].push(a.valueToRelativeY(c))) : (i[u].push(null), o[u].push(null));\n                  }\n                }\n              } else if (\"candlestick\" === this.renderingType) {\n                i = t.map(function () {\n                  return [];\n                });\n\n                for (var l = 0; l <= s - 1; l++) {\n                  for (var u = 0; u <= e - 1; u++) {\n                    var c = t[u][l];\n                    null !== c ? i[u].push(a.valueToRelativeY(c)) : i[u].push(null);\n                  }\n                }\n              } else {\n                if (\"normal\" !== n) throw \"stack.type unknown value: \" + n;\n                var S = 0,\n                    b = 0,\n                    x = 0;\n                i = t.map(function () {\n                  return [];\n                });\n\n                for (var l = 0; l <= s - 1; l++) {\n                  for (var u = 0; u <= e - 1; u++) {\n                    var c = t[u][l];\n\n                    if (0 === u && (S = b = x = 0), null !== c) {\n                      b += c;\n                      var C = a.valueToRelativeY(b);\n                      i[u].push(C - x), x = C;\n                    } else i[u].push(null);\n                  }\n                }\n              }\n\n              this.ystackNegative = o, this.ystack = i;\n            }\n          }, t.prototype.exportData = function (t, e) {\n            var i;\n\n            if (this.times && this.vstack) {\n              for (var n = this.times, r = this.centers.length, s = 0; s < r && n[s + 1] <= t;) {\n                s++;\n              }\n\n              for (var a = s; a < r && n[a + 1] < e;) {\n                a++;\n              }\n\n              i = [];\n\n              for (var o = 0; o < this.vstack.length; o++) {\n                var l = this.vstack[o],\n                    h = this.countStack[o],\n                    u = 0,\n                    c = -(1 / 0),\n                    d = 1 / 0,\n                    p = null,\n                    f = null;\n                r = 0;\n                var g = this.series[o].data.aggregation,\n                    v = !1,\n                    m = !1;\n                \"sum\" === g ? (v = !1, m = !0) : \"avg\" === g && (v = !0, m = !0);\n\n                for (var y = s; y <= a; y++) {\n                  var S = l[y],\n                      b = Math.floor(h[y]);\n                  null == S || isNaN(S) || (u += v ? S * b : S, c = Math.max(c, S), d = Math.min(d, S), null === p && (p = S), f = S, r += b);\n                }\n\n                r > 0 ? i.push({\n                  sum: u,\n                  max: c,\n                  min: d,\n                  first: p,\n                  last: f,\n                  count: r,\n                  avg: m ? u / r : null,\n                  change: f - p\n                }) : i.push(null);\n              }\n            } else i = this.series.map(function () {\n              return null;\n            });\n\n            for (var x = [], C = this.series.length - 1; C >= 0; C--) {\n              var w = this.series[C];\n              x.push({\n                name: w.name || \"\",\n                values: i[C],\n                config: w\n              });\n            }\n\n            return {\n              name: this.options.name,\n              stack: this,\n              config: this.options,\n              data: x\n            };\n          }, t;\n        }();\n\n        t.Stack = s;\n      }(i = t.Series || (t.Series = {}));\n\n      var c = function () {\n        function t() {\n          this.enabled = !0, this.animate = \"auto\", this.initialAnimationValue = null, this.initialAnimationValueMultiplier = 4.5, this.logScale = !1, this.position = \"outside\", this.gridPosition = \"above\", this.side = \"left\", this.title = null, this.minValue = null, this.maxValue = null, this.forceTopAndBottomValues = !1, this.alignZero = !1, this.size = null, this.hgrid = null, this.axisLine = !1, this.scaleAdjustmentTolerance = .3, this.scaleAdjustmentAnimationDelay = 200, this.scaleAdjustmentAnimation = \"=\", this.scaleStep = null, this.scaleMinStep = 0, this.zeroLine = \"visible\", this.valueFormatterFunction = null, this.style = {\n            title: {\n              textStyle: {\n                fillColor: \"#000000\",\n                font: \"13px Arial\"\n              },\n              reverseDirection: !1,\n              align: \"center\",\n              margin: 5\n            },\n            tick: {\n              lineColor: \"#AAAAAA\"\n            },\n            axisLine: {\n              lineColor: \"rgba(127,127,127,0.5)\",\n              lineWidth: 1\n            },\n            valueLabel: {\n              textStyle: {\n                fillColor: \"#000000\",\n                font: \"11px Arial\"\n              },\n              margin: 0\n            },\n            labelSpacing: 25,\n            baseLine: {\n              lineColor: \"rgba(127,127,127,0.5)\",\n              depthColor: \"rgba(127,127,127,0.5)\",\n              lineWidth: 1,\n              lineDepth: 0,\n              showLabel: 1\n            },\n            hgrid: {\n              lineColor: \"rgba(255,255,255,0.2)\"\n            }\n          }, this.thresholds = [];\n        }\n\n        return t;\n      }();\n\n      t.SettingsValueAxis = c;\n\n      var p = function () {\n        function t() {\n          this.fromType = \"constant\", this.toType = \"constant\", this.seriesID = null, this.percentileFrom = 0, this.percentileTo = 0, this.from = -(1 / 0), this.to = 1 / 0, this.position = \"under\", this.style = {\n            fillColor: \"rgba(255,133,152,0.2)\",\n            lineColor: \"rgba(255,0,0,0.5)\",\n            lineWidth: 1,\n            lineDash: null\n          }, this.labelType = \"text\", this.labelHorizontalPosition = \"left\", this.labelVerticalPosition = \"above\", this.labelHorizontalPadding = 0, this.labelVerticalPadding = 0, this.labelDecimals = null, this.labelDisplayUnits = null;\n        }\n\n        return t;\n      }();\n\n      t.SettingsValueAxisThreshold = p;\n\n      var f = function () {\n        function t(t, e) {\n          this.axisPoints = new d.ValueAxisPoints(), this.title = null, this.isPrimary = !1, this._chart = t, this.options = e, this.events = t.events, this.scene = t.scene, this.axisScale = new d.ValueAxisScale(this.options.logScale), this.isInside = \"inside\" === this.options.position, this.createTitle(), this.panel = d.ValueAxisUtils.generatePanel(t, this.title, this.options.size, this.options.style.valueLabel, this.options.valueFormatterFunction), this.lastMaxValue = 0, this.lastMinValue = 0, this.minValue = 0, this.maxValue = 0, this.lastScaleMin = 0, this.lastScaleMax = 0, this.minValueAnimation = null, this.maxValueAnimation = null, this.usingDefaultMinMax = !0, this.axisChanged = !1, this.seriesDepth = 0, this.seriesMinValue = null, this.seriesMaxValue = null, this.series = 0;\n        }\n\n        return Object.defineProperty(t.prototype, \"scale\", {\n          get: function get() {\n            return this.axisScale.getRawScale();\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"zeroY\", {\n          get: function get() {\n            return this.axisScale.zeroY;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.valueToRelativeY = function (t) {\n          return this.axisScale.valueToRelativeY(t);\n        }, t.prototype.createTitle = function () {\n          var t = this.options,\n              e = t.style.title,\n              i = this.title = new d.Label(e);\n          i.text = t.title, i.allowCache = !1;\n          var n = i.style.angle;\n          null == n && (n = \"right\" === t.side ? 90 : -90), e.reverseDirection && (n = -n), i.style.angle = n;\n        }, t.prototype.getPanel = function () {\n          var t = this.options;\n          return t.enabled ? (this.panel.location = t.position, this.panel.side = t.side, this.panel) : null;\n        }, t.prototype.setPanel = function (t) {\n          null != t && (this.panel = t);\n        }, t.prototype.receiveSeriesGeometry = function (t, e, i, n) {\n          if (null === this.options.minValue || this.options.alignZero ? void 0 !== t && (null !== this.seriesMinValue ? this.seriesMinValue = Math.min(t, this.seriesMinValue) : this.seriesMinValue = t) : this.seriesMinValue = this.options.minValue, null === this.options.maxValue || this.options.alignZero ? void 0 !== e && (null !== this.seriesMaxValue ? this.seriesMaxValue = Math.max(e, this.seriesMaxValue) : this.seriesMaxValue = e) : this.seriesMaxValue = this.options.maxValue, this.seriesDepth = Math.max(i, this.seriesDepth), d.Helpers.isNull(this.seriesAggregates)) this.seriesAggregates = n;else for (var r in n) {\n            var s = n[r];\n            this.seriesAggregates[r] = s;\n          }\n        }, t.prototype.updateMinMax = function (t) {\n          var e = t.changes,\n              i = e.bounds || e.assets || 0 === this.axisPoints.locations.length;\n\n          if (e.settings && (this.axisScale.updateScale(this.options.logScale), this.isInside = \"inside\" === this.options.position, i = !0), this.shouldChangeScale() && (this.seriesMinValue !== this.lastMinValue && (i = !0, \"always\" === this.options.animate || null !== this.lastMinValue && !e.displayUnit && this.minValue !== this.maxValue ? this.minValueAnimation ? this.minValueAnimation.retarget(this.seriesMinValue, t.timeStamp) : this.minValueAnimation = new d.Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp) : this.minValueAnimation = null, this.lastMinValue = this.seriesMinValue), this.seriesMaxValue !== this.lastMaxValue)) {\n            if (i = !0, \"always\" === this.options.animate || null !== this.lastMaxValue && !e.displayUnit && this.minValue !== this.maxValue) {\n              if (this.maxValueAnimation) this.maxValueAnimation.retarget(this.seriesMaxValue, t.timeStamp);else {\n                var n = this.lastMaxValue;\n                this.lastMaxValue || (null !== this.options.initialAnimationValue ? n = this.options.initialAnimationValue : this.seriesMaxValue && (n = this.seriesMaxValue * this.options.initialAnimationValueMultiplier)), this.maxValueAnimation = new d.Animator(n, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp);\n              }\n            } else this.maxValueAnimation = null;\n            this.lastMaxValue = this.seriesMaxValue;\n          }\n\n          this.seriesMaxValue = this.options.alignZero ? null : this.options.minValue, this.seriesMinValue = this.options.alignZero ? null : this.options.maxValue;\n          var r, s;\n          this.minValueAnimation ? (i = !0, r = this.minValueAnimation.get(t.timeStamp), this.minValueAnimation.finished(t.timeStamp) && (this.minValueAnimation = null)) : r = this.lastMinValue, this.maxValueAnimation ? (i = !0, s = this.maxValueAnimation.get(t.timeStamp), this.maxValueAnimation.finished(t.timeStamp) && (this.maxValueAnimation = null)) : s = this.lastMaxValue, this.axisChanged = i, i && this.computeNewScaleInternal(r, s, !0), (this.minValueAnimation || this.maxValueAnimation) && (t.animating = !0);\n        }, t.prototype.doAnimations = function (t) {\n          if (this.axisChanged && this._chart.assetsLoaded) {\n            this.axisChanged = !1;\n            var e = this.options;\n\n            if (e.enabled) {\n              var i = \"right\" === e.side,\n                  n = this.axisPoints.generatePoints(this.axisScale, this.scene.y0, this.scene.y0 + this.scene.height, this.minValue, this.maxValue, this.isInside, e.style.labelSpacing, e.scaleStep, e.scaleMinStep, this.scene.bottomAxisSize, e.style.valueLabel.textStyle.font, e.forceTopAndBottomValues, e.style.baseLine.showLabel);\n              this.axisPoints.generateLabels(this.axisScale, n, this.scene.settings.localization.valueUnits, e.valueFormatterFunction, e.valueFormat, e.style.valueLabel, i, this.isInside, !1);\n            }\n          }\n        }, t.prototype.paintUnder = function (t) {\n          var e = this.options;\n\n          if (e.enabled) {\n            var i = t.context;\n            this.paintThresholds(t, \"under\", !1), \"under\" === e.gridPosition && this.paintGrid(i), this.paintZeroLineDepth(i);\n          }\n        }, t.prototype.paint = function (t) {\n          var e = this.options;\n\n          if (e.enabled) {\n            var i = t.context;\n\n            if (this.paintThresholds(t, \"above\", !0), e.gridPosition && \"above\" !== e.gridPosition || this.paintGrid(i), this.axisPoints.locations.length > 0 && (this.paintZeroLine(i), this.paintLabels(i, t.labelRenderer)), e.axisLine) {\n              var n = d.Graphics.beginStrokeAndFill(i, e.style.axisLine);\n              this.paintAxisLine(n), d.Graphics.endStrokeAndFill(i, n, e.style.axisLine);\n            }\n          }\n        }, t.prototype.shouldChangeScale = function () {\n          var t = this.seriesMinValue,\n              e = this.seriesMaxValue;\n          if (null === t || null === e) return !1;\n          if (null === this.lastMinValue || null === this.lastMaxValue || !(this.lastMinValue < this.lastMaxValue)) return !0;\n          if (\"center\" === this.options.zeroLine ? (e = Math.max(e, -t), t = -e) : \"visible\" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), t < this.minValue || e > this.maxValue) return !0;\n          var i = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;\n          return t > this.lastMinValue + i || e < this.lastMaxValue - i;\n        }, t.prototype.computeNewScale = function (t, e, i) {\n          if (t > 0 && e > 0 || t < 0 && e < 0) return Number.POSITIVE_INFINITY;\n          var n = 0 === t ? 0 : this.lastScaleMin / t,\n              r = 0 === e ? 0 : this.lastScaleMax / e,\n              s = Math.max(n, r);\n          if (0 === s) return Number.POSITIVE_INFINITY;\n\n          for (var a = t * s, o = e * s, l = 0; l < 10; l++) {\n            if (this.computeNewScaleInternal(a, o, !1), void 0 === i || !this.options.alignZero || this.usingDefaultMinMax) return this.computeScaleError(o, a);\n            var h = this.axisScale.forceZeroY(i),\n                u = this.axisScale.relativeYToValue(h);\n            if (Math.abs(u) === Number.POSITIVE_INFINITY) break;\n            var c = a + u,\n                d = o + u,\n                p = Math.abs(u);\n            c -= p, d += p, a = c, o = d;\n          }\n\n          return this.computeScaleError(o, a);\n        }, t.prototype.computeScaleError = function (t, e) {\n          var i = (t - e) / (this.lastScaleMax - this.lastScaleMin),\n              n = i < 0 ? Number.POSITIVE_INFINITY : Math.log(i);\n          return n;\n        }, t.prototype.computeNewScaleInternal = function (t, e, i) {\n          i && (this.lastScaleMin = t, this.lastScaleMax = e), this.axisChanged = !0;\n          var n = this.scene.height,\n              r = this.scene.y0;\n          if (\"center\" === this.options.zeroLine ? (e = Math.max(e, -t), t = -e) : \"visible\" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), this.options.alignZero || null === this.options.minValue || (t = this.options.minValue), this.options.alignZero || null === this.options.maxValue || (e = this.options.maxValue), !(n > 0 && t < e)) return this.minValue = 0, this.maxValue = 0, this.axisScale.resetToDefaultScale(r + n), void (this.usingDefaultMinMax = !0);\n          this.usingDefaultMinMax = !1;\n          var s = 0;\n          this.options.scaleStep > 0 ? s = this.options.scaleStep : this.options.scaleMinStep > 0 && (s = this.options.scaleMinStep), s > 0 && (t < 0 && (t = Math.floor(t / s) * s), e > 0 && (e = Math.ceil(e / s) * s));\n          var a = e - t;\n          if (this.axisScale.isLogScale) t = d.Helpers.sign(t) * Math.pow(Math.abs(t), 1 - d.Helpers.sign(t) * this.options.scaleAdjustmentTolerance);else {\n            var o = t - a * this.options.scaleAdjustmentTolerance;\n            t > 0 ? t = Math.max(0, o) : t < 0 && (t = Math.min(0, o));\n          }\n          if (this.axisScale.isLogScale) e = d.Helpers.sign(e) * Math.pow(Math.abs(e), 1 + d.Helpers.sign(e) * this.options.scaleAdjustmentTolerance);else {\n            var l = e + a * this.options.scaleAdjustmentTolerance;\n            e > 0 ? e = Math.max(0, l) : e < 0 && (e = Math.min(0, l));\n          }\n          this.options.alignZero || null === this.options.minValue || (t = this.options.minValue), this.options.alignZero || null === this.options.maxValue || (e = this.options.maxValue), this.options.alignZero && i && (null !== this.options.minValue || null !== this.options.maxValue) && d.Helpers.warn(\"Cannot use alignZero with custom minValue or maxValue. minValue and maxValue are being ignored.\"), this.minValue = t, this.maxValue = e, this.axisScale.updateRange(t, e, r, n);\n        }, t.prototype.paintGrid = function (t) {\n          this.options.hgrid === !1 || null == this.options.hgrid && !this.isPrimary || this.axisPoints.paintGrid(t, this.options.style.hgrid, this.scene, !1);\n        }, t.prototype.paintAxisLine = function (t) {\n          var e,\n              i = this.options.side,\n              n = this.panel.left,\n              r = this.panel.right,\n              s = this.scene.y0 + this.scene.height;\n          this.isInside ? (\"right\" === i && (e = n), \"left\" === i && (e = r)) : e = \"right\" === i ? n - .5 : r + .5, t.moveTo(e, this.scene.y0), t.lineTo(e, s);\n        }, t.prototype.paintZeroLineDepth = function (t) {\n          if (!(this.axisScale.zeroY > this.scene.chartHeight)) {\n            var e = this.options.style.baseLine,\n                i = Math.max(e.lineDepth, this.seriesDepth);\n\n            if (i > 0) {\n              var n = d.Graphics.beginStroke(t, this.options.style.baseLine),\n                  r = this.scene.x0,\n                  s = r + this.scene.width,\n                  a = Math.round(this.axisScale.zeroY) - .5 * (e.lineWidth || 1);\n              n.moveTo(r, a), n.lineTo(r + i, a - i), n.lineTo(s, a - i), n.lineTo(s, a), t.fillStyle = e.depthColor, t.fill(), d.Graphics.endStroke(t, n, e);\n            }\n          }\n        }, t.prototype.paintZeroLine = function (t) {\n          this.axisScale.zeroY > this.scene.chartHeight || this.axisPoints.paintZeroLine(t, this.axisScale, this.options.style.baseLine, this.scene, 0, !1);\n        }, t.prototype.generateThresholdValue = function (t, e, i, n) {\n          if (\"constant\" === e) return t;\n          if (null === i) return d.Helpers.warn(\"Warning: Specified non-constant threshold but did not specify the seriesID\"), t;\n          if (!this.seriesAggregates.hasOwnProperty(i)) return d.Helpers.warn(\"Warning: '\" + i + \"' does not exist.\"), t;\n          n = Math.round(Math.max(Math.min(n, 100), 0)), e = this.replaceExtremePercentiles(e, n);\n          var r = this.seriesAggregates[i];\n          return r.selectSeriesAggregate(t, e, n);\n        }, t.prototype.replaceExtremePercentiles = function (t, e) {\n          return \"percentile\" === t && (100 === e ? t = \"maximum\" : 0 === e && (t = \"minimum\")), t;\n        }, t.prototype.applyDecimals = function (t, e) {\n          var i = d.Helpers.decimalShortening(e, t);\n          return null === i || void 0 === i ? \"\" : i;\n        }, t.prototype.paintThresholds = function (t, e, i) {\n          var n = this.options;\n          if (n.enabled && n.thresholds) for (var r = 0; r < n.thresholds.length; r++) {\n            var s = n.thresholds[r];\n            s.position === e && this.paintThreshold(t.context, s, t.labelRenderer, i);\n          }\n        }, t.prototype.paintThreshold = function (t, e, i, n) {\n          if (this.axisScale.isScaleValid()) {\n            var r = this.scene.x0,\n                s = this.scene.x0 + this.scene.width,\n                a = this.scene.y0,\n                o = a + this.scene.height,\n                l = this.generateThresholdValue(e.to, e.toType, e.seriesID, e.percentileTo),\n                h = this.generateThresholdValue(e.from, e.fromType, e.seriesID, e.percentileFrom);\n\n            if (!(n === !0 && h === l && \"above\" === e.position || n === !1 && h !== l && \"above\" === e.position)) {\n              var u = this.axisScale.valueToScreenYInRange(h, a, o) + .5,\n                  c = this.axisScale.valueToScreenYInRange(l, a, o) + .5;\n              e.style.fillColor && d.Helpers.nonNull(u) && d.Helpers.nonNull(c) && (t.fillStyle = e.style.fillColor, t.beginPath(), t.rect(r, c, this.scene.width, u - c), t.fill(), t.closePath());\n              var p = d.Graphics.beginStroke(t, e.style);\n\n              if (u !== o && d.Helpers.nonNull(u) && (p.moveTo(r, u), p.lineTo(s, u)), c !== a && null !== c && d.Helpers.nonNull(c) && (p.moveTo(r, c), p.lineTo(s, c)), d.Graphics.endStroke(t, p, e.style), e.label || \"text\" !== e.labelType) {\n                var f = e.labelStyle ? e.labelStyle : {},\n                    g = new d.Label(f),\n                    v = d.Helpers.valueShorteningWithUnit(h, e.labelDisplayUnits),\n                    m = d.Helpers.valueShorteningWithUnit(l, e.labelDisplayUnits),\n                    y = this.applyDecimals(v.value, e.labelDecimals) + v.valueUnit,\n                    S = this.applyDecimals(m.value, e.labelDecimals) + m.valueUnit;\n\n                switch (e.labelType) {\n                  case \"text\":\n                    g.text = e.label;\n                    break;\n\n                  case \"fromValue\":\n                    g.text = \"\" + y;\n                    break;\n\n                  case \"toValue\":\n                    g.text = \"\" + S;\n                    break;\n\n                  case \"textFromValue\":\n                    g.text = e.label + y;\n                    break;\n\n                  case \"textToValue\":\n                    g.text = e.label + S;\n                    break;\n\n                  default:\n                    g.text = e.label, d.Helpers.warn(\"Warning: '\" + e.labelType + \"' is not a valid label type.\");\n                }\n\n                i.measure(t, g);\n                var b = g.hheight,\n                    x = g.hwidth,\n                    C = Math.floor(e.labelHorizontalPadding || 0),\n                    w = Math.floor(e.labelVerticalPadding || 0),\n                    L = \"left\" == e.labelHorizontalPosition ? r + x + C : \"center\" == e.labelHorizontalPosition ? r + (s - r) / 2 + C : s - x - C,\n                    T = \"above\" == e.labelVerticalPosition ? c - b - w : \"center\" == e.labelVerticalPosition ? u + (c - u) / 2 - w : u + b - w;\n                i.paint(t, L, T, 1, g);\n              }\n            }\n          }\n        }, t.prototype.paintLabels = function (t, e) {\n          this.axisPoints.paintLabels(t, e, this._chart, this.scene, this.panel, this.title, this.options.style.tick, \"right\" === this.options.side, this.isInside, !1, 0);\n        }, t;\n      }();\n\n      t.ValueAxis = f;\n\n      var g = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e._computedValueAxisList = [], e._computedValueAxis = {}, e._computedSeries = [], e._computedStacks = {}, e.area = new F(), e.legend = new s(), e.valueAxisDefault = new c(), e.valueAxis = {}, e.chartTypes = {\n            columns: {\n              type: \"columns\"\n            },\n            line: {\n              type: \"line\"\n            },\n            candlestick: {\n              type: \"candlestick\"\n            }\n          }, e.stacks = {}, e.seriesDefault = {\n            type: \"columns\"\n          }, e.series = [], e.info = new M(), e.events = new v(), e.horizontal = !1, e.interaction = new P(), e.localization = new A(), e.style = {\n            columnColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\"],\n            lineColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\"]\n          }, e;\n        }\n\n        return n(e, t), e.addSeparateSeries = function (t, e, i, n, r, s, a) {\n          var o = d.Helpers.extendCopy({}, t);\n          o.stack = r, o.id = \"series\" + d.Helpers.SeparatorChar + s, o.name = e, o.data = {\n            aggregation: n,\n            index: i\n          }, o.style = t.style, a.push(o);\n        }, e._hasSeriesSettingsChanged = function (t) {\n          return t.series || t.chartTypes || t.seriesDefault || t.stacks || t.style;\n        }, e.prototype.apply = function (i, n) {\n          var r = i.valueAxis;\n\n          if (r) {\n            var s = [{\n              from: \"style.baseLineColor\",\n              to: \"style.baseLine.lineColor\"\n            }, {\n              from: \"style.baseLineWidth\",\n              to: \"style.baseLine.lineWidth\"\n            }, {\n              from: \"style.hgridLineColor\",\n              to: \"style.hgrid.lineColor\"\n            }, {\n              from: \"style.title.alignment\",\n              to: \"style.title.align\"\n            }, {\n              from: \"style.title.font\",\n              to: \"style.title.textStyle.font\"\n            }, {\n              from: \"style.title.fillColor\",\n              to: \"style.title.textStyle.fillColor\"\n            }, {\n              from: \"style.valueLabel.font\",\n              to: \"style.valueLabel.textStyle.font\"\n            }, {\n              from: \"style.valueLabel.fillColor\",\n              to: \"style.valueLabel.textStyle.fillColor\"\n            }];\n\n            for (var a in r) {\n              this.applyCompatibility(r[a], s, \"valueAxis[\" + a + \"]\");\n            }\n          }\n\n          this.applyCompatibility(i, [{\n            from: \"valueAxis.default\",\n            to: \"valueAxisDefault\"\n          }, {\n            from: \"valueAxisDefault.style.baseLineColor\",\n            to: \"valueAxisDefault.style.baseLine.lineColor\"\n          }, {\n            from: \"valueAxisDefault.style.baseLineWidth\",\n            to: \"valueAxisDefault.style.baseLine.lineWidth\"\n          }, {\n            from: \"valueAxisDefault.style.hgridLineColor\",\n            to: \"valueAxisDefault.style.hgrid.lineColor\"\n          }, {\n            from: \"valueAxisDefault.style.title.alignment\",\n            to: \"valueAxisDefault.style.title.align\"\n          }, {\n            from: \"valueAxisDefault.style.title.font\",\n            to: \"valueAxisDefault.style.title.textStyle.font\"\n          }, {\n            from: \"valueAxisDefault.style.title.fillColor\",\n            to: \"valueAxisDefault.style.title.textStyle.fillColor\"\n          }, {\n            from: \"valueAxisDefault.style.valueLabel.font\",\n            to: \"valueAxisDefault.style.valueLabel.textStyle.font\"\n          }, {\n            from: \"valueAxisDefault.style.valueLabel.fillColor\",\n            to: \"valueAxisDefault.style.valueLabel.textStyle.fillColor\"\n          }]);\n          var o = t.prototype.apply.call(this, i);\n\n          if (this._initializing || e._hasSeriesSettingsChanged(o)) {\n            this._initializing && !o.series && (o.series = []);\n            var l = this.series,\n                h = [],\n                u = null,\n                p = 0;\n            this._computedStacks = d.Helpers.clone(this.stacks);\n\n            for (var f = 0; f < l.length; f++) {\n              var g = l[f];\n              if (!g.valueAxis || \"default\" === g.valueAxis || this.valueAxis[g.valueAxis]) {\n                if (g.data && 0 === g.data.index) d.Helpers.error(\"Value `0` references the timestamp and cannot be used when specifying `series.data.index`.\");else if (g.data && 0 === g.data.countIndex) d.Helpers.error(\"Value `0` references the timestamp and cannot be used when specifying `series.data.countIndex`.\");else if (\"candlestick\" !== g.type || g.data && g.data.index) h.push(g);else {\n                  if (void 0 === g.stack || null === g.stack) {\n                    u = \"default\" + d.Helpers.SeparatorChar + p++;\n                    var v = new m();\n                    v.name = g.name, this._computedStacks[u] = v;\n                  }\n\n                  var y = g.data;\n\n                  if (null == y || null == y.high || null == y.low || null == y.open || null == y.close) {\n                    d.Helpers.error(\"Each candlestick series should define four data properties: low, high, open, close\");\n                    continue;\n                  }\n\n                  var S = g.localization;\n                  S || (S = this.chartTypes.candlestick.localization), S || (S = new w().localization), e.addSeparateSeries(g, S.high || \"high\", y.high, \"max\", u, p++, h), e.addSeparateSeries(g, S.open || \"open\", y.open, \"first\", u, p++, h), e.addSeparateSeries(g, S.close || \"close\", y.close, \"last\", u, p++, h), e.addSeparateSeries(g, S.low || \"low\", y.low, \"min\", u, p++, h);\n                }\n              } else d.Helpers.error(\"The series reference a non-existant value axis `\" + g.valueAxis + \"`.\");\n            }\n\n            this._computedSeries = d.SettingsHelper.mergeDefaultValues(h, this.seriesDefault, this.chartTypes, n.createInstance, n.getMapping, \"series\"), this.applySeriesColor(this._computedSeries);\n          }\n\n          if (this._initializing || o.valueAxis || o.valueAxisDefault || !this._computedValueAxisList.length) {\n            this._initializing && !o.valueAxis && (o.valueAxis = {});\n\n            for (var b = !1, x = 0; x < this._computedSeries.length; x++) {\n              var C = this._computedSeries[x];\n              b = b || \"default\" === C.valueAxis;\n            }\n\n            this._computedValueAxisList = [], this._computedValueAxis = {};\n            var L = this.valueAxisDefault;\n\n            for (var T in this.valueAxis) {\n              var k = new c(),\n                  M = this.valueAxis[T];\n              this.applyCompatibility(M, [{\n                from: \"style.baseLineColor\",\n                to: \"style.baseLine.lineColor\"\n              }, {\n                from: \"style.baseLineWidth\",\n                to: \"style.baseLine.lineWidth\"\n              }, {\n                from: \"style.hgridLineColor\",\n                to: \"style.hgrid.lineColor\"\n              }]), d.SettingsHelper.updateRecursive(k, L, d.SettingsMapping.LinearChartSettingsValueAxis, {}, \"valueAxisDefault\"), d.SettingsHelper.updateRecursive(k, M, d.SettingsMapping.LinearChartSettingsValueAxis, {}, \"valueAxis[\" + T + \"]\"), k.id = T, this._computedValueAxis[T] = k, this._computedValueAxisList.push(k);\n            }\n\n            if (b && !this.valueAxis.default) {\n              var A = d.Helpers.realClone(L);\n              A.id = \"default\", this._computedValueAxis[A.id] = A, this._computedValueAxisList.push(A);\n            }\n\n            this._computedValueAxisList.sort(function (t, e) {\n              return t.id.localeCompare(e.id);\n            });\n          }\n\n          return o;\n        }, e.prototype.applySeriesColor = function (t) {\n          for (var e = 0, i = 0, n = this.style.columnColors, r = this.style.lineColors, s = 0; s < t.length; s++) {\n            var a = t[s];\n            \"columns\" === a.type && null == a.style.fillColor ? (a.style.fillColor = n[e], e = (e + 1) % n.length) : \"line\" === a.type && null == a.style.lineColor && (a.style.lineColor = r[i], i = (i + 1) % r.length);\n          }\n        }, e;\n      }(d.Settings);\n\n      t.Settings = g;\n\n      var v = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.onAnimationDone = null, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsEvents);\n\n      t.SettingsEvents = v;\n\n      var m = function () {\n        function t() {\n          this.name = \"\", this.type = \"normal\", this.separateNegativeValues = null, this.drawFullArea = null;\n        }\n\n        return t;\n      }();\n\n      t.SettingsStack = m;\n\n      var y = function () {\n        function t() {\n          this.id = null, this.enabled = !0, this.data = new b(), this.type = \"columns\", this.valueAxis = \"default\", this.name = null, this.nameLegend = null, this.showInLegend = !0, this.showInInfoPopup = !0, this.legendGroupId = null, this.stack = null, this.cluster = null, this.style = new S();\n        }\n\n        return t.getMapping = function (t, e) {\n          throw new Error(\"This method is abstract.\");\n        }, t.createInstance = function (t, e) {\n          throw new Error(\"This method is abstract.\");\n        }, t;\n      }();\n\n      t.SettingsSeries = y;\n\n      var S = function () {\n        function t() {\n          this.fillColor = null, this.lineColor = null, this.fillGradient = null, this.fillGradientMode = null, this.fillPattern = null, this._fillPatternOpacity = 1, this._currentFillStyleKey = null, this.lineDash = null, this.lineWidth = 1, this.shadowOffsetX = 1, this.shadowOffsetY = -1, this.shadowColor = null, this.legend = {\n            textColor: null,\n            marker: {\n              shape: null\n            }\n          }, this.depth = 0;\n        }\n\n        return t;\n      }();\n\n      t.SettingsSeriesStyle = S;\n\n      var b = function () {\n        function t() {\n          this.source = \"default\", this.valueFunction = null, this.aggregation = \"sum\", this.aggregatedValueFunction = null, this.noDataPolicy = \"join\";\n        }\n\n        return t;\n      }();\n\n      t.SettingsSeriesData = b;\n\n      var x = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.valueLabels = {\n            enabled: !1,\n            style: {\n              padding: 1,\n              margin: 0,\n              aspectRatio: 3,\n              align: \"center\",\n              textStyle: {\n                fillColor: \"black\",\n                font: \"12px Arial\"\n              },\n              backgroundStyle: {\n                lineColor: \"rgba(255,255,255,0.4)\",\n                fillColor: \"rgba(255,255,255,0.4)\"\n              }\n            },\n            position: \"insideTopAuto\",\n            xPosition: \"center\",\n            allowOverlap: !1,\n            minFontSize: 7,\n            contentsFunction: null,\n            useStackedValue: null,\n            showZeroData: !0,\n            showNullData: !0\n          }, e.style = new L(), e.type = \"columns\", e;\n        }\n\n        return n(e, t), e;\n      }(y);\n\n      t.SettingsSeriesColumns = x;\n\n      var C = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.valueLabels = {\n            enabled: !1,\n            style: {\n              padding: 2,\n              margin: 0,\n              aspectRatio: 3,\n              align: \"center\",\n              textStyle: {\n                fillColor: \"black\",\n                font: \"12px Arial\"\n              },\n              backgroundStyle: {\n                lineColor: \"rgba(255,255,255,0.4)\",\n                fillColor: \"rgba(255,255,255,0.4)\"\n              }\n            },\n            position: \"value\",\n            xPosition: \"center\",\n            allowOverlap: !1,\n            minFontSize: 7,\n            contentsFunction: null,\n            useStackedValue: null,\n            showZeroData: !0,\n            showNullData: !0\n          }, e.style = new T(), e.type = \"line\", e;\n        }\n\n        return n(e, t), e;\n      }(y);\n\n      t.SettingsSeriesLines = C;\n\n      var w = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.style = new k(), e.localization = {\n            high: \"high\",\n            low: \"low\",\n            open: \"open\",\n            close: \"close\"\n          }, e.type = \"candlestick\", e;\n        }\n\n        return n(e, t), e;\n      }(y);\n\n      t.SettingsSeriesCandleStick = w;\n\n      var L = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.minHeight = 4, e.gradient = .8, e.fillGradientMode = null, e.fillGradientType = null, e.lineColor = \"\", e.padding = [1, 1], e.clusterPadding = [2, 2], e.shadowBlur = 3, e.depth = 0, e.depthBrightness = .5, e.radius = [0, 0, 0, 0], e.widthScale = 1, e.connectorLineID = null, e.connectorLinePositionX = \"edge\", e.enableOutlineLines = !0, e;\n        }\n\n        return n(e, t), e;\n      }(S);\n\n      t.SettingsSeriesColumnsStyle = L;\n\n      var T = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.shadowBlur = 5, e.smoothing = !1, e.steps = !1, e.marker = {\n            shape: null,\n            width: 10,\n            fillColor: null,\n            lineColor: null,\n            lineWidth: 1\n          }, e.markerStyleFunction = null, e;\n        }\n\n        return n(e, t), e;\n      }(S);\n\n      t.SettingsSeriesLinesStyle = T;\n\n      var k = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.pattern = \"candlestick\", e.padding = [1, 1], e.increase = {\n            bar: {\n              lineColor: \"green\",\n              shadowColor: null,\n              lineDash: null,\n              lineWidth: 1,\n              shadowOffsetX: 1,\n              shadowOffsetY: -1,\n              shadowBlur: 0\n            },\n            candlestick: {\n              lineColor: \"#000\",\n              shadowColor: null,\n              lineDash: null,\n              lineWidth: 1,\n              shadowOffsetX: 1,\n              shadowOffsetY: -1,\n              shadowBlur: 0,\n              fillColor: \"yellow\"\n            }\n          }, e.decrease = {\n            bar: {\n              lineColor: \"red\",\n              shadowColor: null,\n              lineDash: null,\n              lineWidth: 1,\n              shadowOffsetX: 1,\n              shadowOffsetY: -1,\n              shadowBlur: 0\n            },\n            candlestick: {\n              lineColor: \"#000\",\n              shadowColor: null,\n              lineDash: null,\n              lineWidth: 1,\n              shadowOffsetX: 1,\n              shadowOffsetY: -1,\n              shadowBlur: 0,\n              fillColor: \"black\"\n            }\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(S);\n\n      t.SettingsSeriesCandleStickStyle = k;\n\n      var M = function () {\n        function t() {\n          this.enabled = !0, this.useStackedValue = !1, this.showNoData = !0, this.showZeroData = !0, this.showNullData = !0, this.position = \"inside\", this.valueFormatterFunction = null, this.aggregations = null, this.style = {\n            highlight: {\n              fillColor: \"rgba(30,160,220,0.15)\",\n              fadeIn: 200,\n              fadeOut: 200\n            }\n          }, this.advanced = {\n            contentsFunction: null,\n            showOnlyHoveredSeries: !1,\n            scope: null,\n            showHeader: !0\n          };\n        }\n\n        return t;\n      }();\n\n      t.SettingsInfoPopup = M;\n\n      var A = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.valueUnits = {\n            K: 1e3,\n            M: 1e6,\n            B: 1e9,\n            T: 1e12,\n            P: 1e15\n          }, e.noDataLabel = \"No data\", e.unnamedSeries = \"Unnamed\", e.toolbar = new I(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLocalization);\n\n      t.SettingsLocalization = A;\n\n      var I = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.linButton = \"Lin\", e.logButton = \"Log\", e.linLogTitle = \"Switch lin/log scale\", e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLocalizationToolbar);\n\n      t.SettingsLocalizationToolbar = I;\n\n      var P = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.swipeSensitivity = .6, e.ignoreBottomAxis = !1, e.scrolling = new N(), e.zooming = new D(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsInteraction);\n\n      t.SettingsInteraction = P;\n\n      var D = function () {\n        function t() {\n          this.enabled = !0, this.wheel = !1, this.swipe = !0, this.fingers = !0, this.fingersMaxZoom = 10, this.sensitivity = 2, this.wheelSensitivity = 1.5, this.keyboardFactor = 2, this.upDownTreshold = 10, this.zoomHighlightThreshold = 1.5;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionZooming = D;\n\n      var N = function () {\n        function t() {\n          this.enabled = !0, this.swipePageFlipping = !0, this.keyboardScrollingFactor = 1, this.kineticFriction = 1e-6, this.maxAnimationLength = 1500;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionScrolling = N;\n\n      var F = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.style = new O(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsArea);\n\n      t.SettingsArea = F;\n\n      var O = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.noData = {\n            fillColor: \"#888\",\n            image: null\n          }, e.zoomHighlight = {\n            fillColor: \"rgba(30,160,220,0.15)\",\n            fadeIn: 100,\n            fadeOut: 500\n          }, e.zoomHighlightInactive = {\n            fillColor: \"rgba(30,160,220,0.08)\"\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsAreaStyle);\n\n      t.SettingsAreaStyle = O, function (e) {\n        var i = function (t) {\n          function e(e, i) {\n            var n,\n                r = e.settings.localization.toolbar;\n            i.title = i.title || r.linLogTitle, i.label = i.label || r.linButton, n = t.call(this, e, i) || this;\n            var s = (i.cssClass || \"\") + \" DVSL-bar-btn DVSL-bar-btn-l\";\n            return n.linClass = s + \"in\", n.logClass = s + \"og\", n.logScale = n.chart.scene.settings.valueAxisDefault.logScale, n.updateElements(), n;\n          }\n\n          return n(e, t), e.prototype.onClick = function (e) {\n            this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, \"user\"), t.prototype.onClick.call(this, e);\n          }, e.prototype.updateElements = function () {\n            var t = this.chart.settings.localization.toolbar,\n                e = this.logScale;\n            this.a.className = e ? this.logClass : this.linClass, this.options.showLabel !== !1 && (this.p.innerHTML = e ? t.logButton : t.linButton);\n          }, e.prototype.onSceneChange = function (t) {\n            var e = this.chart.scene.settings.valueAxisDefault.logScale;\n            t.settings && e !== this.logScale && (this.logScale = e, this.updateElements());\n          }, e;\n        }(d.Bar.Button);\n\n        e.LinLogButton = i, d.Bar.ToolbarItemNames.logScale = function (e, i) {\n          return new t.Bar.LinLogButton(e, i);\n        };\n      }(e = t.Bar || (t.Bar = {}));\n\n      var E = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.enabled = !0, e.export = !0, e.back = !0, e.zoomOut = !0, e.logScale = !0, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsToolbar);\n\n      t.SettingsToolbar = E;\n\n      var R = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 1e3, i.chart = null, i.scene = null, i.events = null, i.pointer1 = null, i.pointer2 = null, i.t1 = 0, i.t2 = 0, i.x1 = 0, i.x2 = 0, i.scaleOrigin = null, i.initialZoom = null, i.dragStartFrom = null, i.dragStartTo = null, i.active = !1, i.lastScrollingY = 0, i.scrollingActive = !1, i.scalingActive = 0, i.hadSecondPointer = !1, i.wheelOrigin = null, i.wheelProportion = null, i.highlight = null, i.highlightRemoveWhenDone = !1, i._animationsDone = !0, i.chart = e, i.scene = e.scene, i.events = e.events, i._settings = e.settings.interaction, i.inertiaF = new d.Inertia(1, 0, !0), i.inertiaT = new d.Inertia(1, 0, !0), i;\n        }\n\n        return n(e, t), e.prototype.getVisibleRange = function () {\n          return this._currentTo - this._currentFrom;\n        }, e.prototype.onZoomOut = function (t, e, i, n) {\n          return null == n && (n = 2), {\n            from: i - (i - t) * n,\n            to: i + (e - i) * n,\n            center: i\n          };\n        }, e.prototype.onZoomIn = function (t, e, i, n) {\n          return void 0 === n && (n = .5), null == n && (n = .5), {\n            from: i - (i - t) * n,\n            to: i + (e - i) * n,\n            center: i\n          };\n        }, e.prototype.onScroll = function (t, e, i) {\n          return \"<\" === i ? {\n            from: 2 * t - e,\n            to: t\n          } : {\n            from: e,\n            to: 2 * e - t\n          };\n        }, e.prototype.onGoHome = function (t, e) {\n          return {\n            from: t,\n            to: e,\n            origin: e\n          };\n        }, e.prototype.getFrom = function (t) {\n          return null == t || t === 1 / 0 ? this.inertiaF.getTargetValue() : this.inertiaF.getValue(t);\n        }, e.prototype.getTo = function (t) {\n          return null == t || t === 1 / 0 ? this.inertiaT.getTargetValue() : this.inertiaT.getValue(t);\n        }, e.prototype.setFrom = function (t, e, i, n) {\n          void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaF.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentFrom = t, this.inertiaF.jump(t));\n        }, e.prototype.setTo = function (t, e, i, n) {\n          void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaT.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentTo = t, this.inertiaT.jump(t));\n        }, e.prototype.onWheel = function (t) {\n          if (null === this.pointer1) {\n            var e = this.getFrom(),\n                i = this.getTo();\n\n            if (!(e >= i)) {\n              var n = this._settings;\n\n              if (n.zooming.wheel && n.zooming.enabled && this.xyInArea(t.x, t.y)) {\n                this.active = !0;\n                var r = this.wheelOrigin;\n                null === r && (this.wheelOrigin = this.scaleOrigin = r = this.xyToPosition(t.x, t.y), this.wheelProportion = (r - e) / (i - e), this.x1 = t.x);\n                var s = this.wheelProportion,\n                    a = Math.pow(Math.max(1.1, n.zooming.wheelSensitivity), .004 * t.wheely);\n                e = r - (i - e) * s * a, i = r + (i - e) * (1 - s) * a;\n                var o = t.wheely < 0 ? 1 : -1,\n                    l = d.Helpers.performanceNow();\n                this.handleZoomWheel(e, i, r, l, o), t.consumed = !0, this.active = !1;\n              }\n            }\n          }\n        }, e.prototype.onPointerDown = function (t) {\n          this.wheelOrigin = null;\n          var e = this._settings;\n\n          if (this.xyInArea(t.x, t.y) && (e.scrolling.enabled || e.zooming.enabled)) {\n            var i = this.xyToPosition(t.x, t.y),\n                n = d.Helpers.performanceNow(),\n                r = this.getFrom(n),\n                s = this.getTo(n);\n\n            if (r > s) {\n              var a = s;\n              s = r, r = a;\n            }\n\n            null === this.pointer1 ? (this.pointer1 = t.identifier, this.x1 = t.x, this.t1 = i, this.scaleOrigin = i, this.onStartDragging(r, s, i), this.lastScrollingY = t.y, this.dragStartFrom = r, this.dragStartTo = s, this.dragCurFrom = r, this.dragCurTo = s, t.consumed = !0, this.inertiaF.finished(n) && this.inertiaT.finished(n) || (this.setFrom(r), this.setTo(s), this.stopAnimations(), this.scrollingActive = !0), this.chart.cancelChartUpdateNotify(), t.consumed = !0) : null === this.pointer2 ? (this.pointer2 = t.identifier, this.x2 = t.x, this.t2 = i, this.initialZoom = s - r, this.scaleOrigin = (this.t1 + this.t2) / 2, t.consumed = !0) : (this.scalingActive || this.scrollingActive) && (t.consumed = !0);\n          }\n        }, e.prototype.xyToDragPosition = function (t, e) {\n          return this.dragCurFrom + (t - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom);\n        }, e.prototype.scaleViewRange = function (t, e, i) {\n          var n = Math.pow(1 + this._settings.zooming.sensitivity, -t.dy / this.scene.height);\n          return e = (e - this.scaleOrigin) * n + this.scaleOrigin, i = (i - this.scaleOrigin) * n + this.scaleOrigin, {\n            from: e,\n            to: i\n          };\n        }, e.prototype.onPointerMove = function (t) {\n          null !== this.wheelOrigin && Math.abs(this.x1 - t.x) > this._settings.zooming.sensitivity && (this.wheelOrigin = null);\n        }, e.prototype.onPointerDrag = function (t) {\n          var e = this.dragCurFrom,\n              i = this.dragCurTo,\n              n = this._settings;\n\n          if (t.identifier === this.pointer1 && null === this.pointer2) {\n            this.scaleOrigin = this.t1, this.x1 = t.x;\n            var r = t.y - this.lastScrollingY;\n\n            if (Math.abs(t.dx) > 4 * Math.abs(t.dy) && n.scrolling.enabled && (this.scrollingActive = !0), !this.hadSecondPointer && (n.zooming.enabled && n.zooming.swipe && Math.abs(r) > n.zooming.upDownTreshold ? this.scalingActive = r > 0 ? 1 : -1 : this.scalingActive = 0, this.scalingActive)) {\n              this.clearZoomHighlight();\n              var s = this.scaleViewRange(t, e, i);\n              e = s.from, i = s.to, t.consumed = !0;\n            }\n\n            if (this.scrollingActive) {\n              var a = this.xyToDragPosition(t.x, t.y),\n                  o = this.t1 - a;\n              e += o, i += o;\n            }\n          } else if (t.identifier === this.pointer1 && n.scrolling.enabled) {\n            this.x1 = t.x, this.clearZoomHighlight();\n            var l = this.twoPointerDrag();\n            e = l.from, i = l.to;\n          } else {\n            if (t.identifier !== this.pointer2 || !n.scrolling.enabled) return void ((this.scalingActive || this.scrollingActive) && (t.consumed = !0));\n            this.x2 = t.x, this.clearZoomHighlight();\n            var l = this.twoPointerDrag();\n            e = l.from, i = l.to;\n          }\n\n          this.dragCurFrom = e, this.dragCurTo = i;\n          var h = this.onSnapWhileDragging(e, i, this.scaleOrigin, this.scrollingActive, this.scalingActive);\n          this.goToPositionDragging(h.from, h.to), t.consumed = !0;\n        }, e.prototype.twoPointerDrag = function () {\n          var t = this._settings,\n              e = t.zooming.fingersMaxZoom;\n          this.scaleOrigin = (this.t1 + this.t2) / 2;\n          var i = this.t2 - this.t1,\n              n = this.dragCurFrom,\n              r = this.dragCurTo,\n              s = this.xyToDragPosition(this.x1, 0),\n              a = this.xyToDragPosition(this.x2, 0);\n\n          if (t.scrolling.enabled && t.zooming.enabled && t.zooming.fingers && 0 !== i) {\n            var o = this.initialZoom,\n                l = ((s + a) / 2 - this._currentFrom) / (this._currentTo - this._currentFrom),\n                h = (a - s) / (this._currentTo - this._currentFrom),\n                u = void 0;\n            u = i * h > 0 ? i / h : 1 / 0;\n            var c = o * e,\n                d = o / e;\n            u = Math.max(d, Math.min(c, u)), n = this.scaleOrigin - l * u, r = this.scaleOrigin + (1 - l) * u, this.scalingActive = u < o ? 1 : -1, this.scrollingActive = !0, this.hadSecondPointer = !0;\n          } else if (t.scrolling.enabled) {\n            var p = (this.t1 + this.t2) / 2,\n                f = (s + a) / 2,\n                g = p - f;\n            n += g, r += g, this.scrollingActive = !0;\n          }\n\n          return {\n            from: n,\n            to: r\n          };\n        }, e.prototype.onPointerUp = function (t) {\n          var e = this._settings,\n              i = d.Helpers.performanceNow(),\n              n = this.scrollingActive,\n              r = this.scalingActive;\n          if (t.identifier === this.pointer2) this.pointer2 = null, t.consumed = !0, this.scaleOrigin = this.t1;else if (t.identifier === this.pointer1 && null !== this.pointer2) this.pointer1 = this.pointer2, this.pointer2 = null, this.t1 = this.t2, this.scaleOrigin = this.t1, t.consumed = !0;else if (t.identifier === this.pointer1) {\n            this.pointer1 = null, this.active = !0;\n            var s = void 0,\n                a = void 0,\n                o = void 0;\n\n            if (e.scrolling.enabled) {\n              o = -t.vx, o = o > 0 ? Math.min(o, .002 * this.scene.width) : Math.max(o, .002 * -this.scene.width);\n              var l = this.getVisibleRange();\n              o = o * l / this.scene.width;\n            } else o = 0;\n\n            if (this.updateFriction(i), this.inertiaF.jump(this._currentFrom, o, i), this.inertiaT.jump(this._currentTo, o, i), this._animationsDone = !1, e.scrolling.swipePageFlipping && t.swipeUp && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {\n              var h = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);\n              s = h.from, a = h.to;\n            } else if (e.scrolling.swipePageFlipping && t.swipeDown && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {\n              var u = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);\n              s = u.from, a = u.to;\n            } else if (n || r) {\n              if (n && !r && e.scrolling.swipePageFlipping && (t.swipeLeft || t.swipeRight) && t.swipeSpeed > this.scene.width / e.swipeSensitivity * .7) {\n                var c = t.swipeLeft ? \"<\" : \">\",\n                    p = this.onScroll(this.dragStartFrom, this.dragStartTo, c);\n                s = p.from, a = p.to;\n              } else s = this._currentFrom, a = this._currentTo;\n\n              this.scaleOrigin = (s + a) / 2;\n            }\n\n            if (s || a) {\n              var f = this.onSnapAfterDragging(this.inertiaF.getTargetValue(), this.inertiaT.getTargetValue(), this.scaleOrigin, n || 0 !== r, r);\n              f && this.goToPosition(f.from, f.to, !0, i, !1), t.consumed = !0, this.scaleOrigin = null;\n            }\n\n            this.hadSecondPointer = !1, this.active = !1, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1;\n          } else (r || n) && (t.consumed = !0);\n        }, e.prototype.onPointerCancel = function (t) {\n          t.identifier === this.pointer2 ? (this.pointer2 = null, this.scaleOrigin = this.t1) : t.identifier === this.pointer1 && null !== this.pointer2 ? (this.pointer1 = this.pointer2, this.t1 = this.t2, this.scaleOrigin = this.t1, this.pointer2 = null, this.t2 = null) : t.identifier === this.pointer1 && (this.active = !0, this.pointer1 = null, this.t1 = null, this.scaleOrigin = null, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1, this.active = !1, this.hadSecondPointer = !1);\n        }, e.prototype.onKeyDown = function (t) {}, e.prototype.goToPositionDragging = function (t, e) {\n          this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e);\n        }, e.prototype.goToPosition = function (t, e, i, n, r) {\n          if (t < e) if (this._currentFrom < this._currentTo || (i = !1), this.stopAnimations(), i) {\n            var s = this._settings.zooming.zoomHighlightThreshold,\n                a = this._currentFrom,\n                o = this._currentTo;\n            this.updateFriction(n, t, e), this.setFrom(t, !0, n, r), this.setTo(e, !0, n, r);\n            var l = Math.abs((t - e) / (a - o + 1));\n            if (l < 1 / s) this.setZoomHighlight(t, e, !0);else if (l > s) {\n              var h = null !== this.dragStartFrom ? this.dragStartFrom : a,\n                  u = null !== this.dragStartTo ? this.dragStartTo : o;\n              this.setZoomHighlight(h, u, !1);\n            }\n            this.events.notifySceneChanges({\n              requestPaint: !0\n            });\n          } else this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e), this.onAnimationDone(t, e), this._animationsDone = !0;\n        }, e.prototype.doAnimations = function (t) {\n          if (!this._animationsDone) {\n            var e = t.timeStamp,\n                i = this.inertiaF.finished(e),\n                n = this.inertiaT.finished(e);\n            this._animationsDone = i && n;\n            var r = this._currentFrom = this.getFrom(e),\n                s = this._currentTo = this.getTo(e);\n            this._animationsDone || isNaN(r + s) ? (this.stopAnimations(), this.onPositionChanged(r, s, !1), this.onAnimationDone(r, s)) : (this.onPositionChanged(r, s, !0), t.animating = !0);\n          }\n        }, e.prototype.stopAnimations = function () {\n          this.highlight && (this.highlightRemoveWhenDone ? this.clearZoomHighlight() : (this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor, this.events.notifySceneChanges({\n            highlight: !0\n          })));\n        }, e.prototype.abort = function () {\n          this.isActive() && (this.pointer2 && this.onPointerCancel({\n            identifier: this.pointer2\n          }), this.pointer1 && this.onPointerCancel({\n            identifier: this.pointer1\n          }), this.setFrom(this._currentFrom), this.setTo(this._currentTo), this.clearZoomHighlight(), this._animationsDone = !0);\n        }, e.prototype.isActive = function () {\n          return this.active || null != this.pointer1 || !this._animationsDone;\n        }, e.prototype.clearZoomHighlight = function () {\n          this.highlight && (this.scene.removeHighlight(\"zoomTrace\"), this.highlight = null, this.events.notifySceneChanges({\n            highlight: !0\n          }));\n        }, e.prototype.setZoomHighlight = function (t, e, i) {\n          this.highlight = this.scene.setHighlight(\"zoomTrace\", t, e, this.scene.settings.area.style.zoomHighlight), this.highlightRemoveWhenDone = i, this.events.notifySceneChanges({\n            highlight: !0\n          });\n        }, e.prototype.updateFriction = function (t, e, i) {\n          var n = this.getVisibleRange();\n\n          if (null != e && null != i) {\n            var r = i - e,\n                s = .3,\n                a = n * (1 - s) > r,\n                o = n * (1 + s) < r;\n            o && (n = r), (a || o) && (n *= 2);\n          }\n\n          var l = n * this._settings.scrolling.kineticFriction;\n          this.inertiaF.setAcceleration(l, t), this.inertiaT.setAcceleration(l, t);\n        }, e;\n      }(d.ChartElement);\n\n      t.Scrolling = R;\n\n      var H = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.highlights = {}, e.dataLabels = {\n            spots: {},\n            fontWidths: Object.create(null),\n            metaData: {\n              availableWidth: 0,\n              styles: null\n            }\n          }, e.transform = [1, 0, 0, 1, 0, 0], e.invertedTransform = [1, 0, 0, 1, 0, 0], e.bottomAxisSize = 0, e;\n        }\n\n        return n(e, t), e.prototype.xyInChart = function (t, e) {\n          return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height;\n        }, e.prototype.xyInChartOrBottom = function (t, e) {\n          var i = this.settings.interaction.ignoreBottomAxis ? 0 : this.bottomAxisSize;\n          return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height + i;\n        }, e.prototype.xyInBottom = function (t, e) {\n          return !this.settings.interaction.ignoreBottomAxis && t >= this.x0 && t < this.x0 + this.width && e >= this.y0 + this.height && e < this.y0 + this.height + this.bottomAxisSize;\n        }, e.prototype.timeToX = function (t) {\n          throw \"Need to implement timeToX\";\n        }, e.prototype.xToTime = function (t) {\n          throw \"Need to implement xToTime\";\n        }, e.prototype.setHighlight = function (t, e, i, n) {\n          var r = this.highlights[t];\n          return r ? (r.from = e, r.to = i, r.style = n, r.removed = !1) : (r = {\n            from: e,\n            to: i,\n            style: n,\n            removed: !1\n          }, this.highlights[t] = r), r;\n        }, e.prototype.removeHighlight = function (t) {\n          var e = this.highlights[t];\n          e && (e.removed = !0, delete this.highlights[t]);\n        }, e.prototype.prepareRotationMatrix = function (t) {\n          if (t) {\n            var e = new GLMath.mat3([0, -1, 0, 1, 0, 0, 0, 0, 1]),\n                i = new GLMath.mat3([1, 0, this.height + this.topMargin + this.bottomMargin, 0, 1, 0, 0, 0, 1]),\n                n = e.multiply(i);\n            this.assignTransform(this.transform, d.Geometry.mat3ToMat2d(n)), this.assignTransform(this.invertedTransform, d.Geometry.mat3ToMat2d(n.inverse()));\n          }\n        }, e.prototype.assignTransform = function (t, e) {\n          for (var i = 0; i < t.length; i++) {\n            t[i] = e[i];\n          }\n        }, e;\n      }(d.Scene);\n\n      t.Scene = H;\n\n      var z = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 45, i.updateOrder = 700, i.scene = null, i.customId = 0, i.animating = !1, i.highlights = {}, i.chart = e, i.scene = e.scene, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          if (t.changes.highlight) {\n            var e = [];\n\n            for (var i in this.highlights) {\n              var n = this.highlights[i];\n              n.exiting = !0, n.origin.removed && (delete this.highlights[i], n.animator = null, e.push(n));\n            }\n\n            for (var r = 0; r < e.length; r++) {\n              var n = e[r];\n              this.highlights[\"__\" + ++this.customId] = n;\n            }\n\n            for (var i in this.scene.highlights) {\n              var s = this.scene.highlights[i];\n\n              if (this.highlights[i]) {\n                var n = this.highlights[i];\n                n.exiting = !1, n.from = s.from, n.to = s.to, n.style = d.Helpers.clone(s.style);\n              } else {\n                var n = {\n                  from: s.from,\n                  to: s.to,\n                  style: d.Helpers.clone(s.style),\n                  animator: null,\n                  exiting: !1,\n                  origin: s\n                };\n                this.highlights[i] = n, s.style.fadeIn > 0 && (this.animating = !0, n.animator = new d.ColorAnimator(d.Colors.derive(d.Colors.parse(n.style.fillColor), 1, 0), n.style.fillColor, n.style.fadeIn, \"=\", t.timeStamp));\n              }\n            }\n\n            for (var i in this.highlights) {\n              var n = this.highlights[i];\n\n              if (n.exiting && !n.animator) {\n                var a = n.style;\n                a.fadeOut > 0 ? (this.animating = !0, n.animator = new d.ColorAnimator(a.fillColor, d.Colors.derive(d.Colors.parse(a.fillColor), 1, 0), a.fadeOut, \"=\", t.timeStamp)) : delete this.highlights[i];\n              }\n            }\n          }\n\n          if (this.animating) {\n            var o = !1,\n                l = t.timeStamp;\n\n            for (var i in this.highlights) {\n              var n = this.highlights[i];\n              n.animator && (n.style.fillColor = n.animator.get(l), n.animator.finished(l) ? (n.animator = null, n.exiting && delete this.highlights[i]) : o = !0);\n            }\n\n            this.animating = o, t.animating = t.animating || o;\n          }\n        }, e.prototype.paintScene = function (t) {\n          var e = this.scene.x0,\n              i = e + this.scene.width,\n              n = Math.round(this.scene.y0),\n              r = this.scene.height,\n              s = t.context,\n              a = this.chart.settings.horizontal;\n          a && s.transform.apply(s, this.chart.scene.transform);\n\n          for (var o in this.highlights) {\n            var l = this.highlights[o],\n                h = Math.max(this.scene.timeToX(l.from), e),\n                u = Math.min(this.scene.timeToX(l.to), i);\n            u < e || h > i || (d.Graphics.rectStyle(s, l.style), s.fillRect(h, n, u - h, r));\n          }\n\n          a && s.transform.apply(s, this.chart.scene.invertedTransform);\n        }, e;\n      }(d.ChartElement);\n\n      t.Highlights = z;\n\n      var B = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.rightAxis = null, i.leftAxis = null, i.timeAxisPanel = null, i;\n        }\n\n        return n(e, t), e.prototype.createDom = function (e) {\n          t.prototype.createDom.call(this, e), this.timeAxisPanel = d.Helpers.createDom(\"div\", \"DVSL-TC-timeAxis\", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.timeAxisPanel), this.leftAxis = d.Helpers.createDom(\"div\", \"DVSL-valueAxis\", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.leftAxis), this.rightAxis = d.Helpers.createDom(\"div\", \"DVSL-valueAxis\", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.rightAxis);\n        }, e.prototype.doAnimations = function (e) {\n          t.prototype.doAnimations.call(this, e), e.changes.bounds && (this.background.style.left = this.scene.x0 + \"px\", this.background.style.right = this.scene.chartWidth - (this.scene.x0 + this.scene.width) + \"px\", this.leftAxis.style.width = this.scene.leftMargin + \"px\", this.leftAxis.style.bottom = this.scene.bottomMargin + \"px\", this.rightAxis.style.width = this.scene.rightMargin + \"px\", this.rightAxis.style.bottom = this.scene.bottomMargin + \"px\", this.timeAxisPanel.style.top = this.scene.y0 + this.scene.height + \"px\", this.timeAxisPanel.style.left = this.scene.x0 + \"px\", this.timeAxisPanel.style.width = this.scene.width + \"px\", this.outerBorder.style.left = this.scene.x0 + \"px\", this.outerBorder.style.width = this.scene.width + \"px\");\n        }, e;\n      }(d.DomLayer);\n\n      t.DomLayer = B;\n\n      var U = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e, i, n) || this;\n          return r.scrolling = null, r.renderer = null, r.scene.prepareRotationMatrix(e.horizontal), r;\n        }\n\n        return n(e, t), e.prototype.createDomLayer = function () {\n          return new B(this);\n        }, e.prototype.notifyAnimationDone = function () {\n          var t = this;\n          window.setTimeout(function () {\n            t.removed || t.dispatchEventParams(\"animationDone\", t.createEventArguments(null, \"api\"), null);\n          }, 0);\n        }, e.prototype.processChangedSettings = function (t) {\n          var e = t.settingsChanges;\n          e && (g._hasSeriesSettingsChanged(e) && (t.linearChartSeries = !0), (e.valueAxis || e.valueAxisDefault) && (t.linearChartValueAxis = !0));\n        }, e.prototype.updateSettings = function (e, i) {\n          t.prototype.updateSettings.call(this, e, i);\n        }, e.prototype.setLogScale = function (t, e) {\n          var i = {};\n\n          for (var n in this.settings.valueAxis) {\n            i[n] = {\n              logScale: t\n            };\n          }\n\n          this.updateSettings({\n            valueAxisDefault: {\n              logScale: t\n            },\n            valueAxis: i\n          }, e);\n        }, e.prototype.finalInitialize = function () {\n          t.prototype.finalInitialize.call(this), this.legend = this.events.addElement(new h(this));\n        }, e.prototype.getEnabledSeries = function () {\n          for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) {\n            e[i].enabled && t.push(e[i]);\n          }\n\n          return t;\n        }, e.prototype.getSeries = function () {\n          for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) {\n            t.push(e[i]);\n          }\n\n          return t;\n        }, e;\n      }(d.Impl);\n\n      t.Impl = U;\n\n      var G = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 10, i.t0 = 0, i.t1 = 0, i.object = null, i.activePointer = null, i.pointerX = 0, i.pointerY = 0, i.chart = e, i.container = e.shell.interactiveContainer, i.scene = e.scene, i.events = e.events, i.popup = new V(i.chart), i.settings = e.scene.settings.info, i;\n        }\n\n        return n(e, t), e.prototype.getPopupAreaMouseMoved = function (t, e) {\n          return null;\n        }, e.prototype.buildHeader = function (t, e) {\n          return \"\";\n        }, e.prototype.applyEventPosToPointer = function (t) {\n          this.pointerX = t.x, this.pointerY = t.y;\n        }, e.prototype.show = function (t) {\n          this.settings.enabled && (this.applyEventPosToPointer(t), this.updatePopup(t));\n        }, e.prototype.previewPointerMove = function (t) {\n          !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.applyEventPosToPointer(t), this.updatePopup(t));\n        }, e.prototype.previewPointerDrag = function (t) {\n          !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.activePointer = t.identifier, this.applyEventPosToPointer(t));\n        }, e.prototype.previewPointerCancel = function (t) {\n          null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n        }, e.prototype.previewPointerUp = function (t) {\n          null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n        }, e.prototype.previewPointerOut = function (t) {\n          !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || t.touch || (this.activePointer = null, this.pointerX = null, this.pointerY = null, d.Helpers.isParentOf(this.popup.popup, t.target) || this.hideInfoPopup(t));\n        }, e.prototype.previewRightClick = function (t) {\n          this.settings.enabled && t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t));\n        }, e.prototype.previewPointerDown = function (t) {\n          this.settings.enabled && null === this.activePointer && (this.activePointer = t.identifier, this.hideInfoPopup(t));\n        }, e.prototype.updatePopup = function (t) {\n          if (!this.pointerX && !this.pointerY) return void this.hideInfoPopup(t);\n          var e = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);\n          e ? this.showInfoPopup(e.t0, e.t1, e.obj, e.contents, t) : this.hideInfoPopup(t);\n        }, e.prototype.manualShowInfoPopup = function (t, e, i) {\n          this.showInfoPopup(t, e, null, i || this.buildContent(t, e, null, null), null);\n        }, e.prototype.showInfoPopup = function (t, e, i, n, r) {\n          if (!this.popup.visible || t !== this.t0 || e !== this.t1 || i !== this.object || this.contents !== n) {\n            var s = this.scene,\n                a = this.settings;\n            this.t0 = t, this.t1 = e, this.object = i, this.contents = n, s.setHighlight(\"infoRange\", t, e, a.style.highlight), this.popup.show(s.timeToX(this.t0), s.timeToX(this.t1), s.y0, n, d.InfoPopupPosition[a.position]), this.notifyChanges(r);\n          }\n        }, e.prototype.notifyChanges = function (t) {\n          t ? (t.changes.infoLabel = !0, t.changes.highlight = !0) : this.events.notifySceneChanges({\n            infoLabel: !0,\n            highlight: !0\n          });\n        }, e.prototype.hideInfoPopup = function (t) {\n          this.popup.visible && (this.popup.hide(), this.t0 = 0, this.t1 = 0, this.scene.removeHighlight(\"infoRange\"), this.notifyChanges(t));\n        }, e.prototype.paintScene = function (t) {\n          this.popup.visible && this.updateXY();\n        }, e.prototype.updateXY = function () {\n          var t = this.scene,\n              e = t.timeToX(this.t0),\n              i = t.timeToX(this.t1),\n              n = t.y0;\n          this.popup.updateXY(e, i, n, d.InfoPopupPosition[t.settings.info.position]);\n        }, e.prototype.getPopupMouseMoved = function (t, e, i, n, r, s) {\n          if (this.scene.displayUnit && !this.scene.xyInChartOrBottom(t, e)) return null;\n          var a = this.getPopupAreaMouseMoved(t, e);\n          if (!a) return null;\n          var o = a.t0,\n              l = a.t1,\n              h = null,\n              u = null,\n              c = this.scene.hoverSeriesItem,\n              d = this.settings.advanced.scope,\n              p = o,\n              f = l;\n          if (c && (u = c.seriesIndex, (\"stack\" === d || \"value\" === d || \"auto\" === d && void 0 !== u && null !== u) && (p = this.scene.xToTime(c.x0), f = this.scene.xToTime(c.x1)), h = c.stack), null === p) return null;\n          if (p === i && f === n && u === r) return {\n            t0: i,\n            t1: n,\n            obj: r,\n            contents: s\n          };\n          var g = this.buildContent(o, l, u, h);\n          return {\n            t0: p,\n            t1: f,\n            obj: u,\n            contents: g\n          };\n        }, e.prototype.getContentsFunctionRange = function (t, e) {\n          return [t, e];\n        }, e.prototype.buildContent = function (t, e, i, n) {\n          var r,\n              s = this.settings.advanced,\n              a = this.chart.renderer.exportData(t, e);\n\n          if (s.contentsFunction) {\n            var o = null;\n            null !== i && this.scene.settings._computedSeries.length > i && (o = this.scene.settings._computedSeries[i]), r = s.contentsFunction.call(this.chart.api, a, o, this.getContentsFunctionRange(t, e));\n          } else r = this.buildValues(a, i, n);\n\n          if (!s.showHeader) return r;\n          var l = this.buildHeader(t, e);\n          return l + r;\n        }, e.prototype.buildValues = function (t, e, i) {\n          var n = this.chart.settings,\n              r = {},\n              s = 0;\n\n          for (var a in n.valueAxis) {\n            if (n.valueAxis[a].valueFormat) {\n              var o = d.Helpers.matchPercentFormat(n.valueAxis[a].valueFormat);\n              r[a] = o, s++;\n            }\n          }\n\n          var l = void 0;\n          n.valueAxisDefault && n.valueAxisDefault.valueFormat && (l = d.Helpers.matchPercentFormat(n.valueAxisDefault.valueFormat));\n          var h = {},\n              u = 0;\n\n          for (var a in n.valueAxis) {\n            if (n.valueAxis[a].valueFormat) {\n              var o = d.Helpers.matchCurrencyFormat(n.valueAxis[a].valueFormat);\n              h[a] = o, u++;\n            }\n          }\n\n          var c = void 0;\n          n.valueAxisDefault && n.valueAxisDefault.valueFormat && (c = d.Helpers.matchCurrencyFormat(n.valueAxisDefault.valueFormat));\n\n          for (var p = n.localization.noDataLabel, f = n.info.valueFormatterFunction, g = n.info.advanced.showOnlyHoveredSeries ? n.info.advanced.scope : null, v = i && (\"stack\" === g || \"value\" === g) || \"auto\" === g && void 0 !== e && null !== e, m = \"value\" === g, y = \"\", S = !1, b = 0; b < t.length; b++) {\n            var C = t[b];\n\n            if (v) {\n              for (var w = !1, L = 0; L < C.data.length; L++) {\n                var T = C.data[L];\n                T.config.showInInfoPopup && (T.values || n.info.showNoData && n.info.showNullData) && (w = w || null !== e && T.config === n._computedSeries[e] || i === C.stack);\n              }\n\n              if (!w) continue;\n            }\n\n            var k = t.length + C.data.length === 2 ? \"\" : n.localization.unnamedSeries;\n            C.name && (S && (y += \"</table>\", S = !1), C.data.length > 1 ? y += \"<h3>\" + C.name + \"</h3>\" : k = C.name), S || (y += '<table cellspacing=\"0\">', S = !0);\n\n            for (var M = this.computeEffectiveSeries(C, n), L = 0; L < M.length; L++) {\n              var T = C.data[L],\n                  A = M[L].values,\n                  I = null !== e && T.config === this.scene.settings._computedSeries[e];\n\n              if (T.config.showInInfoPopup && (A || n.info.showNoData && n.info.showNullData) && (!m || I)) {\n                var P = \"\";\n                P += \"<tr><td\";\n                var D = void 0,\n                    N = void 0,\n                    F = T.config;\n                n instanceof x ? (D = F.style.fillColor, N = F.style.lineColor) : (D = F.style.lineColor, N = F.style.fillColor), D && \"transparent\" !== D || (D = N);\n                var O = d.Colors.parse(D);\n                O.A = 1, D = d.Colors.format(O), D && (P += ' data-color=\"' + D + '\"'), I && (P += \" data-selected\"), P += \">\", P += T.name || k, P += \"</td><td>\";\n                var E = \"\";\n\n                if (s > 0 || l || u > 0 || c) {\n                  if (A) {\n                    var R = F.data.aggregation ? A[F.data.aggregation] : A.sum;\n                    if (this.cantShowValue(n, R)) continue;\n                    E += r[T.config.valueAxis] ? d.Helpers.printPercentValue(R, r[T.config.valueAxis]) : l ? d.Helpers.printPercentValue(R, l) : h[T.config.valueAxis] ? d.Helpers.printCurrencyValue(R, h[T.config.valueAxis]) : c ? d.Helpers.printPercentValue(R, c) : d.Helpers.numberFormat(R);\n                  } else if (E += n.localization.noDataLabel, !n.info.showNullData) continue;\n                } else if (A) {\n                  if (A.count > 1 && n.info.aggregations && n.info.aggregations.length > 0) {\n                    for (var H = !1, z = 0; z < n.info.aggregations.length; z++) {\n                      var B = n.info.aggregations[z],\n                          R = A[B];\n\n                      if (this.cantShowValue(n, R)) {\n                        H = !0;\n                        break;\n                      }\n\n                      E += \"\" + d.Helpers.numberFormat(R) + (\"&nbsp;(\" + B + \")\");\n                    }\n\n                    if (H) continue;\n                  } else if (F.data.aggregation) {\n                    var R = A[F.data.aggregation];\n                    if (this.cantShowValue(n, R)) continue;\n                    E += d.Helpers.numberFormat(R);\n                  } else {\n                    var R = A.sum;\n                    if (this.cantShowValue(n, R)) continue;\n                    E += d.Helpers.numberFormat(R);\n                  }\n                } else if (E += p, !n.info.showNullData) continue;\n\n                P += f ? f.call(this.chart.api, A, T.config) : E, P += \"</td></tr>\", y += P;\n              }\n            }\n          }\n\n          return S && (y += \"</table>\"), y;\n        }, e.prototype.computeEffectiveSeries = function (t, e) {\n          for (var i = [], n = 0; n < t.data.length; n++) {\n            i.push(d.Helpers.realClone(t.data[n]));\n          }\n\n          var r = e.info.useStackedValue,\n              s = t.config && \"based\" === t.config.type;\n          return null === r && (r = !s), r && (t.config.separateNegativeValues ? this.computeStackTotalsWithSeparateNegativeValues(i) : this.computeStackTotalsWithoutSeparateNegativeValues(i)), i;\n        }, e.prototype.computeStackTotalsWithSeparateNegativeValues = function (t) {\n          for (var e = 0, i = 0, n = 0, r = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, a = 0, o = 0, l = 0, h = 0, u = 0, c = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, p = 0, f = 0, g = t.length - 1; g >= 0; g--) {\n            var v = t[g].values;\n            v.avg >= 0 && (v.avg += e, e = v.avg), v.change >= 0 && (v.change += i, i = v.change), v.sum >= 0 && (v.sum += n, n = v.sum), v.first >= 0 && (v.first += a, a = v.first), v.last >= 0 && (v.last += o, o = v.last), v.min >= 0 && (v.min = Math.min(v.min, r), r = v.min), v.max >= 0 && (v.max = Math.max(v.max, s), s = v.max), v.avg <= 0 && (v.avg += l, l = v.avg), v.change <= 0 && (v.change += h, h = v.change), v.sum <= 0 && (v.sum += u, u = v.sum), v.first <= 0 && (v.first += p, p = v.first), v.last <= 0 && (v.last += f, f = v.last), v.min <= 0 && (v.min = Math.min(v.min, c), c = v.min), v.max <= 0 && (v.max = Math.max(v.max, d), d = v.max);\n          }\n        }, e.prototype.computeStackTotalsWithoutSeparateNegativeValues = function (t) {\n          for (var e = t.length - 2; e >= 0; e--) {\n            var i = t[e].values,\n                n = t[e + 1].values;\n            i.avg += n.avg, i.change += n.change, i.sum += n.sum, i.min = Math.min(i.min, n.min), i.max = Math.max(i.max, n.max), i.first += n.first, i.last += n.last;\n          }\n        }, e.prototype.cantShowValue = function (t, e) {\n          return !t.info.showNullData && (null === e || void 0 == e) || !t.info.showZeroData && 0 === e;\n        }, e.prototype.remove = function () {\n          this.popup.remove();\n        }, e;\n      }(d.ChartElement);\n\n      t.InfoPopup = G;\n\n      var V = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e.prototype.updateXY = function (e, i, n, r) {\n          void 0 === r && (r = d.InfoPopupPosition.inside), t.prototype.updateXY.call(this, e, i, n, r);\n        }, e;\n      }(d.InfoPopup),\n          j = function () {\n        function t(t, e) {\n          if (this.axisConfigList = e, this.chart = t, this.axis = Object.create(null), 0 !== e.length) for (var i = !1, n = 0; n < e.length; n++) {\n            var r = e[n];\n            this.axis[r.id] = new f(t, r), !i && r.enabled && (i = !0, this.axis[r.id].isPrimary = !0);\n          }\n        }\n\n        return t.prototype.getAxis = function (t) {\n          return this.axis[t];\n        }, t.prototype.getPanels = function (t) {\n          for (var e = [], i = 0; i < this.axisConfigList.length; i++) {\n            var n = this.axisConfigList[i],\n                r = this.axis[n.id].getPanel();\n            (r || t) && e.push(r);\n          }\n\n          return e;\n        }, t.prototype.setPanels = function (t) {\n          for (var e = 0; e < this.axisConfigList.length; e++) {\n            var i = this.axisConfigList[e];\n            this.axis[i.id].setPanel(t[e]);\n          }\n        }, t.prototype.updateMinMax = function (t) {\n          var e = Number.POSITIVE_INFINITY,\n              i = Number.NEGATIVE_INFINITY,\n              n = 0,\n              r = 0;\n\n          for (var s in this.axis) {\n            var a = this.axis[s];\n            a.updateMinMax(t), a.options.alignZero && (e = Math.min(e, a.lastScaleMin), i = Math.max(i, a.lastScaleMax), n++, r += a.zeroY);\n          }\n\n          if (!(n < 2)) {\n            r /= n;\n            var o = this.chart.scene.y0 + .001,\n                l = this.chart.scene.y0 + this.chart.scene.height - .001,\n                h = this.computeMinMaxForZeroLine(e, i, o),\n                u = this.computeMinMaxForZeroLine(e, i, l),\n                c = this.computeMinMaxForZeroLine(e, i, r),\n                d = this.binaryMinSearch(e, i, r, c, o, h, l, u, 40);\n            this.computeMinMaxForZeroLine(e, i, d);\n          }\n        }, t.prototype.binaryMinSearch = function (t, e, i, n, r, s, a, o, l) {\n          if (l <= 0) return i;\n\n          for (var h = (r + a) / 2, u = this.computeMinMaxForZeroLine(t, e, h), c = 0; c < l; c++) {\n            if (u < s && u < o) {\n              var d = (h + r) / 2,\n                  p = (h + a) / 2,\n                  f = this.computeMinMaxForZeroLine(t, e, d),\n                  g = this.computeMinMaxForZeroLine(t, e, p);\n              if (f > s || g > o) return this.pickBestZero(i, n, h, u, r, s, a, o);\n              if (u < f && u < g) r = d, a = p, s = f, o = g;else if (u < f && u > g) r = h, s = u, h = p, u = g;else {\n                if (!(u < g && u > f)) return this.forkBinaryMin(l - c - 1, h, u, r, s, o, a, t, e, i, n);\n                a = h, o = u, h = d, u = f;\n              }\n            } else {\n              if (u > s && u > o) return this.pickBestZero(i, n, h, u, r, s, a, o);\n              if (s < o) a = h, o = u;else {\n                if (!(s > o)) return this.forkBinaryMin(l - c - 1, h, u, r, s, o, a, t, e, i, n);\n                r = h, s = u;\n              }\n              h = (r + a) / 2, u = this.computeMinMaxForZeroLine(t, e, h);\n            }\n          }\n\n          return this.pickBestZero(i, n, h, u, r, s, a, o);\n        }, t.prototype.forkBinaryMin = function (t, e, i, n, r, s, a, o, l, h, u) {\n          if (0 === t) return this.pickBestZero(h, u, e, i, n, r, a, s);\n          var c = Math.floor(t / 2) + 1,\n              d = this.pickBestZero(e, i, e, i, n, r, a, s),\n              p = i;\n          d === n && (p = r), d === a && (p = s);\n          var f = this.binaryMinSearch(o, l, d, p, n, r, e, i, c),\n              g = this.binaryMinSearch(o, l, d, p, e, i, a, s, c),\n              v = this.computeMinMaxForZeroLine(o, l, f),\n              m = this.computeMinMaxForZeroLine(o, l, g);\n          return this.pickBestZero(h, u, f, v, g, m, d, p);\n        }, t.prototype.pickBestZero = function (t, e, i, n, r, s, a, o) {\n          var l = t,\n              h = e;\n          return n < h && (h = n, l = i), s < h && (h = s, l = r), o < h && (h = o, l = a), t = l;\n        }, t.prototype.computeMinMaxForZeroLine = function (t, e, i) {\n          var n = t,\n              r = e,\n              s = (i - this.chart.scene.y0 - this.chart.scene.height) / this.chart.scene.height,\n              a = s / (1 + s),\n              o = e * a,\n              l = 0 === a ? Number.NEGATIVE_INFINITY : t / a;\n          o < t ? n = o : l > e && (r = l);\n          var h = void 0,\n              u = 0;\n\n          for (var c in this.axis) {\n            var d = this.axis[c];\n            d.options.alignZero && (u += d.computeNewScale(n, r, h), void 0 === h && (h = d.zeroY));\n          }\n\n          return u;\n        }, t.prototype.doAnimations = function (t) {\n          for (var e in this.axis) {\n            this.axis[e].doAnimations(t);\n          }\n        }, t.prototype.paintUnder = function (t) {\n          for (var e in this.axis) {\n            this.axis[e].paintUnder(t);\n          }\n        }, t.prototype.paint = function (t) {\n          for (var e in this.axis) {\n            this.axis[e].paint(t);\n          }\n        }, t.prototype.paintThresholds = function (t, e, i) {\n          for (var n in this.axis) {\n            this.axis[n].paintThresholds(t, e, i);\n          }\n        }, t;\n      }();\n\n      t.ValueAxisSet = j, function (t) {\n        var e = function () {\n          function e(t, e) {\n            this.stacks = [], this.idToStack = {}, this.scene = e, this.chart = t;\n          }\n\n          return e.prototype.addSeries = function (e, i, n, r) {\n            var s;\n\n            if (i.stack) {\n              var a = i.stack + \"#\" + i.type;\n              s = this.idToStack[a], s || (s = this.idToStack[a] = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s));\n            } else s = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s);\n\n            s.addSeries(e, i);\n          }, e.prototype.afterInit = function () {\n            for (var t = 0; t < this.stacks.length; t++) {\n              var e = this.stacks[t];\n              e.afterInit();\n            }\n          }, e.prototype.process = function (t) {\n            for (var e = 0; e < this.stacks.length; e++) {\n              var i = this.stacks[e];\n              i.process(t);\n            }\n          }, e.prototype.afterProcess = function () {\n            for (var t = 0; t < this.stacks.length; t++) {\n              var e = this.stacks[t];\n              e.afterProcess();\n            }\n          }, e.prototype.paint = function (t, e) {\n            for (var i = 0; i < this.stacks.length; i++) {\n              var n = this.stacks[i];\n              n.paint(t, e);\n            }\n          }, e.prototype.paintValueLabels = function (t, e) {\n            for (var i = 0; i < this.stacks.length; i++) {\n              var n = this.stacks[i];\n              n.paintValueLabels(t, e);\n            }\n          }, e.prototype.hitTestStack = function (t, e) {\n            for (var i = null, n = 1 / 0, r = 0; r < this.stacks.length; r++) {\n              var s = this.stacks[r],\n                  a = s.hitTestStack(t, e),\n                  o = a.result,\n                  l = a.distance;\n              l < n && (n = l, i = o);\n            }\n\n            return {\n              result: i,\n              distance: n\n            };\n          }, e.prototype.hitTest = function (t, e, i) {\n            for (var n = null, r = 1 / 0, s = 0; s < this.stacks.length; s++) {\n              var a = this.stacks[s],\n                  o = a.hitTest(t, e, i),\n                  l = o.result,\n                  h = o.distance;\n              h < r && (r = h, n = l);\n            }\n\n            return {\n              result: n,\n              distance: r\n            };\n          }, e.prototype.exportData = function (t, e, i) {\n            for (var n = 0; n < this.stacks.length; n++) {\n              var r = this.stacks[n];\n              i.push(r.exportData(t, e));\n            }\n          }, e.prototype.computeStackCenterRadius = function (t, e, i, n) {\n            if (!(e.length < 2)) {\n              var r = this.computeClusterPadding(),\n                  s = r.paddingSubtract,\n                  a = r.paddingAdd;\n              s = this.computeStackPaddingSubtract(s), a = this.computeStackPaddingAdd(a, t), o = this.ensurePaddingIsInsideRenderArea(e, s, a), s = o.paddingSubtract, a = o.paddingAdd, this.computePaddedStackCenterRadius(t, e, s, i, a, n);\n              var o;\n            }\n          }, e.prototype.computeStackPaddingAdd = function (t, e) {\n            for (var i = 0; i < this.stacks.length; i++) {\n              var n = this.stacks[i];\n              if (t += n.paddingLeft, n === e) break;\n              t += n.paddingRight;\n            }\n\n            return t;\n          }, e.prototype.computeStackPaddingSubtract = function (t) {\n            for (var e = 0; e < this.stacks.length; e++) {\n              var i = this.stacks[e];\n              t += i.paddingLeft + i.paddingRight;\n            }\n\n            return t;\n          }, e.prototype.computeClusterPadding = function () {\n            var t = this.aggregateClusterPadding(),\n                e = t.clusterPaddingLeft,\n                i = t.clusterPaddingRight,\n                n = e + i,\n                r = e;\n            return {\n              paddingSubtract: n,\n              paddingAdd: r\n            };\n          }, e.prototype.aggregateClusterPadding = function () {\n            for (var t = 0, e = 0, i = 0; i < this.stacks.length; i++) {\n              t = Math.max(t, this.stacks[i].clusterPaddingLeft), e = Math.max(e, this.stacks[i].clusterPaddingRight);\n            }\n\n            return {\n              clusterPaddingLeft: t,\n              clusterPaddingRight: e\n            };\n          }, e.prototype.ensurePaddingIsInsideRenderArea = function (t, e, i) {\n            var n = t[1] - t[0];\n\n            if (e > n / 2) {\n              var r = i / e;\n              e = n / 2, i = e * r;\n            }\n\n            return {\n              paddingSubtract: e,\n              paddingAdd: i\n            };\n          }, e.prototype.computePaddedStackCenterRadius = function (t, e, i, n, r, s) {\n            for (var a = this.stacks.length, o = this.stacks.indexOf(t), l = (o + .5) / a, h = .5 / a, u = 0; u < e.length - 1; u++) {\n              var c = e[u],\n                  d = e[u + 1] - c - i;\n              n[u] = c + d * l + r, s[u] = d * h;\n            }\n          }, e;\n        }();\n\n        t.Cluster = e;\n      }(i = t.Series || (t.Series = {}));\n\n      var W = function () {\n        function t(t, e) {\n          this.valueAxisSet = e, this.chart = t, this.scene = this.chart.scene, this.clusters = [], this.buildSeries();\n        }\n\n        return t.prototype.buildSeries = function () {\n          this.clusters = [];\n\n          for (var t = {}, e = null, n = {}, r = new m(), s = this.scene.settings, a = 0; a < s._computedSeries.length; a++) {\n            var o = s._computedSeries[a];\n\n            if (o.enabled) {\n              var l = void 0;\n              o.cluster ? (l = t[o.cluster], l || (l = t[o.cluster] = new i.Cluster(this.chart, this.scene), this.clusters.push(l))) : \"line\" === o.type ? o.stack ? n.hasOwnProperty(o.stack) ? l = n[o.stack] : (l = n[o.stack] = new i.Cluster(this.chart, this.scene), this.clusters.push(l)) : (l = new i.Cluster(this.chart, this.scene), this.clusters.push(l)) : (e || (e = new i.Cluster(this.chart, this.scene), this.clusters.push(e)), l = e);\n              var h = s._computedStacks[o.stack] || r;\n              l.addSeries(a, o, h, this.valueAxisSet.getAxis(o.valueAxis));\n            }\n          }\n\n          for (var u = 0; u < this.clusters.length; u++) {\n            var l = this.clusters[u];\n            l.afterInit();\n          }\n        }, t.prototype.process = function (t) {\n          for (var e = 0; e < this.clusters.length; e++) {\n            var i = this.clusters[e];\n            i.process(t);\n          }\n        }, t.prototype.afterProcess = function () {\n          for (var t = 0; t < this.clusters.length; t++) {\n            var e = this.clusters[t];\n            e.afterProcess();\n          }\n        }, t.prototype.paint = function (t) {\n          for (var e = t.context, i = 0; i < this.clusters.length; i++) {\n            for (var n = this.clusters[i], r = 0; r < n.stacks.length; r++) {\n              for (var s = n.stacks[r].series, a = 0; a < s.length; a++) {\n                s[a];\n              }\n            }\n          }\n\n          for (var o = 0; o < this.clusters.length; o++) {\n            var l = this.clusters[o];\n            l.paint(t, e);\n          }\n\n          this.valueAxisSet.paintThresholds(t, \"above\", !1);\n\n          for (var o = 0; o < this.clusters.length; o++) {\n            var l = this.clusters[o];\n            l.paintValueLabels(t, t.context);\n          }\n        }, t.prototype.hitTest = function (t, e, i) {\n          void 0 === i && (i = 4);\n\n          for (var n = null, r = 1 / 0, s = 0; s < this.clusters.length; s++) {\n            var a = this.clusters[s],\n                o = a.hitTest(t, e, i),\n                l = o.result,\n                h = o.distance;\n            h < r && (n = l, r = h);\n          }\n\n          if (r > i) {\n            r = 1 / 0, n = null;\n\n            for (var s = 0; s < this.clusters.length; s++) {\n              var a = this.clusters[s],\n                  u = a.hitTestStack(t, e),\n                  l = u.result,\n                  h = u.distance;\n              h < r && (n = l, r = h);\n            }\n          }\n\n          return n;\n        }, t.prototype.exportData = function (t, e) {\n          for (var i = [], n = 0; n < this.clusters.length; n++) {\n            var r = this.clusters[n];\n            r.exportData(t, e, i);\n          }\n\n          return i;\n        }, t;\n      }();\n\n      t.Renderer = W;\n    }(l = i.LinearChart || (i.LinearChart = {})), function (t) {\n      var e = t.Bar || (t.Bar = {}),\n          i = 864e5,\n          r = function () {\n        function e(t, i, n) {\n          this.count = i;\n          var r = e.parsingMap[t];\n          if (!r) throw new Error(\"Time unit `\" + t + \"` is not recognized.\");\n          this.unit = r, this.name = void 0 === n ? i + \" \" + r : n;\n        }\n\n        return e.isGoodUnit = function (t) {\n          return e.parsingMap.hasOwnProperty(t);\n        }, e.parse = function (t, i, n) {\n          if (void 0 === n && (n = !0), null == t) return null;\n\n          if (d.Helpers.isString(t)) {\n            var r = 1,\n                s = void 0,\n                a = t.split(\" \");\n\n            if (2 === a.length) {\n              if (r = d.Helpers.tryParseFloat(a[0], null), null === r || Math.floor(r) !== r) {\n                if (n) throw new Error(\"Cannot parse the time unit - the correct format is `1 s`: \" + t);\n                return null;\n              }\n\n              s = a[1];\n            } else {\n              if (1 !== a.length) {\n                if (n) throw new Error(\"Cannot parse the time unit - the correct format is `1 s`: \" + t);\n                return null;\n              }\n\n              r = 1, s = a[0];\n            }\n\n            if (!this.isGoodUnit(s)) {\n              if (n) throw new Error(\"Cannot parse the time unit - unrecognized time unit: \" + t);\n              return null;\n            }\n\n            return new e(s, r, i || t);\n          }\n\n          if (t instanceof e) return t;\n          if (n) throw new Error(\"Cannot parse the unit text because it is not a string: \" + t);\n          return null;\n        }, e.prototype.clone = function () {\n          return new e(this.unit, this.count, this.name);\n        }, e.prototype.add = function (t, e) {\n          void 0 === e && (e = 1);\n          var n = this.unit,\n              r = this.count * e;\n          if (\"ms\" === n) t += r;else if (\"s\" === n) t += 1e3 * r;else if (\"m\" === n) t += 6e4 * r;else if (\"h\" === n) t += 36e5 * r;else if (\"d\" === n) t += r * i;else if (\"w\" === n) t += r * i * 7;else {\n            var s = new Date(t);\n            \"y\" === n ? s.setUTCFullYear(s.getUTCFullYear() + r) : \"M\" === n && s.setUTCMonth(s.getUTCMonth() + r), t = s.getTime();\n          }\n          return t;\n        }, e.prototype.sub = function (t, e) {\n          return void 0 === e && (e = 1), this.add(t, -1 * e);\n        }, e.prototype.numberOfUnits = function (i, n) {\n          return Math.round(t.moment(n).utc().diff(t.moment(i).utc(), e.unitsTranslation[this.unit], !0) / this.count);\n        }, e.prototype.toShortString = function () {\n          return 1 === this.count ? this.unit : this.toString();\n        }, e.prototype.toString = function () {\n          return this.count + \" \" + this.unit;\n        }, e.prototype.approxTime = function () {\n          return e.timeUnitDiffs[this.unit] * this.count;\n        }, e.prototype.isSmallerOrEqual = function (t) {\n          return this.approxTime() <= t.approxTime();\n        }, e.prototype.isSmaller = function (t) {\n          return this.approxTime() < t.approxTime();\n        }, e.prototype.isBigger = function (t) {\n          return this.approxTime() > t.approxTime();\n        }, e.prototype.isEqual = function (t) {\n          return !!t && this.approxTime() === t.approxTime();\n        }, e.prototype.getBigger = function () {\n          return \"y\" === this.unit ? new e(this.unit, 10 * this.count) : new e(e.toBiggerUnit[this.unit], 1);\n        }, e.prototype.roundTimeDown = function (t, e) {\n          if (null == t) return null;\n          t = Math.round(t);\n          var n = this.count,\n              r = this.unit;\n          if (\"ms\" === r) return Math.floor(t / n) * n;\n          if (\"s\" === r) return Math.floor(t / 1e3 / n) * n * 1e3;\n          if (\"m\" === r) return Math.floor(t / 6e4 / n) * n * 6e4;\n          if (\"h\" === r) return Math.floor(t / 36e5 / n) * n * 36e5;\n\n          if (\"d\" === r) {\n            if (n % 7 !== 0) return Math.floor(t / i / n) * n * i;\n            r = \"w\", n /= 7;\n          }\n\n          if (\"w\" === r) {\n            var s = e.week.dow + 3,\n                a = t;\n            return t = (t / i - s) / 7 + 1, t = (Math.floor(t / n) * n * 7 + s) * i, t > a && (t -= 7 * i), t;\n          }\n\n          var o = new Date(Math.floor(t / i) * i);\n          if (\"y\" === r) return o.setUTCFullYear(Math.floor(o.getUTCFullYear() / n) * n, 0, 1), o.getTime();\n\n          if (\"M\" === r) {\n            var l = 12 * o.getUTCFullYear() + o.getUTCMonth();\n            return o.setUTCMonth(o.getUTCMonth() + Math.floor(l / n) * n - l, 1), o.getTime();\n          }\n\n          throw new Error(\"Unrecognized unit: `\" + this.unit + \"`\");\n        }, e.prototype.roundTimeUp = function (t, e) {\n          return null == t ? null : this.roundTimeDown(this.add(t) - 1, e);\n        }, e.prototype.roundTimeRound = function (t, e) {\n          return null == t ? null : this.roundTimeDown((this.add(t) + t - 1) / 2, e);\n        }, e.prototype.isMultipleOf = function (t) {\n          var e = this.unit,\n              i = t.unit,\n              n = this.approxTime(),\n              r = t.approxTime(),\n              s = n / r;\n          if (s < 1 || Math.floor(s) !== s) return !1;\n          if (e === i) return !0;\n          if (1 === t.count && \"w\" !== i) return !0;\n          var a = 864e5,\n              o = a / r;\n          return o >= 1 && Math.floor(o) === o || (\"y\" === e ? \"M\" === i : \"M\" !== e && \"w\" !== e);\n        }, e;\n      }();\n\n      r.parsingMap = {\n        milliseconds: \"ms\",\n        millisecond: \"ms\",\n        sec: \"s\",\n        second: \"s\",\n        seconds: \"s\",\n        min: \"m\",\n        minute: \"m\",\n        minutes: \"m\",\n        hour: \"h\",\n        hours: \"h\",\n        day: \"d\",\n        days: \"d\",\n        week: \"w\",\n        weeks: \"w\",\n        mon: \"M\",\n        month: \"M\",\n        months: \"M\",\n        year: \"y\",\n        years: \"y\",\n        ms: \"ms\",\n        s: \"s\",\n        m: \"m\",\n        h: \"h\",\n        d: \"d\",\n        D: \"d\",\n        w: \"w\",\n        W: \"w\",\n        M: \"M\",\n        y: \"y\",\n        Y: \"y\"\n      }, r.knownUnits = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"w\", \"M\", \"y\"], r.timeUnitDiffs = {\n        ms: 1,\n        s: 1e3,\n        m: 6e4,\n        h: 36e5,\n        d: 864e5,\n        w: 6048e5,\n        M: 2592e6,\n        y: 31104e6\n      }, r.unitsTranslation = {\n        ms: \"millisecond\",\n        s: \"second\",\n        m: \"minute\",\n        h: \"hour\",\n        d: \"day\",\n        w: \"week\",\n        M: \"month\",\n        y: \"year\"\n      }, r.toBiggerUnit = {\n        ms: \"s\",\n        s: \"m\",\n        m: \"h\",\n        h: \"d\",\n        d: \"w\",\n        w: \"M\",\n        M: \"y\",\n        y: null\n      }, r.toSmallerUnit = {\n        ms: null,\n        s: \"ms\",\n        m: \"s\",\n        h: \"m\",\n        d: \"h\",\n        w: \"d\",\n        M: \"d\",\n        y: \"M\"\n      }, t.TimeStep = r, function (e) {\n        var i = function (t) {\n          function e(e, i) {\n            var n;\n            return i.cssClass = i.cssClass || \"DVSL-bar-btn-month\", i.title = i.title || e.settings.localization.toolbar.periodDropdownTitle, n = t.call(this, e, i) || this, n._getItemsCache = null, n.custom = {\n              displayAnchor: null,\n              disabled: !1,\n              displayPeriod: null,\n              displayPeriodStr: null,\n              displayUnit: null,\n              displayUnitStr: null,\n              selected: !1,\n              name: e.settings.localization.toolbar.customPeriod\n            }, n.updateSelectedItem(), n;\n          }\n\n          return n(e, t), e.prototype.onSelectionChange = function (t) {\n            this.chart.setDisplayPeriod(t.displayPeriodStr, t.displayAnchor, null == t.displayUnit ? null : t.displayUnit.toString(), !0, \"user\");\n          }, e.prototype.onSceneChange = function (t) {\n            t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem();\n          }, e.prototype.updateSelectedItem = function () {\n            var t = this._lastSelectedItem;\n            if (t && t !== this.custom && this.chart.isThisDisplayPeriod(t.displayPeriodStr, t.displayAnchor, t.displayUnitStr)) return void this.setSelectedItem(t);\n\n            for (var e = this.getItems(), i = 0; i < e.length; i++) {\n              var n = e[i];\n              if (n !== t && this.chart.isThisDisplayPeriod(n.displayPeriodStr, n.displayAnchor, n.displayUnitStr)) return void this.setSelectedItem(n);\n            }\n\n            this.setSelectedItem(this.custom);\n          }, e.prototype.setSelectedItem = function (e) {\n            this._lastSelectedItem && (this._lastSelectedItem.selected = !1), e.selected = !0, t.prototype.setSelectedItem.call(this, e), this._lastSelectedItem = e;\n          }, e.prototype.getItems = function () {\n            if (this._getItemsCache) return this._getItemsCache;\n\n            for (var t = [], e = this.chart.settings._minUnit, i = this.custom, n = 0; n < this.chart.settings.toolbar.periods.length; n++) {\n              var r = this.chart.settings.toolbar.periods[n],\n                  s = r.parse(),\n                  a = s.displayPeriod,\n                  o = s.displayUnit;\n              o && o.isSmaller(e) || a && a.isSmallerOrEqual(e) || (t.push(s), this.chart.isThisDisplayPeriod(r.displayPeriod, s.displayAnchor, r.displayUnit) && (i = s));\n            }\n\n            return this._lastSelectedItem = i, i.selected = !0, this._getItemsCache = t, t;\n          }, e;\n        }(d.Bar.Combobox);\n\n        e.DisplayPeriodDropdown = i, d.Bar.ToolbarItemNames.displayPeriod = function (e, i) {\n          return new t.Bar.DisplayPeriodDropdown(e, i);\n        };\n\n        var r = function (t) {\n          function e(e, i) {\n            var n;\n            return i || (i = {}), i.cssClass = i.cssClass || \"DVSL-bar-btn-bars\", i.title = i.title || e.settings.localization.toolbar.unitDropdownTitle, n = t.call(this, e, i) || this, n.updateSelectedItem(), n;\n          }\n\n          return n(e, t), e.prototype.onSelectionChange = function (t) {\n            this.chart.setDisplayUnit(t.value, !0, \"user\");\n          }, e.prototype.onSceneChange = function (t) {\n            t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem();\n          }, e.prototype.updateSelectedItem = function () {\n            var t = this.chart.displayUnit;\n\n            if (t) {\n              for (var e = this.getItems(), i = 0; i < e.length; i++) {\n                var n = e[i];\n                if (n.value.isEqual(t)) return void this.setSelectedItem(n);\n              }\n\n              this.setSelectedItem({\n                name: t.name,\n                value: t,\n                disabled: !1,\n                selected: !0\n              });\n            }\n          }, e.prototype.getItems = function () {\n            if (this._getItemsCache) return this._getItemsCache;\n\n            for (var t = this.chart.scene, e = [], i = (t.timeEnd - t.timeStart) / t.width * this.chart.settings.timeAxis.minUnitWidth, n = !1, r = 0; r < this.chart.settings._displayUnitsParsed.length; r++) {\n              var s = this.chart.settings._displayUnitsParsed[r];\n              s.approxTime() < i ? n || (e.push({\n                name: this.chart.settings.localization.toolbar.unavailableUnitTitle,\n                value: s,\n                disabled: !0,\n                selected: !1\n              }), n = !0) : e.push({\n                name: s.name,\n                value: s,\n                disabled: !1,\n                selected: s.isEqual(t.displayUnit)\n              });\n            }\n\n            return e;\n          }, e;\n        }(d.Bar.Combobox);\n\n        e.DisplayUnitDropdown = r, d.Bar.ToolbarItemNames.displayUnit = function (e, i) {\n          return new t.Bar.DisplayUnitDropdown(e, i);\n        };\n      }(e = t.Bar || (t.Bar = {}));\n\n      var s = function () {\n        function t(t, e, i, n) {\n          this.name = null, this.displayAnchor = null, this.displayPeriod = null, this.displayUnit = null, void 0 === e ? this.displayPeriod = t : (this.name = t, this.displayAnchor = e, this.displayPeriod = i, this.displayUnit = n);\n        }\n\n        return t.prototype.parse = function () {\n          var t = this.displayPeriod,\n              e = this.displayUnit;\n          return {\n            name: this.name,\n            displayAnchor: this.displayAnchor,\n            displayPeriod: \"max\" === t ? null : r.parse(t),\n            displayPeriodStr: t,\n            displayUnit: \"auto\" === e ? null : r.parse(e),\n            displayUnitStr: e,\n            selected: !1,\n            disabled: !1\n          };\n        }, t;\n      }();\n\n      t.SettingsAreaDisplayPeriod = s;\n\n      var a = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.enabled = !0, e.zoomOut = !0, e.logScale = !0, e.displayUnit = !0, e.displayPeriod = !0, e.zoomOutFunction = null, e.periods = [new s(\"Last second\", \"now\", \"1 s\", \"25 ms\"), new s(\"Last minute\", \"now\", \"1 m\", \"1 s\"), new s(\"Last hour\", \"now\", \"1 h\", \"1 m\"), new s(\"Last day\", \"now\", \"1 d\", \"1 h\"), new s(\"Last week\", \"now\", \"1 w\", \"6 h\"), new s(\"Last month\", \"now\", \"1 M\", \"1 d\"), new s(\"Last year\", \"now\", \"1 y\", \"1 M\"), new s(\"All data\", \"newestData\", \"max\", \"auto\")], e.items = [new d.SettingsToolbarItem(\"fullscreen\", \"left\"), new d.SettingsToolbarItem(\"back\", \"left\"), new d.SettingsToolbarItem(\"zoomOut\", \"left\"), new d.SettingsToolbarItem(\"logScale\", \"right\"), new d.SettingsToolbarItem(\"displayPeriod\", \"right\"), new d.SettingsToolbarItem(\"displayUnit\", \"right\"), new d.SettingsToolbarItem(\"export\", \"right\")], e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsToolbar);\n\n      t.SettingsToolbar = a;\n\n      var o = function () {\n        function t(t) {\n          this.settings = t.settings, this.chart = t, this.scene = t.scene;\n        }\n\n        return t.prototype.toBiggerDisplayUnit = function (t) {\n          for (var e = null, i = 0; i < this.settings._displayPeriodsParsed.length; i++) {\n            var n = this.settings._displayPeriodsParsed[i];\n            n.approxTime() > t.approxTime() && (null === e || n.approxTime() < e.approxTime()) && (e = n);\n          }\n\n          return e;\n        }, t.prototype.getMinRangeForUnit = function (t, e, i, n) {\n          var r = i.approxTime(),\n              s = this.scene.settings.timeAxis.minUnitWidth,\n              a = this.scene.settings.timeAxis.maxUnitWidth,\n              o = this.verifyUnitWidth(t, e, i);\n\n          if (o.min || o.max) {\n            d.Helpers.warn(\"Could not show all data as requested by `navigation.initialDisplayPeriod`. Please adjust either `navigation.initialDisplayPeriod` or `timeAxis.minUnitWidth` and `timeAxis.maxUnitWidth`.\");\n            var l = void 0;\n            o.min ? l = this.scene.width / s * r : o.max && (l = this.scene.width / a * r), \"oldestData\" === n ? e = t + l : t = e - l;\n          }\n\n          return {\n            from: t,\n            to: e\n          };\n        }, t.prototype.verifyUnitWidth = function (t, e, i) {\n          var n = i.approxTime(),\n              r = this.scene.settings.timeAxis.minUnitWidth,\n              s = this.scene.settings.timeAxis.maxUnitWidth,\n              a = (e - t) / this.scene.width;\n          return {\n            min: !(r * a < n),\n            max: !(s * a > n)\n          };\n        }, t.prototype.adjustTimeRangeToUnits = function (t, e, i, n) {\n          var r,\n              s = i - (i - e) / 2,\n              a = n.approxTime(),\n              o = this.getUnitRange(t, [n]),\n              l = i - e;\n          r = l < o.minTime ? Math.ceil(o.minTime / a) : Math.min((i - e) / a, Math.floor(o.maxTime / a));\n          var h = r * a;\n          return e = s - h / 2 + 1, i = s + h / 2 - 1, {\n            from: e,\n            to: i\n          };\n        }, t.prototype.preventUnitWidthViolation = function (t, e) {\n          var i = this.scene,\n              n = i.width,\n              r = (t - e) / n,\n              s = r * i.settings.timeAxis.minUnitWidth;\n          return s > i.displayUnit.approxTime();\n        }, t.prototype.getBiggerDisplayPeriod = function (t, e) {\n          for (var i = Math.abs(e - t), n = 0, r = null, s = 0; s < this.settings._displayPeriodsParsed.length; s++) {\n            var a = this.settings._displayPeriodsParsed[s],\n                o = a.approxTime(),\n                l = i / o;\n            l < .9 && l > n && (n = l, r = a);\n          }\n\n          return r;\n        }, t.prototype.getBiggerDisplayUnit = function (t) {\n          for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = 0; n < e.length; n++) {\n            var r = e[n];\n            if (r.approxTime() > i) return r;\n          }\n\n          return t;\n        }, t.prototype.getSmallerDisplayUnit = function (t) {\n          for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = e.length - 1; n >= 0; n--) {\n            var r = e[n];\n            if (r.approxTime() < i) return r;\n          }\n\n          return null;\n        }, t.prototype.getClosestDisplayPeriod = function (t, e, i) {\n          for (var n = null, r = 0, s = null, a = 1 / 0, o = 0; o < this.settings._displayPeriodsParsed.length; o++) {\n            var l = this.settings._displayPeriodsParsed[o],\n                h = l.approxTime();\n            h <= t && (null === n || r < h) && (n = l, r = h), h >= t && (null === s || a > h) && (s = l, a = h);\n          }\n\n          return i ? e && e.approxTime() < .8 * t ? e : null !== s && a < 1.2 * t || null === n ? s : n : null !== n && (r > .8 * t || a > 1.2 * t) ? n : s;\n        }, t.prototype.isAllowedDisplayUnit = function (t) {\n          for (var e = 0; e < this.settings._displayUnitsParsed.length; e++) {\n            var i = this.settings._displayUnitsParsed[e];\n            if (i.isEqual(t)) return !0;\n          }\n\n          return !1;\n        }, t.prototype.adjustTimeAfterScale = function (t, e, i, n) {\n          var r = this.scene,\n              s = (e - t) / r.width,\n              a = r.settings.timeAxis.minUnitWidth,\n              o = r.displayUnit.approxTime();\n\n          if (!(a * s <= o)) {\n            var l = i + (n - i) / 2,\n                h = Math.floor(r.width / a);\n            t = l - h / 2 * o, e = l + h / 2 * o;\n          }\n\n          return {\n            from: t,\n            to: e\n          };\n        }, t.prototype.computeDisplayUnit = function (t, e, i, n, r, s, a) {\n          var o = {\n            from: n,\n            to: r,\n            unit: null\n          };\n          if (null != n && null != r || d.Helpers.error(\"`computeDisplayUnit` called with invalid arguments.\"), a && !a.scale && a.scroll) return o.unit = i || this.scene.displayUnit, o;\n          if (null !== t && null !== e && i && Math.abs(e - t - (r - n)) < .001) return o.unit = i, o;\n\n          var l = this.scene.displayUnit,\n              h = this.scene.settings,\n              u = Math.max(s.width, 10),\n              c = h.timeAxis,\n              p = Math.max(c.minUnitWidth, Math.min(u / 3, c.maxUnitWidth)),\n              f = (r - n) / u * c.minUnitWidth,\n              g = (r - n) / u * p,\n              v = null,\n              m = 0,\n              y = h._displayUnitsParsed,\n              S = h._minUnit.approxTime(),\n              b = \"min\" === c.unitSizePolicy;\n\n          if (a && a.scale) {\n            var x = 1 / 0;\n            i && 2 !== a.scale && (a.scale === -1 ? S = i.approxTime() : x = i.approxTime());\n\n            for (var C = 0; C < y.length; C++) {\n              var w = y[C],\n                  L = w.approxTime();\n\n              if (!(L < S || L > x)) {\n                var T = void 0;\n                T = null === v || (b ? L >= f && L < m || m < f && L > m : L <= g && L > m || m > g && L < m), T && (v = w, m = L);\n              }\n            }\n\n            v || (l.approxTime() !== y[y.length - 1].approxTime() && (d.Helpers.warn(\"`computeDisplayUnit` could not lookup the new unit - no units available matching the `minUnitWidth` and `maxUnitWidth` for the current range.\", null, !0), this.scene.disableScaleLimiter = !0), v = this.scene.displayUnit);\n          } else {\n            var k = n,\n                M = r,\n                A = h.navigation.initialDisplayAnchor,\n                I = this.chart.getDisplayLimits(),\n                P = r === I.to && (\"now\" === A || \"newestData\" === A),\n                D = n === I.from && \"oldestData\" === A;\n            l && l.unit === h._minUnit.unit && 1 === l.count && (v = l);\n\n            for (var N = 50; --N > 0;) {\n              for (var F = !1, C = 0; C < y.length; C++) {\n                var w = y[C],\n                    L = w.approxTime();\n                if (!(L < S)) if (L < f) F = !0;else {\n                  if (!(L <= g)) break;\n                  var T = void 0;\n                  T = null == v || (b ? L < m : L > m), T && (v = w, m = L);\n                }\n              }\n\n              if (!v && !F) {\n                var O = (k + M) / 2,\n                    E = u / p * S / 2;\n                v = h._minUnit, k = O - E, M = O + E;\n              }\n\n              if (v) {\n                var R = this.scene.timeStepSettings;\n                return {\n                  from: v.roundTimeDown(k, R),\n                  to: v.roundTimeUp(M, R),\n                  unit: v\n                };\n              }\n\n              var H = M - k,\n                  z = H - H / 4 >= S,\n                  B = z ? H / 4 : H - S;\n              P ? k += B : D ? M -= B : (k += B / 2, M -= B / 2), f = (M - k) / u * c.minUnitWidth, g = (M - k) / u * p;\n            }\n\n            0 === N && d.Helpers.warn(\"`computeDisplayUnit` could not lookup the new unit. It is possible that the chart did not load the data properly.\");\n          }\n\n          if (!v) throw d.Helpers.error(\"\", t, e, i, n, r, u), new Error(\"Could not calculate displayUnit\");\n          return o.unit = v, o;\n        }, t.prototype.tryComputeDisplayPeriod = function (t, e, i, n, s, a, o) {\n          var l = \"auto\" === i ? null : r.parse(i),\n              h = null,\n              u = null;\n\n          if (t && t.indexOf(\">\") > -1) {\n            var c = t.split(\">\", 2);\n            h = parseInt(c[0], 10), u = parseInt(c[1], 10);\n            var p = r.timeUnitDiffs,\n                f = !l || p[l.unit] < p.d;\n            h = this.scene.timestampToInternal(h, f), u = this.scene.timestampToInternal(u, f);\n          } else if (\"max\" === t && null !== n && null !== s) h = n, u = \"now\" === e ? o : s;else if (\"max\" !== t) {\n            var g = r.parse(t),\n                v = void 0;\n            v = \"now\" === e ? o : \"newestData\" === e && null !== s ? s : d.Helpers.tryParseFloat(e, null), g && null !== v && (h = g.sub(v), u = v);\n          }\n\n          if (null === h || null === u) return {\n            from: null,\n            to: null,\n            unit: null\n          };\n          var m = this.getUnitRange(a),\n              y = m.minTime,\n              S = m.maxTime,\n              b = m.minUnit,\n              x = m.maxUnit;\n          return u - h > S && (l = x, h = u - S), u - h < y && (l = b, h = u - y), {\n            from: h,\n            to: u,\n            unit: l\n          };\n        }, t.prototype.resolveFromTo = function (t, e, i) {\n          var n,\n              r,\n              s,\n              a = this.scene,\n              o = a.timeStepSettings,\n              l = null,\n              h = a.majorTimeUnit || i;\n          return d.Helpers.isNumber(t) ? n = t : (s = \"oldestDataRounded\" === t) || \"oldestData\" === t ? (null === l && (l = this.chart.getDisplayLimits(i)), n = l.from, s && (n = h.roundTimeDown(n, o))) : (t && d.Helpers.error(\"Invalid `interaction.scrolling.limitFrom` value '\" + t + \"'.\"), n = null), d.Helpers.isNumber(e) ? r = e : (s = \"newestDataRounded\" === e) || \"newestData\" === e ? (null === l && (l = this.chart.getDisplayLimits(i)), r = l.to, s && (r = h.roundTimeUp(r, o))) : \"now\" === e ? r = a.getCurTime() : (e && d.Helpers.error(\"Invalid `interaction.scrolling.limitTo` value '\" + e + \"'.\"), r = null), {\n            from: i.roundTimeDown(n, o),\n            to: i.roundTimeUp(r, o)\n          };\n        }, t.prototype.getUnitRange = function (t, e) {\n          void 0 === e && (e = this.settings._displayUnitsParsed);\n          var i = e[e.length - 1],\n              n = i.approxTime(),\n              r = e[0],\n              s = r.approxTime(),\n              a = Math.max(10, t.width),\n              o = a / this.settings.timeAxis.minUnitWidth * n,\n              l = a / this.settings.timeAxis.maxUnitWidth * s;\n          return {\n            minTime: l,\n            maxTime: o,\n            minUnit: r,\n            maxUnit: i\n          };\n        }, t.prototype.getLimits = function (t, e) {\n          var i = this.settings.interaction.scrolling,\n              n = i.limitMode,\n              r = e ? null !== n : \"block\" === n;\n          return r && t ? this.resolveFromTo(i.limitFrom, i.limitTo, t) : {\n            from: null,\n            to: null\n          };\n        }, t.prototype.preventOverscale = function (t, e, i, n, r, s, a) {\n          var o = this.getLimits(s, a),\n              l = o.from,\n              h = o.to,\n              u = this.getUnitRange(t, e),\n              c = u.minTime,\n              p = u.maxTime;\n\n          if (null !== l && null !== h && r - n > h - l) {\n            var f = (l + h) / 2,\n                g = (h - l) / 2;\n            return g = Math.max(g, c / 2), this.adjustTimeRangeToUnits(t, f - g, f + g, s);\n          }\n\n          p *= .99, c *= 1.01;\n          var v = r - n;\n          v = Math.min(v, p), v = Math.max(v, c);\n          var m = v === c ? v / (r - n) : 1;\n          return null === i && (i = (n + r) / 2), n === r && n > 0 && d.Helpers.error(\"From = To, trouble\", n, r), {\n            from: i + (n - i) * m,\n            to: i + (r - i) * m\n          };\n        }, t.prototype.preventOverscroll = function (t, e, i, n) {\n          var r = this.getLimits(t, n),\n              s = r.from,\n              a = r.to,\n              o = this.settings.interaction.scrolling,\n              l = i - e;\n          return null !== s && null !== a && (l = Math.min(l, a - s)), l *= o.overscrollProportion, null !== s && (s -= l), null !== a && (a += l), null !== s && null !== a && a - s < i - e ? (s < e ? l = e - s : a > i && (l = i - a), e -= l, i -= l) : null !== a && a < i ? (l = i - a, e -= l, i -= l) : null !== s && s > e && (l = s - e, e = s, i += l), {\n            from: e,\n            to: i\n          };\n        }, t.prototype.scroll = function (t, e, i, n, s, a) {\n          var o;\n          if (\"displayUnit\" === a) o = i.clone();else if (\"page\" === a) o = this.getTimeRangeStep(t, e);else {\n            if (!r.isGoodUnit(a)) return void d.Helpers.error(\"Incorrect scroll unit: \" + a);\n            o = r.parse(a);\n          }\n          return o.count *= s, \"<\" === n ? {\n            from: o.sub(t),\n            to: o.sub(e)\n          } : {\n            from: o.add(t),\n            to: o.add(e)\n          };\n        }, t.prototype.getTimeRangeStep = function (t, e) {\n          t = Math.round(t), e = Math.round(e);\n\n          for (var i = null, n = this.scene.timeStepSettings, s = 0; s < r.knownUnits.length; s++) {\n            var a = r.knownUnits[s],\n                o = new r(a, 1),\n                l = o.roundTimeRound(t, n),\n                h = o.roundTimeRound(e, n);\n            t === l && e === h && (null === i || i.approxTime() < o.approxTime()) && (i = o);\n          }\n\n          return i.count = Math.max(1, i.numberOfUnits(t, e)), i;\n        }, t;\n      }();\n\n      t.TimeSetup = o;\n      var h;\n      h = \"undefined\" != typeof Float64Array ? function (t) {\n        return Array.isArray(t) || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array || t instanceof Int16Array || t instanceof Uint16Array;\n      } : function (t) {\n        return Array.isArray(t);\n      };\n\n      var u = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.units = [\"ms\", \"s\", \"m\", \"h\", \"d\", \"M\", \"y\"], e.url = null, e.urlByUnit = null, e.requestMaxUnits = 1e4, e.prefetchRatio = 1, e.minimizeRequests = !1, e.cacheSize = 5e5, e.timestampInSeconds = !1, e.stringTimestampFormat = null, e.timeZoneOffset = null, e.dataFunction = null, e.preloaded = null, e.suppressWarnings = !1, e.useSmallerUnitCache = !0, e._skipRequestRangeRounding = !1, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsData);\n\n      t.SettingsData = u;\n\n      var c = function () {\n        function e(t, e) {\n          this.chart = null, this.scene = null, this.settings = null, this.noData = !1, this.dataLimitFrom = null, this.dataLimitTo = null, this.dataLimitFromUnit = null, this.dataLimitToUnit = null, this.dataFrom = null, this.dataTo = null, this.error = null, this.cache = {}, this.requests = {}, this._pendingAddData = [], this.dataSettings = e, this.scene = t.scene, this.settings = t.settings, this.chart = t, this.dataId = \"data\" + e.id, this._prepareUsableUnits(), this.updateDataLimit(null, null, null, null, new r(\"ms\", 1));\n        }\n\n        return e.binSearch = function (t, e) {\n          var i = 0;\n          if (!t) throw \"no data\";\n\n          for (var n = t.length - 1; i < n;) {\n            var r = Math.floor((n + i) / 2);\n            if (t[r][0] < e) i = r + 1;else {\n              if (!(t[r][0] > e)) {\n                for (; r > 0 && t[r - 1][0] === e;) {\n                  r -= 1;\n                }\n\n                return r;\n              }\n\n              n = r;\n            }\n          }\n\n          return i < t.length && t[i][0] < e ? i + 1 : i;\n        }, e.linSearchUp = function (t, e, i, n) {\n          if (n) {\n            for (var r = e + 1; r <= t.length - 1; r++) {\n              if (null !== n(t[r])) return r;\n            }\n          } else for (var r = e + 1; r <= t.length - 1; r++) {\n            if (null !== t[r][i]) return r;\n          }\n\n          return -1;\n        }, e.linSearchDown = function (t, e, i, n) {\n          if (n) {\n            for (var r = e - 1; r >= 0; r--) {\n              if (null !== n(t[r])) return r;\n            }\n          } else for (var r = e - 1; r >= 0; r--) {\n            if (null !== t[r][i]) return r;\n          }\n\n          return -1;\n        }, e.findSubrange = function (t, i, n) {\n          var r = e.binSearch(t, i),\n              s = e.binSearch(t, n);\n          return {\n            i0: r,\n            i1: s\n          };\n        }, e.prototype.notifyAssetsLoaded = function () {\n          if (t.moment && t.moment.tz) {\n            for (var e = this._pendingAddData, i = 0; i < e.length; i++) {\n              var n = e[i];\n              this.addDataInt(n.request, n.parsedData, n.append);\n            }\n\n            this._pendingAddData = [];\n          }\n        }, e.prototype.applyPreloadedData = function () {\n          this.dataSettings.preloaded && this.addData(this.dataSettings.preloaded);\n        }, e.prototype.remove = function () {\n          this.scene.setMessage(this.dataId, null);\n\n          for (var t in this.requests) {\n            var e = this.requests[t];\n            e && (e.callback = null);\n          }\n        }, e.prototype._prepareUsableUnits = function () {\n          var t = this.dataSettings.units;\n          if (0 === t.length) throw new Error(\"The `data.units` array must contain at least one value.\");\n\n          for (var e = this._units = new Array(t.length), i = 0; i < t.length; i++) {\n            var n = t[i],\n                s = r.parse(n, n, !0);\n            s && (e[i] = {\n              size: s.approxTime(),\n              unit: s,\n              key: s.toString()\n            });\n          }\n\n          e.sort(function (t, e) {\n            return e.size - t.size;\n          });\n        }, e.prototype._findUsableUnit = function (t) {\n          for (var e = this._units, i = this.cache, n = 0; n < e.length; n++) {\n            var r = e[n];\n            if (null !== i[r.key] && t.isMultipleOf(r.unit)) return r.unit;\n          }\n\n          this.chart.error(\"Cannot load data - no suitable data unit configured for the requested `\" + t + \"`.\");\n        }, e.prototype.determineDataLimits = function (t, e, i, n) {\n          var r = this;\n\n          if (t) {\n            if (t = this._findUsableUnit(t), !t) return;\n          } else t = this._units[0].unit;\n\n          var s = null,\n              a = null,\n              o = t.approxTime();\n          if (this.dataLimitFromUnit && this.dataLimitFromUnit.approxTime() <= o && (s = this.dataLimitFrom), this.dataLimitToUnit && this.dataLimitToUnit.approxTime() <= o && (a = this.dataLimitTo), !(e && null == s || i && null == a)) return void n(this.dataLimitFrom, this.dataLimitTo, t);\n          this.scene.setMessage(this.dataId, this.settings.localization.determiningDataBounds, 999);\n\n          var l = function l(t, i, s, a) {\n            if (!a) return void r.scene.setMessage(r.dataId, null);\n\n            if (null === r.dataLimitFrom && e) {\n              if (t !== i) return void r.scheduleDataLoading(a, null, i, !1, function (t, e, n) {\n                return l(i, t, e, n);\n              });\n              r.dataLimitFrom = i;\n            }\n\n            r.scene.setMessage(r.dataId, null), n(r.dataLimitFrom, r.dataLimitTo, a);\n          },\n              h = function h(t, e, n, s, a) {\n            if (!a) return void r.scene.setMessage(r.dataId, null);\n\n            if (null === r.dataLimitTo && i) {\n              if (e !== s) return void r.scheduleDataLoading(a, s, null, !1, function (e, i, n) {\n                return h(t, s, e, i, n);\n              });\n              r.dataLimitTo = s;\n            }\n\n            l(t + 1, t, s, a);\n          };\n\n          this.scheduleDataLoading(t, null, null, !1, function (t, e, i) {\n            return h(t, e, t, e, i);\n          });\n        }, e.prototype.getDataForRange = function (t, i, n, r) {\n          var s = this.dataSettings,\n              a = null,\n              o = t,\n              l = i;\n          null !== this.dataLimitFrom && (o = Math.max(this.dataLimitFrom, o), l = Math.max(l, this.dataLimitFrom)), null !== this.dataLimitTo && (l = Math.min(this.dataLimitTo, l), o = Math.min(o, this.dataLimitTo));\n          var h = o !== l;\n          if (h) for (var u = 0; u < this._units.length; u++) {\n            var c = this._units[u],\n                p = this.cache[c.key];\n\n            if (p && n.isMultipleOf(c.unit) && p.from < i && p.to > t) {\n              (s.useSmallerUnitCache || p.unit.approxTime() === n.approxTime()) && (a = p, h = o < p.from || l > p.to);\n              break;\n            }\n          }\n          var f = !1;\n\n          if (h && (h = !!s.dataFunction || !!s.url || !!s.urlByUnit, h && (!s.minimizeRequests || !this.chart.scrolling.isActive()))) {\n            var g = this._findUsableUnit(n),\n                v = !1;\n\n            a && g.approxTime() === a.unit.approxTime() && (o >= a.from && (v = !0, o = Math.max(o, a.to)), (l <= a.to || o < a.from) && (l = Math.min(l, a.from)));\n            var m = g.numberOfUnits(t, i),\n                y = s.cacheSize;\n            m > y && (d.Helpers.warn(\"The chart requires \" + m + \" values (using data unit `\" + g + \"`) to display the current time range. `data.cacheSize` limit (currently \" + y + \") will be automatically increased to allow this.\"), s.cacheSize = Math.floor(1.2 * m)), f = this.scheduleDataLoading(g, o, l, v, r);\n          }\n\n          if (a) {\n            var S = e.findSubrange(a.values, t, i),\n                b = S.i0,\n                x = S.i1;\n            return {\n              unit: n.unit,\n              count: n.count,\n              from: a.from,\n              to: a.to,\n              values: a.values,\n              startIndex: b,\n              endIndex: x,\n              loading: f\n            };\n          }\n\n          return f ? {\n            unit: n.unit,\n            count: n.count,\n            from: o,\n            to: l,\n            values: [],\n            startIndex: 0,\n            endIndex: 0,\n            loading: !0\n          } : (o !== l && d.Helpers.warn(\"The datasource `\" + s.id + \"` cannot return data for unit \" + n, null, !0), {\n            unit: null,\n            count: null,\n            from: null,\n            to: null,\n            values: [],\n            startIndex: 0,\n            endIndex: 0,\n            loading: !1\n          });\n        }, e.prototype.updateData = function (t, e, i) {\n          var n = this._findUsableUnit(t),\n              r = n.toString();\n\n          if (this.cache[r] && !this.requests[r]) {\n            var s = this.scene.timeStepSettings,\n                a = n.roundTimeUp(e, s),\n                o = n.roundTimeDown(this.cache[r].lastTimestamp, s);\n            o <= a && this.scheduleDataLoading(t, o, a, !1, i);\n          }\n        }, e.prototype.scheduleDataLoading = function (t, e, i, n, s) {\n          var a = this;\n          if (!t) throw \"No unit\";\n          if (e > i) return !1;\n          this.chart.log(\"Scheduling data loading \" + t + \",\" + e + \",\" + i);\n          var o = d.Helpers.performanceNow(),\n              l = t.toString(),\n              h = this.requests[l];\n\n          if (h) {\n            if (!(h.time + this.dataSettings.requestTimeout < o)) return this.chart.log(\"Already loading for selected period\"), !0;\n            h.callback = null, delete this.requests[l];\n          }\n\n          var u = e,\n              c = i,\n              p = this.scene.timeStepSettings;\n\n          if (this.dataSettings._skipRequestRangeRounding || (null !== u && (u = t.roundTimeDown(u, p)), null !== c && (c = t.roundTimeUp(c, p))), null !== u && null !== c) {\n            var g = (c - u) / t.approxTime();\n            g > this.dataSettings.requestMaxUnits && (n ? c = t.add(u, this.dataSettings.requestMaxUnits) : u = t.sub(c, this.dataSettings.requestMaxUnits));\n          }\n\n          var v = this.getDataFunction();\n          if (!v) return this.chart.log(\"No data function. Cannot load data?\"), !1;\n          var m = r.timeUnitDiffs[t.unit] < r.timeUnitDiffs.d,\n              y = m ? null : this.settings.timeAxis.timeZone;\n          this.requests[l] = h = new f(t, u, c, s, o, y);\n\n          var S = function S(t) {\n            return a.dataReceivedRaw(h, t);\n          },\n              b = function b() {\n            return a.dataFailed(h);\n          };\n\n          u = this.convertTimestampFromInternal(u, m), c = this.convertTimestampFromInternal(c, m), u === c && null !== c && c++;\n          var x = v(u, c, t.toShortString(), S, b, y);\n          return this.chart.log(\"Data requested \" + t + \", \" + u + \", \" + c), (d.Helpers.isObjectOrArray(x) || d.Helpers.isString(x)) && (this.dataSettings.suppressWarnings || d.Helpers.warn(\"Data object should not be returned directly from the `dataFunction` delegate - instead call the `success` callback.\"), this.dataReceivedRaw(h, x)), !0;\n        }, e.prototype.dataReceivedRaw = function (t, e) {\n          if (!this.chart.removed) {\n            this.scene.setMessage(this.dataId, null), delete this.requests[t.unitStr], this.chart.log(\"Data arrived\");\n            var i = d.Helpers.parseData(e, this.dataSettings.format);\n            d.Helpers.isObjectOrArray(e) && (i = this.cloneDataObject(i)), this.addDataInt(t, i, !1);\n          }\n        }, e.prototype.cloneDataObject = function (t) {\n          t = d.Helpers.clone(t);\n          var e = t.values;\n          if (!t.error && e) if (Array.isArray(e)) {\n            t.values = e = e.slice();\n\n            for (var i = 0; i < e.length; i++) {\n              var n = e[i];\n\n              if (!h(n)) {\n                t.error = \"The `values` in the TimeChart data object must be an array of arrays. The value at index \" + i + \" is not an array.\";\n                break;\n              }\n\n              e[i] = Array.prototype.slice.call(n);\n            }\n          } else t.error = \"The `values` in the TimeChart data object must be an array or arrays.\";\n          return t;\n        }, e.prototype.addData = function (t) {\n          t = this.cloneDataObject(t), this.addDataInt(null, t, !0);\n        }, e.prototype.addDataInt = function (e, i, n) {\n          if (void 0 === n && (n = !1), null !== i) {\n            if (!t.moment || !t.moment.tz) return void this._pendingAddData.push({\n              request: e,\n              parsedData: i,\n              append: n\n            });\n            var r = this.cleanupData(i);\n            if (r.error) return \"no-unit\" === r.error && e && (this.cache[e.unitStr] = null), void this.chart.error(r.error);\n            var s;\n            if (s = e ? this.analyzeData(r, e) : this.analyzeDataNoRequest(r, n), e && !e.unit.isMultipleOf(s.unit)) this.chart.error(\"Incorrect data - requested unit `\" + e.unit + \"`, got `\" + s.unit + \"`. The requested unit must be a multiple of returned unit.\"), this.cache[e.unitStr] = null, e.callback && e.callback(null, null, null);else {\n              var a = s.unitStr;\n\n              if (e && a !== e.unitStr) {\n                this.cache[e.unitStr] = null;\n\n                for (var o = !0, l = this._units, h = 0; h < l.length; h++) {\n                  if (l[h].unit.isEqual(s.unit)) {\n                    o = !1;\n                    break;\n                  }\n                }\n\n                o && (d.Helpers.warn(\"The data source returned unit `\" + a + \"` which was not declared in `data.units`.\"), this.dataSettings.units.push(a), this._prepareUsableUnits());\n              }\n\n              if (s.unit && null != s.from && null != s.to) {\n                var u = this.cache[s.unitStr];\n                u ? this.cache[s.unitStr].merge(s, this.dataSettings.cacheSize, this.chart, n) : this.cache[s.unitStr] = s;\n              }\n\n              e && e.callback && e.callback(s.from, s.to, s.unit);\n            }\n            this.chart.events.notifySceneChanges({\n              data: (c = {}, c[this.dataSettings.id] = !0, c)\n            });\n            var c;\n          }\n        }, e.prototype.dataFailed = function (t) {\n          this.cache[t.unitStr] || (this.cache[t.unitStr] = null), this.scene.setMessage(this.dataId, this.settings.localization.dataRequestFailed, 1e3), this.chart.error(\"Failed data loading request\"), t.callback && t.callback(null, null, null);\n        }, e.prototype.updateDataLimit = function (t, e, i, n, r) {\n          this.chart.invalidateDataLimits(), void 0 !== t && null !== t && (null === this.dataFrom || this.dataFrom > t) && (this.dataFrom = t), void 0 !== e && null !== e && (null === this.dataTo || this.dataTo < e) && (this.dataTo = e), null != i && (this.dataLimitFrom = i, this.dataLimitFromUnit = r, this.dataFrom = null == this.dataFrom ? i : Math.max(this.dataFrom, i)), null != n && (this.dataLimitTo = n, this.dataLimitToUnit = r, this.dataTo = null == this.dataTo ? n : Math.min(this.dataTo, n));\n        }, e.prototype.cleanupData = function (e) {\n          if (e.error) return e;\n          \"local\" === e.timeZone && (d.Helpers.error(\"The data source has to specify a timezone that is not `local` so that it works independent of the browser settings.\"), e.timeZone = t.moment.tz.guess()), e.error = \"bad-response\";\n          var i = !this.dataSettings.suppressWarnings,\n              n = \"\";\n          e.data && !e.values && (i && d.Helpers.warn(\"Use of property `data` in the TimeChart data object (returned from the URL, dataFunction or preloaded property) is deprecated. Please use `values` instead.\", null, !0), e.values = e.data), null == e.unit && (n += \"\\nRequired field 'unit' not set in data\"), null == e.values && (n += \"\\nRequired field 'values' not set in data\");\n          var s = r.parse(e.unit, void 0, !1);\n          if (null === s && (n += \"\\nData error: unrecognized data unit: \" + e.unit), n.length) return e.error = n.substr(1), e;\n          e.error = null;\n          var a = e.timeZone || \"UTC\",\n              o = r.timeUnitDiffs[s.unit] < r.timeUnitDiffs.d,\n              l = t.moment.defaultZone,\n              h = t.moment.locale();\n          t.moment.locale(this.scene.momentLocale), t.moment.tz.setDefault(a), e.from = this.convertTimestampToInternal(e.from, o), e.to = this.convertTimestampToInternal(e.to, o), e.dataLimitFrom = this.convertTimestampToInternal(e.dataLimitFrom, o), e.dataLimitTo = this.convertTimestampToInternal(e.dataLimitTo, o);\n          var u,\n              c,\n              p = -1e30,\n              f = !1;\n          null != e.from && null != e.to && e.from >= e.to && (this.chart.error(\"Data logic error. from >= to: \" + e.from + \", \" + e.to + \". The values will be ignored.\"), e.from = null, e.to = null), null != e.dataLimitFrom && null != e.dataLimitTo && e.dataLimitFrom >= e.dataLimitTo && (this.chart.error(\"Data logic error. dataLimitFrom >= dataLimitTo: \" + e.dataLimitFrom + \", \" + e.dataLimitTo + \". The values will be ignored.\"), e.dataLimitFrom = null, e.dataLimitTo = null);\n          var g = e.dataLimitFrom,\n              v = e.dataLimitTo;\n          null == g && (g = -(1 / 0)), null == v && (v = 1 / 0);\n          var m = 0;\n\n          if (\"UTC\" === a && \"UTC\" === this.settings.timeAxis.timeZone && (m = this.dataSettings.timestampInSeconds ? 1e3 : 1), e.values.length > 0) {\n            for (var y = [], S = 0; S < e.values.length; S++) {\n              var b = e.values[S];\n\n              if (Array.isArray(b)) {\n                for (var x = b.length, C = 1; C < x; C++) {\n                  var w = b[C];\n                  null != w ? \"number\" != typeof w && isNaN(b[C] = parseFloat(w)) ? (this.chart.error(\"Data error: the value is not a number: values[\" + S + \"][\" + C + \"] = \" + w), b[C] = null) : isNaN(w) && (b[C] = null) : b[C] = null;\n                }\n\n                var L = x ? b[0] : null;\n\n                if (null != L) {\n                  if (b[0] = L = m && \"number\" == typeof L ? L * m : this.convertTimestampToInternal(L, o), null === L) continue;\n                  (L < g || L > v) && this.chart.error(\"Data error: value timestamp outside data limits. values[\" + S + \"][0] = \" + b[0] + \". Limits: \" + g + \"...\" + v), i && p === L && d.Helpers.warn(\"There are multiple values given for the same timestamp \" + b[0] + \" which might produce invalid results.\"), p > L && !f && (i && d.Helpers.warn(\"Data values are not sorted on timestamp in ascending order (timestamp \" + b[0] + \"). TimeChart will sort the data automatically but to achieve better performance the data source should be sorted.\"), f = !0), p = b[0], y.push(b);\n                }\n              } else this.chart.error(\"Data error: the value at index \" + S + \" is not an array.\");\n            }\n\n            e.values = y, f && y.sort(function (t, e) {\n              return t[0] - e[0];\n            }), u = y[0][0], c = y[y.length - 1][0];\n          }\n\n          return null != e.from && u < e.from && (d.Helpers.warn(\"Data logic error. Data time \" + u + \" outside [from, to) range: \" + e.from + \", \" + e.to), e.from = u), null != e.to && c >= e.to && (d.Helpers.warn(\"Data logic error. Data time \" + c + \" outside [from, to) range: \" + e.from + \", \" + e.to), e.to = c + 1), t.moment.defaultZone = l, t.moment.locale(h), e;\n        }, e.prototype.analyzeDataNoRequest = function (t, e) {\n          var i = this.dataSettings,\n              n = t.from,\n              s = t.to,\n              a = r.parse(t.unit),\n              o = null,\n              l = null;\n\n          if ((null == n || null == s) && t.values.length > 0) {\n            var h = this.scene.timeStepSettings;\n            o = t.values[0][0], l = t.values[t.values.length - 1][0], o = a.roundTimeDown(o, h), l = a.roundTimeUp(l + 1, h), null == n && (n = o), null == s && (s = l);\n          }\n\n          null != i.dataFunction || null != i.url || null != t.dataLimitFrom || null != t.dataLimitTo || d.Helpers.hasProperties(i.urlByUnit) || (d.Helpers.warn(\"Using preloaded data without specifying `dataLimitFrom` and `dataLimitTo` is not recommended - these values will be implied from the data and might result in invalid behavior.\", null, 1e30), null == t.dataLimitFrom && (t.dataLimitFrom = Math.min((e ? this.dataLimitFrom : 0) || 1e30, t.from || o)), null == t.dataLimitTo && (t.dataLimitTo = Math.max((e ? this.dataLimitTo : 0) || -1e30, t.to || l))), this.updateDataLimit(o, l, t.dataLimitFrom, t.dataLimitTo, a);\n          var u = new p(a, n, s, t.values);\n          return null != t.error && (u.error = t.error), u;\n        }, e.prototype.analyzeData = function (t, e) {\n          null === e.from && null == t.from && null != t.dataLimitFrom && (t.from = t.dataLimitFrom, d.Helpers.warn(\"`from` is not set in the data response - using `dataLimitFrom` instead. This may produce unexpected results.\")), null === e.to && null == t.to && null != t.dataLimitTo && (t.to = t.dataLimitTo, d.Helpers.warn(\"`to` is not set in the data response - using `dataLimitTo` instead. This may produce unexpected results.\"));\n          var i = t.from,\n              n = t.to,\n              s = null,\n              a = null;\n          null != i && null != n && i >= n && this.chart.error(\"Data logic error. from >= to: \" + i + \", \" + n);\n          var o = r.parse(t.unit),\n              l = this.scene.timeStepSettings;\n\n          if (t.values.length > 0 ? (s = t.values[0][0], a = t.values[t.values.length - 1][0], s = o.roundTimeDown(s, l), a = o.roundTimeUp(a + 1, l), null == i && (i = null !== e.from ? Math.min(e.from, s) : s), null == n && (n = null !== e.to ? Math.max(e.to, a) : a), e.from && a <= e.unit.add(e.from) && (this.dataSettings._skipRequestRangeRounding = !0)) : (null == i && (i = e.from), null == n && (n = e.to), null != t.from && null != t.to ? (s = t.from, a = t.to) : (s = e.from, a = e.to, null === e.from && null === e.to && null == i && null == n && null == t.dataLimitFrom && null == t.dataLimitTo && (this.noData = !0))), this.updateDataLimit(s, a, t.dataLimitFrom, t.dataLimitTo, o), null !== e.from && null != t.to) {\n            var h = o.roundTimeDown(t.to, l);\n            h <= e.from && this.updateDataLimit(null, null, null, t.to, o);\n          }\n\n          if (null !== e.to && null != t.from) {\n            var u = o.roundTimeUp(t.from, l);\n            u >= e.to && this.updateDataLimit(null, null, t.from, null, o);\n          }\n\n          null == t.from && null == t.dataLimitFrom && (null !== this.dataLimitFrom && (null === e.from || e.from <= this.dataLimitFrom && s > this.dataLimitFrom) || null === this.dataLimitFrom && (void 0 === e.from || null === e.from)) && (this.updateDataLimit(null, null, s, null, o), i = s), null == t.to && null == t.dataLimitTo && (null !== this.dataLimitTo && (null === e.to || e.to >= this.dataLimitTo && a < this.dataLimitTo) || null === this.dataLimitTo && (void 0 === e.to || null === e.to)) && (this.updateDataLimit(null, null, null, a, o), n = a);\n          var c = new p(o, i, n, t.values);\n          return t.error && (c.error = t.error), c;\n        }, e.prototype.getDataFunction = function () {\n          var t = this,\n              e = this.dataSettings;\n          if (e.dataFunction) return e.dataFunction;\n          var i = d.Helpers.hasProperties(e.urlByUnit);\n          return e.url || i ? function (n, r, s, a, o, l) {\n            var h;\n\n            if (i) {\n              if (h = e.urlByUnit[s], !h) return '{\"error\":\"no-unit\", \"errormessage\":\"no data url for this time unit: ' + s + '\"}';\n            } else h = e.url;\n\n            var u = [];\n            null !== n && u.push([\"from\", n.toString(10)]), null !== r && u.push([\"to\", r.toString(10)]), u.push([\"unit\", s]), null !== l && u.push([\"timeZone\", l]), d.Data.doRequest(h, t.dataSettings, u, a, o);\n          } : null;\n        }, e.prototype.hasPendingRequests = function () {\n          return d.Helpers.hasProperties(this.requests);\n        }, e.prototype.convertTimestampToInternal = function (e, i) {\n          if (null == e) return null;\n          var n = this.dataSettings,\n              r = this.settings.timeAxis,\n              s = d.Helpers.isNumber(e);\n          s && n.timestampInSeconds && (e = 1e3 * e);\n          var a = t.moment(e, s ? null : n.stringTimestampFormat);\n\n          if (!a.isValid()) {\n            var o = parseFloat(e);\n            return s || isNaN(o) ? (d.Helpers.error(\"Could not parse timestamp value `\" + e + \"`. The value will be ignored.\"), null) : (d.Helpers.warn(\"Numeric timestamp value `\" + e + \"` was passed as string. This has been deprecated starting from version 1.12.\"), this.convertTimestampToInternal(o, i));\n          }\n\n          i && (a = a.tz(r.timeZone));\n          var l = a.utcOffset ? a.utcOffset() : a.zone();\n          return e = +a + 6e4 * l, e + 6e4 * (r.timeZoneOffset - n.timeZoneOffset);\n        }, e.prototype.convertTimestampFromInternal = function (t, e) {\n          if (null == t) return null;\n          var i = this.dataSettings;\n          return t = this.scene.timestampFromInternal(t, e), t += 6e4 * i.timeZoneOffset, i.timestampInSeconds && (t /= 1e3), t;\n        }, e;\n      }();\n\n      t.Data = c;\n\n      var p = function () {\n        function t(t, e, i, n) {\n          this.values = null, this.error = null, this.values = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.updateLastTimestamp();\n        }\n\n        return t.prototype.updateLastTimestamp = function () {\n          this.values.length > 0 ? this.lastTimestamp = this.values[this.values.length - 1][0] : this.lastTimestamp = 0;\n        }, t.prototype.merge = function (t, e, i, n) {\n          if (t.unit.approxTime() !== this.unit.approxTime()) throw new Error(\"merge unit mismatch\");\n          if (!n && (this.from > t.to || this.to < t.from)) return this.values = t.values, this.from = t.from, void (this.to = t.to);\n          t.values.length > 0 && t.from > t.values[0][0] && i.error(\"Data merge - oldest data before from\"), t.values.length > 0 && t.to < t.values[t.values.length - 1][0] && i.error(\"Data merge - newest data after to\");\n\n          for (var r = 0; r < this.values.length && this.values[r][0] < t.from;) {\n            r += 1;\n          }\n\n          for (var s = this.values.length; s > 0 && this.values[s - 1][0] >= t.to;) {\n            s -= 1;\n          }\n\n          var a = t.values;\n\n          if (this.from = Math.min(this.from, t.from), this.to = Math.max(this.to, t.to), r > 0) {\n            var o = Math.max(0, a.length + r - e);\n            a = this.values.slice(o, r - 1 + 1).concat(a), o > 0 && (this.from = this.values[o - 1][0] + 1);\n          }\n\n          if (s < this.values.length) {\n            var l = this.values.length - s;\n            l = Math.min(l, e - a.length), a = a.concat(this.values.slice(s, s + l + 1)), l < this.values.length - s && (this.to = this.values[s + l][0]);\n          }\n\n          this.values = a, this.updateLastTimestamp();\n        }, t;\n      }();\n\n      t.TimeData = p;\n\n      var f = function () {\n        function t(t, e, i, n, r, s) {\n          this.time = r, this.callback = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.timeZone = s;\n        }\n\n        return t;\n      }(),\n          g = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.limitMode = \"snapBack\", e.limitFrom = \"oldestData\", e.limitTo = \"newestData\", e.overscrollProportion = 0, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsInteractionScrolling);\n\n      t.SettingsInteractionScrolling = g;\n\n      var v = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1400, i.animationUnit = null, i.targetUnit = null, i.dragStartBar0 = null, i.dragStartBar1 = null, i.dragStartUnit = null, i.timeSetup = new o(e), i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (e) {\n          t.prototype.onSceneChange.call(this, e);\n          var i = this.scene,\n              n = this.scene.displayUnit;\n          !this.scalingActive && i.timeScale && i.lastUnit === n || !n || this.timeSetup.preventUnitWidthViolation(this.chart.timeEnd, this.chart.timeStart) || (i.timeScale = (i.timeEnd - i.timeStart) / i.width), i.lastUnit !== n && (i.lastUnit = n);\n        }, e.prototype.scaleViewRange = function (e, i, n) {\n          var r = t.prototype.scaleViewRange.call(this, e, i, n),\n              s = this.scene,\n              a = s.settings.timeAxis,\n              o = (r.to - r.from) / s.width * a.minUnitWidth / 1.5;\n          return s.disableScaleLimiter || o <= s.displayUnit.approxTime() ? r : {\n            from: i,\n            to: n\n          };\n        }, e.prototype.setTimeRangeSnap = function (t, e, i, n, r, s, a, o) {\n          var l = this.snap(t, e, i, n, a, o);\n          t = l.from, e = l.to;\n          var h = l.unit,\n              u = l.period,\n              c = l.anchor;\n          this.setTimeRange(t, e, h, r, s, c, u);\n        }, e.prototype.computeDisplayPeriod = function (t, e, i, n, r) {\n          var s = this.timeSetup.tryComputeDisplayPeriod(t, e, i, n, r, this.scene, this.scene.getCurTime()),\n              a = s.from,\n              o = s.to,\n              l = s.unit;\n          return null === a || null === o ? {\n            from: null,\n            to: null,\n            unit: null\n          } : this.computeTimeRangeExtend(a, o, l);\n        }, e.prototype.computeTimeRangeExtend = function (t, e, i) {\n          var n = this.scene;\n\n          if (!i) {\n            var r = this.timeSetup.computeDisplayUnit(n.timeStart, n.timeEnd, n.displayUnit, t, e, n);\n            t = r.from, e = r.to, i = r.unit;\n          }\n\n          var s = n.timeStepSettings;\n          t = i.roundTimeDown(t, s), e = i.roundTimeUp(e, s), e === t && (e = i.add(e, 1));\n\n          var a = this._preventOverscroll(t, e, i, !0);\n\n          return t = a.from, e = a.to, {\n            from: t,\n            to: e,\n            unit: i\n          };\n        }, e.prototype.computeDisplayUnit = function (t, e, i) {\n          var n = null !== this.dragStartFrom ? this.dragStartFrom : this.scene.timeStart,\n              r = null !== this.dragStartTo ? this.dragStartTo : this.scene.timeEnd,\n              s = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit,\n              a = this.chart.scrolling,\n              o = {\n            scroll: a.scrollingActive,\n            scale: a.scalingActive,\n            animate: i\n          };\n          return this.timeSetup.computeDisplayUnit(n, r, s, t, e, this.scene, o);\n        }, e.prototype.setTimeRange = function (t, e, i, n, r, s, a) {\n          if (void 0 === s && (s = null), void 0 === a && (a = null), t = Math.round(t), e = Math.round(e), !(t > e)) {\n            if (!i) {\n              var o = this.computeDisplayUnit(t, e);\n              t = o.from, e = o.to, i = o.unit;\n            }\n\n            if (\"init\" === r) {\n              var o = this.timeSetup.getMinRangeForUnit(t, e, i, s);\n              t = o.from, e = o.to;\n            }\n\n            t === this.getFrom() && e === this.getTo() && i.isEqual(this.scene.displayUnit) || (n && this.abort(), this.scene.anchor = s, this.scene.period = a, this.targetUnit = i, this.animationUnit = !i || this.scene.displayUnit && i.toString() !== this.scene.displayUnit.toString() ? null : i, this.goToPosition(t, e, n, d.Helpers.performanceNow(), !0), this.events.notifySceneChanges({\n              time: !0\n            }), r && this.chart.notifyTimeChanged(t, e, i, r));\n          }\n        }, e.prototype.zoomOut = function (t, e, i, n, r) {\n          if (this.scene.displayUnit) {\n            var s = this.computeZoomOut(e, i);\n            this.scene.displayUnit = s.unit, this.setTimeRangeSnap(s.from, s.to, s.center, s.unit, n, r, !1, !0);\n          }\n        }, e.prototype.zoomIn = function (t, e, i, n, r, s) {\n          if (this.scene.displayUnit) {\n            null === e && (e = (i + n) / 2);\n            var a = this.onZoomIn(i, n, e, .5);\n            this.setTimeRangeSnap(a.from, a.to, a.center, t, r, s, !1, !0);\n          }\n        }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {\n          var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);\n          t = s.from, e = s.to;\n          var a = s.unit;\n\n          if (this.scene.displayUnit = a, null === this.pointer1) {\n            var o = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);\n            t = o.from, e = o.to, a = o.unit, this.scene.displayUnit = a;\n          }\n\n          this.goToPosition(t, e, !0, n, !0);\n        }, e.prototype.xyInArea = function (t, e) {\n          return this.scene.xyInChart(t, e);\n        }, e.prototype.xyToPosition = function (t, e) {\n          return this.scene.xToTime(t);\n        }, e.prototype.onZoomOut = function (e, i, n, r) {\n          return void 0 === r && (r = null), r ? t.prototype.onZoomOut.call(this, e, i, n, r) : this.computeZoomOut(e, i);\n        }, e.prototype.onZoomIn = function (e, i, n, r) {\n          if (void 0 === r && (r = null), r) return t.prototype.onZoomIn.call(this, e, i, n, r);\n\n          if (this.dragStartBar0 && (e = this.dragStartBar0, i = this.dragStartBar1, i - e > this.scene.timeEnd - this.scene.timeStart)) {\n            var s = this.scene.getClickBar(n);\n            e = s.time0, i = s.time1;\n          }\n\n          return {\n            from: e,\n            to: i,\n            center: (e + i) / 2\n          };\n        }, e.prototype.onScroll = function (t, e, i) {\n          return this.timeSetup.scroll(t, e, this.scene.displayUnit, i, 1, \"page\");\n        }, e.prototype.onGoHome = function (t, e) {\n          var i = this.chart.getDisplayLimits().to;\n          if (null === i) return {\n            from: t,\n            to: e,\n            origin: null\n          };\n          this.scene.anchor = \"newestData\";\n          var n = e - t;\n          return {\n            from: i - n,\n            to: i,\n            origin: i\n          };\n        }, e.prototype.onStartDragging = function (t, e, i) {\n          this.scene.anchor = null, this.animationUnit = null, this.dragStartUnit = this.scene.displayUnit;\n          var n = this.scene.getClickBar(i);\n          this.dragStartBar0 = n.time0, this.dragStartBar1 = n.time1;\n        }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {\n          if (t > e) {\n            var s = e;\n            e = t, t = s;\n          }\n\n          var a = this._preventOverscale(t, e, null, i, !1);\n\n          t = a.from, e = a.to;\n\n          var o = this.computeDisplayUnit(t, e).unit,\n              l = this._preventOverscroll(t, e, o, !1);\n\n          return t = l.from, e = l.to, this.events.notifySceneChanges({\n            time: !0\n          }), {\n            from: t,\n            to: e,\n            unit: o\n          };\n        }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {\n          if (r) {\n            var s = this.timeSetup.adjustTimeAfterScale(t, e, this.dragStartBar0, this.dragStartBar1);\n            t = s.from, e = s.to;\n          }\n\n          var a = this.snap(t, e, i, null, n, !1),\n              o = a.unit,\n              l = a.period,\n              h = a.anchor;\n          return this.targetUnit = o, this.animationUnit = this.scene.displayUnit, this.scene.period = l, this.scene.anchor = h, this.dragStartBar0 = null, this.dragStartBar1 = null, this.dragStartFrom = null, this.dragStartTo = null, this.dragStartUnit = null, this.events.notifySceneChanges({\n            time: !0\n          }), this.chart.notifyTimeChanged(t, e, o, \"user\"), {\n            from: a.from,\n            to: a.to,\n            unit: o\n          };\n        }, e.prototype.onPositionChanged = function (t, e, i) {\n          if (!isNaN(t) || !isNaN(e)) {\n            var n;\n            n = this.animationUnit ? this.animationUnit : this.computeDisplayUnit(t, e).unit, this.scene.setTimeRange(t, e, n), this.chart.timeStart = t, this.chart.timeEnd = e, this.chart.displayUnit = n, this.events.notifySceneChanges({\n              position: !0,\n              time: !0\n            });\n          }\n        }, e.prototype.onAnimationDone = function (t, e) {\n          if (this.targetUnit) {\n            var i = this.targetUnit ? this.targetUnit : this.computeDisplayUnit(t, e).unit;\n            this.chart.displayUnit = i, this.scene.setTimeRange(t, e, i);\n          }\n\n          this.targetUnit = null, this.animationUnit = null, this.chart.notifyAnimationDone();\n        }, e.prototype.onPointerDown = function (e) {\n          null !== this.pointer1 && null === this.pointer2 && (this.dragStartUnit = this.scene.displayUnit), t.prototype.onPointerDown.call(this, e);\n        }, e.prototype.onPointerDrag = function (e) {\n          this.scene.displayUnit && t.prototype.onPointerDrag.call(this, e);\n        }, e.prototype.computeZoomOut = function (t, e) {\n          var i,\n              n = this.scene.settings.toolbar.zoomOutFunction,\n              s = this.scene.displayUnit,\n              a = null,\n              o = null,\n              l = e - t,\n              h = e - l / 2;\n          n && (o = n(s.unit, s.count, t, e)), null != o && o.unit && (a = new r(o.unit, o.count || 1)), a || (a = this.timeSetup.getBiggerDisplayUnit(s));\n          var u = a.approxTime(),\n              c = this.timeSetup.getUnitRange(this.scene, [a]),\n              d = null != o && (null != o.from || null != o.to);\n\n          if (d) {\n            i = Math.min(c.maxTime, o.to - o.from);\n            var p = this.timeSetup.verifyUnitWidth(o.from, o.to, a);\n\n            if (p.min || p.max) {\n              var f = this.timeSetup.adjustTimeRangeToUnits(this.chart.scene, o.from, o.to, a);\n              t = f.from, e = f.to;\n            }\n          } else {\n            var g = Math.min(30 * l / u, Math.floor(c.maxTime / u));\n            i = u * g;\n          }\n\n          return (!o || o && !o.from) && (t = h - i / 2, e = h + i / 2), {\n            from: t,\n            to: e,\n            center: h,\n            unit: a\n          };\n        }, e.prototype.snap = function (t, e, i, n, r, s) {\n          if ((s || r) && this.scene.settings.interaction.scrolling.limitMode) {\n            var a = this._preventOverscale(t, e, n, i, !0);\n\n            t = a.from, e = a.to;\n          }\n\n          var o, l;\n\n          if (n ? o = n : !s || !s && r ? o = this.scene.displayUnit : (l = this.computeDisplayUnit(t, e), o = l.unit, t = l.from, e = l.to), r || s) {\n            var h = e - t,\n                u = this._preventOverscroll(t, e, o, !1);\n\n            t = u.from, e = u.to, u = this._preventOverscroll(t, e, o, !0), t = u.from, e = u.to, s = s || e - t !== h;\n          }\n\n          if (!n && s) return l = this.computeDisplayUnit(t, e), t = l.from, e = l.to, this.snap(t, e, i, o, r, s);\n          var c = s ? null : this.scene.period,\n              d = this.scene.anchor,\n              p = this.scene.settings.interaction.snapMode;\n\n          if (p) {\n            var f = this.scene.majorTimeUnit && \"y\" === this.scene.majorTimeUnit.unit,\n                g = void 0;\n            if (\"displayUnit\" === p) g = o;else if (\"multiperiod\" === p || \"period\" === p) {\n              var v = e - t,\n                  m = this.chart.getDisplayLimits(),\n                  y = m.from,\n                  S = m.to;\n              null !== y && (v = Math.min(v, S - y));\n              var b = this.timeSetup.getClosestDisplayPeriod(v, this.scene.majorTimeUnit, \"multiperiod\" === p || f);\n              g = b, c = b.toString();\n            }\n            var x = this.scene.timeStepSettings;\n            if (\"period\" !== p || f) {\n              if (s) t = g.roundTimeRound(t, x), e = g.roundTimeRound(e, x);else {\n                var C = Math.max(g.numberOfUnits(t, e), 1),\n                    w = Math.abs(g.roundTimeRound(t, x) - t),\n                    L = Math.abs(g.roundTimeRound(e, x) - e);\n                w < L ? (t = g.roundTimeRound(t, x), e = g.add(t, C)) : (e = g.roundTimeRound(e, x), t = g.sub(e, C));\n              }\n            } else t = g.roundTimeDown(i, x), e = g.add(t, 1);\n          } else t = Math.round(t), e = Math.round(e);\n\n          return {\n            from: t,\n            to: e,\n            unit: o,\n            period: c,\n            anchor: d\n          };\n        }, e.prototype._preventOverscroll = function (t, e, i, n) {\n          return this.timeSetup.preventOverscroll(i, t, e, n);\n        }, e.prototype._preventOverscale = function (t, e, i, n, r) {\n          var s;\n          return i ? s = [i] : (i = this.scene.displayUnit, s = this.scene.settings._displayUnitsParsed), this.timeSetup.preventOverscale(this.scene, s, n, t, e, i, r);\n        }, e;\n      }(l.Scrolling);\n\n      t.Scrolling = v;\n\n      var m = function () {\n        function t() {\n          this.enabled = !0, this.tolerance = 6, this.moveByDragging = !1, this.resizeSensitivity = 2, this.resizeTolerance = 20, this.clearOnRightClick = !0;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionSelection = m;\n\n      var y = function () {\n        function t() {\n          this.lineColor = \"rgba(0,0,0,0.5)\", this.lineWidth = 2, this.fillColor = \"rgba(30,160,220,0.15)\", this.behindSeries = !1, this.roundToNearestTime = !1;\n        }\n\n        return t;\n      }();\n\n      t.SettingsAreaStyleSelection = y;\n\n      var S = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          i.selectStart = null, i.selectingPointer = null, i.isSelecting = !1, i.isHoveringEdge = !1, i.lastX = 0, i.lastY = 0, i.roundAround = !1, i.selectionRemoved = !1, i.animationOrder = 500, i.updateOrder = 1300, i.isMoving = !1, i.moveStartX = 0, i.moveStartY = 0, i.moveSelectionStart = null, i.moveSelectionEnd = null, i.chart = e, i.scene = e.scene;\n          var n = e.settings;\n          return i.settings = n.interaction.selection, i.styleSettings = n.area.style.selection, i.labelStyle = n.area.style.selectionLabel, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          if ((t.changes.time || t.changes.bounds) && null !== this.selectStart && this.dragPointer(null, this.lastX, this.lastY, t.changes), t.changes.settings) {\n            var e = this.styleSettings.behindSeries ? 3 : 15;\n            this.paintOrder !== e && (this.paintOrder = e, this.chart.events.refreshElementOrder());\n          }\n        }, e.prototype.getLineCoordinates = function () {\n          var t = this.scene,\n              e = this.styleSettings,\n              i = Math.round(t.timeToX(t.selectionStart)),\n              n = Math.round(t.timeToX(t.selectionEnd)),\n              r = e.lineWidth,\n              s = Math.round(t.x0),\n              a = Math.round(s + t.width);\n          return i - r < s && i > s - 4 * r && (i = s + r), n + r > a && n < a + 4 * r && (n -= r), {\n            start: i,\n            end: n\n          };\n        }, e.prototype.paintScene = function (t) {\n          var e = this.scene;\n\n          if (null != e.minorTimeUnit && null != e.selectionStart && null != e.selectionEnd && this.chart.assetsLoaded) {\n            var i = this.styleSettings,\n                n = i.lineWidth,\n                r = Math.round(e.x0),\n                s = Math.round(r + e.width),\n                a = Math.round(e.y0),\n                o = Math.round(a + e.height + e.bottomAxisSize),\n                l = this.getLineCoordinates(),\n                h = l.start,\n                u = l.end,\n                c = e.getRoundedTimes(),\n                p = e.formatTimeRange(c[0], c[1], !0),\n                f = p[0],\n                g = p[1],\n                v = t.context,\n                m = e.height + e.bottomAxisSize;\n            d.Graphics.pushClip(t, r, a, e.width, m), d.Graphics.rectStyle(v, i);\n            var y = h + n % 2 / 2,\n                S = u + n % 2 / 2;\n            v.fillRect(y + n / 2, a, u - h - n, m), v.beginPath(), v.moveTo(y, a), v.lineTo(y, o), v.moveTo(S, a), v.lineTo(S, o), d.Graphics.stroke(v, i);\n            var b = t.labelRenderer,\n                x = this.labelStyle,\n                C = d.Graphics.getTextWidth(v, x, f),\n                w = d.Graphics.getTextWidth(v, x, g),\n                L = new d.Label({\n              text: f,\n              textStyle: x\n            }, !0),\n                T = new d.Label({\n              text: g,\n              textStyle: x\n            }, !0),\n                k = 10,\n                M = 5;\n            h < r && (h = r), u > s && (u = s), C + w + 20 < u - h ? (h += M, u = u - w - M) : (h = h - C - M, u += M);\n            var A = this.chart.shell.getChartInnerArea(),\n                I = A.findTopPosition(h, h + C),\n                P = A.findTopPosition(u, u + w);\n            b.paint(v, h + C / 2, I + k, 1, L), b.paint(v, u + w / 2, P + k, 1, T), d.Graphics.popClip(t);\n          }\n        }, e.prototype.onPointerMove = function (t) {\n          var e = this.scene,\n              i = this.settings;\n\n          if (i.enabled) {\n            e.xyInBottom(t.x, t.y) && (t.cursor = \"text\");\n            var n = !1;\n\n            if (null != e.selectionStart && null != e.selectionEnd && e.xyInChartOrBottom(t.x, t.y) && e.timeStart < e.timeEnd) {\n              var r = this.getLineCoordinates();\n              Math.abs(r.start - t.x) <= i.tolerance ? (t.cursor = \"e-resize\", t.consumed = !0, n = !0) : Math.abs(r.end - t.x) <= i.tolerance ? (t.cursor = \"w-resize\", t.consumed = !0, n = !0) : i.moveByDragging && r.start < t.x && r.end > t.x && (t.cursor = \"move\", t.consumed = !0);\n            }\n\n            this.isHoveringEdge = n;\n          }\n        }, e.prototype.onPointerDown = function (t) {\n          var e = this.scene,\n              i = this.settings;\n\n          if (e.xyInChartOrBottom(t.x, t.y) && null === this.selectingPointer && i.enabled) {\n            this.selectionRemoved = !1, this.lastX = t.x;\n            var n = null,\n                r = null;\n\n            if (null !== e.selectionStart || null !== e.selectionEnd) {\n              var s = this.getLineCoordinates(),\n                  a = Math.abs(s.start - t.x),\n                  o = Math.abs(s.end - t.x),\n                  l = !1;\n              if (a < i.tolerance && a <= o ? (this.selectStart = e.selectionEnd, l = !0) : o < i.tolerance && o <= a ? (this.selectStart = e.selectionStart, l = !0) : i.moveByDragging && s.start < t.x && s.end > t.x && (this.isMoving = !0, this.moveStartX = t.x, this.moveStartY = t.y, this.moveSelectionStart = e.selectionStart, this.moveSelectionEnd = e.selectionEnd, this.selectStart = e.xToTime(t.x), l = !0), l) return this.selectingPointer = t.identifier, t.consumed = !0, this.roundAround = !0, void (this.isSelecting = !0);\n            }\n\n            e.xyInBottom(t.x, t.y) && (this.selectingPointer = t.identifier, this.selectStart = e.xToTime(t.x), t.capture = !0, this.roundAround = !0, this.isSelecting = !0, t.x >= n && t.x <= r || null !== e.selectionStart && (this.selectionRemoved = !0, e.selectionStart = null, e.selectionEnd = null, t.changes.selection = !0));\n          }\n        }, e.prototype.onPointerDrag = function (t) {\n          this.scene.displayUnit && this.selectingPointer === t.identifier && (this.dragPointer(t, t.x, t.y, t.changes), t.consumed = !0);\n        }, e.prototype.dragPointer = function (t, e, i, n) {\n          var r,\n              s,\n              a = this.scene;\n\n          if (this.isMoving) {\n            var o = a.dxToDtime(e - this.moveStartX);\n            r = this.moveSelectionStart + o, s = this.moveSelectionEnd + o;\n            var l = i - this.moveStartY,\n                h = this.settings.resizeTolerance;\n\n            if (Math.abs(l) > h) {\n              l = l < 0 ? l + h : l - h;\n              var u = this.moveSelectionEnd - this.moveSelectionStart,\n                  c = Math.min(u, a.dxToDtime(l * this.settings.resizeSensitivity)),\n                  p = 0 === u ? .5 : (this.selectStart - this.moveSelectionStart) / u;\n              r += c * p, s -= c * (1 - p);\n            }\n          } else {\n            var f = this.selectStart,\n                g = this.scene.xToTime(e),\n                v = Math.abs(f - g),\n                m = a.snapTimeRound(f),\n                o = m - f,\n                y = d.Helpers.sign(o);\n            m = f + Math.min(o * y, .9 * v) * y, m < g ? (r = m, s = g) : (r = g, s = m);\n          }\n\n          this.lastX = e, this.lastY = i, a.selectionStart = r, a.selectionEnd = s, n.selection = !0, a.settings.events.selectionChangeDuringInteraction && this.chart.notifySelectionChanged(this.chart.createEventArguments(t, \"user\"));\n        }, e.prototype.onPointerUp = function (t) {\n          if (this.selectingPointer === t.identifier) {\n            if (this.isSelecting) {\n              var e = this.snapSelection(),\n                  i = e.st,\n                  n = e.en;\n              i === n && (i = null, n = null);\n              var r = this.scene;\n              r.selectionStart = i, r.selectionEnd = n, null != i && (r.hoverFrom = i, r.hoverTo = n), this.chart.notifySelectionChanged(this.chart.createEventArguments(t, \"user\")), t.changes.selection = !0;\n            }\n\n            (this.isSelecting || this.selectionRemoved) && (t.consumed = !0), this.isSelecting = !1, this.isMoving = !1, this.selectStart = null, this.selectingPointer = null;\n          }\n        }, e.prototype.onPointerCancel = function (t) {\n          this.onPointerUp(t);\n        }, e.prototype.snapSelection = function () {\n          var t,\n              e,\n              i = this.scene;\n          return null != i.selectionStart ? this.roundAround ? (t = i.snapTimeRound(i.selectionStart), e = i.snapTimeRound(i.selectionEnd)) : (t = i.snapTimeDown(i.selectionStart), e = i.snapTimeUp(i.selectionEnd)) : (t = null, e = null), {\n            st: t,\n            en: e\n          };\n        }, e;\n      }(d.ChartElement);\n\n      t.Selection = S;\n\n      var b = function (e) {\n        function i() {\n          var t = e.apply(this, arguments) || this;\n          return t.chart = null, t.hoverItem = null, t.timeStart = 0, t.timeEnd = 0, t.anchor = null, t.period = null, t.displayUnit = null, t.data = {}, t.markers = [], t.mainData = null, t.selectionStart = null, t.selectionEnd = null, t.minorTimeFormat = null, t.minorTimeUnit = null, t.majorTimeUnit = null, t.majorTimeFormat = null, t.hoverFrom = null, t.hoverTo = null, t.timeScale = 0, t.lastUnit = null, t.disableScaleLimiter = !1, t.momentLocale = \"zc\" + (i._momentLocaleCounter++).toFixed(0), t;\n        }\n\n        return n(i, e), i.prototype.setTimeRange = function (t, e, i) {\n          i || d.Helpers.error(\"Scene.setTimeRange: no display unit\"), this.timeStart = t, this.timeEnd = e, this.displayUnit = i;\n        }, i.prototype.getTimeRange = function () {\n          return {\n            timeStart: this.timeStart,\n            timeEnd: this.timeEnd,\n            displayUnit: this.displayUnit\n          };\n        }, i.prototype.pixelsPerTime = function () {\n          return this.width / (this.timeEnd - this.timeStart);\n        }, i.prototype.getScale = function () {\n          return (this.timeEnd - this.timeStart) / this.width;\n        }, i.prototype.timeToX = function (t) {\n          return this.x0 + this.width * (t - this.timeStart) / (this.timeEnd - this.timeStart);\n        }, i.prototype.timeToXCoefs = function () {\n          return {\n            tadd: this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart),\n            tmul: this.width / (this.timeEnd - this.timeStart)\n          };\n        }, i.prototype.xToTime = function (t) {\n          return this.timeStart + (this.timeEnd - this.timeStart) * (t - this.x0) / this.width;\n        }, i.prototype.xToFraction = function (t) {\n          return (t - this.x0) / this.width;\n        }, i.prototype.dTimeToDx = function (t) {\n          return this.width * t / (this.timeEnd - this.timeStart);\n        }, i.prototype.dxToDtime = function (t) {\n          return t / this.width * (this.timeEnd - this.timeStart);\n        }, i.prototype.snapTimeDown = function (t) {\n          return this.displayUnit.roundTimeDown(t, this.timeStepSettings);\n        }, i.prototype.snapTimeUp = function (t) {\n          return this.displayUnit.roundTimeUp(t, this.timeStepSettings);\n        }, i.prototype.snapTimeRound = function (t) {\n          return this.displayUnit.roundTimeRound(t, this.timeStepSettings);\n        }, i.prototype.getClickBar = function (t) {\n          var e = this.displayUnit;\n          return e ? {\n            time0: e.roundTimeDown(t, this.timeStepSettings),\n            time1: e.roundTimeUp(t + 1, this.timeStepSettings)\n          } : {\n            time0: null,\n            time1: null\n          };\n        }, i.prototype.getCurTime = function () {\n          var t,\n              e = this.settings.currentTime;\n          return t = null != e.time ? e.time : new Date().getTime(), this.timestampToInternal(t, !0);\n        }, i.prototype.timestampToInternal = function (e, i) {\n          if (null == e) return null;\n          e = +e;\n          var n = this.settings.timeAxis;\n\n          if (i) {\n            if (!t.moment || !t.moment.tz) return null;\n            var r = t.moment.utc(e).tz(n.timeZone),\n                s = r.utcOffset ? r.utcOffset() : r.zone();\n            e = +r + 6e4 * s;\n          }\n\n          return e + 6e4 * n.timeZoneOffset;\n        }, i.prototype.timestampFromInternal = function (e, i) {\n          if (null == e) return null;\n          var n = this.settings.timeAxis;\n\n          if (i) {\n            if (!t.moment || !t.moment.tz) return null;\n            var r = t.moment.utc(e).tz(n.timeZone),\n                s = r.utcOffset ? r.utcOffset() : r.zone();\n            e = +r - 6e4 * s;\n          }\n\n          return e -= 6e4 * n.timeZoneOffset;\n        }, i.prototype.getRoundedTimes = function (t) {\n          if (void 0 === t && (t = [this.selectionStart, Math.max(this.selectionStart, this.selectionEnd - 1)]), null === t) return null;\n\n          for (var e = 0; e < t.length; e++) {\n            this.settings.area.style.selection.roundToNearestTime ? t[e] = this.displayUnit.roundTimeRound(t[e], this.timeStepSettings) : t[e] = this.displayUnit.roundTimeDown(t[e], this.timeStepSettings);\n          }\n\n          return t;\n        }, i.prototype.formatTimeRange = function (e, i, n, r) {\n          n = void 0 !== n && n, r = void 0 !== r && r;\n          var s = this.displayUnit,\n              a = this.settings.localization.infoDates,\n              o = a.minorTimeFormats[s.unit],\n              l = a.majorTimeFormats[s.unit],\n              h = a.fullTimeFormats[s.unit],\n              u = t.moment.utc(e).locale(this.momentLocale),\n              c = t.moment.utc(i).locale(this.momentLocale),\n              d = h,\n              p = !1;\n          if (r) d = h, p = !1;else if (n) d = o, p = !1;else {\n            var f = s.getBigger() || s;\n            \"w\" === f.unit && (f = f.getBigger()), \"y\" !== s.unit && f.roundTimeDown(e, this.timeStepSettings) === f.roundTimeDown(i, this.timeStepSettings) ? (d = o, p = !0) : (d = h, p = !1);\n          }\n          var g = [u.format(d), c.format(d)];\n          return p && g.push(u.format(l)), g;\n        }, i.prototype.headerItem = function (e, i) {\n          var n = this.displayUnit,\n              r = null;\n          if (!n) return r;\n          var s,\n              a = this.settings.localization,\n              o = a.infoDates,\n              l = Math.max(1, Math.ceil(n.numberOfUnits(e, i))),\n              h = Math.floor(l * n.count),\n              u = h % 10 === 1 && h % 100 !== 11 ? a.timeUnitsNames[n.unit] : a.timeUnitsNamesPlural[n.unit],\n              c = this.momentLocale;\n\n          if (1 === l) {\n            var d = t.moment(e).locale(c).utc(),\n                p = d.format(o.fullTimeFormats[n.unit]);\n            s = \"\" + p;\n          } else {\n            var f = this.formatTimeRange(e, i);\n            s = 3 === f.length ? f[0] + \" - \" + f[1] + \", \" + f[2] : f[0] + \" - \" + f[1];\n          }\n\n          return r = {\n            date: s,\n            unitCount: h,\n            unitName: u\n          };\n        }, i;\n      }(l.Scene);\n\n      b._momentLocaleCounter = 0, t.Scene = b;\n\n      var x = function () {\n        function e(t, e, i, n, r, s, a) {\n          void 0 === i && (i = []), void 0 === n && (n = null), void 0 === r && (r = null), void 0 === s && (s = !0), void 0 === a && (a = 2), this.scene = null, this.step = null, this.uniform = !1, this.currentFrom = 0, this.currentTo = 0, this.fromBar = null, this.toBar = null, this.fromIndex = 0, this.toIndex = 0, this.times = [], this.xes = [], this.oldMul = 0, this.oldAdd = 0, this.values = [], this.counts = [], this.arrays = [], this.extraArrays = [], this.bufExpandSize = 100, this.extraSteps = 2, this.uniformTolerance = 0, this.approxExtraTime = 0, this.extraSteps = a, this.uniform = s, this.step = e, this.scene = t, n = n || this.scene.timeStart, r = r || this.scene.timeEnd, this.extraArrays = i.slice(0), this.arrays = i.slice(0), this.arrays.push(\"xes\"), this.arrays.push(\"times\"), this.uniformTolerance = Math.min(1, this.step.count - 2), this.approxExtraTime = this.extraSteps * e.approxTime(), this.init(n - this.approxExtraTime, r + this.approxExtraTime);\n        }\n\n        return e.prototype.getArray = function (t) {\n          switch (t) {\n            case \"xes\":\n              return this.xes;\n\n            case \"times\":\n              return this.times;\n\n            case \"values\":\n              return this.values;\n\n            case \"counts\":\n              return this.counts;\n\n            default:\n              return d.Helpers.error(\"TimeSlicer: Invalid get array: '\" + t + \"'\"), null;\n          }\n        }, e.prototype.setArray = function (t, e) {\n          switch (t) {\n            case \"xes\":\n              return void (this.xes = e);\n\n            case \"times\":\n              return void (this.times = e);\n\n            case \"values\":\n              return void (this.values = e);\n\n            case \"counts\":\n              return void (this.counts = e);\n\n            default:\n              return void d.Helpers.error(\"TimeSlicer: Invalid set array: '\" + t + \"'\");\n          }\n        }, e.prototype._getOrigin = function (t) {\n          var e = this.scene.timeStepSettings;\n          if (1 === this.step.count || this.uniform) return this.step.roundTimeDown(t, e);\n          var i = this.step.getBigger().roundTimeDown(t, e),\n              n = this.step.numberOfUnits(i, t);\n          return this.step.add(i, n);\n        }, e.prototype._add = function (t) {\n          if (this.uniform || 1 === this.step.count || \"d\" !== this.step.unit) return t.add(this.step.count, this.step.unit);\n          var e = t.daysInMonth(),\n              i = t.date();\n          return i + 2 * this.step.count > e + 1 + this.uniformTolerance ? t.add(e - i + 1, \"d\") : t.add(this.step.count, this.step.unit);\n        }, e.prototype._sub = function (t) {\n          if (this.uniform || 1 === this.step.count || \"d\" !== this.step.unit) return t.subtract(this.step.count, this.step.unit);\n          var e = t.date();\n\n          if (e <= this.step.count) {\n            t.subtract(1, \"M\");\n            var i = t.daysInMonth() - 1,\n                n = i + 1 - this.step.count + this.uniformTolerance;\n            return t.date(1 + n - d.Helpers.trunc(n % this.step.count));\n          }\n\n          return t.subtract(this.step.count, this.step.unit);\n        }, e.prototype.init = function (e, i) {\n          for (var n = this, r = 0; r < this.arrays.length; r++) {\n            var s = this.arrays[r];\n            this.setArray(s, []);\n          }\n\n          if (e >= i) return this.fromIndex = 0, this.toIndex = 0, this.fromBar = null, void (this.toBar = null);\n          this.fromBar = t.moment(this._getOrigin(e)).utc(), this.fromIndex = 0;\n          var a = t.moment(this.fromBar).utc();\n\n          for (this.times.push(a.valueOf()); a.valueOf() < i;) {\n            this._add(a), this.times.push(a.valueOf());\n          }\n\n          this.toIndex = this.times.length, this.toBar = a, this.currentFrom = e, this.currentTo = i, this.xes = this.times.map(function (t) {\n            return n.scene.timeToX(t);\n          });\n\n          for (var o = 0; o < this.extraArrays.length; o++) {\n            var l = this.extraArrays[o],\n                h = [];\n            h.length = this.times.length, this.setArray(l, h);\n          }\n        }, e.prototype.makeMiniSlice = function (e) {\n          var i = this.scene.timeToXCoefs(),\n              n = i.tadd,\n              r = i.tmul,\n              s = t.moment(this._getOrigin(e)).utc(),\n              a = s.valueOf(),\n              o = n + a * r;\n\n          this._add(s);\n\n          var l = s.valueOf(),\n              h = n + l * r;\n          return {\n            t0: a,\n            x0: o,\n            t1: l,\n            x1: h\n          };\n        }, e.prototype.update = function (t, e) {\n          if (void 0 === t && (t = this.scene.timeStart), void 0 === e && (e = this.scene.timeEnd), null == e && (e = this.scene.timeEnd), null == t && (t = this.scene.timeStart), t -= this.approxExtraTime, e += this.approxExtraTime, t === this.currentFrom && e === this.currentTo) return this.updateXes(this.fromIndex, this.toIndex), {\n            offset: 0,\n            newBefore: this.fromIndex,\n            newAfter: this.toIndex\n          };\n          if (null === this.fromBar || t > this.toBar.valueOf() || e < this.fromBar.valueOf()) return this.init(t, e), {\n            offset: 0,\n            newBefore: this.toIndex,\n            newAfter: this.toIndex\n          };\n          var i = 0,\n              n = this.fromIndex,\n              r = this.toIndex,\n              s = this.scene.timeToXCoefs(),\n              a = s.tadd,\n              o = s.tmul,\n              l = this.fromBar.valueOf() - t;\n\n          if (l > 0) {\n            var h = d.Helpers.trunc(l / this.step.approxTime()) + 2;\n\n            if (this.fromIndex < h) {\n              var u = [];\n              u.length = h + this.bufExpandSize;\n\n              for (var c = 0; c < this.arrays.length; c++) {\n                var p = this.arrays[c];\n                this.setArray(p, u.concat(this.getArray(p)));\n              }\n\n              i += u.length, n += u.length, r += u.length, this.fromIndex += u.length, this.toIndex += u.length;\n            }\n\n            for (var f = this.fromBar.valueOf(); f > t;) {\n              this._sub(this.fromBar), this.fromIndex -= 1, f = this.fromBar.valueOf(), this.times[this.fromIndex] = f, this.xes[this.fromIndex] = a + f * o;\n            }\n          }\n\n          var g = e - this.toBar.valueOf();\n\n          if (g > 0) {\n            var h = d.Helpers.trunc(g / this.step.approxTime()) + 2;\n            if (this.times.length < this.toIndex + h) for (var v = this.toIndex + h + this.bufExpandSize, c = 0; c < this.arrays.length; c++) {\n              var p = this.arrays[c];\n              this.getArray(p).length = v;\n            }\n\n            for (var f = this.toBar.valueOf(); f < e;) {\n              this._add(this.toBar), f = this.toBar.valueOf(), this.times[this.toIndex] = f, this.xes[this.toIndex] = a + f * o, this.toIndex += 1;\n            }\n          }\n\n          for (this._add(this.fromBar); this.fromBar.valueOf() < t;) {\n            this.fromIndex += 1, this._add(this.fromBar);\n          }\n\n          for (this._sub(this.fromBar), this._sub(this.toBar); this.toBar.valueOf() >= e;) {\n            this.toIndex -= 1, this._sub(this.toBar);\n          }\n\n          this._add(this.toBar);\n\n          var m = this.toIndex - this.fromIndex + this.bufExpandSize;\n\n          if (this.fromIndex > m) {\n            for (var y = this.fromIndex - this.bufExpandSize, c = 0; c < this.arrays.length; c++) {\n              var p = this.arrays[c];\n              this.getArray(p).splice(0, y);\n            }\n\n            i -= y, n -= y, r -= y, this.fromIndex -= y, this.toIndex -= y;\n          }\n\n          if (this.toIndex < this.times.length - m) for (var c = 0; c < this.arrays.length; c++) {\n            var p = this.arrays[c];\n            this.getArray(p).length = this.toIndex + this.bufExpandSize;\n          }\n          return this.updateXes(n, r), this.currentFrom = t, this.currentTo = e, {\n            offset: i,\n            newBefore: n,\n            newAfter: r\n          };\n        }, e.prototype.updateXes = function (t, e) {\n          var i = this.scene.timeToXCoefs(),\n              n = i.tadd,\n              r = i.tmul;\n\n          if (this.oldAdd !== n || this.oldMul !== r) {\n            this.oldAdd = n, this.oldMul = r;\n\n            for (var s = t; s <= e - 1; s++) {\n              this.xes[s] = n + this.times[s] * r;\n            }\n          }\n        }, e;\n      }();\n\n      t.TimeSlicer = x;\n\n      var C = function () {\n        function t() {\n          this.enabled = !0, this.vgrid = !0, this.minUnitWidth = 1, this.maxUnitWidth = 200, this.showHolidays = !0, this.miniTimeRuler = !0, this.unitSizePolicy = \"auto\", this.timeZoneOffset = null, this.timeZone = \"UTC\", this.padding = 32, this.style = {\n            showMinorTimeBalloons: !1,\n            showMajorTimeBalloons: !0,\n            minorTimeBalloonStyle: {\n              fillColor: \"#FFF\"\n            },\n            majorTimeBalloonStyle: {\n              fillColor: null\n            },\n            minorTimeLabel: {\n              fillColor: \"#000000\",\n              font: \"12px Arial\"\n            },\n            majorTimeLabel: {\n              fillColor: \"#FFF\",\n              font: \"11px Arial\"\n            },\n            dateLighten: {\n              fillColor: \"rgba(255,255,255,0.2)\"\n            },\n            dateHolidays: {\n              fillColor: \"rgba(230,230,230,0.2)\"\n            },\n            minorTimeRuler: {\n              lineColor: \"rgba(0,0,0,0.2)\"\n            },\n            vgrid: {\n              lineColor: \"rgba(0,0,0,0.1)\"\n            }\n          };\n        }\n\n        return t;\n      }();\n\n      t.SettingsTimeAxis = C;\n\n      var w = function (e) {\n        function i(t) {\n          var i = e.call(this) || this;\n          return i.curSceneScale = 0, i.minorFormat = null, i.majorFormat = null, i.minorTimeUnit = null, i.majorTimeUnit = null, i.minorLabelHeight = null, i.majorLabelHeight = null, i.minorLabelWidths = null, i.minorLabelBallonWidths = null, i.majorLabelWidths = null, i.fullLabelWidths = null, i.multiYearWidth = 0, i.majorSlices = null, i.minorSlices = null, i.animationOrder = 610, i.paintOrder = 30, i.updateOrder = 1e3, i.multiples = {\n            ms: [1, 10, 100],\n            s: [1, 2, 5, 15, 30],\n            m: [1, 2, 5, 15, 30],\n            h: [1, 3, 6, 12, 24],\n            d: [1, 2, 5, 10],\n            w: [1, 5, 10, 20],\n            M: [1, 3, 6],\n            y: [1, 10, 100, 1e3]\n          }, i.chart = t, i.scene = i.chart.scene, i.tt = new o(t), i.options = i.scene.settings.timeAxis, i.panel = new d.ChartPanel(), i.panel.side = \"bottom\", i.panel.packingOrder = 100, i.panel.computeSize = function (t, e, n, r) {\n            return i.computeSize(t, e, n, r);\n          }, i;\n        }\n\n        return n(i, e), i.prototype.computeSize = function (e, i, n, s) {\n          if (!this.options.enabled) return this.scene.bottomAxisSize = 0, {\n            width: e,\n            height: 0\n          };\n          var a = t.moment(0xc694d6e77ef8).utc(),\n              o = this.scene.settings.localization.timeAxisDates,\n              l = this.options.style.minorTimeLabel;\n          this.minorLabelHeight = .8 * d.Graphics.getTextHeight(n, this.options.style.minorTimeLabel.font), this.minorLabelWidths = {}, this.minorLabelBallonWidths = {};\n          var h;\n\n          for (h = 0; h < r.knownUnits.length; h++) {\n            var u = r.knownUnits[h],\n                c = d.Graphics.getTextWidth(n, l, a.format(o.minorLabelTimeFormats[u]));\n            this.minorLabelWidths[u] = c, this.minorLabelBallonWidths[u] = c + this.minorLabelHeight;\n          }\n\n          for (l = this.options.style.majorTimeLabel, this.majorLabelHeight = .8 * d.Graphics.getTextHeight(n, this.options.style.majorTimeLabel.font), this.majorLabelWidths = {}, this.fullLabelWidths = {}, h = 0; h < r.knownUnits.length; h++) {\n            var u = r.knownUnits[h];\n            this.majorLabelWidths[u] = this.majorLabelHeight + d.Graphics.getTextWidth(n, l, a.format(o.majorLabelTimeFormats[u])), this.fullLabelWidths[u] = this.majorLabelHeight + d.Graphics.getTextWidth(n, l, a.format(o.majorLabelFullTimeFormats[u]));\n          }\n\n          this.multiYearWidth = d.Graphics.getTextWidth(n, l, \"8888 - 8888\") + this.majorLabelHeight;\n          var p = (this.options.padding + 23) / 23,\n              f = Math.round(Math.min((this.minorLabelHeight + this.majorLabelHeight) * p, i));\n          return this.scene.bottomAxisSize = f, {\n            width: e,\n            height: f\n          };\n        }, i.prototype.onSceneChange = function (t) {\n          var e = t.changes.settingsChanges;\n          e && e.timeAxis && (t.changes.bounds = !0);\n        }, i.prototype.getPanels = function () {\n          return [this.panel];\n        }, i.prototype.getMajorLabelWidth = function (t, e) {\n          return \"y\" === t.unit && t.count > 1 ? this.multiYearWidth : e ? this.majorLabelWidths[t.unit] : null !== this.fullLabelWidths ? this.fullLabelWidths[t.unit] || null : null;\n        }, i.prototype.computeLabels = function (t) {\n          var e,\n              i,\n              n = new o(this.chart),\n              s = this.scene.timeEnd - this.scene.timeStart,\n              a = n.toBiggerDisplayUnit(t);\n\n          if (a) {\n            var l = new r(\"s\", 1);\n\n            for (e = a.isSmaller(l) ? l : a, i = this.computeMinorUnit(e), a = n.toBiggerDisplayUnit(e); a && (a.approxTime() <= .5 * s || e.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(e, null != i)));) {\n              e = a, i = this.computeMinorUnit(e), a = n.toBiggerDisplayUnit(a);\n            }\n          }\n\n          if (!a) {\n            e = \"y\" === t.unit ? t : new r(\"y\", 1);\n\n            for (var h = 0; h < this.multiples.y.length; h++) {\n              var u = this.multiples.y[h];\n              if (e = new r(\"y\", u), i = this.computeMinorUnit(e), e.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(e, null != i))) break;\n            }\n          }\n\n          return {\n            minorUnit: i,\n            majorUnit: e\n          };\n        }, i.prototype.computeMinorUnit = function (t) {\n          var e = this.scene.displayUnit.clone(),\n              i = new r(r.toSmallerUnit[t.unit], 1);\n          i.unit && i.isBigger(e) && (e = i);\n          var n = e.approxTime(),\n              s = null;\n          if (null === this.minorLabelWidths) return null;\n\n          for (var a = 1.5 * this.scene.dxToDtime(this.minorLabelWidths[e.unit]), o = 0; o < this.multiples[e.unit].length; o++) {\n            var l = this.multiples[e.unit][o];\n\n            if (l < e.count && (l = e.count), e.count = l, n = e.approxTime(), a <= n) {\n              s = e;\n              break;\n            }\n          }\n\n          return s && s.isEqual(t) && (s = null), s;\n        }, i.prototype.doAnimations = function (t) {\n          if (this.scene.displayUnit && this.scene.timeStart < this.scene.timeEnd) {\n            var e = this.scene.getScale();\n\n            if (!(Math.abs(1 - this.curSceneScale / e) < .001)) {\n              this.curSceneScale = e;\n              var i = this.computeLabels(this.scene.displayUnit),\n                  n = i.minorUnit,\n                  r = i.majorUnit;\n              n ? (this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[n.unit], this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[r.unit]) : (this.minorFormat = null, this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[r.unit]), this.minorTimeUnit = n, this.majorTimeUnit = r, null !== this.majorSlices && r.approxTime() === this.majorSlices.step.approxTime() || (this.majorSlices = new x(this.scene, r)), !n || null !== this.minorSlices && n.approxTime() === this.minorSlices.step.approxTime() ? null === n && (this.minorSlices = null) : this.minorSlices = new x(this.scene, n, [], null, null, !1);\n            }\n\n            this.majorSlices.update(), this.minorSlices && this.minorSlices.update(), this.minorTimeUnit ? (this.scene.minorTimeFormat = this.minorFormat, this.scene.minorTimeUnit = this.minorTimeUnit) : this.scene.displayUnit && (this.scene.minorTimeUnit = this.scene.displayUnit, this.scene.minorTimeFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[this.scene.displayUnit.unit]), this.scene.majorTimeFormat = this.majorFormat, this.scene.majorTimeUnit = this.majorTimeUnit;\n          }\n        }, i.prototype.paintScene = function (e) {\n          if (this.scene.displayUnit && this.options.enabled && this.scene.timeStart < this.scene.timeEnd) {\n            var i = this.scene.settings.timeAxis.style,\n                n = e.context,\n                r = e.labelRenderer,\n                s = this.scene.x0,\n                a = s + this.scene.width,\n                o = this.panel.top + 1,\n                l = this.panel.bottom,\n                h = l - o,\n                u = this.scene.y0,\n                c = this.scene.height,\n                p = l - 1.8 * this.majorLabelHeight;\n            d.Graphics.pushClip(e, s, u, this.scene.width, h + c);\n            var f = this.majorSlices.xes,\n                g = this.majorSlices.times,\n                v = this.majorSlices.fromIndex,\n                m = this.majorSlices.toIndex,\n                y = i.dateLighten;\n\n            if (y && y.fillColor) {\n              var S = this.majorSlices.step.numberOfUnits(0, g[v]);\n              n.beginPath();\n\n              for (var b = v + d.Helpers.trunc(S) % 2; b <= m - 2; b += 2) {\n                var x = d.Helpers.trunc(Math.max(f[b], s)) + 1,\n                    C = d.Helpers.trunc(Math.min(f[b + 1], a));\n                n.rect(x, o - 1, C - x, h);\n              }\n\n              d.Graphics.fill(n, y);\n            }\n\n            if (this.options.showHolidays && this.minorSlices && (\"w\" === this.minorSlices.step.unit || \"d\" === this.minorSlices.step.unit || \"h\" === this.minorSlices.step.unit)) {\n              var w = this.scene.timeToXCoefs(),\n                  L = w.tadd,\n                  T = w.tmul,\n                  k = 864e5,\n                  M = this.scene.timeStart;\n              M = Math.round(M - M % k);\n\n              for (var A = t.moment(M).utc().isoWeekday(), I = this.scene.settings.localization.holidayWeekdays, P = i.dateHolidays, D = d.Graphics.beginStrokeAndFill(n, P), x = M * T + L; x <= a;) {\n                var C = x + T * k;\n                I.indexOf(A) > -1 && D.rect(x, u, C - x, Math.min(5, h) + c), A = A % 7 + 1, x = C;\n              }\n\n              d.Graphics.endStrokeAndFill(n, D, P);\n            }\n\n            if (this.options.vgrid) {\n              for (var N = d.Graphics.beginStrokeAndFill(n, this.options.style.vgrid), b = v + 1; b <= m - 2; b++) {\n                var F = d.Helpers.trunc(f[b]) + .5;\n                if (F >= a) break;\n                N.moveTo(F, u), N.lineTo(F, l);\n              }\n\n              d.Graphics.endStrokeAndFill(n, N, this.options.style.vgrid);\n            }\n\n            var O = \"y\" === this.majorSlices.step.unit && this.majorSlices.step.count > 1,\n                E = this.getMajorLabelWidth(this.majorSlices.step, null != this.minorFormat),\n                R = this.scene.momentLocale;\n\n            if (!this.minorSlices || this.majorSlices.step.unit !== this.minorSlices.step.unit) {\n              if (i.showMajorTimeBalloons) {\n                n.beginPath();\n\n                for (var b = v; b <= m - 2; b++) {\n                  var H = f[b],\n                      z = f[b + 1];\n\n                  if (!(H >= a || z <= s)) {\n                    var B = (H + z) / 2;\n                    H < s && (H = s, B = Math.min((H + z) / 2, z - E)), z > a && (z = a, B = Math.max((H + z) / 2, H + E)), d.Graphics.strokeBalloon2(n, B, p + 1, E, this.majorLabelHeight);\n                  }\n                }\n\n                d.Graphics.paint(n, i.majorTimeBalloonStyle);\n              }\n\n              for (var b = v; b <= m - 2; b++) {\n                var H = f[b],\n                    z = f[b + 1];\n\n                if (!(H >= a || z <= s)) {\n                  var M = g[b],\n                      U = void 0;\n\n                  if (O) {\n                    var G = g[b + 1] - 1;\n                    U = t.moment.utc(M).locale(R).format(this.majorFormat) + \" - \" + t.moment(G).locale(R).utc().format(this.majorFormat);\n                  } else U = t.moment.utc(M).locale(R).format(this.majorFormat);\n\n                  var B = (H + z) / 2;\n                  H < s && (H = s, B = Math.min((H + z) / 2, z - E)), z > a && (z = a, B = Math.max((H + z) / 2, H + E));\n                  var V = new d.Label({\n                    text: U,\n                    textStyle: i.majorTimeLabel\n                  }, !0);\n                  r.paint(n, B, p, 1, V);\n                }\n              }\n            }\n\n            var j = this.scene.settings.timeAxis,\n                W = j.style.minorTimeRuler;\n\n            if (this.minorSlices) {\n              g = this.minorSlices.times, f = this.minorSlices.xes, v = this.minorSlices.fromIndex, m = this.minorSlices.toIndex, E = this.minorLabelWidths[this.minorSlices.step.unit];\n              var Z = o + d.Helpers.trunc(.4 * this.minorLabelHeight),\n                  Y = o - 1,\n                  q = Z + d.Helpers.trunc(1.6 * this.minorLabelHeight);\n\n              if (i.showMinorTimeBalloons) {\n                n.beginPath();\n\n                for (var b = v; b <= m - 1; b++) {\n                  var F = f[b];\n                  d.Graphics.strokeBalloon(n, F, o - 5, E, this.minorLabelHeight);\n                }\n\n                d.Graphics.paint(n, i.minorTimeBalloonStyle);\n              } else {\n                var _ = this.majorSlices.fromIndex,\n                    X = this.majorSlices.xes;\n                n.beginPath();\n\n                for (var Q = _, b = v; b <= m - 1; b++) {\n                  for (var F = f[b]; F > X[Q];) {\n                    Q += 1;\n                  }\n\n                  if (X[Q] !== F) {\n                    if (F >= a) break;\n                    F = d.Helpers.trunc(F) - .5, n.moveTo(F, Y), n.lineTo(F, q);\n                  }\n                }\n\n                d.Graphics.stroke(n, W);\n              }\n\n              for (var J = i.showMinorTimeBalloons ? \"center\" : \"left\", K = i.showMinorTimeBalloons ? 0 : 3, b = v; b <= m - 1; b++) {\n                var F = f[b],\n                    M = g[b],\n                    U = t.moment(M).locale(R).utc().format(this.minorFormat),\n                    V = new d.Label({\n                  text: U,\n                  aspectRatio: 1e9,\n                  align: J,\n                  textStyle: i.minorTimeLabel\n                });\n                r.measure(n, V);\n                var $ = F + K + V.hwidth;\n                r.paint(n, $, Z + V.hheight, 1, V);\n              }\n            }\n\n            var tt = this.chart.dataWarehouse.getDisplayUnitsSlicer();\n\n            if (j.miniTimeRuler && W && tt && tt.xes[tt.fromIndex + 1] - tt.xes[tt.fromIndex] > 4) {\n              var et = o - 1,\n                  it = o + 3;\n              f = tt.xes;\n              var nt = this.majorSlices.fromIndex,\n                  rt = this.minorSlices ? this.minorSlices.fromIndex : nt,\n                  st = this.majorSlices.xes,\n                  at = this.minorSlices ? this.minorSlices.xes : st;\n              n.beginPath();\n\n              for (var ot = nt, lt = rt, ht = 0, b = tt.fromIndex; b <= tt.toIndex - 2; b++) {\n                for (var F = f[b]; F > st[ot];) {\n                  ot += 1;\n                }\n\n                if (st[ot] !== F) {\n                  for (; F > at[lt];) {\n                    lt += 1;\n                  }\n\n                  if (at[lt] !== F) {\n                    if (F >= a) break;\n                    F = d.Helpers.trunc(F) - .5, n.moveTo(F, et), n.lineTo(F, it), ht++;\n                  }\n                }\n              }\n\n              if (ht && d.Graphics.stroke(n, W), this.scene.settings.advanced.themeCSSClass.indexOf(\"gradient\") !== -1) {\n                var ut = d.Colors.colorTone(W.lineColor, 2, 2);\n                ht = 0, n.beginPath(), ot = nt, lt = rt;\n\n                for (var b = tt.fromIndex; b <= tt.toIndex - 2; b++) {\n                  for (var F = f[b]; F > st[ot];) {\n                    ot += 1;\n                  }\n\n                  if (st[ot] !== F) {\n                    for (; F > at[lt];) {\n                      lt += 1;\n                    }\n\n                    if (at[lt] !== F) {\n                      if (F >= a) break;\n                      F = d.Helpers.trunc(F) + .5, n.moveTo(F, et), n.lineTo(F, it), ht++;\n                    }\n                  }\n                }\n\n                ht && d.Graphics.stroke(n, {\n                  lineColor: ut.color\n                });\n              }\n            }\n\n            d.Graphics.popClip(e);\n          }\n        }, i;\n      }(d.ChartElement);\n\n      t.TimeAxis = w;\n\n      var L = function () {\n        function t() {\n          this.enabled = !0, this.label = {\n            padding: 3,\n            margin: 3,\n            aspectRatio: 3,\n            align: \"center\",\n            textStyle: {\n              fillColor: \"white\",\n              font: \"12px Arial\"\n            },\n            backgroundStyle: {\n              lineColor: \"#0099cc\",\n              fillColor: \"#0099cc\"\n            }\n          }, this.align = \"left\", this.side = \"top\", this.style = {\n            lineColor: \"#0099cc\"\n          }, this.time = null, this.overrideLimits = !1, this.showTime = !1;\n        }\n\n        return t;\n      }();\n\n      t.SettingsMarker = L;\n\n      var T = function () {\n        function t(t, e, i) {\n          if (this.labelCacheUnit = null, this.labelCacheTime = null, this.initialText = null, this.isMilestone = !0, this.settings = e, this.label = new d.Label(e.label), i) {\n            var n = d.Helpers.clone(i);\n            d.Helpers.extendStyleTo(this.label.style.textStyle, n), n.fillColor || (n.fillColor = e.style.lineColor), this.label.style.textStyle = n;\n          }\n\n          null != e.time ? this.time = t.timestampToInternal(e.time, !0) : this.time = null, this.initialText = this.label.text || null;\n        }\n\n        return t;\n      }();\n\n      t.Marker = T;\n\n      var k = function (e) {\n        function i(t) {\n          var i = e.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 40, i.updateOrder = 800, i.scene = null, i._initialized = !1, i.chart = t, i.scene = i.chart.scene, i;\n        }\n\n        return n(i, e), i.prototype.onSceneChange = function (t) {\n          if (this.chart.assetsLoaded) {\n            var e = t.changes,\n                i = e.settingsChanges,\n                n = i && i.milestones;\n            (!this._initialized || n || e.assets) && (this.createMarkers(), this._initialized = !0), (e.time || n) && this.scene.markers.sort(function (t, e) {\n              return t.time - e.time;\n            });\n          }\n        }, i.prototype.paintScene = function (t) {\n          var e = this.scene,\n              i = e.markers,\n              n = t.labelRenderer,\n              r = t.context;\n\n          if (0 !== i.length && e.displayUnit) {\n            var s = Math.round(e.y0);\n            r.textBaseline = \"middle\", d.Graphics.pushClip(t, e.x0, Math.round(e.y0), e.width, e.height + e.bottomAxisSize);\n\n            for (var a = this.getRenderingParts(t, i), o = a.lines, l = 0; l < o.length; l++) {\n              var h = o[l],\n                  u = d.Graphics.beginStrokeAndFill(r, h.style),\n                  c = \"bottom\" === h.side ? this.getTopPos(h.x, 0) : s + e.height;\n              c = Math.round(c), u.moveTo(h.x, c), u.lineTo(h.x, h.y), d.Graphics.endStrokeAndFill(r, u, h.style);\n            }\n\n            for (var p = a.labels, f = 0; f < p.length; f++) {\n              var g = p[f];\n              n.paint(r, g.x, g.y, 1, g.label);\n            }\n\n            d.Graphics.popClip(t);\n          }\n        }, i.prototype.getRenderingParts = function (e, i) {\n          for (var n = e.context, r = this.scene, s = e.labelRenderer, a = r.displayUnit.unit, o = r.settings.localization.markerDates.timeFormats[a], l = r.x0, h = l + r.width, u = Math.round(r.y0), c = Math.round(u + r.height), p = [], f = [], g = [], v = [], m = [], y = [], S = [], b = [], x = this.scene.momentLocale, C = 0; C < i.length; C++) {\n            var w = i[C],\n                L = r.timeToX(w.time);\n            L = Math.floor(L) + .5, w.labelCacheUnit === a && w.labelCacheTime === w.time || (null !== w.initialText ? (w.label.text = w.initialText, w.settings.showTime && (w.label.text += \" \" + t.moment(w.time).locale(x).utc().format(o).replace(/ /g, \" \"))) : w.settings.showTime && (w.label.text = t.moment(w.time).locale(x).utc().format(o).replace(/ /g, \" \")), s.measure(n, w.label), w.labelCacheUnit = a, w.labelCacheTime = w.time);\n            var T = w.label.style.margin || 0,\n                k = w.label.hwidth + T,\n                M = w.label.hheight + T,\n                A = 2 * k,\n                I = 2 * M;\n\n            if (L + k >= l - 1 && L - k <= h + 1) {\n              var P = w.settings.align,\n                  D = \"center\" === P ? k : A;\n              L + D >= h ? (P = \"left\", L -= 2) : L - D <= l && (P = \"right\", L += 2);\n              var N = L - k,\n                  F = L + k,\n                  O = L;\n              \"left\" === P ? (O = L - k + T, F = L, N = L - A) : \"right\" === P && (O = L + k - T, F = L + A, N = L);\n              var E = [],\n                  R = -1,\n                  H = N < l ? Math.max(l, N) : N > h ? Math.min(h, N) : N,\n                  z = this.getTopPos(H, D),\n                  B = \"top\" === w.settings.side ? z : Math.round(r.height + .5 * r.bottomAxisSize);\n              if (0 !== p.length) for (;;) {\n                var U = R !== -1 ? g[R] + m[R] : B,\n                    G = U + I;\n                R = -1;\n\n                for (var V = 0; V < p.length; V++) {\n                  if (E.indexOf(V) === -1) {\n                    var j = f[V],\n                        W = p[V],\n                        Z = g[V],\n                        Y = v[V],\n                        q = N >= W && N <= j || F >= W && F <= j || N <= W && F >= j,\n                        _ = U >= Z && U <= Y || G >= Z && G <= Y || U <= Z && G >= Y;\n\n                    if (q && _) {\n                      E.push(V), B = g[V] + m[V], R = V;\n                      break;\n                    }\n                  }\n                }\n\n                if (R === -1) break;\n              }\n              var X = void 0;\n              \"top\" === w.settings.side ? X = B + M : (c = u + r.height - M + T, X = Math.min(B, r.height + .5 * r.bottomAxisSize)), X = d.Helpers.trunc(X) + .5, m.push(I), y.push(A), g.push(B), v.push(B + I), p.push(N), f.push(N + A);\n              var Q = {\n                value: c,\n                changes: !1\n              };\n              null != w.animator && (Q = w.animator.updateAndGet(X, e.timeStamp)), S.push({\n                x: L,\n                y: Q.value + M - T,\n                style: w.settings.style,\n                side: w.settings.side\n              }), b.push({\n                x: O,\n                y: Q.value,\n                label: w.label\n              }), Q.changes && (e.animating = !0);\n            }\n          }\n\n          return {\n            lines: S,\n            labels: b\n          };\n        }, i.prototype.getTopPos = function (t, e) {\n          var i = this.scene.x0 + this.scene.width,\n              n = this.chart.shell.getChartInnerArea();\n          return n.findTopPosition(t, Math.min(t + e, i));\n        }, i.prototype.createMarkers = function () {\n          var t = this.scene,\n              e = t.markers.filter(function (t) {\n            return !t.isMilestone;\n          }),\n              i = t.settings,\n              n = i.milestones;\n\n          for (var r in n) {\n            var s = n[r];\n\n            if (s.enabled) {\n              var a = new T(t, s, i.area.style.markerText);\n              a.animator = new d.Animator(0, 0, 200), e.push(a);\n            }\n          }\n\n          t.markers = e;\n        }, i;\n      }(d.ChartElement);\n\n      t.Markers = k;\n\n      var M = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.showTime = !0, e.align = \"left\", e.side = \"bottom\", e.label = {\n            margin: 4,\n            padding: 3,\n            textStyle: {\n              font: \"12px Arial\",\n              fillColor: \"red\"\n            }\n          }, e.style = {\n            lineColor: \"red\"\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(L);\n\n      t.SettingsCurrentTime = M;\n\n      var A = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 100, i.paintOrder = 35, i.updateOrder = 900, i.marker = null, i.timeTimerUnit = null, i.timeTimer = null, i.timeTimerTarget = -(1 / 0), i.timeTickerEnabled = !1, i.timeTimerCheckAlways = !1, i._lastAnchor = null, i.chart = e, i.settings = i.chart.settings, i.scene = i.chart.scene, i.events = i.chart.events, i.createMarker(), i.updateTimers(), i;\n        }\n\n        return n(e, t), e.prototype.updateTimers = function () {\n          var t = this,\n              e = this.settings.advanced;\n          this.timeTickerEnabled = e.timeUpdateInterval && (this.settings.currentTime.enabled || \"now\" === this.scene.anchor), this.timeTickerEnabled ? this.updateCurTime() : this.timeTimer && (clearTimeout(this.timeTimer), this.timeTimer = null), e.dataUpdateInterval ? this.dataTimer = setInterval(function () {\n            return t.dataTick();\n          }, e.dataUpdateInterval) : this.dataTimer && (clearInterval(this.dataTimer), this.dataTimer = null);\n        }, e.prototype.createMarker = function () {\n          var t = this.settings.currentTime,\n              e = this.marker,\n              i = this.scene.markers;\n          e && (i.splice(i.indexOf(e), 1), this.marker = null), t.enabled && (e = this.marker = new T(this.scene, t, null), e.isMilestone = !1, i.push(e));\n        }, e.prototype.onSceneChange = function (t) {\n          var e = !1,\n              i = t.changes.settingsChanges;\n          i && ((i.advanced || i.currentTime) && (this.updateTimers(), e = !0), i.currentTime && this.createMarker()), this._lastAnchor !== this.scene.anchor && (e || this.updateTimers(), this._lastAnchor = this.scene.anchor), this.timeTickerEnabled && (t.changes.timeMarker || t.changes.time && (this.timeTimerCheckAlways || !this.timeTimer || this.scene.getScale() < this.timeTimerUnit)) && (this.updateCurTime(), this.updateVisiblePeriod());\n        }, e.prototype.timerTick = function () {\n          this.timeTimer = null, this.chart.removed || (this.updateCurTime(), this.updateVisiblePeriod());\n        }, e.prototype.dataTick = function () {\n          var t = this;\n\n          if (this.dataTimer = null, !this.chart.removed && this.scene.displayUnit) {\n            var e = this.scene.getCurTime(),\n                i = function i() {\n              t.updateVisiblePeriod();\n            };\n\n            for (var n in this.chart.data) {\n              var r = this.chart.data[n];\n              r.updateData(this.scene.displayUnit, e, i);\n            }\n          }\n        }, e.prototype.doAnimations = function (t) {\n          t.changes.data && this.updateVisiblePeriod();\n        }, e.prototype.updateCurTime = function (t) {\n          var e = this,\n              i = this.scene;\n          this.timeTimerUnit = i.getScale();\n          var n = i.getCurTime();\n          this.marker && (this.marker.time = n);\n          var r = i.timeToX(n);\n\n          if (!isNaN(r)) {\n            var s = r + 200 > i.x0 && r - 200 < i.x0 + i.width,\n                a = this.settings.advanced.timeUpdateInterval,\n                o = 0;\n            if (s) this.timeTimerCheckAlways = !1, void 0 === t && this.events.notifySceneChanges({\n              requestPaint: !0\n            }), i.displayUnit.approxTime() >= 36e5 && (o = Math.floor(i.xToTime(r + 1) - n) / 2, a = Math.max(a, o), o /= 4);else {\n              if (r > 0) return;\n              a = Math.max(a, i.dxToDtime(-r - 200) / 2), this.timeTimerCheckAlways = !0;\n            }\n            var l = +new Date();\n\n            if (this.timeTimer) {\n              var h = this.timeTimerTarget - l;\n              if (h < a + o) return;\n              window.clearTimeout(this.timeTimer);\n            }\n\n            s && i.dTimeToDx(a) > 1 ? this.events.notifySceneChanges({\n              timeMarker: !0\n            }) : (this.timeTimerTarget = l + a, this.timeTimer = setTimeout(function () {\n              return e.timerTick();\n            }, a));\n          }\n        }, e.prototype.updateVisiblePeriod = function () {\n          var t = this.scene,\n              e = t.displayUnit;\n\n          if (e && this.settings.navigation.followAnchor) {\n            var i = null;\n\n            if (\"now\" === t.anchor) {\n              var n = t.getCurTime();\n              i = n;\n            } else if (\"newestData\" === t.anchor) {\n              var r = this.chart.getDataLimits().to;\n              i = r;\n            }\n\n            if (null !== i) {\n              var s = this.chart.scrolling,\n                  a = s.getTo();\n\n              if (a < i) {\n                var o = s.getFrom(),\n                    l = e.roundTimeUp(i, t.timeStepSettings) - a;\n                this.chart.scrolling.setTimeRangeSnap(o + l, a + l, a + l, t.displayUnit, !0, \"timer\", !0, !1);\n              }\n            }\n          }\n        }, e;\n      }(d.ChartElement);\n\n      t.TimeUpdater = A;\n\n      var I = function (t) {\n        function e(i) {\n          var n = t.call(this, d.SettingsMapping.TimeChartSettings) || this;\n          return n._minUnit = null, n._displayUnitsParsed = [], n._displayPeriodsParsed = [], n._computedDataMap = {}, n.theme = e.FlatTheme, n.navigation = {\n            initialDisplayAnchor: \"newestData\",\n            initialDisplayPeriod: \"max\",\n            initialDisplayUnit: \"auto\",\n            followAnchor: !1\n          }, n.area = new j(), n.chartTypes = {\n            columns: {\n              type: \"columns\"\n            },\n            line: {\n              type: \"line\"\n            },\n            candlestick: {\n              type: \"candlestick\"\n            }\n          }, n.currentTime = new M(), n.milestones = [], n.timeAxis = new C(), n.data = [], n.toolbar = new a(), n.localization = new B(), n.interaction = new G(), n.advanced = new z(), n.events = new H(), n.advanced.assets.push({\n            url: \"assets://moment.js\",\n            required: function required() {\n              return !window.moment;\n            }\n          }), n.advanced.assets.push({\n            url: \"assets://moment-tz.js\",\n            required: function required() {\n              return !window.moment || !window.moment.tz;\n            }\n          }), n.apply(i), n._initializing = !1, n;\n        }\n\n        return n(e, t), e.prototype.timeZoneCompatibility = function () {\n          var t = this.timeAxis;\n          null == t.timeZone && (t.timeZone = \"UTC\", d.Helpers.warn(\"`null` is not a valid value for `timeAxis.timeZone`, using `UTC`\")), \"local\" === t.timeZoneOffset && (t.timeZoneOffset = -new Date().getTimezoneOffset());\n\n          for (var e = this.data, i = 0; i < e.length; i++) {\n            var n = e[i];\n            null != n.timeZoneOffset && (d.Helpers.error(\"Setting `data.timeZoneOffset` has been deprecated. Please use `timeZone` in the data response instead.\"), \"local\" === n.timeZoneOffset && (n.timeZoneOffset = -new Date().getTimezoneOffset()));\n          }\n        }, e.prototype.apply = function (e) {\n          this.applyCompatibility(e, [{\n            from: \"toolbars\",\n            to: \"toolbar\"\n          }, {\n            from: \"toolbar.periodSelection\",\n            to: \"toolbar.displayPeriod\"\n          }, {\n            from: \"toolbar.zoomOutButton\",\n            to: \"toolbar.zoomOut\"\n          }, {\n            from: \"toolbar.backButton\",\n            to: \"toolbar.back\"\n          }, {\n            from: \"interaction.scrolling.noData\",\n            to: \"interaction.scrolling.limitMode\"\n          }, {\n            from: \"interaction.scrolling.noDataSnapBackProportion\",\n            to: \"interaction.scrolling.overscrollProportion\",\n            transform: function transform(t) {\n              return 1 - t;\n            }\n          }, {\n            from: \"area.initialDisplayPeriod\",\n            to: \"navigation.initialDisplayPeriod\"\n          }, {\n            from: \"area.initialDisplayAnchor\",\n            to: \"navigation.initialDisplayAnchor\"\n          }, {\n            from: \"area.initialDisplayUnit\",\n            to: \"navigation.initialDisplayUnit\"\n          }, {\n            from: \"area.followAnchor\",\n            to: \"navigation.followAnchor\"\n          }, {\n            from: \"timeAxis.timeZoneOffset\",\n            alternative: \"timeAxis.timeZone\"\n          }, {\n            from: \"timeAxis.style.vgrid\",\n            to: \"timeAxis.style.vgrid.lineColor\",\n            filter: function filter(t) {\n              return \"string\" == typeof t;\n            }\n          }, {\n            from: \"currentTime.overrideCurTime\",\n            to: \"currentTime.time\"\n          }, {\n            from: \"advanced.maxUnitsToDisplay\",\n            alternative: \"timeAxis.minUnitWidth\"\n          }]);\n          var i = t.prototype.apply.call(this, e, P);\n          return this.timeZoneCompatibility(), this._calcMinUnit(), this._displayUnitsParsed = this._parseUnits(this.area.displayUnits), this._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods), i;\n        }, e.prototype._parseUnits = function (t) {\n          for (var e = [], i = 0; i < t.length; i++) {\n            var n = t[i],\n                s = r.parse(n.unit, n.name);\n            this._minUnit.isSmallerOrEqual(s) && e.push(s);\n          }\n\n          return e.sort(function (t, e) {\n            return t.approxTime() - e.approxTime();\n          });\n        }, e.prototype._parsePeriods = function (t) {\n          for (var e = [], i = 0; i < t.length; i++) {\n            var n = r.parse(t[i].unit);\n            n && this._minUnit.isSmallerOrEqual(n) && e.push(n);\n          }\n\n          return e.sort(function (t, e) {\n            return t.approxTime() - e.approxTime();\n          });\n        }, e.prototype._calcMinUnit = function () {\n          for (var t = new r(\"y\", 1e6), e = t, i = 0; i < this.area.displayUnits.length; i++) {\n            var n = this.area.displayUnits[i],\n                s = r.parse(n.unit, n.name);\n            s.isSmaller(t) && (t = s);\n          }\n\n          for (var i = 0; i < this._computedSeries.length; i++) {\n            var a = this._computedSeries[i],\n                o = this._computedDataMap[a.data.source];\n            if (!o) throw new Error(\"Data source `\" + a.data.source + \"` for series not found!\");\n\n            for (var l = 0; l < o.units.length; l++) {\n              var h = o.units[l],\n                  u = r.parse(h);\n              u.isSmaller(e) && (e = u);\n            }\n          }\n\n          e.isBigger(t) && (t = e), this._minUnit = t;\n        }, e;\n      }(l.Settings);\n\n      I.StaticChart = {\n        interaction: {\n          zooming: {\n            enabled: !1,\n            click: !1\n          },\n          selection: {\n            enabled: !1\n          },\n          scrolling: {\n            enabled: !1\n          },\n          resizing: {\n            enabled: !1\n          }\n        },\n        toolbar: {\n          items: [\"export\"]\n        }\n      }, I.DarkTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat DVSL-dark\",\n          style: {\n            loadingArcStyle: {\n              lineColor: \"#EEE\"\n            },\n            messageTextStyle: {\n              fillColor: \"#EEE\"\n            }\n          }\n        },\n        area: {\n          style: {\n            fillColor: \"rgba(28,26,28,1)\",\n            noData: {\n              fillColor: \"#DDD\",\n              image: \"builtin://linearchart-no-data-light\"\n            },\n            selection: {\n              lineColor: \"#838283\"\n            },\n            selectionLabel: {\n              fillColor: \"#BFBBB9\"\n            },\n            zoomHighlight: {\n              fillColor: \"rgba(142,142,142,0.15)\"\n            },\n            zoomHighlightInactive: {\n              fillColor: \"rgba(142,142,142,0.15)\"\n            }\n          }\n        },\n        title: {\n          margin: 15,\n          style: {\n            fillColor: \"#A8A7A8\"\n          }\n        },\n        chartTypes: {\n          columns: {\n            style: {\n              gradient: 1,\n              depth: 0\n            }\n          }\n        },\n        valueAxisDefault: {\n          style: {\n            valueLabel: {\n              textStyle: {\n                fillColor: \"#A8A7A8\"\n              }\n            },\n            title: {\n              textStyle: {\n                fillColor: \"#A8A7A8\"\n              }\n            }\n          }\n        },\n        timeAxis: {\n          style: {\n            majorTimeLabel: {\n              fillColor: \"#A8A7A8\",\n              shadowColor: null\n            },\n            minorTimeLabel: {\n              fillColor: \"#A8A7A8\",\n              shadowColor: null\n            },\n            minorTimeRuler: {\n              lineColor: \"#838283\"\n            },\n            dateLighten: {\n              fillColor: \"rgba(142,142,142,0.15)\"\n            },\n            dateHolidays: {\n              fillColor: \"rgba(139,139,139,0.11)\"\n            }\n          }\n        },\n        info: {\n          style: {\n            highlight: {\n              fillColor: \"rgba(142,142,142,0.15)\"\n            }\n          }\n        },\n        currentTime: {\n          style: {\n            lineColor: \"#D12E2B\"\n          }\n        },\n        legend: {\n          text: {\n            fillColor: \"#A8A7A8\"\n          },\n          advanced: {\n            disabledSeries: {\n              textColor: \"rgba(168,167,168,0.5)\",\n              lineColor: \"rgba(117,117,117,0.8)\"\n            }\n          }\n        }\n      }, I.FlatTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\"\n        },\n        area: {\n          style: {\n            noData: {\n              fillColor: \"#DDD\",\n              image: \"builtin://linearchart-no-data-light\"\n            }\n          }\n        },\n        chartTypes: {\n          columns: {\n            style: {\n              gradient: 1,\n              depth: 0\n            }\n          }\n        },\n        timeAxis: {\n          style: {\n            showMajorTimeBalloons: !1,\n            showMinorTimeBalloons: !1,\n            majorTimeLabel: {\n              fillColor: \"#000\",\n              shadowColor: null\n            },\n            minorTimeLabel: {\n              fillColor: \"#000\",\n              shadowColor: null\n            },\n            dateLighten: {\n              fillColor: \"rgba(0,0,0,0.05)\"\n            }\n          }\n        }\n      }, I.RoundTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-round\"\n        },\n        valueAxisDefault: {\n          style: {\n            valueLabel: {\n              textStyle: {\n                fillColor: \"#000000\",\n                font: \"11px Arial\",\n                shadowOffsetX: 0,\n                shadowOffsetY: 1,\n                shadowBlur: 0,\n                shadowColor: \"rgba(255,255,255,0.5)\"\n              }\n            }\n          }\n        },\n        timeAxis: {\n          style: {\n            showMinorTimeBalloons: !1,\n            showMajorTimeBalloons: !0,\n            minorTimeBalloonStyle: {\n              fillColor: \"#FFF\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 2,\n              shadowBlur: 2,\n              shadowColor: \"#888\"\n            },\n            majorTimeBalloonStyle: {\n              fillColor: \"#AAA\",\n              shadowOffsetX: 0,\n              shadowOffsetY: -1,\n              shadowBlur: 0,\n              shadowColor: \"rgba(0,0,0,0.3)\"\n            },\n            minorTimeLabel: {\n              fillColor: \"#000000\",\n              font: \"12px Arial\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 1,\n              shadowBlur: 0,\n              shadowColor: \"rgba(255,255,255,0.5)\"\n            },\n            majorTimeLabel: {\n              fillColor: \"#FFF\",\n              font: \"11px Arial\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 1,\n              shadowBlur: 1,\n              shadowColor: \"#7c7c7c\"\n            },\n            minorTimeRuler: {\n              lineColor: \"rgba(0,0,0,0.2)\"\n            },\n            dateLighten: {\n              fillColor: \"rgba(0,0,0,0.05)\"\n            }\n          }\n        },\n        chartTypes: {\n          columns: {\n            style: {\n              gradient: .8,\n              depth: 3\n            }\n          }\n        },\n        area: {\n          style: {\n            noData: {\n              image: \"builtin://linearchart-no-data-dark\"\n            }\n          }\n        }\n      }, I.GradientTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-gradient\"\n        },\n        valueAxisDefault: {\n          style: {\n            valueLabel: {\n              textStyle: {\n                fillColor: \"#000000\",\n                font: \"11px Arial\",\n                shadowOffsetX: 0,\n                shadowOffsetY: 1,\n                shadowBlur: 0,\n                shadowColor: \"rgba(255,255,255,0.5)\"\n              }\n            }\n          }\n        },\n        timeAxis: {\n          style: {\n            showMinorTimeBalloons: !1,\n            showMajorTimeBalloons: !0,\n            minorTimeBalloonStyle: {\n              fillColor: \"#FFF\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 2,\n              shadowBlur: 2,\n              shadowColor: \"#888\"\n            },\n            majorTimeBalloonStyle: {\n              fillColor: \"AAA\",\n              shadowOffsetX: 0,\n              shadowOffsetY: -1,\n              shadowBlur: 0,\n              shadowColor: \"rgba(0,0,0,0.3)\"\n            },\n            minorTimeLabel: {\n              fillColor: \"#000000\",\n              font: \"12px Arial\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 1,\n              shadowBlur: 0,\n              shadowColor: \"rgba(255,255,255,0.5)\"\n            },\n            majorTimeLabel: {\n              fillColor: \"#FFF\",\n              font: \"11px Arial\",\n              shadowOffsetX: 0,\n              shadowOffsetY: 1,\n              shadowBlur: 1,\n              shadowColor: \"#7c7c7c\"\n            },\n            minorTimeRuler: {\n              lineColor: \"rgba(0,0,0,0.2)\"\n            },\n            dateLighten: {\n              fillColor: \"rgba(255,255,255,0.2)\"\n            }\n          }\n        },\n        chartTypes: {\n          columns: {\n            style: {\n              gradient: .8,\n              depth: 3\n            }\n          }\n        },\n        area: {\n          style: {\n            noData: {\n              image: \"builtin://linearchart-no-data-dark\"\n            }\n          }\n        }\n      }, t.Settings = I;\n\n      var P = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = new D(), e;\n        }\n\n        return n(e, t), e.getMapping = function (t, e) {\n          if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n          switch (t ? t.type : e.type) {\n            case \"columns\":\n            case void 0:\n              return d.SettingsMapping.TimeChartSettingsSeriesColumns;\n\n            case \"candlestick\":\n              return d.SettingsMapping.TimeChartSettingsSeriesCandleStick;\n\n            case \"line\":\n              return d.SettingsMapping.TimeChartSettingsSeriesLines;\n\n            default:\n              throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.\");\n          }\n        }, e.createInstance = function (t, e) {\n          switch (e || t.type) {\n            case \"columns\":\n            case void 0:\n              return new N();\n\n            case \"candlestick\":\n              return new R();\n\n            case \"line\":\n              return new F();\n\n            default:\n              throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.\");\n          }\n        }, e;\n      }(l.SettingsSeries);\n\n      t.SettingsSeries = P;\n\n      var D = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.index = 1, e.countIndex = null, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesData);\n\n      t.SettingsSeriesData = D;\n\n      var N = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = new D(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesColumns);\n\n      t.SettingsSeriesColumns = N;\n\n      var F = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = new D(), e.style = new O(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesLines);\n\n      t.SettingsSeriesLines = F;\n\n      var O = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.markerStyleFunction = null, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesLinesStyle);\n\n      t.SettingsSeriesLinesStyle = O;\n\n      var E = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.high = null, e.open = null, e.close = null, e.low = null, e;\n        }\n\n        return n(e, t), e;\n      }(D);\n\n      t.SettingsSeriesCandleStickData = E;\n\n      var R = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = new E(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesCandleStick);\n\n      t.SettingsSeriesCandleStick = R;\n\n      var H = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.selectionChangeDuringInteraction = !1, e.onTimeChange = null, e.chartUpdateDelay = 400, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsEvents);\n\n      t.SettingsEvents = H;\n\n      var z = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.timeUpdateInterval = 900, e.dataUpdateInterval = null, e.maxUnitsToDisplay = 2e4, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsAdvanced);\n\n      t.SettingsAdvanced = z;\n\n      var B = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.calendar = {\n            parentLocale: null\n          }, e.holidayWeekdays = [6, 7], e.toolbar = new U(), e.timeUnitsNames = {\n            ms: \"millisecond\",\n            s: \"second\",\n            m: \"minute\",\n            h: \"hour\",\n            d: \"day\",\n            w: \"week\",\n            M: \"month\",\n            y: \"year\"\n          }, e.timeUnitsNamesPlural = {\n            ms: \"milliseconds\",\n            s: \"seconds\",\n            m: \"minutes\",\n            h: \"hours\",\n            d: \"days\",\n            w: \"weeks\",\n            M: \"months\",\n            y: \"years\"\n          }, e.markerDates = {\n            timeFormats: {\n              ms: \"HH:mm:ss\",\n              s: \"HH:mm:ss\",\n              m: \"HH:mm:ss\",\n              h: \"HH:mm\",\n              d: \"D, HH:mm\",\n              w: \"MMM D\",\n              M: \"MMM D\",\n              y: \"YYYY, MMM D\"\n            }\n          }, e.infoDates = {\n            majorTimeFormats: {\n              y: null,\n              M: \"YYYY\",\n              w: \"GGGG\",\n              d: \"YYYY\",\n              h: \"MMM D, YYYY\",\n              m: \"MMM D, YYYY\",\n              s: \"MMM D, YYYY\",\n              ms: \"MMM D, YYYY\"\n            },\n            minorTimeFormats: {\n              y: \"YYYY\",\n              M: \"MMM\",\n              w: \"[Week] W\",\n              d: \"MMM D\",\n              h: \"HH:mm\",\n              m: \"HH:mm\",\n              s: \"HH:mm:ss\",\n              ms: \"ss.SSS\"\n            },\n            fullTimeFormats: {\n              ms: \"MMM D, YYYY HH:mm:ss\",\n              s: \"MMM D, YYYY HH:mm:ss\",\n              m: \"MMM D, YYYY, HH:mm\",\n              h: \"MMM D, YYYY HH:00\",\n              d: \"MMM D, YYYY\",\n              w: \"[Week] W, GGGG\",\n              M: \"MMM YYYY\",\n              y: \"YYYY\"\n            }\n          }, e.timeAxisDates = {\n            minorLabelTimeFormats: {\n              ms: \"ss.SSS\",\n              s: \"HH:mm:ss\",\n              m: \"HH:mm\",\n              h: \"HH:00\",\n              d: \"MMM D\",\n              w: \"MMM D\",\n              M: \"MMM\",\n              y: \"YYYY\"\n            },\n            majorLabelTimeFormats: {\n              ms: \"MMM D, YYYY HH:mm:ss\",\n              s: \"MMM D, YYYY HH:mm:ss\",\n              m: \"MMM D, YYYY\",\n              h: \"MMM D, YYYY HH:00\",\n              d: \"MMM D, YYYY\",\n              w: \"[Week] W, GGGG\",\n              M: \"MMM YYYY\",\n              y: \"YYYY\"\n            },\n            majorLabelFullTimeFormats: {\n              ms: \"MMM D, YYYY HH:mm:ss\",\n              s: \"MMM D, YYYY HH:mm:ss\",\n              m: \"MMM D, YYYY\",\n              h: \"MMM D, YYYY HH:00\",\n              d: \"MMM D, YYYY\",\n              w: \"[Week] W, GGGG\",\n              M: \"MMM YYYY\",\n              y: \"YYYY\"\n            }\n          }, e.determiningDataBounds = \"Determining data bounds\", e.loadingLabel = \"Loading...\", e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsLocalization);\n\n      t.SettingsLocalization = B;\n\n      var U = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.customPeriod = \"Custom\", e.periodDropdownTitle = \"Select units in which to show the data\", e.unitDropdownTitle = \"Select units in which to show the data\", e.zoomoutButton = \"Zoom-out\", e.zoomoutTitle = \"Zoom out\", e.unavailableUnitTitle = \"zoom in for more\", e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsLocalizationToolbar);\n\n      t.SettingsLocalizationToolbar = U;\n\n      var G = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.snapMode = \"displayUnit\", e.selection = new m(), e.scrolling = new g(), e.zooming = new V(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsInteraction);\n\n      t.SettingsInteraction = G;\n\n      var V = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.enabled = !0, e.click = !0, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsInteractionZooming);\n\n      t.SettingsInteractionZooming = V;\n\n      var j = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.displayUnits = [{\n            unit: \"1 ms\",\n            name: \"millisecond\"\n          }, {\n            unit: \"1 s\",\n            name: \"second\"\n          }, {\n            unit: \"5 s\",\n            name: \"5 seconds\"\n          }, {\n            unit: \"1 m\",\n            name: \"minute\"\n          }, {\n            unit: \"5 m\",\n            name: \"5 minutes\"\n          }, {\n            unit: \"1 h\",\n            name: \"hour\"\n          }, {\n            unit: \"6 h\",\n            name: \"6 hours\"\n          }, {\n            unit: \"1 d\",\n            name: \"day\"\n          }, {\n            unit: \"1 M\",\n            name: \"month\"\n          }, {\n            unit: \"1 y\",\n            name: \"year\"\n          }], e.displayPeriods = [{\n            unit: \"10 ms\"\n          }, {\n            unit: \"100 ms\"\n          }, {\n            unit: \"s\"\n          }, {\n            unit: \"m\"\n          }, {\n            unit: \"h\"\n          }, {\n            unit: \"d\"\n          }, {\n            unit: \"M\"\n          }, {\n            unit: \"y\"\n          }, {\n            unit: \"10 y\"\n          }, {\n            unit: \"100 y\"\n          }], e.style = new W(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsArea);\n\n      t.SettingsArea = j;\n\n      var W = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.markerText = {\n            font: \"12px Arial\"\n          }, e.selection = new y(), e.selectionLabel = {\n            fillColor: \"#000000\",\n            font: \"12px Arial\"\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsAreaStyle);\n\n      t.SettingsAreaStyle = W;\n\n      var Z = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.animationOrder = 700, i.paintOrder = 25, i.updateOrder = 1100, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          var e = this.scene;\n\n          if (null != e.selectionStart && this.chart.selection.isSelecting && e.settings.info.enabled) {\n            var i = e.selectionStart,\n                n = e.selectionEnd;\n            this.showInfoPopup(i, n, null, this.buildContent(i, n, null, null), t);\n          }\n        }, e.prototype.getPopupAreaMouseMoved = function (t, e) {\n          var i = this.scene;\n          if (!i.displayUnit || !i.xyInChartOrBottom(t, e)) return null;\n          var n = i.hoverFrom,\n              r = i.hoverTo;\n          return {\n            t0: n,\n            t1: r\n          };\n        }, e.prototype.getContentsFunctionRange = function (t, e) {\n          var i = r.timeUnitDiffs,\n              n = this.scene,\n              s = !n.displayUnit || i[n.displayUnit.unit] < i.d;\n          return [n.timestampFromInternal(t, s), n.timestampFromInternal(e, s)];\n        }, e.prototype.buildContent = function (e, i, n, r) {\n          var s = this.scene.getRoundedTimes([e, i]);\n          return t.prototype.buildContent.call(this, s[0], s[1], n, r);\n        }, e.prototype.buildHeader = function (t, e) {\n          var i = this.scene.displayUnit,\n              n = this.scene.headerItem(t, e);\n          return i && n ? \"<em></em><strong>\" + n.date + (\"<small>(\" + n.unitCount + \" \" + n.unitName + \")</small></strong>\") : \"\";\n        }, e;\n      }(l.InfoPopup);\n\n      t.InfoPopup = Z;\n\n      var Y = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 600, i.paintOrder = 20, i.updateOrder = 1200, i.chart = null, i.scene = null, i.renderer = null, i.pointer = null, i.chart = e, i.scene = e.scene, i.renderer = e.renderer, i;\n        }\n\n        return n(e, t), e.prototype.previewPointerMove = function (t) {\n          this.pointer = null, this.updateHover(t);\n        }, e.prototype.onPointerOut = function (t) {\n          var e = this.scene;\n          e.hoverFrom = null, e.hoverTo = null, e.hoverSeriesItem = null, e.hoverItem = null, t.changes.hover = !0, this.chart.notifyHoverChanged(t, this.chart.createEventArguments(t, \"user\"));\n        }, e.prototype.previewPointerDown = function (t) {\n          this.pointer = t.identifier, this.updateHover(t);\n        }, e.prototype.setHoverItem = function (t, e) {\n          var i = null;\n\n          if (t && e) {\n            i = {\n              header: this.scene.headerItem(t, e),\n              values: []\n            };\n            var n = this.renderer.exportData(t, e);\n            if (n) for (var r = 0; r < n.length; r++) {\n              for (var s = 0; s < n[r].data.length; s++) {\n                i.values = i.values.concat(n[r].data[s]);\n              }\n            }\n          }\n\n          return i;\n        }, e.prototype.updateHover = function (t) {\n          var e = this.chart,\n              i = e.scene,\n              n = this.getClickRange(t.x, t.y),\n              r = null,\n              s = null,\n              a = null;\n          if (n && (r = n.t0, s = n.t1, a = e.renderer.hitTest(t.x, t.y)), e.legend) if (a) e.legend.notifyHoveredSeries(i.settings._computedSeries[a.seriesIndex]);else {\n            e.legend.notifyHoveredSeries(null);\n            var o = e.legend.getLastHoveredSeries();\n            o && (a = {\n              x0: null,\n              y0: null,\n              x1: null,\n              y1: null,\n              isMarker: !1,\n              seriesIndex: i.settings._computedSeries.indexOf(o)\n            });\n          }\n          (r !== i.hoverFrom || s !== i.hoverTo || !a != !i.hoverSeriesItem || a && (a.seriesIndex !== i.hoverSeriesItem.seriesIndex || a.x0 !== i.hoverSeriesItem.x0)) && (i.hoverFrom = r, i.hoverTo = s, i.hoverSeriesItem = a, i.hoverItem = this.setHoverItem(r, s), t.changes.hover = !0, e.notifyHoverChanged(t, e.createEventArguments(t, \"user\")));\n        }, e.prototype.onClick = function (t) {\n          t.identifier === this.pointer && this.chart.notifyClick(t, this.chart.createEventArguments(t, \"user\"));\n        }, e.prototype.defaultClick = function (t, e) {\n          var i = this.scene,\n              n = this.chart,\n              r = i.settings.interaction;\n\n          if (r.zooming.click) {\n            var s = i.xToTime(t.x);\n            if (null !== i.selectionStart && (i.selectionStart > s || i.selectionEnd < s)) this.clearSelection(t, \"user\");else if (null !== i.hoverFrom && !n.selection.isHoveringEdge) {\n              var a = i.displayUnit,\n                  o = n.scrolling,\n                  l = i.hoverFrom,\n                  h = i.hoverTo,\n                  u = o.timeSetup.getLimits(a, !0);\n              null != u.from && (l = Math.max(l, u.from)), null != u.to && (h = Math.min(h, u.to)), o.setTimeRangeSnap(l, h, null, null, !0, \"user\", !1, !0);\n              var c = o.targetUnit || i.displayUnit;\n              a.isSmallerOrEqual(c) && (c = o.timeSetup.getSmallerDisplayUnit(c), c && o.setTimeRangeSnap(l, h, null, c, !0, \"user\", !1, !0)), null !== i.selectionStart && this.clearSelection(t, \"user\"), t.consumed = !0;\n            }\n          }\n        }, e.prototype.onRightClick = function (t) {\n          var e = this.chart.settings.interaction.selection.clearOnRightClick;\n          null !== this.scene.selectionStart && e && this.clearSelection(t, \"user\"), null !== this.scene.hoverFrom && (this.chart.notifyRightClick(t, this.chart.createEventArguments(t, \"user\")), t.defaultPrevented && (t.consumed = !0));\n        }, e.prototype.onDoubleClick = function (t) {\n          null !== this.scene.hoverFrom && (this.chart.notifyDoubleClick(t, this.chart.createEventArguments(t, \"user\")), t.consumed = !0);\n        }, e.prototype.clearSelection = function (t, e) {\n          this.scene.selectionStart = null, this.scene.selectionEnd = null, this.chart.notifySelectionChanged(this.chart.createEventArguments(t, e)), t.changes.selection = !0, t.consumed = !0;\n        }, e.prototype.onTripleClick = function (t) {\n          void 0 !== this.scene.hoverFrom && null !== this.scene.hoverFrom && (this.chart.notifyTripleClick(t, this.chart.createEventArguments(t, \"user\")), t.consumed = !0);\n        }, e.prototype.getClickRange = function (t, e) {\n          var i = this.scene;\n          if (!i.xyInChartOrBottom(t, e)) return null;\n          var n,\n              r,\n              s,\n              a = this.scene.xToTime(t);\n          if (null !== i.selectionStart && a >= i.selectionStart && a < i.selectionEnd) n = i.selectionStart, r = i.selectionEnd, s = Math.max(2, i.displayUnit.numberOfUnits(n, r));else if (i.displayUnit) {\n            var o = !0,\n                l = i.timeStepSettings;\n\n            if (i.majorTimeUnit) {\n              var h = i.majorTimeUnit.roundTimeDown(a, l),\n                  u = i.majorTimeUnit.roundTimeUp(a + 1, l);\n              e > i.y0 + i.height && (h > i.timeStart || u < i.timeEnd) && (n = h, r = u, n = i.displayUnit.roundTimeDown(n, l), r = i.displayUnit.roundTimeUp(r, l), s = i.displayUnit.numberOfUnits(n, r), o = !1);\n            }\n\n            o && (n = i.displayUnit.roundTimeDown(a, l), r = i.displayUnit.roundTimeUp(a + 1, l), s = 1);\n          } else n = null, r = null, s = null;\n          return {\n            t0: n,\n            t1: r,\n            numBars: s\n          };\n        }, e;\n      }(d.ChartElement);\n\n      t.ClickNotifier = Y;\n\n      var q = function () {\n        function t(t) {\n          this.requests = {}, this.results = {}, this.dataSlicesCache = {}, this.nextRequestId = 0, this.hasNewRequests = !1, this.lastSlicer = null, this.chart = t, this.scene = this.chart.scene;\n        }\n\n        return t.prototype.registerDataProcessingRequest = function (t) {\n          this.requests[this.nextRequestId] = t;\n          var e = this.chart;\n          return this.results[this.nextRequestId] = {\n            leadIn: null,\n            leadOut: null,\n            times: [],\n            xes: [],\n            values: [],\n            counts: [],\n            fromIndex: 0,\n            toIndex: 0,\n            data: [],\n            from: 0,\n            to: 0,\n            slicer: null,\n            dataExistsFrom: null,\n            dataExistsTo: null,\n            externalItems: function externalItems(t, i) {\n              for (var n = r.timeUnitDiffs, s = !e.displayUnit || n[e.displayUnit.unit] < n.d, a = new Array(i - t), o = t; o < i; o++) {\n                a[o - t] = e.scene.timestampFromInternal(this.times[o], s);\n              }\n\n              return a;\n            }\n          }, this.hasNewRequests = !0, this.nextRequestId++;\n        }, t.prototype.removeDataProcessingRequest = function (t) {\n          delete this.requests[t], delete this.results[t];\n        }, t.prototype.getDisplayUnitsSlicer = function () {\n          return this.lastSlicer;\n        }, t.prototype.getData = function (t) {\n          return this.results[t];\n        }, t.prototype.clear = function () {\n          this.requests = {}, this.results = {};\n        }, t.prototype.process = function (t) {\n          var e = t.changes;\n          if (e.time || e.data || e.displayUnit || e.bounds || e.settings || this.hasNewRequests) if (this.scene.timeStart >= this.scene.timeEnd) for (var i in this.requests) {\n            var n = this.results[i];\n            n.dataExistsFrom = null, n.dataExistsTo = null;\n          } else {\n            this.hasNewRequests = !1, this.loading = !1, this.hasSomeData = !1;\n            var r = !!e.data || e.time;\n\n            for (var i in this.requests) {\n              var s = this.requests[i],\n                  n = this.results[i],\n                  a = this.updateData(r, s, n);\n              this.updateSlices(a, i, s, n);\n            }\n\n            this.scene.loading = this.loading, this.loading ? this.scene.setMessage(\"noData\", this.scene.settings.localization.loadingLabel, 10) : this.hasSomeData ? this.scene.setMessage(\"noData\", null) : this.scene.setMessage(\"noData\", this.scene.settings.localization.noDataLabel, 999);\n          }\n        }, t.prototype.exportData = function (t, e, i, n) {\n          for (var r = new x(this.scene, i, [], t, e, !0, 0), s = r.times, a = [], o = 0; o < n.length; o++) {\n            var l = n[o],\n                h = l.data,\n                u = this.chart.getData(h.source),\n                c = u.getDataForRange(t, e, i, null),\n                d = new Array(s.length - 1);\n            this.fillValues(c.values, r.times, d, r.counts, r.fromIndex, r.toIndex, h, i), a.push(d);\n          }\n\n          return {\n            timestamps: r.times.slice(r.fromIndex, r.toIndex - 1),\n            values: a\n          };\n        }, t.prototype.updateData = function (t, e, i) {\n          var n = this,\n              r = e.source,\n              s = this.chart.getData(r),\n              a = this.getUnitToUse(e),\n              o = (this.scene.timeEnd - this.scene.timeStart) * s.dataSettings.prefetchRatio;\n\n          if (t || !i.from && this.scene.timeStart || !i.to && this.scene.timeEnd || i.from >= i.to || this.scene.timeStart - o < i.from || this.scene.timeEnd + o > i.to || null !== i.dataExistsFrom && i.dataExistsFrom > this.scene.timeEnd || null !== i.dataExistsTo && i.dataExistsTo < this.scene.timeStart) {\n            t = !0;\n            var l = this.scene.timeStart - 2 * o,\n                h = this.scene.timeEnd + 2 * o,\n                u = s.getDataForRange(l, h, a, function () {\n              return n._newDataArrived(r);\n            });\n            s.noData || (this.hasSomeData = !0), u.from > this.scene.timeEnd || u.to < this.scene.timeStart ? (i.data = [], i.from = 0, i.to = 0, i.dataExistsFrom = null, i.dataExistsTo = null, this.loading = this.loading || u.loading) : (this.loading = this.loading || u.loading && (u.from > this.scene.timeStart || u.to < this.scene.timeEnd), i.data = u.values, i.from = l, i.to = h, i.dataExistsFrom = u.from, i.dataExistsTo = u.to);\n          }\n\n          return t;\n        }, t.prototype.updateSlices = function (t, e, i, n) {\n          var r = this.getUnitToUse(i),\n              s = i.index,\n              a = i.valueFunction,\n              o = n.data,\n              l = n.slicer = this.getSlice(e, i, r),\n              h = l.update(this.scene.timeStart, this.scene.timeEnd),\n              u = h.newBefore,\n              c = h.newAfter,\n              d = n.times = l.times,\n              p = n.counts = l.counts;\n          n.xes = l.xes;\n          var f = n.values = l.values;\n          if (o = n.data, n.fromIndex = l.fromIndex, n.toIndex = l.toIndex, o) o.length > 0 && !a && s >= o[0].length ? this.chart.error(\"No data for this DataIndex: \" + s + \", only \" + (o[0].length - 1) + \" values present\") : (t ? this.fillValues(o, d, f, p, l.fromIndex, l.toIndex, i, r) : (this.fillValues(o, d, f, p, l.fromIndex, u + 1, i, r), this.fillValues(o, d, f, p, c - 1, l.toIndex, i, r)), this.setLeads(i, n, r));else {\n            f = n.values = new Array(d.length);\n\n            for (var g = 0; g < f.length; g++) {\n              f[g] = null;\n            }\n\n            n.leadIn = null, n.leadOut = null;\n          }\n        }, t.prototype.getSlice = function (t, e, i) {\n          var n,\n              r = t + \"-\" + i.toString();\n          return n = this.dataSlicesCache.hasOwnProperty(r) ? this.dataSlicesCache[r] : this.dataSlicesCache[r] = new x(this.scene, i, [\"values\", \"counts\"]), this.lastSlicer = n, n;\n        }, t.prototype.getUnitToUse = function (t) {\n          return this.scene.displayUnit;\n        }, t.prototype.setLeads = function (t, e, i) {\n          var n = t.noDataPolicy,\n              r = t.index,\n              s = t.valueFunction,\n              a = e.data,\n              o = e.values,\n              l = e.times,\n              h = null,\n              u = null;\n\n          if (\"join\" === n && a) {\n            var d = e.fromIndex;\n\n            if (null === o[d]) {\n              var p = c.binSearch(a, l[d]);\n\n              if (p = c.linSearchDown(a, p, r, s), p !== -1) {\n                var f = a[p][0],\n                    g = e.slicer.makeMiniSlice(f),\n                    v = [g.t0, g.t1],\n                    m = [g.x0, g.x1],\n                    y = [null, null],\n                    S = [null, null];\n                this.fillValues(a, v, y, S, 0, 2, t, i), h = {\n                  times: v,\n                  xes: m,\n                  values: y,\n                  counts: S,\n                  fromIndex: 0,\n                  toIndex: 2\n                };\n              }\n            }\n\n            var b = e.toIndex;\n\n            if (null === o[b - 2]) {\n              var p = c.binSearch(a, l[b - 1]);\n\n              if (p = c.linSearchUp(a, p, r, s), p !== -1) {\n                var f = a[p][0],\n                    g = e.slicer.makeMiniSlice(f),\n                    v = [g.t0, g.t1],\n                    m = [g.x0, g.x1],\n                    y = [null, null],\n                    S = [null, null];\n                this.fillValues(a, v, y, S, 0, 2, t, i), u = {\n                  times: v,\n                  xes: m,\n                  values: y,\n                  counts: S,\n                  fromIndex: 0,\n                  toIndex: 2\n                };\n              }\n            }\n          }\n\n          e.leadIn = h, e.leadOut = u;\n        }, t.prototype.fillValues = function (t, e, i, n, r, s, a, o) {\n          var l = a.aggregation,\n              h = Math.floor(a.index),\n              u = Math.floor(a.countIndex),\n              c = a.valueFunction,\n              d = a.aggregatedValueFunction;\n          if (!(r + 1 >= s) && (\"sum\" === l ? this.fillValueSum(t, e, i, n, r, s, h, u, c) : \"min\" === l ? this.fillValueMin(t, e, i, n, r, s, h, u, c) : \"max\" === l ? this.fillValueMax(t, e, i, n, r, s, h, u, c) : \"avg\" === l ? this.fillValueAvg(t, e, i, n, r, s, h, u, c) : \"count\" === l ? this.fillValueCount(t, e, i, n, r, s, h, u, c) : \"first\" === l ? this.fillValueFirst(t, e, i, n, r, s, h, u, c) : \"last\" === l ? this.fillValueLast(t, e, i, n, r, s, h, u, c) : this.chart.error(\"Unrecognized aggregation function: \" + l), d)) for (var p = r; p <= s - 2; p++) {\n            i[p] = d(i[p], e[p], o ? o.toString() : null);\n          }\n        }, t.prototype.fillValueSum = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = 0, g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (f += v, g += 0 === o ? 1 : t[u][o]), u += 1;\n            }\n\n            n[d] = g, i[d] = 0 === g ? null : f;\n          }\n        }, t.prototype.fillValueMin = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = 1 / 0, g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (f = Math.min(f, v), g += 0 === o ? 1 : t[u][o]), u += 1;\n            }\n\n            n[d] = g, i[d] = 0 === g ? null : f;\n          }\n        }, t.prototype.fillValueMax = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = -(1 / 0), g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (f = Math.max(f, v), g += 0 === o ? 1 : t[u][o]), u += 1;\n            }\n\n            n[d] = g, i[d] = 0 === g ? null : f;\n          }\n        }, t.prototype.fillValueCount = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = 0, g = void 0; u < h && t[u][0] < p;) {\n              g = l ? l(t[u]) : t[u][a], null != g && (f += o ? t[u][o] : 1), u += 1;\n            }\n\n            n[d] = f, i[d] = f;\n          }\n        }, t.prototype.fillValueAvg = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = 0, g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (f += v, g += o ? t[u][o] : 1), u += 1;\n            }\n\n            n[d] = g, i[d] = 0 === g ? null : f / g;\n          }\n        }, t.prototype.fillValueFirst = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = null, g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (null === f && (f = v), g += o ? t[u][o] : 1), u += 1;\n            }\n\n            n[d] = g, i[d] = f;\n          }\n        }, t.prototype.fillValueLast = function (t, e, i, n, r, s, a, o, l) {\n          for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {\n            for (var p = e[d + 1], f = null, g = 0, v = void 0; u < h && t[u][0] < p;) {\n              v = l ? l(t[u]) : t[u][a], null != v && (f = v, g += o ? t[u][o] : 1), u += 1;\n            }\n\n            n[d] = g, i[d] = f;\n          }\n        }, t.prototype._newDataArrived = function (t) {\n          var e = {};\n          e[t] = !0, this.chart.events.notifySceneChanges({\n            data: e\n          });\n        }, t;\n      }();\n\n      t.DataWarehouse = q;\n\n      var _ = function (t) {\n        function e(e, i) {\n          var n = t.call(this) || this;\n          return n.animationOrder = 400, n.paintOrder = 5, n.updateOrder = 1500, n.dataWarehouse = i, n.chart = e, n.scene = n.chart.scene, n.events = n.chart.events, n.buildSeries(), n;\n        }\n\n        return n(e, t), e.prototype.buildSeries = function () {\n          this.valueAxis = new l.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.r = new l.Renderer(this.chart, this.valueAxis), this.dataWarehouse.clear(), this.requestIds = [];\n\n          for (var t = 0; t < this.scene.settings._computedSeries.length; t++) {\n            var e = this.scene.settings._computedSeries[t];\n            this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(e.data));\n          }\n        }, e.prototype.onSceneChange = function (t) {\n          var e = t.changes;\n          (e.linearChartSeries || e.linearChartValueAxis) && this.buildSeries(), e.linearChartValueAxis && (e.bounds = !0), (e.bounds || e.settings) && (e.time = !0), e.data && d.Helpers.hasProperties(e.data) && this.chart.notifyChartUpdate(\"data\", !0);\n        }, e.prototype.getPanels = function () {\n          return this.valueAxis.getPanels(!1);\n        }, e.prototype.doAnimations = function (t) {\n          var e = t.changes;\n\n          if (this.dataWarehouse.process(t), this.scene.displayUnit) {\n            if (this.displayUnit !== this.scene.displayUnit && (this.displayUnit = this.scene.displayUnit, e.displayUnit = !0), e.time || e.data || e.displayUnit || e.bounds) {\n              for (var i = [], n = 0; n < this.requestIds.length; n++) {\n                i.push(this.dataWarehouse.getData(this.requestIds[n]));\n              }\n\n              this.r.process(i);\n            }\n\n            this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t);\n          }\n        }, e.prototype.paintScene = function (t) {\n          this.valueAxis.paintUnder(t), d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height), this.r.paint(t), d.Graphics.popClip(t), this.valueAxis.paint(t);\n        }, e.prototype.hitTest = function (t, e) {\n          return this.scene.xyInChart(t, e) ? this.r.hitTest(t, e, this.scene.settings.interaction.selection.tolerance) : null;\n        }, e.prototype.exportData = function (t, e) {\n          return this.r.exportData(t, e);\n        }, e;\n      }(d.ChartElement);\n\n      t.Renderer = _;\n\n      var X = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.chart = e, i.scene = e.scene, i.settings = e.settings, i.reinitializePeriod = !0, i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          var e = t.changes.settingsChanges;\n          e && e.navigation && (this.reinitializePeriod = !0), this.reinitializePeriod && this.chart.assetsLoaded && this.setupInitialDisplayPeriod();\n        }, e.prototype.onNewDataObject = function () {}, e.prototype.setupInitialDisplayPeriod = function () {\n          var t = this;\n\n          if (this.scene.width) {\n            this.reinitializePeriod = !1;\n            var e = this.settings.navigation.initialDisplayAnchor,\n                i = this.settings.navigation.initialDisplayPeriod,\n                n = this.settings.navigation.initialDisplayUnit;\n            this.computeDisplayPeriod(i, e, n, function (n, r, s) {\n              if (t.scene.setMessage(\"impl\", null, 0), t.scene.loading = !1, t.scene.displayUnit && (s = t.scene.displayUnit), !t.scene.timeStart && !t.scene.timeEnd) {\n                var a = t.chart.scrolling.timeSetup,\n                    o = a.getLimits(s, !0);\n                null !== o.from && (n = Math.round(Math.max(n, o.from))), null !== o.to && (r = Math.round(Math.min(r, o.to))), t.chart.scrolling.setTimeRange(n, r, s, !1, \"init\", e, i);\n              }\n            });\n          }\n        }, e.prototype.computeDisplayPeriod = function (t, e, i, n) {\n          var r = this,\n              s = this.chart.scrolling.computeDisplayPeriod(t, e, i, this.scene.mainData.dataFrom, this.scene.mainData.dataTo),\n              a = s.from,\n              o = s.to,\n              l = s.unit;\n          if (null !== a && null !== o && l) return n(a, o, l);\n          if (!(this.scene.mainData.dataSettings.dataFunction || this.scene.mainData.dataSettings.url || this.scene.mainData.dataSettings.urlByUnit || this.scene.mainData.dataSettings.preloaded)) return void this.chart.error(\"Cannot compute data dependant display period, no data given. DisplayPeriod = \" + t + \", DisplayAnchor = \" + e);\n\n          var h = function h(l, u, c, d, p, f) {\n            if (!r.chart.removed) {\n              if (null === l || null === u || 0 === l && 0 === u && r.scene.mainData.noData) return void n(d, p, f);\n              s = r.chart.scrolling.computeDisplayPeriod(t, e, i, l, u), a = s.from, o = s.to;\n              var g = s.unit;\n              return null === a || null === o ? void r.chart.error(\"Could not setup display time interval. Check your configuration.\") : void (g.isMultipleOf(c) ? n(a, o, g) : r.scene.mainData.determineDataLimits(g, !0, !0, function (t, e, i) {\n                return h(t, e, i, l, u, g);\n              }));\n            }\n          };\n\n          this.scene.mainData.determineDataLimits(null, !0, !0, function (t, e, i) {\n            return h(t, e, i, 0, 0, null);\n          });\n        }, e;\n      }(d.Navigator);\n\n      t.Navigator = X, t.moment = null;\n\n      var Q = !1,\n          J = function (e) {\n        function i(i, n) {\n          var r = e.call(this, new I(i), new b(), n) || this;\n          return r.timeAxis = null, r.timeStart = 0, r.timeEnd = 0, r.displayUnit = null, r.selectionStart = 0, r.selectionEnd = 0, r._cachedDataLimits = null, r.dataWarehouse = new q(r), r.renderer = r.events.addElement(new _(r, r.dataWarehouse)), r.scrolling = r.events.addElement(new v(r)), r.selection = r.events.addElement(new S(r)), r.navigator = r.events.addElement(new X(r)), r.clickNotifier = r.events.addElement(new Y(r)), r.infoPopup = r.events.addElement(new Z(r)), r.events.addElement(new A(r)), r.events.addElement(new t.Markers(r)), r.events.addElement(new l.Highlights(r)), r.finalInitialize(), r;\n        }\n\n        return n(i, e), i.prototype.notifyAssetsLoaded = function () {\n          if (!this.removed) {\n            if (!t.moment) {\n              if (t.moment = window.moment, !t.moment) return void this.error(\"Unable to load moment library. Please check that the assets are configured properly.\");\n              d.Helpers.compareVersions(t.moment.version, [2, 9]) || this.error(\"ZoomCharts requires moment version 2.9.0 or newer. The loaded version is \" + t.moment.version);\n            }\n\n            !Q && t.moment.tz && (d.Helpers.compareVersions(t.moment.tz.version, [0, 5]) || this.error(\"ZoomCharts requires moment-timezone version 0.5.0 or newer. The loaded version is \" + t.moment.tz.version), Q = !0), this.setMomentLocale();\n            var i = this.settings.timeAxis;\n            t.moment.tz && \"local\" === i.timeZone && (i.timeZone = t.moment.tz.guess(), d.Helpers.warn(\"Instead of using `local` for `timeAxis.timeZone` it is recommended to specify the exact timezone since the local timezone detection is error prone. The timezone was detected as `\" + i.timeZone + \"`.\")), this.timeAxis || (this.timeAxis = this.events.addElement(new w(this)));\n\n            for (var n = Object.keys(this.data), r = 0; r < n.length; r++) {\n              this.data[n[r]].notifyAssetsLoaded();\n            }\n\n            e.prototype.notifyAssetsLoaded.call(this), this.api._notifyAssetsLoaded();\n          }\n        }, i.prototype.createDataObj = function (t) {\n          return new c(this, t);\n        }, i.prototype.getData = function (t) {\n          return e.prototype.getData.call(this, t);\n        }, i.prototype.setMomentLocale = function () {\n          var e = this.scene.momentLocale,\n              i = t.moment.locale(),\n              n = this.settings.localization.calendar;\n          n.parentLocale && !d.Helpers.compareVersions(t.moment.version, [2, 12]) && this.error(\"Using `parentLocale` requires moment.js 2.12.0 or newer. The loaded version is \" + t.moment.version), t.moment.locale(e, null), t.moment.locale(e, n), this.scene.timeStepSettings = {\n            week: {\n              dow: t.moment.localeData().firstDayOfWeek()\n            }\n          }, t.moment.locale(i);\n        }, i.prototype.remove = function () {\n          t.moment && t.moment.locale(this.scene.momentLocale, null), e.prototype.remove.call(this), this.infoPopup.remove();\n        }, i.prototype.onSettingsChanged = function (t) {\n          if (t.data && (t.toolbar = !0), t.area && t.area.displayUnits) {\n            var e = this.scene,\n                i = new o(this);\n\n            if (e.displayUnit && !i.isAllowedDisplayUnit(e.displayUnit)) {\n              var n = i.computeDisplayUnit(e.timeStart, e.timeEnd, e.displayUnit, e.timeStart, e.timeEnd, e);\n              this.scrolling.setTimeRangeSnap(e.timeStart, e.timeEnd, null, n.unit, !0, \"api\", !0, !0);\n            }\n          }\n\n          this.assetsLoaded && t.localization && t.localization.calendar && this.setMomentLocale(), this.events.notifySceneChanges({\n            time: !0\n          });\n        }, i.prototype.save = function () {\n          var t = this.scene;\n          return JSON.stringify({\n            from: this.timeStart,\n            to: this.timeEnd,\n            unit: this.displayUnit.toString(),\n            selFrom: t.selectionStart,\n            selTo: t.selectionEnd,\n            anchor: t.anchor,\n            period: t.period\n          });\n        }, i.prototype.restore = function (t, e) {\n          if (t) {\n            var i = JSON.parse(t),\n                n = r.parse(i.unit);\n            n && (this.scrolling.setTimeRange(i.from, i.to, n, e, \"api\", i.anchor, i.period), this.setSelection(i.selFrom, i.selTo));\n          }\n        }, i.prototype.warnInvisibleChart = function (t) {\n          this.scene.width || d.Helpers.warn(\"`\" + t + \"()` method has been called on a hidden chart. This might produce invalid results since the chart width impacts the calculations.\");\n        }, i.prototype.setSelection = function (t, e, i) {\n          void 0 === i && (i = \"api\");\n          var n = this.scene;\n          n.selectionStart === t && n.selectionEnd === e || (n.selectionStart = t, n.selectionEnd = e, this.events.notifySceneChanges({\n            selection: !0\n          }), this.notifySelectionChanged(this.createEventArguments(null, i)));\n        }, i.prototype.setTimeRange = function (t, e, i, n, s, a, o) {\n          void 0 === n && (n = \"api\"), void 0 === s && (s = void 0), void 0 === a && (a = !0), void 0 === o && (o = !0), this.warnInvisibleChart(\"time\"), o && this.setSelection(null, null, n);\n          var l = void 0 !== s ? s : this.displayUnit;\n\n          if (!l) {\n            var h = this.settings.navigation.initialDisplayUnit;\n            h && \"auto\" !== h && (l = r.parse(h));\n          }\n\n          if (this.scene.width && a) {\n            this.scene.displayUnit = l;\n            var u = this.scrolling.onSnapWhileDragging(t, e, null, !0, 2);\n            u.unit && (this.scene.displayUnit = u.unit, u = this.scrolling.onSnapAfterDragging(u.from, u.to, null, !0, 2)), t = u.from, e = u.to, l = u.unit;\n          }\n\n          this.scrolling.setTimeRange(t, e, l, i, n);\n        }, i.prototype.getTimeRange = function () {\n          return this.scene.getTimeRange();\n        }, i.prototype.setTimeRangeAndUnit = function (t, e, i, n, r, s) {\n          void 0 === n && (n = !0), void 0 === r && (r = !0), void 0 === s && (s = !0), this.setTimeRange(t, e, n, \"api\", i, r, s);\n        }, i.prototype.setDisplayPeriod = function (t, e, i, n, r) {\n          var s = this;\n          return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !0), void 0 === r && (r = \"api\"), this.warnInvisibleChart(\"setDisplayPeriod\"), null === e && (e = this.scene.anchor), this.setSelection(null, null), \"string\" == typeof e && (e = e.trim()), \"string\" == typeof t && (t = t.trim()), this.navigator.computeDisplayPeriod(t, e, i, function (i, a, o) {\n            return s.scrolling.setTimeRange(i, a, o, n, r, e, t);\n          });\n        }, i.prototype.scroll = function (t, e, i) {\n          void 0 === i && (i = !1);\n          var n = t.trim().split(\" \");\n          if (3 !== n.length) return void this.error(\"Incorrect scroll format: \" + t);\n          var r = n[0],\n              s = parseInt(n[1], 10),\n              a = n[2];\n          if (\"<\" !== r && \">\" !== r || \"number\" != typeof s) return void this.error(\"Scroll:Incorrect scroll format: \" + t);\n          var l = new o(this),\n              h = l.scroll(this.timeStart, this.timeEnd, this.displayUnit, r, s, a),\n              u = h.from,\n              c = h.to;\n          i ? this.scrolling.setTimeRangeSnap(u, c, 0, this.displayUnit, e, \"api\", null, null) : this.scrolling.setTimeRange(u, c, this.displayUnit, e, \"api\", null, this.scene.period);\n        }, i.prototype.zoomOut = function (t, e, i) {\n          void 0 === t && (t = !0), void 0 === e && (e = \"api\"), void 0 === i && (i = null), this.setSelection(null, null), this.scrolling.zoomOut(i, this.scene.timeStart, this.scene.timeEnd, t, e), this.scene.period = null;\n        }, i.prototype.zoomOutPossible = function () {\n          return !!this.scene.displayUnit;\n        }, i.prototype.zoomIn = function (t, e, i, n) {\n          void 0 === e && (e = null), void 0 === i && (i = !0), void 0 === n && (n = \"api\"), this.setSelection(null, null), this.scrolling.zoomIn(t, e, this.scene.timeStart, this.scene.timeEnd, i, n), this.scene.period = null;\n        }, i.prototype.setDisplayUnit = function (t, e, i, n) {\n          void 0 === i && (i = \"api\"), void 0 === n && (n = !1), this.warnInvisibleChart(\"displayUnit\");\n          var s, a, o;\n\n          if (\"auto\" === t) {\n            var l = this.scrolling.timeSetup.computeDisplayUnit(null, null, null, this.timeStart, this.timeEnd, this.scene);\n            s = l.unit, a = l.from, o = l.to;\n          } else {\n            if (s = r.parse(t), !s) return;\n\n            if (n) {\n              for (var h = s.toString(), u = this.scene.settings._displayUnitsParsed, c = !1, p = 0; p < u.length; p++) {\n                if (u[p].toString() === h) {\n                  c = !0;\n                  break;\n                }\n              }\n\n              c || d.Helpers.warn(\"The display unit `\" + h + \"` does not match a display unit configured in `area.displayUnits`.\");\n            }\n\n            var f = this.scene.timeStepSettings;\n            a = s.roundTimeDown(this.timeStart, f), o = s.roundTimeUp(this.timeEnd, f);\n          }\n\n          var g = this.scrolling.snap(a, o, null, s, !1, !0);\n          this.scrolling.setTimeRange(g.from, g.to, s, e, i, g.anchor, g.period);\n        }, i.prototype.invalidateDataLimits = function () {\n          this._cachedDataLimits = null;\n        }, i.prototype.getDataLimits = function (t) {\n          void 0 === t && (t = this.displayUnit);\n          var e = this._cachedDataLimits;\n          if (e && e.unit === t) return e;\n\n          for (var i = this.settings._computedSeries, n = Object.create(null), r = 0; r < i.length; r++) {\n            var s = i[r];\n            s.enabled && (n[s.data.source] = !0);\n          }\n\n          var a = 1 / 0,\n              o = -(1 / 0);\n\n          for (var l in n) {\n            var h = this.data[l];\n            h && (h.dataLimitFrom || h.dataLimitTo) && (a = Math.min(a, h.dataLimitFrom), o = Math.max(o, h.dataLimitTo));\n          }\n\n          return a > o ? (a = null, o = null) : t && (a = t.roundTimeDown(a, this.scene.timeStepSettings), o = t.roundTimeUp(o, this.scene.timeStepSettings)), this._cachedDataLimits = {\n            from: a,\n            to: o,\n            unit: t\n          };\n        }, i.prototype.getDisplayLimits = function (t) {\n          var e = this.getDataLimits(t),\n              i = e.from,\n              n = e.to;\n          if (null === i) return e;\n\n          for (var r = 0; r < this.scene.markers.length; r++) {\n            var s = this.scene.markers[r];\n            s.settings.overrideLimits && (i = Math.min(i, s.time), n = Math.max(n, s.time));\n          }\n\n          return {\n            from: i,\n            to: n\n          };\n        }, i.prototype.exportVisibleData = function () {\n          if (!this.displayUnit) return [];\n\n          for (var e = this.settings._computedSeries, i = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, e), n = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit], r = i.timestamps, s = i.values, a = [\"timestamp\", \"time\"], o = 0; o < e.length; o++) {\n            var l = e[o];\n            a.push(l.name || l.id || \"\");\n          }\n\n          for (var h = [a], u = this.scene.momentLocale, c = 0; c < r.length; c++) {\n            for (var d = r[c], p = [d, t.moment.utc(d).locale(u).format(n)], f = 0; f < e.length; f++) {\n              p.push(s[f][c]);\n            }\n\n            h.push(p);\n          }\n\n          return h;\n        }, i.prototype.isThisDisplayPeriod = function (t, e, i) {\n          if (!this.displayUnit) return !1;\n          var n = this.scene.mainData.dataFrom,\n              r = this.scene.mainData.dataTo,\n              s = this.scrolling.computeDisplayPeriod(t, e, i, n, r);\n          n = s.from, r = s.to;\n          var a = this.scrolling.getFrom(),\n              o = this.scrolling.getTo(),\n              l = o - a,\n              h = Math.abs(a - n) / l;\n          if (h > .1) return !1;\n          var u = Math.abs(o - r) / l;\n          return !(u > .1);\n        }, i.prototype.notifyTimeChanged = function (t, e, i, n) {\n          this.timeStart = t, this.timeEnd = e, this.displayUnit = i, this.notifyChartUpdate(n);\n        }, i.prototype.saveNavigation = function () {\n          return this.displayUnit ? {\n            timeStart: this.timeStart,\n            timeEnd: this.timeEnd,\n            displayUnit: this.displayUnit,\n            anchor: this.scene.anchor,\n            period: this.scene.period\n          } : null;\n        }, i.prototype.restoreNavigation = function (t, e, i) {\n          this.timeStart = t.timeStart, this.timeEnd = t.timeEnd, this.displayUnit = t.displayUnit, this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, e, i, t.anchor, t.period);\n        }, i.prototype.doChartUpdateNotify = function (t) {\n          e.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams(\"timeChange\", this.createEventArguments(null, t), null);\n        }, i.prototype.createEventArguments = function (t, e) {\n          var i = this.scene,\n              n = i.hoverSeriesItem,\n              s = n && null != n.seriesIndex ? i.settings._computedSeries[n.seriesIndex] : null,\n              a = !!n && n.isMarker,\n              o = r.timeUnitDiffs,\n              l = !this.displayUnit || o[this.displayUnit.unit] < o.d,\n              h = i.timestampFromInternal(i.hoverFrom, l),\n              u = i.timestampFromInternal(i.hoverTo, l);\n          return {\n            chart: this.api,\n            origin: e,\n            timeStart: i.timestampFromInternal(this.timeStart, l),\n            timeEnd: i.timestampFromInternal(this.timeEnd, l),\n            displayUnit: this.displayUnit ? this.displayUnit.toString() : null,\n            selectionStart: i.timestampFromInternal(i.selectionStart, l),\n            selectionEnd: i.timestampFromInternal(i.selectionEnd, l),\n            hoverStart: h,\n            hoverEnd: u,\n            hoverSeries: s,\n            hoverItem: i.hoverItem,\n            hoverMarker: a,\n            clickStart: h,\n            clickEnd: u,\n            clickSeries: s,\n            clickMarker: a\n          };\n        }, i.prototype.defaultClick = function (t, i) {\n          e.prototype.defaultClick.call(this, t, i), this.clickNotifier.defaultClick(t, i);\n        }, i.prototype.defaultRightClick = function (t) {\n          this.infoPopup.show(t), t.preventDefault();\n        }, i.prototype.getBottomHeight = function () {\n          return this.scene.height - this.scene.bottomAxisSize;\n        }, i.prototype.showInfoPopup = function (t, e, i) {\n          if (null == t) return void this.infoPopup.hideInfoPopup(null);\n          if (null == e || t === e) e = t + 1;else if (t > e) {\n            var n = t;\n            t = e, e = n;\n          }\n          var r = this.displayUnit,\n              s = this.scene.timeStepSettings;\n          t = r.roundTimeDown(t, s), e = r.roundTimeUp(e, s), e < this.scene.timeStart || t > this.scene.timeEnd || this.infoPopup.manualShowInfoPopup(t, e, i);\n        }, i;\n      }(l.Impl);\n\n      t.Impl = J;\n    }(o = i.TimeChart || (i.TimeChart = {})), function (e) {\n      var r = e.Renderers || (e.Renderers = {}),\n          s = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.itemsToLoad = 50, e.partialLoad = !0, e.autoCategories = null, e.sortField = null, e.dataFunction = null, e.preloaded = null, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsData);\n\n      e.SettingsData = s;\n\n      var a = {\n        values: 1,\n        id: 1,\n        offset: 1,\n        limit: 1,\n        afterSum: 1,\n        beforeSum: 1,\n        subvalues: 1,\n        sum: 1,\n        extra: 1,\n        name: 1,\n        totalCount: 1,\n        total: 1,\n        valuesSum: 1,\n        done: 1,\n        afterFraction: 1,\n        beforeFraction: 1\n      },\n          o = function () {\n        function t() {\n          this.name = null, this.values = [], this.offset = 0, this.totalCount = null, this.total = 0, this.valuesSum = 0, this.beforeSum = 0, this.afterSum = 0, this.done = !1, this.extra = null;\n        }\n\n        return t;\n      }();\n\n      e.PieData = o;\n\n      var l = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e, i) || this;\n          return r.pies = {}, r.pendingPies = {}, r.requestedPies = {}, r.nextId = 0, r._isFacetChart = n, r;\n        }\n\n        return n(e, t), e.exportValues = function (t) {\n          var e = [\"id\", \"name\", \"value\"],\n              i = {\n            id: 0,\n            name: 1,\n            value: 2\n          },\n              n = 3,\n              r = t.values,\n              s = new Array(r.length + 1);\n          s[0] = e;\n\n          for (var a = 0; a < r.length; a++) {\n            var o = r[a],\n                l = new Array(n);\n            s[a + 1] = l;\n\n            for (var h = Object.keys(o), u = 0; u < h.length; u++) {\n              var c = h[u];\n\n              if (\"_\" !== c.charAt(0) && \"fraction\" !== c) {\n                var p = o[c];\n                if (Array.isArray(p)) p = p.length;else if (d.Helpers.isObjectOrArray(p)) continue;\n                var f = i[c];\n                void 0 === f && (i[c] = f = n++, e.push(c)), l[f] = p;\n              }\n            }\n          }\n\n          return s;\n        }, e.prototype.hasDataFunc = function () {\n          return !!this.dataSettings.dataFunction || !!this.dataSettings.url;\n        }, e.prototype.applyPreloadedData = function () {\n          if (t.prototype.applyPreloadedData.call(this), !this.hasDataFunc()) {\n            for (var e = Object.keys(this.pies), i = 0; i < e.length; i++) {\n              var n = this.pies[e[i]];\n              n.done || (n.done = !0, n.afterSum = 0, n.totalCount = n.offset + n.values.length);\n            }\n\n            this.chart.scene.loading = !1;\n          }\n        }, e.prototype.getRootId = function () {\n          return this.settings.navigation.initialDrilldown && this.settings.navigation.initialDrilldown.length > 0 ? this.settings.navigation.initialDrilldown[0] : \"\";\n        }, e.prototype.canExpand = function (t) {\n          return !!d.Helpers.hasProperty(this.pies, t) || !(!this.hasDataFunc() || this.dataSettings.autoCategories) && !(!t || t[0] === d.Helpers.SeparatorChar);\n        }, e.prototype.getPieData = function (t) {\n          if (!d.Helpers.hasProperty(this.pies, t)) return null;\n          var e = this.pies[t];\n          return this.needPostprocessing() && (e = this.filterAndSortData(e)), e;\n        }, e.prototype.requestMorePieData = function (t, e) {\n          return void 0 === e && (e = this.dataSettings.itemsToLoad), null == e && (e = this.dataSettings.itemsToLoad), !(!d.Helpers.hasProperty(this.pies, t) || this.pies[t].done) && (this.requestPieData(t, this.pies[t].offset + this.pies[t].values.length, e), !0);\n        }, e.prototype.requestLessPieData = function (t, e) {\n          if (void 0 === e && (e = this.dataSettings.itemsToLoad), !d.Helpers.hasProperty(this.pies, t)) return !1;\n          var i = this.pies[t];\n          return (0 !== i.offset || !(i.done || i.values.length > 1)) && (this.requestPieData(t, Math.max(i.offset - this.dataSettings.itemsToLoad, 0), e), !0);\n        }, e.prototype.requestPieData = function (t, e, i) {\n          if (void 0 === i && (i = this.dataSettings.itemsToLoad), this.dataSettings.autoCategories) {\n            if (d.Helpers.hasProperties(this.pies)) throw new Error(\"Cannot request additional data when autoCategories is in use!\");\n            t = \"\";\n          }\n\n          if (t[0] === d.Helpers.SeparatorChar) throw new Error(\"Invalid Id: \" + t);\n\n          if (d.Helpers.hasProperty(this.pies, t)) {\n            var n = this.pies[t],\n                r = n.offset,\n                s = r + n.values.length;\n            if (e < r) i = r - e;else {\n              if (!(e + i > s)) return;\n              i = e + i - s, e = s;\n            }\n          } else (this.needPostprocessing() || !this.dataSettings.partialLoad || this.dataSettings.autoCategories) && (i = 2147483647, e = 0);\n\n          if (!d.Helpers.hasProperty(this.requestedPies, t)) if (d.Helpers.hasProperty(this.pendingPies, t)) {\n            var a = this.pendingPies[t],\n                o = Math.min(a.offset, e),\n                l = Math.max(a.offset + a.limit, e + i);\n            a.offset = o, a.limit = l - o;\n          } else this.dataFunc && (this.pendingPies[t] = {\n            id: t,\n            offset: e,\n            limit: i\n          }, this.scheduleRequests());\n        }, e.prototype.autoCategorize = function (t, e) {\n          if (0 === e.length) return t;\n\n          for (var i = d.Helpers.clone(t), n = [i], r = 0; r < e.length; r++) {\n            for (var s = e[r], a = [], o = 0; o < n.length; o++) {\n              for (var l = n[o], h = [], u = {}, c = 0; c < l.subvalues.length; c++) {\n                var p = l.subvalues[c],\n                    f = void 0;\n                f = d.Helpers.isFunction(s) ? s(p) : p[s], f = void 0 === f || null === f ? \"None\" : f.toString();\n                var g = void 0;\n                d.Helpers.hasProperty(u, f) ? g = u[f] : (g = {\n                  id: l.id + d.Helpers.SeparatorChar + f,\n                  __id: l.id + d.Helpers.SeparatorChar + f,\n                  value: 0,\n                  subvalues: [],\n                  name: f,\n                  __category: s\n                }, u[f] = g, h.push(g), a.push(g)), g.subvalues.push(p), g.value += d.Helpers.tryParseFloat(p.value, 0);\n              }\n\n              l.subvalues = h;\n            }\n\n            n = a;\n          }\n\n          return i;\n        }, e.prototype.valueSum = function (t) {\n          if (this._isFacetChart) return 0;\n\n          for (var e = 0, i = 0; i < t.length; i++) {\n            e += t[i].value;\n          }\n\n          return e;\n        }, e.prototype.addDataInt = function (t, e, i, n, r, s, l, h, u) {\n          var c;\n          c = d.Helpers.hasProperty(this.pies, t) ? this.pies[t] : this.pies[t] = new o();\n          var p = c.offset + c.values.length,\n              f = i + e.length;\n          if (0 === c.values.length || f < c.offset || p < i) c.offset = i, c.done = n > e.length, c.values = e.slice(), c.valuesSum = this.valueSum(e), c.totalCount = c.done ? c.values.length + c.offset : null, c.afterSum = c.done ? 0 : r, c.beforeSum = 0 === c.offset ? 0 : s, c.total = c.done && 0 === c.offset ? c.valuesSum : l;else {\n            var g = null,\n                v = null,\n                m = 0,\n                y = 0;\n            c.offset < i && (i === p ? (g = c.values, m = c.valuesSum) : (g = c.values.slice(0, i - c.offset), m = this.valueSum(g))), p > f && e.length >= n && (c.offset === f ? (v = c.values, y = c.valuesSum) : (v = c.values.slice(f - c.offset), y = this.valueSum(v))), v ? c.values = g ? g.concat(e, v) : e.concat(v) : c.values = g ? g.concat(e) : e.slice(), c.offset = Math.min(c.offset, i), c.valuesSum = this.valueSum(e) + m + y, e.length < n && (c.done = !0), g || (c.beforeSum = s), v || (c.afterSum = r), c.total = l, c.done && (c.afterSum = 0), 0 === c.offset && (c.beforeSum = 0), c.done && 0 === c.offset && (c.total = c.valuesSum);\n          }\n          if (c.extra = h.extra, c.name = h.name, h) for (var S in h) {\n            d.Helpers.hasProperty(a, S) || (c[S] = h[S]);\n          }\n\n          for (var b = 0; b < e.length; b++) {\n            var x = e[b];\n            x.subvalues && (u[x.__id] = !0, this.addDataInt(x.__id, x.subvalues, 0, 1 / 0, null, null, null, x, u));\n          }\n        }, e.prototype.needPostprocessing = function () {\n          var t = this.chart.settings.filters;\n          return !!t.sliceFilter || !t.allowZeroValues || !!this.dataSettings.sortField;\n        }, e.prototype.filterAndSortData = function (t) {\n          var e = this.chart.settings.filters,\n              i = e.allowZeroValues,\n              n = e.sliceFilter;\n\n          if (!i || n) {\n            for (var r = t.total || 0, s = [], a = 0; a < t.values.length; a++) {\n              var l = t.values[a];\n              n && !n(l) || !i && 0 === l.value ? r -= l.value : s.push(l);\n            }\n\n            var h = new o();\n            h.values = s, h.done = t.done, h.beforeSum = t.beforeSum, h.afterSum = t.afterSum, h.total = t.total || null, h.totalCount = t.totalCount || null, h.extra = t.extra, t = h;\n          }\n\n          return this.dataSettings.sortField && this.sortData(t), t;\n        }, e.prototype.sortData = function (t) {\n          var e = this.dataSettings.sortField;\n          if (d.Helpers.isFunction(e)) return void t.values.sort(e);\n          var i;\n          i = Array.isArray(e) ? e.slice() : [e];\n\n          for (var n = new Array(i.length), r = 0; r < i.length; r++) {\n            var s = i[r];\n            \"-\" === s.charAt(0) ? (i[r] = s.substr(1), n[r] = -1) : n[r] = 1;\n          }\n\n          var a = function a(t, e) {\n            for (var r = 0; r < i.length; r++) {\n              var s = t[i[r]],\n                  a = e[i[r]],\n                  o = void 0;\n              if (null == s ? o = null == a ? 0 : a < 0 ? -1 : 1 : null == a ? o = s < 0 ? 1 : -1 : (o = a - s, isNaN(o) && (o = (\"\" + a).localeCompare(s))), 0 !== o) return n[r] * o;\n            }\n\n            return 0;\n          };\n\n          t.values.sort(a);\n        }, e.prototype.buildRequest = function () {\n          if (!d.Helpers.hasProperties(this.pendingPies)) return null;\n          var t = d.Helpers.removePropertyValue(this.pendingPies),\n              e = t.key,\n              i = t.value;\n          return this.requestedPies[e] = i, i;\n        }, e.prototype.dataFunc = function (t, e, i) {\n          var n = this.dataSettings;\n          if (n.dataFunction) n.dataFunction(t.id, t.limit, t.offset, e, i);else if (n.url) {\n            var r = [];\n            t.id && r.push([\"id\", t.id]), r.push([\"limit\", t.limit.toString(10)]), r.push([\"offset\", t.offset.toString(10)]), d.Data.doRequest(n.url, n, r, e, i);\n          } else i({\n            error: \"Chart configuration does not define data retrieval function\"\n          });\n        }, e.prototype.verifySlices = function (t, e, i) {\n          for (var n = !0, r = 0; r < t.length; r++) {\n            var s = t[r],\n                a = s.id ? \" Slice id: `\" + s.id + \"`\" : \"\";\n\n            if (d.Helpers.isObjectOrArray(s)) {\n              if (!this._isFacetChart) if (s.value = d.Helpers.tryParseFloat(s.value, null), null === s.value) {\n                if (!i) {\n                  d.Helpers.warn(\"Slices must have a numeric `value` property!\" + a), t.splice(r, 1), r--;\n                  continue;\n                }\n\n                this.chart.error(\"Slices must have a numeric `value` property!\" + a), n = !1;\n              } else if (s.value < 0) {\n                if (!i) {\n                  d.Helpers.warn(\"Slice values cannot be negative.\" + a), t.splice(r, 1), r--;\n                  continue;\n                }\n\n                this.chart.error(\"Slice values cannot be negative.\" + a), n = !1;\n              }\n              d.Helpers.hasProperty(s, \"id\") ? (s.__id = \"\" + s.id, d.Helpers.hasProperty(e, s.__id) && (this.chart.error(\"Multiple slices with the same ID.\" + a), n = !1), e[s.__id] = !0) : (s.__id = d.Helpers.SeparatorChar + this.nextId, this.nextId++), d.Helpers.hasProperty(s, \"subvalues\") && (Array.isArray(s.subvalues) ? this.verifySlices(s.subvalues, e, i) || (n = !1) : (this.chart.error(\"Field `subvalues` is not an array!\" + a), n = !1));\n            } else this.chart.error(\"Slices must be objects!\"), n = !1;\n          }\n\n          return n;\n        }, e.prototype.verifyData = function (t, e) {\n          if (d.Helpers.hasProperty(e, \"id\") || (e.id = t ? t.id : this.getRootId()), t && e.id && e.id !== t.id) return this.chart.error(\"Requested data for ID `\" + t.id + \"` but got data with ID `\" + e.id + \"`. Consider specifying `navigation.initialDrilldown`.\"), !1;\n\n          if (delete this.requestedPies[e.id], e.limit = d.Helpers.tryParseInt(e.limit, 1 / 0), e.offset = d.Helpers.tryParseInt(e.offset, 0), e.beforeSum = d.Helpers.tryParseFloat(e.beforeSum, null), e.afterSum = d.Helpers.tryParseFloat(e.afterSum, null), e.sum = d.Helpers.tryParseFloat(e.sum, null), !d.Helpers.hasProperty(e, \"subvalues\")) {\n            if (!d.Helpers.hasProperty(e, \"values\")) return this.chart.error(\"Field `subvalues` not set in root data object\"), !1;\n            d.Helpers.warn(\"Use of property `values` within PieChart data object is being deprecated. Please use `subvalues` instead.\", null, !0), e.subvalues = e.values;\n          }\n\n          if (!Array.isArray(e.subvalues)) return this.chart.error(\"Field `subvalues` is not an array!\"), !1;\n          var i = !0;\n          e.offset < 0 && (this.chart.error(\"Data `offset` must be greater or equal to 0.\"), i = !1), e.limit < 1 && (this.chart.error(\"Data `limit` must be greater than 0.\"), i = !1);\n          var n = e.offset > 0 || e.limit <= e.subvalues.length;\n          if (!this.verifySlices(e.subvalues, {}, n)) return !1;\n          var r = e.limit > e.subvalues.length,\n              s = e.offset + e.subvalues.length;\n\n          if (t && (e.offset >= t.offset + t.limit || t.offset >= s && !r) && (this.chart.error(\"Response and request do not overlap. Requested \" + t.limit + \" items starting at \" + t.offset + \". Received \" + e.subvalues.length + \" items starting at \" + e.offset), i = !1), d.Helpers.hasProperty(this.pies, e.id)) {\n            var a = this.pies[e.id];\n\n            if (a.values.length > 0) {\n              var o = a.offset + a.values.length;\n              (o < e.offset || s < a.offset && !r) && (this.chart.error(\"Data cannot be merged - there is a gap between old data and new data! Old data spans slices from \" + a.offset + \" to \" + (o - 1) + \"; new data spans slices from \" + e.offset + \" to \" + (s - 1) + \".\"), i = !1);\n            }\n          }\n\n          if (n && this.dataSettings.autoCategories && (this.chart.error(\"Cannot auto categorize partial data\"), i = !1), !this._isFacetChart && n) {\n            var l = (null == e.beforeSum ? 0 : 1) + (null == e.afterSum ? 0 : 1) + (null == e.sum ? 0 : 1);\n            l < 2 ? (this.chart.error(\"For partial loading, at least 2 of the following need to be set: beforeSum, afterSum, sum.\"), i = !1) : (e.__valuesSum = this.valueSum(e.subvalues), null == e.beforeSum ? e.beforeSum = e.sum - e.afterSum - e.__valuesSum : null == e.afterSum ? e.afterSum = e.sum - e.beforeSum - e.__valuesSum : null == e.sum && (e.sum = e.beforeSum + e.afterSum + e.__valuesSum), e.sum !== e.beforeSum + e.afterSum + e.__valuesSum && (this.chart.error(\"For partial loading, beforeSum + (sum of subvalues) + afterSum must equal sum!\"), i = !1), this._isFacetChart || (e.beforeSum < 0 && (this.chart.error(\"beforeSum cannot be negative!\"), i = !1), e.afterSum < 0 && (this.chart.error(\"afterSum cannot be negative!\"), i = !1), e.sum < 0 && (this.chart.error(\"sum cannot be negative!\"), i = !1)));\n          }\n\n          return i;\n        }, e.prototype.addVerifiedData = function (t, e) {\n          this.chart.scene.loading = this.hasPendingRequests();\n          var i = e.id,\n              n = {};\n          return n[i] = !0, t ? this.chart.log(\"Data arrived, id=\" + i + \", offset=\" + t.offset + \", len=\" + e.subvalues.length + \" of \" + (t.limit || \"unset\")) : this.chart.log(\"Data arrived, id=\" + i + \", offset=\" + e.offset + \", len=\" + e.subvalues.length + \" of \" + (e.limit || \"unset\")), this.dataSettings.autoCategories && (e = this.autoCategorize(e, this.dataSettings.autoCategories)), this.addDataInt(i, e.subvalues, e.offset, e.limit, e.afterSum, e.beforeSum, e.sum, e, n), {\n            pieChartPieIds: n\n          };\n        }, e.prototype.requestFailedPermanently = function (t) {\n          if (this.chart.scene.loading = this.hasPendingRequests(), t) {\n            var e = new o();\n            e.done = !0, this.pies[t.id] = e, this.chart.error(\"Data request failed for pie with ID `\" + t.id + \"`.\"), delete this.requestedPies[t.id];\n          } else this.chart.error(\"Data request failed.\");\n        }, e;\n      }(d.Data);\n\n      e.Data = l;\n\n      var h = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.marker = new u(), e.showOthers = !1, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegend);\n\n      e.SettingsLegend = h;\n\n      var u = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.shape = \"square\", e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLegendMarker);\n\n      e.SettingsLegendMarker = u;\n\n      var p = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e, i, null, null) || this;\n          return r.sliceHovered = !1, r.data = n, r;\n        }\n\n        return n(e, t), e.prototype.isHovered = function () {\n          return this.hoverCount > 0 || this.sliceHovered;\n        }, e;\n      }(d.LegendEntry),\n          f = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.paintOrder = 20, i.updateOrder = 1e3, i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (e) {\n          t.prototype.onSceneChange.call(this, e);\n          var i = e.changes;\n          i.pie && (this.rebuildItems(), i.bounds = !0);\n        }, e.prototype.getLastHoveredSlice = function () {\n          var t = this.getLastHoveredEntry();\n          return t ? t.data : null;\n        }, e.prototype.doAnimations = function () {\n          for (var t = this.chart.scene.hoverSlice, e = 0; e < this.entries.length; e++) {\n            this.entries[e].sliceHovered = this.entries[e].data === t;\n          }\n\n          for (var i = this.chart.scene.selection, e = 0; e < i.length; e++) {\n            var n = this.entryIndex[i[e].id];\n            n && (n.sliceHovered = !0);\n          }\n        }, e.prototype.paintMarker = function (t, e, i, n, r) {\n          var s = r.data,\n              a = {\n            fillColor: s.currentFillColor,\n            lineColor: this.settings.marker.lineColor\n          },\n              o = t.context;\n          o.beginPath();\n          var l = this.settings.marker.shape;\n          l || (l = \"circle\"), d.Graphics.strokeMarker(o, l, e, i, n), d.Graphics.paint(o, a);\n        }, e.prototype.rebuildItems = function () {\n          var t = [],\n              e = this.chart.scene.peek();\n\n          if (e) {\n            var i = this.settings.text.fillColor,\n                n = function n(t) {\n              return new p(t.data.nameLegend || t.label.text || t.data.name, i, t);\n            },\n                r = this.settings.showOthers,\n                s = e.slices,\n                a = e.previousSlice,\n                o = e.othersSlice;\n\n            r && a && !a.removed && t.push(n(a)), t.push.apply(t, s.map(n)), r && o && !o.removed && t.push(n(o));\n          }\n\n          this.entryIndex = {};\n\n          for (var l = 0; l < t.length; l++) {\n            this.entryIndex[t[l].data.id] = t[l];\n          }\n\n          this.resetEntries(t);\n        }, e.prototype.itemClicked = function (t, e) {}, e;\n      }(d.Legend);\n\n      e.Legend = f;\n\n      var g = function () {\n        function t() {\n          this.hwidth = 0, this.hheight = 0, this.x = null, this.y = null, this.userPlaced = !1, this.inside = !0;\n        }\n\n        return t;\n      }();\n\n      e.Icon = g;\n\n      var v = function () {\n        function t(t, e) {\n          this.id = null, this.pie = null, this.data = null, this.index = 0, this.value = 0, this.percent = null, this.fraction = 0, this.cutoutDistance = 0, this.selectDistance = 15, this.selection = 0, this.brightness = 1, this.expandable = !0, this.selected = !1, this.active = !1, this.removed = !1, this.icon = null, this.iconOffset = null, this.url = null, this.urlTarget = null, this.userPlaced = !1, this.inside = !0, this.x = 0, this.y = 0, this.originalId = null, this.currentCutoutDistance = null, this.currentFraction = null, this.currentInsideLabel = null, this.currentLabel = null, this.currentIcon = null, this.currentLineColor = null, this.currentFillColor = null, this.targetFillColor = null, this.targetLineColor = null, this._resetLabelText = !1, this._label = {\n            textStyle: {}\n          }, this._insideLabel = {\n            textStyle: {}\n          }, this.lineColor = null, this.fillColor = null, this.fillColor2 = null, this.lineWidth = 1, this.lineDash = null, this.lineBrightness = 0, this._animatorF = null, this._animatorLineColor = null, this._animatorFillColor = null, this._animatorCutout = null, this._renderParams = null, this.index = e, this.pie = t;\n        }\n\n        return Object.defineProperty(t.prototype, \"label\", {\n          get: function get() {\n            return this._label;\n          },\n          set: function set(t) {\n            d.Helpers.isObjectOrArray(t) ? this._label = t : (d.Helpers.warn(\"Slice.label should no longer be set to the text value - instead use Slice.label.text.\"), this._label.text = t ? \"\" + t : null, this._resetLabelText = !1);\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"insideLabel\", {\n          get: function get() {\n            return this._insideLabel;\n          },\n          set: function set(t) {\n            d.Helpers.isObjectOrArray(t) ? this._insideLabel = t : (d.Helpers.warn(\"Slice.insideLabel should no longer be set to the text value - instead use Slice.insideLabel.text.\"), this._insideLabel.text = t ? \"\" + t : null, this._resetLabelText && (this._resetLabelText = !1, this._label.text = null));\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"labelStyle\", {\n          get: function get() {\n            return d.Helpers.warn(\"Slice.labelStyle is deprecated - use Slice.label instead.\"), this._label;\n          },\n          set: function set(t) {\n            d.Helpers.warn(\"Slice.labelStyle is deprecated - use Slice.label instead.\"), t && (t.text || (t.text = this._label.text), d.Helpers.extendDeep(this._label, t));\n          },\n          enumerable: !0,\n          configurable: !0\n        }), Object.defineProperty(t.prototype, \"insideLabelStyle\", {\n          get: function get() {\n            return d.Helpers.warn(\"Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.\"), this._insideLabel;\n          },\n          set: function set(t) {\n            d.Helpers.warn(\"Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead.\"), t && (t.text || (t.text = this._insideLabel.text), d.Helpers.extendDeep(this._insideLabel, t));\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t;\n      }();\n\n      e.Slice = v;\n\n      var m = function () {\n        function t() {\n          this.id = null, this.data = null, this.total = 1, this.parentSlice = null, this.othersSlice = null, this.previousSlice = null, this.slices = [], this.allSlices = [], this.offset = 0, this.count = 0, this.background = !1, this.activeSliceId = null, this.brightness = 1, this.loading = !1, this.scrollOffset = 0, this.fillColor = null, this.x = 0, this.y = 0, this.startAngle = 0, this.endAngle = 0, this.rotationSpeed = 0, this.currentlyRotating = !1, this.currentStartAngle = null, this.currentEndAngle = null, this.currentRadius = 0, this.innerRadius = 0, this.radius = 0, this.currentInnerRadius = 0, this.colorDistribution = null, this.sliceColors = null, this.removed = !1, this.visibleFraction = 1, this.removeTime = null, this._animatorA0 = null, this._animatorA1 = null, this._animatorR0 = null, this._animatorR1 = null;\n        }\n\n        return t.prototype.getActiveSlice = function () {\n          if (!this.activeSliceId) return null;\n\n          for (var t = 0; t < this.slices.length; t++) {\n            var e = this.slices[t];\n            if (e.id === this.activeSliceId) return e;\n          }\n\n          return null;\n        }, t;\n      }();\n\n      e.Pie = m;\n\n      var y = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.radius = 100, e.innerRadius = 0, e.currentRadius = null, e.currentInnerRadius = null, e.pies = [], e.stack = [], e.selectionIds = [], e.hoverBack = !1, e.hoverSlice = null, e.hoverLabel = null, e.hoverPie = null, e.view = null, e.selection = [], e.pendingAction = null, e.pendingOffset = null, e;\n        }\n\n        return n(e, t), e.prototype.addPie = function (t) {\n          return this.pies.push(t), this.stack.push(t), t;\n        }, e.prototype.removePie = function (t) {\n          if (null !== t) {\n            t.removed = !0, t.removeTime = null, d.Helpers.removeFromArray(this.stack, t);\n\n            for (var e = 0; e < this.selection.length;) {\n              var i = this.selection[e];\n              i.pie === t ? d.Helpers.removeFromArray(this.selection, i) : e++;\n            }\n          }\n        }, e.prototype.deletePie = function (t) {\n          return d.Helpers.removeFromArray(this.pies, t), d.Helpers.removeFromArray(this.stack, t);\n        }, e.prototype.length = function () {\n          return this.stack.length;\n        }, e.prototype.peek = function () {\n          return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n        }, e.prototype.push = function (t, e) {\n          void 0 === e && (e = null);\n          var i = this.peek();\n          if (i && !e) for (var n = 0; n < i.slices.length; n++) {\n            var r = i.slices[n];\n\n            if (r.id === t.id) {\n              e = r;\n              break;\n            }\n          }\n\n          if (e) {\n            t.parentSlice = e;\n            var s = e.pie,\n                a = this.getSliceAngles(e);\n            t.currentStartAngle = a.a0, t.currentEndAngle = a.a1, t.currentRadius = s.currentRadius, t.currentInnerRadius = s.currentInnerRadius, i.activeSliceId = e.id;\n\n            for (var n = 0; n < t.allSlices.length; n++) {\n              var r = t.allSlices[n];\n              r.currentFillColor = e.currentFillColor, r.currentLineColor = e.currentLineColor;\n            }\n          } else i && (i.activeSliceId = null);\n\n          return i && (i.background = !0), this.addPie(t);\n        }, e.prototype.pop = function () {\n          if (0 !== this.stack.length) {\n            this.removePie(this.peek());\n            var t = this.peek();\n            t && (t.background = !1, t.brightness = 1);\n          }\n        }, e.prototype.getParent = function (t) {\n          for (var e = null, i = 0; i < this.stack.length; i++) {\n            var n = this.stack[i];\n            if (n === t) return e;\n            e = n;\n          }\n\n          return null;\n        }, e.prototype.getChild = function (t) {\n          for (var e = null, i = 0; i < this.stack.length; i++) {\n            var n = this.stack[i];\n            if (e === t) return n;\n            e = n;\n          }\n\n          return null;\n        }, e.prototype.updateOnPieChanged = function (t) {\n          var e = this.getParent(t),\n              i = this.getChild(t);\n          if (e && !t.parentSlice) for (var n = 0; n < e.slices.length; n++) {\n            var r = e.slices[n];\n\n            if (r.id === t.id) {\n              t.parentSlice = r, e.activeSliceId = r.id;\n              break;\n            }\n          }\n          if (i && !i.parentSlice) for (var n = 0; n < t.slices.length; n++) {\n            var r = t.slices[n];\n\n            if (r.id === i.id) {\n              i.parentSlice = r, t.activeSliceId = r.id;\n              break;\n            }\n          }\n        }, e.prototype.findPieAt = function (t, e, i) {\n          return this.view.findPieAt(t, e, i);\n        }, e.prototype.findSliceAt = function (t, e, i, n) {\n          return this.view.findSliceAt(t, e, i, n);\n        }, e.prototype.findLabelAt = function (t, e, i) {\n          return this.view.findLabelAt(t, e, i);\n        }, e.prototype.getSliceAngles = function (t) {\n          for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {\n            var s = i.allSlices[r];\n            if (n = e, e += s.currentFraction, s.id === t.id) break;\n          }\n\n          var a = i.currentEndAngle - i.currentStartAngle,\n              o = i.currentStartAngle;\n          return {\n            a0: o + a * n,\n            a1: o + a * e\n          };\n        }, e.prototype.getSliceTargetAngles = function (t) {\n          for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {\n            var s = i.allSlices[r];\n            if (n = e, e += s.currentFraction, s.id === t.id) break;\n          }\n\n          var a = i.currentEndAngle - i.currentStartAngle,\n              o = i.currentStartAngle;\n          return {\n            a0: o + a * n,\n            a1: o + a * e\n          };\n        }, e;\n      }(d.Scene);\n\n      e.Scene = y;\n\n      var S = function (t) {\n        function e(i) {\n          var n = t.call(this, d.SettingsMapping.PieChartSettings) || this;\n          return n.theme = e.FlatTheme, n.data = [], n.legend = new h(), n.navigation = {\n            initialDrilldown: [\"\"],\n            initialOffset: 0\n          }, n.pie = {\n            radius: null,\n            adaptiveRadius: !0,\n            outerMargin: 1,\n            margin: 2,\n            centerMargin: 5,\n            showInnerPiesExport: !0,\n            showInnerPies: !0,\n            innerRadius: .3,\n            innerRadiusWhenDrilldown: .2,\n            startAngle: -Math.PI / 2,\n            endAngle: 1.5 * Math.PI,\n            rotationSpeed: 0,\n            theme: \"flat\",\n            depth: 0,\n            x: null,\n            y: null,\n            style: {\n              fillColor: \"transparent\",\n              sliceColors: [\"#2fc32f\", \"#b0dc0b\", \"#eab404\", \"#de672c\", \"#ec2e2e\", \"#d5429b\", \"#6f52b8\", \"#1c7cd5\", \"#56b9f7\", \"#0ae8eb\"],\n              colorDistribution: \"list\",\n              brightness: 1\n            },\n            noDataStyle: {\n              fillColor: \"#ddd\"\n            },\n            backgroundStyle: {},\n            backgroundHoveredStyle: {\n              brightness: .7\n            },\n            styleFunction: null\n          }, n.slice = {\n            margin: 2,\n            minFraction: 0,\n            style: {\n              lineBrightness: 0,\n              brightness: 1,\n              lineWidth: 1,\n              label: {\n                backgroundStyle: null,\n                textStyle: {\n                  fillColor: \"#000\",\n                  font: \"12px Arial\"\n                },\n                lineSpacing: .2,\n                margin: 4,\n                padding: 0,\n                borderRadius: 999,\n                text: null\n              },\n              insideLabel: {\n                textStyle: {\n                  fillColor: \"#fff\",\n                  font: \"12px Arial\"\n                },\n                lineSpacing: .2,\n                margin: 4,\n                padding: 0,\n                borderRadius: 0,\n                text: null\n              }\n            },\n            hoverStyle: {\n              brightness: 1.2,\n              lineBrightness: 2,\n              lineWidth: .35\n            },\n            selectedStyle: null,\n            backgroundStyle: {\n              fillColor: \"#e2e2e2\",\n              fillColor2: \"#e0e0e0\",\n              fillGradient: null\n            },\n            backgroundActiveStyle: {\n              brightness: 1.3\n            },\n            othersStyle: {\n              fillColor: \"#ccc\",\n              lineDecoration: \"zigzag\"\n            },\n            previousStyle: {\n              fillColor: \"#ccc\",\n              lineDecoration: \"zigzag\"\n            },\n            connectorStyle: {\n              lineColor: \"#333\",\n              lineWidth: 1\n            },\n            expandableMarkStyle: {\n              lineWidth: 1,\n              lineColor: \"rgba(255,255,255,0.8)\",\n              distance: 4,\n              lineDash: null\n            },\n            styleFunction: null\n          }, n.filters = {\n            sliceFilter: null,\n            allowZeroValues: !1\n          }, n.labels = new b(), n.icons = {\n            sizeExtent: [16, 64],\n            placement: \"auto\",\n            autohideWhenTooSmall: !0\n          }, n.advanced = new L(), n.interaction = new w(), n.info = {\n            enabled: !0,\n            contentsFunction: null\n          }, n.events = new x(), n.toolbar = new d.SettingsToolbar(!1, [new d.SettingsToolbarItem(\"back\"), new d.SettingsToolbarItem(\"export\"), new d.SettingsToolbarItem(\"zoomOut\"), new d.SettingsToolbarItem(\"fullscreen\")]), n.localization = new C(), n.toolbar.zoomOut = !1, n.apply(i), n._initializing = !1, n;\n        }\n\n        return n(e, t), e.prototype.apply = function (e) {\n          this.applyCompatibility(e, [{\n            from: \"slice.labelStyle\",\n            to: \"slice.style.label\"\n          }, {\n            from: \"slice.insideLabelStyle\",\n            to: \"slice.style.insideLabel\"\n          }, {\n            from: \"labels.connectorStyle\",\n            to: \"slice.connectorStyle\"\n          }, {\n            from: \"labels.textStyle\",\n            to: \"slice.style.label.textStyle\"\n          }, {\n            from: \"labels.backgroundStyle\",\n            to: \"slice.style.label.backgroundStyle\"\n          }, {\n            from: \"labels.insideTextStyle\",\n            to: \"slice.style.insideLabel.textStyle\"\n          }, {\n            from: \"labels.padding\",\n            to: \"slice.style.label.padding\"\n          }, {\n            from: \"labels.borderRadius\",\n            to: \"slice.style.label.borderRadius\"\n          }, {\n            from: \"area.initialPieId\",\n            to: \"navigation.initialDrilldown\"\n          }, {\n            from: \"area.initialPieOffset\",\n            to: \"navigation.initialOffset\"\n          }, {\n            from: \"area.initialAnimation\",\n            to: \"advanced.initialAnimation\"\n          }, {\n            from: \"advanced.iconMinSize\",\n            alternative: \"icons.sizeExtent[0]\"\n          }, {\n            from: \"advanced.pointer.dragSensitivity\",\n            to: \"interaction.selection.swipeSensitivity\"\n          }]);\n          var i = t.prototype.apply.call(this, e);\n          return i;\n        }, e;\n      }(d.Settings);\n\n      S.FlatTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\",\n          assets: []\n        },\n        pie: {\n          theme: \"flat\",\n          depth: 0\n        }\n      }, S.DarkTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-dark\",\n          assets: []\n        },\n        area: {\n          style: {\n            fillColor: \"rgba(28,26,28,1)\"\n          }\n        },\n        title: {\n          margin: 15,\n          style: {\n            fillColor: \"#A8A7A8\"\n          }\n        },\n        pie: {\n          theme: \"flat\",\n          depth: 0,\n          style: {\n            sliceColors: [\"#32CD32\", \"#36BEFF\", \"#FBBD30\", \"#EE3431\", \"#894BBC\", \"#0EC9AC\", \"#524BBC\", \"#0b83ea\", \"#3ca20d\", \"#BC438F\"]\n          }\n        },\n        slice: {\n          connectorStyle: {\n            lineColor: \"#4C4C4C\"\n          },\n          style: {\n            label: {\n              textStyle: {\n                fillColor: \"#A8A7A8\"\n              }\n            }\n          }\n        },\n        legend: {\n          text: {\n            fillColor: \"#A8A7A8\"\n          },\n          marker: {\n            lineColor: null\n          }\n        }\n      }, S.RoundedTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\",\n          assets: []\n        },\n        pie: {\n          theme: \"rounded\",\n          depth: 0\n        }\n      }, S.BevelTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\",\n          assets: []\n        },\n        pie: {\n          theme: \"bevel\",\n          depth: 0\n        }\n      }, S.GradientTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\",\n          assets: []\n        },\n        pie: {\n          theme: \"smoothy\",\n          depth: 0\n        }\n      }, S.CanTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\",\n          assets: []\n        },\n        pie: {\n          theme: \"can\",\n          depth: 10\n        }\n      }, e.Settings = S;\n\n      var b = function () {\n        function t() {\n          this.enabled = !0, this.connectors = !0, this.connectorLength = 20, this.angle = 0, this.insideLabel = \"append\", this.insideLabelVisibilityFraction = .8, this.interLabelSpacing = .6, this.placement = \"aligned\";\n        }\n\n        return t;\n      }();\n\n      e.SettingsLabels = b;\n\n      var x = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.onPieChange = null, e.onPieReadyStateChanged = null, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsEvents);\n\n      e.SettingsEvents = x;\n\n      var C = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.othersLabel = \"Others\", e.previousLabel = \"Previous\", e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsLocalization);\n\n      e.SettingsLocalization = C;\n\n      var w = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.mode = \"drilldown\", e.coverCenter = !1, e.selection = {\n            enabled: !0,\n            tolerance: 2,\n            swipe: !1,\n            swipeSensitivity: 10,\n            partialSwipe: !1,\n            maxSwipeDistance: 45\n          }, e.animation = {\n            scrollDuration: 500,\n            hoverDuration: 200\n          }, e.others = {\n            enabled: !0,\n            centerGoesToPrevious: !1,\n            navigationFraction: .15,\n            maxSlicesVisible: 15,\n            minSlices: 1,\n            maxOthersFraction: .6,\n            minSliceFraction: .01\n          }, e.scrolling = {\n            enabled: !1\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsInteraction);\n\n      e.SettingsInteraction = w;\n\n      var L = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.iconMinSize = null, e.initialAnimation = !0, e.renderQuality = 1, e.backImage = \"builtin://piechart-back\", e.backImageBackground = null, e.backAlwaysVisible = !1, e.labelInsideTreshold = 1, e.builtinAssets[\"piechart-back\"] = c.PiechartBack, e.pointer.noClickOnDoubleClick = !1, e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsAdvanced);\n\n      e.SettingsAdvanced = L;\n\n      var T = function (t) {\n        function i(i) {\n          var n = t.call(this) || this;\n          return n.animationOrder = 1100, n.paintOrder = 10, n.updateOrder = 1200, n.currentSlice = null, n.currentLabel = null, n.currentPie = null, n.hoveringLegend = !1, n.draggedLabelSlice = null, n.draggedLabel = null, n.hoverEvent = null, n.dragStartConditions = {\n            angle: 1 / 0,\n            distance: 1 / 0,\n            slice: null,\n            pie: null\n          }, n.isScrolling = !1, n.px = 0, n.py = 0, n.chart = i, n.scene = i.scene, n.events = i.events, n.scrolling = new e.Scrolling(i), n;\n        }\n\n        return n(i, t), i.prototype.doAnimations = function (t) {\n          this.hoverEvent && this.onPointerMove(this.hoverEvent);\n        }, i.prototype.previewPointerDrag = function (t) {\n          this.hoverEvent = t;\n        }, i.prototype.onPointerMove = function (t) {\n          this.hoverEvent = t, this.updateCurrentObject(t);\n        }, i.prototype.onPointerOut = function (t) {\n          this.updateCurrentObject(t), this.switchCurrentSlice(null, null, !1, t), this.hoverEvent = null;\n        }, i.prototype.onPointerDown = function (t) {\n          this.handlePointerDown(t), this.scrolling.handlePointerDown(t);\n        }, i.prototype.handlePointerDown = function (t) {\n          this.updateCurrentObject(t);\n          var e = this.currentSlice;\n          (e || this.currentPie) && (t.consumed = !0), this.px = t.x, this.py = t.y;\n          var i = this.scene.settings.interaction.selection;\n\n          if (i.swipe || i.partialSwipe) {\n            var n = this.scene.settings.interaction,\n                r = this.scene.pies[0],\n                s = r && n.others.centerGoesToPrevious && r.previousSlice,\n                a = n.coverCenter && !s && (!r || !r.background),\n                o = this.scene.findSliceAt(t.x, t.y, n.selection.tolerance, a);\n\n            if (this.dragStartConditions.slice = null, this.dragStartConditions.pie = null, this.dragStartConditions.distance = 1 / 0, this.dragStartConditions.angle = 0, o && null !== o.id) {\n              this.dragStartConditions.slice = e, this.dragStartConditions.pie = r;\n              var l = t.x - r.x,\n                  h = t.y - r.y,\n                  u = Math.sqrt(l * l + h * h);\n              this.dragStartConditions.distance = u - e.currentCutoutDistance, this.dragStartConditions.angle = 180 * Math.atan2(h, l) / Math.PI;\n            }\n          }\n\n          var c = this.scene.findLabelAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);\n          this.draggedLabelSlice = c.slice, this.draggedLabel = c.label, this.draggedLabel = null, this.draggedLabelSlice = null;\n        }, i.prototype.onPointerDrag = function (t) {\n          this.handlePointerDrag(t), this.scrolling.handlePointerDrag(t);\n        }, i.prototype.handlePointerDrag = function (t) {\n          var e = this.scene.settings.interaction.selection;\n\n          if (!this.isScrolling) {\n            if (t.distance({\n              x: this.px,\n              y: this.py\n            }) < e.swipeSensitivity) return;\n            this.isScrolling = !0;\n          }\n\n          if ((e.swipe || e.partialSwipe) && (this.currentSlice || this.dragStartConditions.slice)) {\n            var i = this.dragStartConditions.slice;\n\n            if (null !== i) {\n              var n = this.dragStartConditions.pie,\n                  r = this.dragStartConditions.distance,\n                  s = this.dragStartConditions.angle;\n              s === 1 / 0 && (s = 180 * Math.atan2(t.y - n.y, t.x - n.x) / Math.PI);\n              var a = t.x - n.x,\n                  o = t.y - n.y,\n                  l = 180 * Math.atan2(o, a) / Math.PI,\n                  h = Math.abs(s - l);\n\n              if (h <= 90) {\n                var u = Math.sqrt(a * a + o * o);\n                this.dragStartConditions.distance === 1 / 0 && (r = u - i.currentCutoutDistance);\n                var c = this.scene.innerRadius >= i.selectDistance / 2 ? -i.selectDistance / 2 : 0,\n                    p = u * Math.cos(h * Math.PI / 180),\n                    f = p - r > e.maxSwipeDistance,\n                    g = p - r > c;\n                i.userPlaced = !0, f ? i.currentCutoutDistance = e.maxSwipeDistance : g && (i.currentCutoutDistance = p - r > c ? d.Helpers.trunc(p - r) : 0), i.selection = i.currentCutoutDistance > 0 ? i.currentCutoutDistance / e.maxSwipeDistance * 100 : 0, t.changes.pie = !0;\n              }\n            }\n          }\n\n          if (this.draggedLabel) {\n            var v = this.draggedLabel;\n            v.userPlaced = !0, v.x += t.dx, v.y += t.dy, t.consumed = !0, t.changes.pie = !0;\n          }\n        }, i.prototype.onPointerUp = function (t) {\n          this.handlePointerUp(t), this.scrolling.handlePointerUp(t);\n        }, i.prototype.handlePointerUp = function (t) {\n          this.isScrolling = !1;\n          var e = this.scene.settings.interaction.selection;\n\n          if (e.swipe || e.partialSwipe) {\n            var i = this.dragStartConditions.slice;\n\n            if (i) {\n              var n = i.currentCutoutDistance >= i.selectDistance / 2 && !i.selected,\n                  r = i.currentCutoutDistance < i.selectDistance / 2 && i.selected;\n              e.swipe || i.currentCutoutDistance <= 0 && e.partialSwipe ? i.userPlaced = !1 : e.partialSwipe && (i.userPlaced = !0), r || n ? this.updateSelection(t, i, !1) : i.currentCutoutDistance >= i.selectDistance / 2 && i.selected && this.setSelection([i], [], !0);\n            }\n          }\n\n          this.draggedLabel && (this.draggedLabel = null, t.consumed = !0);\n        }, i.prototype.onPointerCancel = function (t) {\n          this.onPointerUp(t);\n        }, i.prototype.defaultClick = function (t, e) {\n          var i = this.chart,\n              n = e.clickSlice,\n              r = e.clickPie,\n              s = \"drilldown\" === i.settings.interaction.mode;\n          if (s || n && (n === n.pie.othersSlice || n === n.pie.previousSlice)) if (n) {\n            if (n.url) d.Helpers.openUrl(n.url, n.urlTarget), t.preventDefault();else {\n              var a = i.settings.interaction.selection.enabled;\n              a && t.ctrlKey || !this.chart.navigator.expandSlice(n, \"user\") || t.preventDefault();\n            }\n          } else r && \"back\" === e.clickOrigin && (this.setSelection([], [], !1, \"user\"), this.chart.navigator.goCenter(\"user\"), t.preventDefault());\n        }, i.prototype.onClick = function (t) {\n          this.onPointerMove(t);\n          var e = this.createClickArgs(t);\n\n          if (\"legend\" !== e.clickOrigin || this.chart.settings.legend.interaction.click ? (this.chart.notifyClick(t, e), (this.currentSlice || this.currentPie) && (t.consumed = !0), t.defaultPrevented || this.updateSelection(t, this.currentSlice, !1)) : \"legend\" === e.clickOrigin && (e.clickSlice = null, e.clickPie = null, this.chart.notifyClick(t, e)), t.touch) {\n            var i = t.x;\n            t.x = 1e9, this.onPointerOut(t), t.x = i;\n          }\n        }, i.prototype.onLongPress = function (t) {\n          this.updateSelection(t, this.currentSlice, !1);\n        }, i.prototype.onRightClick = function (t) {\n          this.onPointerMove(t), (this.currentSlice || this.currentPie) && (t.consumed = !0), this.chart.notifyRightClick(t, this.createClickArgs(t)), t.defaultPrevented && (t.consumed = !0);\n        }, i.prototype.onDoubleClick = function (t) {\n          this.onPointerMove(t), this.chart.notifyDoubleClick(t, this.createClickArgs(t)), t.consumed = !0;\n        }, i.prototype.onTripleClick = function (t) {\n          this.onPointerMove(t), this.chart.notifyTripleClick(t, this.createClickArgs(t)), t.consumed = !0;\n        }, i.prototype.createClickArgs = function (t) {\n          var e = this.chart.createEventArguments(t, \"user\"),\n              i = e.hoverSlice;\n\n          if (e.clickSlice = i, e.clickPie = i ? i.pie : e.hoverPie, e.clickLabel = e.hoverLabel, i) {\n            var n = e.clickLabel;\n            this.hoveringLegend ? e.clickOrigin = \"legend\" : n ? n === i.currentInsideLabel ? e.clickOrigin = \"insideLabel\" : e.clickOrigin = \"label\" : e.clickOrigin = \"slice\";\n          } else this.scene.hoverBack && (e.clickOrigin = \"back\");\n\n          return e;\n        }, i.prototype.updateSelection = function (t, e, i) {\n          var n = this.scene,\n              r = n.settings.interaction;\n\n          if (r.selection.enabled) {\n            var s = t.shiftKey,\n                a = \"toggle\" === r.mode || t.ctrlKey;\n            e ? s || i && e.selected || a && !e.selected ? e.selected || (this.scene.selection.push(e), e.selected = !0, this.setSelection(n.selection, n.selectionIds, !0)) : a && e.selected ? (d.Helpers.removeFromArray(n.selection, e), e.selected = !1, this.setSelection(n.selection, n.selectionIds, !0)) : !e.selected || n.selection.length > 1 ? this.setSelection([e]) : this.setSelection([]) : s || a || this.setSelection([]);\n          }\n        }, i.prototype.switchCurrentSlice = function (t, e, i, n) {\n          t === this.currentSlice && e === this.currentLabel && this.hoveringLegend === i || (n.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverSlice = t, this.scene.hoverPie = null, this.scene.hoverLabel = e, this.currentSlice = t, this.currentLabel = e, this.currentPie = null, this.hoveringLegend = i, t && (t.active = !0), this.events.notifySceneChanges({\n            pie: !0\n          }), this.chart.notifyHoverChanged(n, this.chart.createEventArguments(n, \"user\")));\n        }, i.prototype.switchCurrentPie = function (t, e) {\n          t !== this.currentPie && (e.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverPie = t, this.scene.hoverSlice = null, this.currentSlice = null, this.currentPie = t, this.hoveringLegend = !1, t && (t.active = !0), this.events.notifySceneChanges({\n            pie: !0\n          }), this.chart.notifyHoverChanged(e, this.chart.createEventArguments(e, \"user\")));\n        }, i.prototype.onSceneChange = function (t) {\n          t.changes.pie && this.updateSelectionIds() && (this.events.notifySceneChanges({\n            selection: !0\n          }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, \"api\")));\n        }, i.prototype.updateSelectionIds = function () {\n          for (var t = [], e = 0; e < this.scene.selectionIds.length; e++) {\n            for (var i = this.scene.selectionIds[e], n = 0; n < this.scene.pies.length; n++) {\n              var r = this.scene.pies[n];\n              if (!r.background) for (var s = 0; s < r.slices.length; s++) {\n                var a = r.slices[s];\n\n                if (a.id === i) {\n                  t.push(a);\n                  break;\n                }\n              }\n            }\n          }\n\n          if (t.length > 0) for (var s = 0; s < t.length; s++) {\n            var a = t[s];\n            a.selected || (a.selected = !0, this.scene.selection.push(a)), d.Helpers.removeFromArray(this.scene.selectionIds, a.id);\n          }\n          return t.length > 0;\n        }, i.prototype.setSelection = function (t, e, i, n) {\n          void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = \"user\"), this.scene.selectionIds = e;\n          var r;\n          if (i) r = !0;else {\n            for (var s = 0; s < this.scene.selection.length; s++) {\n              var a = this.scene.selection[s];\n              t.indexOf(a) < 0 && (a.selected = !1, r = !0);\n            }\n\n            for (var s = 0; s < t.length; s++) {\n              var a = t[s];\n              a.selected || (a.selected = !0, r = !0);\n            }\n\n            this.scene.selection = t;\n          }\n          var o = this.updateSelectionIds();\n          r = r || o, r && (this.events.notifySceneChanges({\n            selection: !0\n          }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)));\n        }, i.prototype.updateCurrentObject = function (t) {\n          var e,\n              i = this.scene,\n              n = i.settings.interaction,\n              r = i.findPieAt(t.x, t.y, n.selection.tolerance),\n              s = r && n.others.centerGoesToPrevious && r.previousSlice,\n              a = n.coverCenter && !s && (!r || !r.background),\n              o = i.findLabelAt(t.x, t.y, n.selection.tolerance),\n              l = !1;\n          e = o.slice ? o.slice : i.findSliceAt(t.x, t.y, n.selection.tolerance, a);\n          var h = this.chart.legend;\n          !e && h && (e = h.getLastHoveredSlice(), e && (l = !0)), e && (this.chart.settings.legend.interaction.click && (t.cursor = \"pointer\"), t.hovered = !0), this.switchCurrentSlice(e, o.label, l, t), r && (r.background || s) && !e ? (t.cursor = \"pointer\", t.hovered = !0, r.background ? this.switchCurrentPie(r, t) : (this.switchCurrentSlice(r.previousSlice, null, !1, t), this.switchCurrentPie(null, t)), i.hoverBack = !0) : (this.switchCurrentPie(null, t), i.hoverBack = !1);\n        }, i;\n      }(d.ChartElement);\n\n      e.Selection = T;\n\n      var k = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 100, i.paintOrder = 25, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i;\n        }\n\n        return n(e, t), e.needStyleUpdate = function (t) {\n          return t.settings || t.pie || t.selection || t.style;\n        }, e.prototype.onSceneChange = function (t) {\n          if (e.needStyleUpdate(t.changes)) for (var i = 0; i < this.scene.pies.length; i++) {\n            var n = this.scene.pies[i];\n            this.updatePie(n), this.computePieColors(n);\n\n            for (var r = 0; r < n.allSlices.length; r++) {\n              var s = n.allSlices[r];\n              this.updateSlice(s, r);\n            }\n          }\n        }, e.prototype.updatePie = function (t) {\n          d.Helpers.extendStyleTo(this.scene.settings.pie.style, t), 0 === t.slices.length && d.Helpers.extendStyleTo(this.scene.settings.pie.noDataStyle, t), t.background && d.Helpers.extendStyleTo(this.scene.settings.pie.backgroundStyle, t), this.scene.hoverPie === t && d.Helpers.extendStyleTo(this.scene.settings.pie.backgroundHoveredStyle, t), this.scene.settings.pie.styleFunction && this.scene.settings.pie.styleFunction.call(this.chart.api, t, t.data);\n        }, e.prototype.computePieColors = function (t) {\n          for (var e = t.sliceColors, i = t.colorDistribution, n = 0, r = 0; r < t.slices.length; r++) {\n            var s = t.slices[r];\n            s.removed || (n += 1);\n          }\n\n          if (1 === n) return void (t.slices[0].fillColor = e[0]);\n\n          if (1 === e.length) {\n            var a = e[0];\n            e = [a, d.Colors.blend(a, \"#fff\", .8)];\n          }\n\n          var o = e.length;\n          if (\"gradient\" === i) for (var l = 0, r = 0; r < t.slices.length; r++) {\n            var s = t.slices[r];\n\n            if (!s.removed) {\n              var h = e[Math.floor(l * (o - 1))],\n                  u = e[Math.floor(l * (o - 1) + 1)],\n                  c = l * (o - 1);\n              c -= Math.floor(c);\n              var a = d.Colors.blend(h, u, c, !1);\n              s.fillColor = a, l += 1 / (n - .9);\n            }\n          } else if (\"gradientProportional\" === i) for (var l = 0, r = 0; r < t.slices.length; r++) {\n            var s = t.slices[r];\n\n            if (!s.removed) {\n              var h = e[Math.floor(l * (o - 1))],\n                  u = e[Math.floor(l * (o - 1) + 1)],\n                  c = l * (o - 1);\n              c -= Math.floor(c);\n              var a = d.Colors.blend(h, u, c, !1);\n              s.fillColor = a, l += s.fraction;\n            }\n          } else for (var p = 0; p < t.slices.length; p++) {\n            var s = t.slices[p];\n\n            if (!s.removed) {\n              var a = e[(t.offset + p) % o],\n                  f = Math.floor(p / o);\n              1 === f ? a = d.Colors.derive(a, 1.5, 1) : f >= 2 && (a = d.Colors.derive(a, .5, 1)), s.fillColor = a;\n            }\n          }\n        }, e.prototype.updateSlice = function (t, e) {\n          if (!t.removed) {\n            var i = t.pie,\n                n = this.scene.settings.slice,\n                r = n.styleFunction;\n            t.expandable = this.scene.mainData.canExpand(t.id), d.Helpers.extendDeep(t, n.style), t === i.othersSlice ? d.Helpers.extendDeep(t, n.othersStyle) : t === i.previousSlice && d.Helpers.extendDeep(t, n.previousStyle), i.total > 0 ? t.percent = t.value / i.total * 100 : t.percent = 0;\n            var s = t.label;\n            s.text ? s.text += \" \" : s.text = \"\", t.data.name && (s.text += t.data.name + \" \"), s.text += t.percent.toFixed(1) + \"%\", t.cutoutDistance = t.selected ? t.selectDistance : 0, this.scene.hoverSlice === t && d.Helpers.extendDeep(t, n.hoverStyle), t.data.style && d.SettingsHelper.updateRecursive(t, t.data.style, d.SettingsMapping.PieChartSettingsSliceStyle, {}), r && (t._resetLabelText = !0, r.call(this.chart.api, t, t.data)), i.background && (i.activeSliceId !== t.id ? (d.Helpers.extendDeep(t, n.backgroundStyle), e % 2 === 1 && (t.fillColor = t.fillColor2)) : d.Helpers.extendDeep(t, n.backgroundActiveStyle));\n            var a = \"rgba(255,255,255,0)\";\n            t.fillColor && (a = t.fillColor);\n            var o = \"rgba(255,255,255,0)\";\n            t.lineColor ? o = t.lineColor : t.lineBrightness && (o = d.Colors.derive(a, t.lineBrightness, 1));\n            var l = t.brightness * i.brightness;\n            1 !== l && (a = d.Colors.derive(a, l, 1), o = d.Colors.derive(o, l, 1), a.indexOf(\"255,255,255\") !== -1 && o.indexOf(\"255,255,255\") !== -1 && (o = \"rgb(200,200,200)\")), i.removed && i.parentSlice ? (t.targetFillColor = i.parentSlice.targetFillColor, t.targetLineColor = i.parentSlice.targetLineColor) : (t.targetFillColor = d.Colors.normalize(a), t.targetLineColor = d.Colors.normalize(o));\n          }\n        }, e;\n      }(d.ChartElement);\n\n      e.Styles = k;\n\n      var M = function (t) {\n        function e(e) {\n          return t.call(this, e) || this;\n        }\n\n        return n(e, t), e.prototype.createDom = function (e) {\n          t.prototype.createDom.call(this, e), this.backgroundImage.className += \" DVSL-PC-background-image\", this.backgroundImage.style.display = \"none\";\n        }, e.prototype.doAnimations = function (e) {\n          if (t.prototype.doAnimations.call(this, e), this.scene.settings.area.style.image && this.scene.pies.length > 0) {\n            var i = this.scene.currentInnerRadius - this.scene.settings.pie.margin,\n                n = this.scene.pies[0].x,\n                r = this.scene.pies[0].y;\n            (0 !== n || 0 !== r) && i > 0 ? (this.backgroundImage.style.left = Math.round(n - i) + \"px\", this.backgroundImage.style.top = Math.round(r - i) + \"px\", this.backgroundImage.style.width = Math.round(2 * i) + \"px\", this.backgroundImage.style.height = Math.round(2 * i) + \"px\", this.backgroundImage.style.display = \"\") : this.backgroundImage.style.display = \"none\";\n          }\n        }, e;\n      }(d.DomLayer);\n\n      e.DomLayer = M;\n\n      var A = function () {\n        function t(t) {\n          this.pie = null, this.chart = t, this.scene = t.scene, this.events = t.events;\n        }\n\n        return t.prototype.handlePointerDown = function (t) {\n          this.scene.settings.interaction.scrolling.enabled && (this.pointer || (this.pointer = t.identifier, this.pie = this.scene.peek()));\n        }, t.prototype.handlePointerDrag = function (t) {\n          this.pie && this.scene.settings.interaction.scrolling.enabled && (t.consumed = !0, t.identifier === this.pointer && (this.pie.scrollOffset += this.scene.view.getMovement(this.pie, t).dfraction, this.updatePieScrolling(this.pie), t.changes.pie = !0));\n        }, t.prototype.handlePointerUp = function (t) {\n          this.scene.settings.interaction.scrolling.enabled && t.identifier === this.pointer && (this.updatePieAfterScroll(this.pie), this.pie = null, this.pointer = null);\n        }, t.prototype.updatePieScrolling = function (t) {\n          if (t.scrollOffset > 0 && 0 === t.offset && (t.scrollOffset = 0), 0 !== t.scrollOffset) return this.scene.view.updatePie(this.pie, !1);\n        }, t.prototype.updatePieAfterScroll = function (t) {\n          return t.scrollOffset = 0, this.scene.view.updatePie(t, !0);\n        }, t;\n      }();\n\n      e.Scrolling = A;\n\n      var I = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 250, i.paintOrder = 30, i.updateOrder = 650, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n        }\n\n        return n(e, t), e.prototype.onNewDataObject = function () {}, e.prototype.setPie = function (t, e, i) {\n          Array.isArray(t) || (t = [t]), this.scene.pendingAction = null;\n\n          for (var n = 0; this.scene.length() > t.length;) {\n            this.scene.pop(), n++;\n          }\n\n          for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) {\n            this.scene.pop(), n++;\n          }\n\n          for (; this.scene.length() < t.length;) {\n            var r = new m();\n            r.id = t[this.scene.length()], r.offset = this.scene.length() + 1 === t.length ? e : 0, this.scene.push(r), this.scene.view.updatePie(r), n++;\n          }\n\n          var s = this.scene.peek();\n          s && s.offset !== e ? (this.scroll(s, e), n++) : n && s && this.scene.view.updatePie(s), n && (this.chart.notifyChartUpdate(i), this.events.notifySceneChanges({\n            pie: !0\n          }));\n        }, e.prototype.getPie = function () {\n          return this.scene.stack.map(function (t) {\n            return t.id;\n          });\n        }, e.prototype.getPieOffset = function () {\n          return this.scene.peek().offset;\n        }, e.prototype.goBack = function (t) {\n          var e = this.scene.length();\n          1 === e ? this.goPrevious(this.scene.peek(), t, 0) : e > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t));\n        }, e.prototype.goCenter = function (t) {\n          var e = this.scene.peek();\n          e.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious ? this.goPrevious(e, t) : this.scene.length() > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t));\n        }, e.prototype.drillDown = function (t, e) {\n          this.scene.pendingAction = null;\n          var i = new m();\n          i.id = t, i.offset = 0, this.scene.push(i), this.updateAndNotifyCurrent(e);\n        }, e.prototype.goOthers = function (t, e) {\n          var i = this.scene.view.scrollForward(t, t.offset + t.count);\n          i || (this.scene.pendingAction = \"forward\", this.scene.pendingOffset = null), this.events.notifySceneChanges({\n            pie: !0\n          }), this.chart.notifyChartUpdate(e);\n        }, e.prototype.goPrevious = function (t, e, i) {\n          if (void 0 === i && (i = null), !(t.offset <= 0)) {\n            var n = this.scene.view.scrollBackward(t, i);\n            n || (this.scene.pendingAction = \"back\", this.scene.pendingOffset = null), this.chart.notifyChartUpdate(e), this.events.notifySceneChanges({\n              pie: !0\n            });\n          }\n        }, e.prototype.scroll = function (t, e) {\n          var i = !0;\n          t.offset > e ? (i = this.scene.view.scrollBackward(t, e), i || (this.scene.pendingAction = \"back\", this.scene.pendingOffset = e)) : t.offset < e && (i = this.scene.view.scrollForward(t, e), i || (this.scene.pendingAction = \"forward\", this.scene.pendingOffset = e));\n        }, e.prototype.updateAndNotifyCurrent = function (t) {\n          var e = this.scene.peek();\n          this.scene.view.updatePie(e), this.chart.notifyChartUpdate(t), this.events.notifySceneChanges({\n            pie: !0\n          });\n        }, e.prototype.expandSlice = function (t, e) {\n          var i = t.pie;\n          if (i !== this.scene.peek()) return this.chart.setSelection([]), this.goBack(e), !0;\n          if (t === i.othersSlice) return this.chart.setSelection([]), this.goOthers(i, e), !0;\n          if (t === i.previousSlice) return this.chart.setSelection([]), this.goPrevious(i, e), !0;\n          var n = t.id;\n          return !(!t.expandable || !this.scene.mainData.canExpand(n)) && (this.chart.setSelection([]), this.drillDown(n, e), !0);\n        }, e.prototype.onSceneChange = function (t) {\n          var e = !1,\n              i = this.scene.peek();\n          if (t.changes.data || t.changes.pieChartPieIds || t.changes.dataArrived) for (var n = t.changes.pieChartPieIds || Object.create(null), r = 0; r < this.scene.stack.length; r++) {\n            var s = this.scene.stack[r];\n\n            if (n[s.id] || !s.data || s === i || t.changes.dataDeep) {\n              if (s === i) {\n                var a = void 0;\n                a = \"forward\" === this.scene.pendingAction ? this.scene.view.scrollForward(s, this.scene.pendingOffset) : \"back\" === this.scene.pendingAction ? this.scene.view.scrollBackward(s, this.scene.pendingOffset) : this.scene.view.updatePie(s), a && (this.scene.pendingAction = null, this.scene.pendingOffset = null), e = a;\n              } else this.scene.view.updatePie(s);\n\n              t.changes.pie = !0;\n            }\n          }\n          e && this.chart.notifyChartUpdate(\"data\", !0);\n        }, e;\n      }(d.Navigator);\n\n      e.Navigator = I;\n\n      var P = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.currentSlice = null, i.animationOrder = 500, i.paintOrder = 15, i.updateOrder = 1100, i.activePointer = null, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.events = e.events, i.popup = new d.InfoPopup(e), i;\n        }\n\n        return n(e, t), e.prototype.previewPointerMove = function (t) {\n          if (null === this.activePointer || this.activePointer === t.identifier) {\n            var e = t.y,\n                i = t.x;\n\n            if (this.options.info.enabled && (!this.chart.legend || !this.chart.legend.containsCoordinate(i, e))) {\n              var n = this.scene.hoverSlice,\n                  r = this.scene.hoverPie;\n              r && !n && (n = r.getActiveSlice()), this.setCurrentObject(i, e, n);\n            }\n          }\n        }, e.prototype.previewRightClick = function (t) {\n          t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t));\n        }, e.prototype.previewPointerCancel = function (t) {\n          null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n        }, e.prototype.previewPointerUp = function (t) {\n          null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null);\n        }, e.prototype.previewPointerDown = function (t) {\n          null === this.activePointer && (this.activePointer = t.identifier, this.hide());\n        }, e.prototype.previewPointerDrag = function (t) {\n          null !== this.activePointer && this.activePointer !== t.identifier || this.hide();\n        }, e.prototype.previewPointerOut = function (t) {\n          null !== this.activePointer && this.activePointer !== t.identifier || t.touch || this.hide();\n        }, e.prototype.hide = function () {\n          this.activePointer = null, this.setCurrentObject(0, 0, null);\n        }, e.prototype.setCurrentObject = function (t, e, i) {\n          if (i) {\n            if (i !== this.currentSlice) {\n              var n = this.buildContents(i);\n              this.popup.show(t, t, e, n);\n            } else this.popup.updateXY(t, t, e);\n\n            this.currentSlice = i;\n          } else this.currentSlice = null, this.popup.hide();\n        }, e.prototype.buildContents = function (t) {\n          var e = this;\n\n          if (this.options.info.contentsFunction) {\n            var i = function i(_i2) {\n              if (t === e.currentSlice) return e.popup.updateContents(_i2);\n            };\n\n            return this.options.info.contentsFunction.call(this.chart.api, t.data, t, i);\n          }\n\n          return t.label.text;\n        }, e.prototype.remove = function () {\n          this.popup.remove();\n        }, e;\n      }(d.ChartElement);\n\n      e.InfoPopup = P;\n\n      var D = function () {\n        function t(t) {\n          this.prevTime = 0, this.radiusAnimator = null, this.innerRadiusAnimator = null, this.chart = t, this.scene = t.scene, this.events = t.events;\n        }\n\n        return t.prototype.doAnimations = function (t) {\n          var e = 0;\n          this.prevTime && (e = Math.min(30, t.timeStamp - this.prevTime));\n          var i = this.scene.settings.interaction.animation.scrollDuration,\n              n = this.scene.settings.interaction.animation.hoverDuration,\n              r = t.timeStamp,\n              s = [],\n              a = [],\n              o = !1;\n\n          if (this.scene.settings.pie.adaptiveRadius) {\n            this.innerRadiusAnimator || (this.innerRadiusAnimator = new d.Animator(0, this.scene.innerRadius, i, \"<>\", r), this.radiusAnimator = new d.Animator(0, this.scene.radius, i, \"<>\", r));\n            var l = this.radiusAnimator.updateAndGet(this.scene.radius, r);\n            this.scene.currentRadius = l.value;\n            var h = l.changes;\n            l = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, r), this.scene.currentInnerRadius = l.value;\n            var u = l.changes;\n            o = o || h || u, t.animating = t.animating || o;\n          } else this.scene.currentRadius === this.scene.radius && this.scene.currentInnerRadius === this.scene.innerRadius || (o = !0, this.scene.currentRadius = this.scene.radius, this.scene.currentInnerRadius = this.scene.innerRadius);\n\n          for (var c = 0; c < this.scene.pies.length; c++) {\n            var p = this.scene.pies[c],\n                f = t.changes.bounds || k.needStyleUpdate(t.changes),\n                g = !1;\n            if (p.removed === !0 && null === p.removeTime && (p.removeTime = r + i), p.removed && (t.animating = !0, g = p.removeTime < r), g) s.push(p);else {\n              if (p._animatorA0 || (f = !0, p._animatorA0 = new d.Animator(p.currentStartAngle, p.startAngle, i, \"<>\", r), p._animatorA1 = new d.Animator(p.currentEndAngle, p.endAngle, i, \"<>\", r), p._animatorR0 = new d.Animator(p.currentInnerRadius, p.innerRadius, i, \"<>\", r), p._animatorR1 = new d.Animator(p.currentRadius, p.radius, i, \"<>\", r), this.scene.settings.advanced.initialAnimation || (p._animatorA0.jump(p.startAngle), p._animatorA1.jump(p.endAngle), p._animatorR0.jump(p.innerRadius), p._animatorR1.jump(p.radius))), p.rotationSpeed) {\n                if (null === p.currentStartAngle) p.currentStartAngle = p.startAngle, p.currentEndAngle = p.endAngle;else {\n                  var v = t.dtime * p.rotationSpeed / 1e3;\n                  p.currentStartAngle += v, p.currentEndAngle += v;\n                }\n                p.currentlyRotating = !0, f = !0;\n              } else if (p.currentlyRotating) {\n                var m = 2 * Math.PI;\n                p._animatorA0.reset(p.currentStartAngle % m - m, p.startAngle, t.timeStamp), p._animatorA1.reset(p.currentEndAngle % m, p.endAngle, t.timeStamp), p.currentlyRotating = !1, f = !0;\n              } else {\n                var y = p._animatorA0.updateAndGet(p.startAngle, r);\n\n                p.currentStartAngle = y.value, f = f || y.changes;\n\n                var S = p._animatorA1.updateAndGet(p.endAngle, r);\n\n                p.currentEndAngle = S.value, f = f || S.changes;\n              }\n\n              var b = p._animatorR1.updateAndGet(p.radius, r);\n\n              p.currentRadius = b.value, f = f || b.changes, b = p._animatorR0.updateAndGet(p.innerRadius, r), p.currentInnerRadius = b.value, f = f || b.changes, p.currentInnerRadius = Math.min(p.currentInnerRadius, p.currentRadius);\n\n              for (var x = [], C = 0, w = 0; w < p.allSlices.length; w++) {\n                var L = p.allSlices[w];\n                L._animatorF || (f = !0, L._animatorF = new d.Animator(L.currentFraction, L.fraction, i, \"<>\", r));\n\n                var T = L._animatorF.updateAndGetFixed(L.fraction, r);\n\n                L.currentFraction = T.value, f = f || T.changes, L.removed && 0 === L.currentFraction && x.push(L), C += L.currentFraction;\n              }\n\n              if (Math.abs(C - 1) > .001) {\n                C = 1 / C;\n\n                for (var w = 0; w < p.allSlices.length; w++) {\n                  var L = p.allSlices[w];\n                  L.currentFraction *= C;\n                }\n              }\n\n              if (x.length > 0) {\n                f = !0;\n\n                for (var w = 0; w < x.length; w++) {\n                  var L = x[w];\n                  d.Helpers.removeFromArray(p.slices, L), d.Helpers.removeFromArray(p.allSlices, L), L === p.othersSlice && (p.othersSlice = null), L === p.previousSlice && (p.previousSlice = null);\n                }\n              }\n\n              for (var w = 0; w < p.allSlices.length; w++) {\n                var L = p.allSlices[w];\n                L._animatorLineColor || (f = !0, L._animatorLineColor = new d.ColorAnimator(L.currentLineColor, L.targetLineColor, n, \"<>\", r), L._animatorFillColor = new d.ColorAnimator(L.currentFillColor, L.targetFillColor, n, \"<>\", r), L._animatorCutout = new d.Animator(L.currentCutoutDistance, L.cutoutDistance, n, \"<>\", r));\n                var M = L._animatorLineColor,\n                    A = L._animatorFillColor,\n                    I = L._animatorCutout,\n                    P = M.updateAndGet(L.targetLineColor, r);\n                if (L.currentLineColor = P.value, f = f || P.changes, P = A.updateAndGet(L.targetFillColor, r), L.currentFillColor = P.value, f = f || P.changes, L.userPlaced) I.jump(L.currentCutoutDistance);else {\n                  var l = I.updateAndGet(L.cutoutDistance, r);\n                  L.currentCutoutDistance = l.value, f = f || l.changes;\n                }\n              }\n\n              (f || o) && a.push(p), t.animating = t.animating || f;\n            }\n          }\n\n          for (var c = 0; c < s.length; c++) {\n            var p = s[c];\n            this.scene.deletePie(p);\n          }\n\n          return this.prevTime = r, a;\n        }, t;\n      }();\n\n      e.Animations = D;\n\n      var N = function () {\n        function t(t, e) {\n          this.view = e, this.chart = t, this.scene = t.scene, this.events = t.events;\n        }\n\n        return t.prototype.placeStack = function (t, e) {\n          var i = this.scene,\n              n = i.settings,\n              r = n.pie,\n              s = i.stack,\n              a = r.depth,\n              o = !1,\n              l = i.height - 2 * a;\n          l = Math.max(2, l);\n          var h = r.x,\n              u = r.y;\n          null === h ? h = i.x0 + i.width / 2 : h >= 0 && h <= 1 && (h = i.x0 + i.width * h), null === u ? u = i.y0 + l / 2 : u >= 0 && u <= 1 && (u = i.y0 + i.height * u);\n          var c = n.pie.startAngle,\n              d = n.pie.endAngle,\n              p = n.pie.rotationSpeed;\n          t.x === h && t.y === u && c === t.startAngle && d === t.endAngle && p === t.rotationSpeed || (o = !0, t.x = h, t.y = u, t.startAngle = c, t.endAngle = d, t.rotationSpeed = p);\n          var f = Math.min(l / 2, i.width / 2);\n          f -= n.pie.outerMargin;\n          var g = n.pie.radius;\n          if (g) g <= 1 && (g = f * g);else if (n.labels.enabled && n.pie.adaptiveRadius) {\n            var v = this.computeDesiredRadiusFromLabels(t, e);\n            v = Math.min(f, v), v -= n.labels.connectorLength, v = Math.max(v, f / 3), g = v;\n          } else g = f;\n          var m = n.pie.innerRadius;\n\n          if (m < 1 && (m = g * m), s.length > 1) {\n            var y = n.pie.innerRadiusWhenDrilldown;\n            y < 1 && (y = g * y), m = Math.max(m, y);\n          }\n\n          var S = 0,\n              b = 0;\n          g !== m && (S = 1 / (g - m), b = -m * S), i.radius === g && i.innerRadius === m || (o = !0, i.radius = g, i.innerRadius = m), t.radius = 1, t.innerRadius = m * S + b;\n          var x = s.length - 1;\n\n          if (x > 0) {\n            m -= n.pie.margin;\n\n            for (var C = x, w = Math.max(0, Math.min(g - m, (m - n.pie.centerMargin) / C)), L = x - 1; L >= 0; L--) {\n              g = m, m -= w, t = s[L], u += a, t.x = h, t.y = u, t.radius = g * S + b, t.innerRadius = (m + n.pie.margin) * S + b, t.brightness = .8 - .8 * (C - L - 1) / C, t.startAngle = n.pie.startAngle, t.endAngle = n.pie.endAngle;\n            }\n          }\n\n          for (x = 0; x < i.pies.length; x++) {\n            if (t = i.pies[x], t.removed && t.parentSlice) {\n              var T = i.getSliceTargetAngles(t.parentSlice);\n              t.startAngle = T.a0, t.endAngle = T.a1;\n            }\n          }\n\n          return o;\n        }, t.prototype.computeDesiredRadiusFromLabels = function (t, e) {\n          for (var i = this.scene.settings.slice.style.label, n = new F(e, 1, 0, 100, 0, 100, i, this.scene.settings.labels), r = 2 * i.padding, s = n.lineHeight + r, a = 0, o = 0, l = 0, h = 0, u = 0, c = t.startAngle, p = t.endAngle, f = p - c, g = t.startAngle, v = g, m = 0; m < t.slices.length; m++) {\n            var y = t.slices[m],\n                S = v;\n            u = Math.min(1, u + y.fraction), v = g + u * f;\n            var b = Math.max(S, c),\n                x = Math.min(v, p);\n\n            if (!(b >= p || x <= c) && y.label.text) {\n              for (var C = \"\", w = 0, L = y.label.text.split(\" \"); w < L.length; w++) {\n                var T = L[w];\n                T.length > C.length && (C = T);\n              }\n\n              var k = d.Graphics.getTextWidth(e, y.label.textStyle, C) + r,\n                  M = d.Graphics.getTextWidth(e, y.label.textStyle, y.label.text) + r,\n                  A = s * M * 1.2,\n                  I = ((b + x) / 2 + Math.PI / 2) % (2 * Math.PI) <= Math.PI;\n              I ? (h += A, o = Math.max(o, k)) : (l += A, a = Math.max(a, k));\n            }\n          }\n\n          d.Graphics.clearShadow(e);\n          var P = Math.min(this.scene.width, this.scene.height),\n              D = this.scene.width * P,\n              N = Math.max(1, D - 2 * Math.max(l, h) * 1.2),\n              O = Math.sqrt(N / Math.PI),\n              E = Math.max(a, o),\n              R = this.scene.width / 2 - 1.1 * E;\n          return Math.min(O, R);\n        }, t.prototype.placeLabels = function (t, e) {\n          if (this.chart.assetsLoaded) {\n            var i = this.scene.settings.icons,\n                n = this.scene.settings.labels,\n                r = this.scene.settings.slice,\n                s = n.enabled,\n                a = i.sizeExtent[0],\n                o = i.sizeExtent[1],\n                l = i.placement,\n                h = i.autohideWhenTooSmall;\n            this.scene.settings.advanced.iconMinSize && (a = this.scene.settings.advanced.iconMinSize);\n\n            for (var u = r.margin, c = t.x, p = t.y, f = this.scene.currentInnerRadius, v = this.scene.currentRadius - f, m = t.currentInnerRadius * v + f, y = t.currentRadius * v + f, S = 0, b = t.currentStartAngle, x = t.currentEndAngle, C = x - b, w = t.currentStartAngle, L = this.scene.x0 - c, T = L + this.scene.width, k = this.scene.y0 - p, M = k + this.scene.height, A = new F(e, y, L, T, k, M, r.style.insideLabel, this.scene.settings.labels), I = new F(e, y, L, T, k, M, r.style.label, this.scene.settings.labels), P = [], D = [], N = w, O = 0; O < t.allSlices.length; O++) {\n              var E = t.allSlices[O],\n                  R = N;\n              S = Math.min(1, S + E.currentFraction), N = w + S * C;\n              var H = Math.max(R, b),\n                  z = Math.min(N, x),\n                  B = m + E.currentCutoutDistance,\n                  U = y + E.currentCutoutDistance,\n                  G = (H + z) / 2;\n              if (E.removed || t.background) E.currentLabel = null, E.currentInsideLabel = null;else {\n                if (E.insideLabel.text && s) {\n                  var V = E.insideLabel.text,\n                      j = void 0;\n                  j = E.currentInsideLabel ? E.currentInsideLabel : E.currentInsideLabel = new d.Label(E.insideLabel, !0), E.currentInsideLabel.text !== V && (j.text = V);\n                  var W = A.fitLabelInSlice(e, j, B, U, H, z);\n                  j.shouldBeVisible = j.visible = \"always\" === n.insideLabel || W >= n.insideLabelVisibilityFraction;\n                } else E.currentInsideLabel = null;\n\n                var Z = E.label.text && s ? E.label.text : \"\";\n\n                if (\"append\" === n.insideLabel && E.insideLabel.text && s && !E.currentInsideLabel.userPlaced && !E.currentInsideLabel.shouldBeVisible && (Z ? (c = Math.cos(G), Z = c > 0 ? E.insideLabel.text + \", \" + Z : Z + \", \" + E.insideLabel.text) : Z = E.insideLabel.text), Z) {\n                  var j = null;\n                  j = E.currentLabel ? E.currentLabel : E.currentLabel = new d.Label(E.label, !0), E.currentLabel.text !== Z && (j.text = Z), j.userPlaced || I.placeOutsideLabelInitial(j, G), j.x > 0 ? (j.style.align = \"left\", D.push(j)) : (j.style.align = \"right\", P.push(j));\n                } else E.currentLabel = null;\n              }\n              var Y = null;\n\n              if (E.icon && (!t.background || E.id === t.activeSliceId)) {\n                var q = A.fitBoxInSlice(1, 1, B, U, H, z);\n                c = q.x, p = q.y;\n                var _ = q.prop;\n                _ -= u, (!h || 2 * _ >= a) && (_ = Math.max(Math.min(_, o / 2), a / 2), Y = new g(), Y.hwidth = _, Y.hheight = _, Y.inside = !0, E.iconOffset ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, E.iconOffset, B, U, H, z)) : \"center\" === l ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, [0, 0, 0, 0], B, U, H, z)) : (Y.x = c, Y.y = p));\n              }\n\n              E.currentIcon = Y;\n            }\n\n            I.computeOutsideLabelLocations(e, P, D);\n          }\n        }, t.prototype.applyOffset = function (t, e, i, n, r, s) {\n          var a = 0,\n              o = 0;\n          e.length >= 2 && (a = e[0], o = e[1]);\n          var l = 0,\n              h = 0;\n          e.length >= 4 && (l = e[2], h = e[3]);\n          var u = i + (n - i) * (l + 1) / 2,\n              c = r + (s - r) * (h + 1) / 2;\n          a += Math.cos(c) * u, o += Math.sin(c) * u, t.x += a, t.y += o;\n        }, t;\n      }();\n\n      e.PieLayout = N;\n\n      var F = function (t) {\n        function e(e, i, n, r, s, a, o, l) {\n          var h = t.call(this) || this;\n          return h.config = l, h.bottom = a, h.top = s, h.right = r, h.left = n, h.margin = o.margin || 0, h.rr = i + l.connectorLength, h.lineHeight = d.Graphics.getTextHeight(e, o.textStyle.font), h.interLabelSpacing = Math.max(l.interLabelSpacing * h.lineHeight, h.margin), h;\n        }\n\n        return n(e, t), e.prototype.placeOutsideLabelInitial = function (t, e) {\n          var i = this.rr * Math.cos(e),\n              n = this.rr * Math.sin(e),\n              r = 1;\n          n < this.top && (r = Math.min(r, this.top / n)), n > this.bottom && (r = Math.min(r, this.bottom / n)), i < this.left && (r = Math.min(r, this.left / i)), i > this.right && (r = Math.min(r, this.right / i)), t.x = i * r, t.y = n * r;\n        }, e.prototype.computeOutsideLabelLocations = function (t, e, i) {\n          var n = this.bottom - this.margin,\n              r = this.top + this.margin,\n              s = this.interLabelSpacing;\n          e.sort(function (t, e) {\n            return e.y - t.y;\n          }), i.sort(function (t, e) {\n            return t.y - e.y;\n          });\n\n          for (var a = 0; a < e.length; a++) {\n            var o = e[a];\n            o.originX = o.x;\n          }\n\n          for (var a = 0; a < i.length; a++) {\n            var o = i[a];\n            o.originX = o.x;\n          }\n\n          for (var l = \"wrap\" === this.config.placement ? [!1] : [!0, !1], h = 0; h < l.length; h++) {\n            for (var u = l[h], c = 100, d = !1, p = 0; p < 2; p++) {\n              for (var f = 0 === p ? e : i, a = 0; a < f.length; a++) {\n                var o = f[a];\n                o.prop = this.fitLabelOutside(t, o, u);\n              }\n\n              for (var g = n - r, v = [], m = 0, a = 0; a < f.length; a++) {\n                var o = f[a];\n\n                if (o.visible) {\n                  var y = 2 * o.hheight + s;\n                  m + y < g ? (v.push(o), m += y) : (o.visible = o.userPlaced, c = .5);\n                }\n              }\n\n              var S = n,\n                  b = r;\n              f === e ? b += m : S -= m;\n\n              for (var a = 0; a < v.length; a++) {\n                var o = v[a];\n\n                if (f === e ? b -= 2 * o.hheight + s : S += 2 * o.hheight + s, !o.userPlaced && (o.y + o.hheight > S || o.y - o.hheight < b)) {\n                  o.y = Math.min(Math.max(o.y, b + o.hheight), S - o.hheight);\n                  var x = this.fitLabelOutside(t, o, u);\n                  c = Math.min(x, c), d = d || o.rows && o.rows.subLines[o.rows.subLines.length - 1].row > 0;\n                } else c = Math.min(c, o.prop);\n\n                f === e ? S = o.y - o.hheight - s : b = o.y + o.hheight + s;\n              }\n            }\n\n            if (c >= 1 || !d) break;\n          }\n        }, e.prototype.fitLabelOutside = function (t, e, i) {\n          var n = this;\n          void 0 === i && (i = !1), null == i && (i = !1);\n\n          var r = function r(t) {\n            return e.userPlaced ? n.getOutsideMaxWidth(e.x, e.y, t, !1) : n.placeOutsideMaxWidth(e.originX, e.y, t, i);\n          };\n\n          return this.fitLabelInRect(t, e, r);\n        }, e.prototype.fitLabelInSlice = function (t, e, i, n, r, s) {\n          var a,\n              o = this,\n              l = Math.cos(r),\n              h = Math.cos(s),\n              u = Math.min(l, h),\n              c = Math.max(l, h);\n          a = u < 0 && c < 0 || -u > 2 * c ? \"right\" : u > 0 && c > 0 || 2 * -u < c ? \"left\" : \"center\";\n          var d, p;\n          if (e.userPlaced) d = e.x, p = e.y;else {\n            var f = void 0;\n            f = 2 * i >= n ? .5 : .5 + (n - 2 * i) / n / 4;\n            var g = i + (n - i) * f,\n                v = (r + s) / 2,\n                m = Math.cos(v),\n                y = Math.sin(v);\n            d = g * m, p = g * y;\n          }\n\n          var S = p - this.rayIntersectsSlice(d, p, 0, -1, i, n, r, s),\n              b = p + this.rayIntersectsSlice(d, p, 0, 1, i, n, r, s),\n              x = function x(t, e) {\n            if (!(n > 0) || e <= S || e >= b) return [1e-5, 1e-5];\n            var a = o.rayIntersectsSlice(t, e, -1, 0, i, n, r, s),\n                l = o.rayIntersectsSlice(t, e, 1, 0, i, n, r, s);\n            return [a, l];\n          };\n\n          return this.fitLabelInLines(t, e, d, p, \"center\", a, x);\n        }, e.prototype.placeOutsideMaxWidth = function (t, e, i, n) {\n          var r = this.rr,\n              s = e - i / 2,\n              a = s + i;\n\n          if (s < this.top) {\n            var o = this.top - s;\n            s += o, a += o;\n          }\n\n          if (a > this.bottom) {\n            var o = this.bottom - a;\n            s += o, a += o;\n          }\n\n          var l,\n              h = this.left,\n              u = this.right;\n          return l = n ? r : s > r || a < -r ? 0 : s > 0 ? Math.sqrt(r * r - s * s) : a < 0 ? Math.sqrt(r * r - a * a) : r, t > 0 ? h = Math.max(l, t) : u = Math.min(t, -l), {\n            x: (h + u) / 2,\n            y: (s + a) / 2,\n            dx: 1,\n            dy: 0,\n            width: u - h\n          };\n        }, e.prototype.getOutsideMaxWidth = function (t, e, i, n) {\n          var r,\n              s = e - i / 2,\n              a = s + i,\n              o = this.left,\n              l = this.right,\n              h = this.rr;\n          r = n ? h : s > h || a < -h ? 0 : s > 0 ? Math.sqrt(h * h - s * s) : a < 0 ? Math.sqrt(h * h - a * a) : h, t > 0 ? o = r : l = -r;\n          var u = Math.min(Math.abs(t - o), Math.abs(t - l));\n          return {\n            x: t,\n            y: e,\n            dx: 1,\n            dy: 0,\n            width: 2 * u\n          };\n        }, e.prototype.fitBoxInSlice = function (t, e, i, n, r, s) {\n          var a = .5 + (n - i) / n / 4,\n              o = i + (n - i) * a,\n              l = (r + s) / 2,\n              h = Math.cos(l),\n              u = Math.sin(l),\n              c = o * h,\n              d = o * u,\n              p = t,\n              f = e,\n              g = this.rayIntersectsSlice(c, d, p, f, i, n, r, s),\n              v = this.rayIntersectsSlice(c, d, -p, f, i, n, r, s),\n              m = this.rayIntersectsSlice(c, d, -p, -f, i, n, r, s),\n              y = this.rayIntersectsSlice(c, d, p, -f, i, n, r, s),\n              S = Math.min(g, v, m, y);\n          return {\n            x: c,\n            y: d,\n            prop: S\n          };\n        }, e.prototype.rayIntersectsSlice = function (t, e, i, n, r, s, a, o) {\n          var l = d.Geometry.rayIntersectsCircle(t, e, i, n, r);\n          l = Math.min(l, d.Geometry.rayIntersectsCircle(t, e, i, n, s));\n          var h = Math.cos(a),\n              u = Math.sin(a);\n          return l = Math.min(l, d.Geometry.rayIntersectsSegment(t, e, i, n, r * h, r * u, s * h, s * u)), h = Math.cos(o), u = Math.sin(o), l = Math.min(l, d.Geometry.rayIntersectsSegment(t, e, i, n, r * h, r * u, s * h, s * u));\n        }, e;\n      }(d.LabelLayoutBase);\n\n      e.LabelLayout = F, function (t) {\n        var e = function () {\n          function t(t) {\n            this.renderer = t, this.settings = this.renderer.settings;\n          }\n\n          return t.prototype.paintPie = function (t, e, i, n, r, s, a, o) {\n            o.fillColor && (t.beginPath(), t.arc(e, i, r, s, a, !1), t.arc(e, i, n, a, s, !0), t.closePath(), d.Graphics.fill(t, o));\n          }, t.prototype.paintExpandableHilights = function (t, e, i, n) {\n            var r = this.settings.slice.expandableMarkStyle.distance,\n                s = this.settings.slice.expandableMarkStyle;\n            if (!(s.lineWidth <= 0)) for (var a = 0; a < n.length; a++) {\n              var o = n[a];\n\n              if (o.expandable) {\n                var l = o._renderParams,\n                    h = e + o.x,\n                    u = i + o.y,\n                    c = l[0],\n                    p = l[1],\n                    f = Math.max((c + p) / 2, p - r),\n                    g = l[2],\n                    v = l[3];\n                t.beginPath(), t.arc(h, u, f, g, v), d.Graphics.paint(t, s);\n              }\n            }\n          }, t.prototype.strokeSlice = function (t, e, i, n) {\n            var r = n._renderParams;\n            e += n.x, i += n.y;\n            var s = r[0],\n                a = r[1],\n                o = r[2],\n                l = r[3],\n                h = r[4],\n                u = r[5],\n                c = a * Math.abs(l - o),\n                d = a - s,\n                p = Math.min(.1 * Math.min(c, d), 3);\n            s + a === -2 && (s = 0, a = 0), t.beginPath(), \"zigzag\" === n.lineDecoration ? this.strokeZigZag(t, e, i, a, p, o, l) : t.arc(e, i, a, o, l, !1), h === u ? t.lineTo(e + Math.cos(u) * s, i + Math.sin(h) * s) : t.arc(e, i, s, u, h, !0), t.closePath();\n          }, t.prototype.strokeZigZag = function (t, e, i, n, r, s, a) {\n            var o = 5 / n,\n                l = s;\n\n            for (t.moveTo(e + n * Math.cos(s), i + n * Math.sin(s)); l + o < a;) {\n              l += o, t.lineTo(e + (n + r) * Math.cos(l), i + (n + r) * Math.sin(l)), r = -r;\n            }\n\n            t.lineTo(e + n * Math.cos(a), i + n * Math.sin(a));\n          }, t.prototype.strokeAndPaint = function (t, e, i, n) {\n            var r = d.Graphics.beginStrokeAndFill(t, n);\n\n            if (this.strokeSlice(r, e, i, n), n.fillGradient) {\n              for (var s = t.createRadialGradient(e, i, n._renderParams[0], e, i, n._renderParams[1]), a = 0; a < n.fillGradient.length; a++) {\n                var o = n.fillGradient[a];\n                s.addColorStop(o[0], o[1]);\n              }\n\n              n.fillColor = s;\n            }\n\n            d.Graphics.endStrokeAndFill(t, r, n);\n          }, t;\n        }();\n\n        t.CommonBase = e;\n\n        var i = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n            for (var r = 0; r < n.length; r++) {\n              var s = n[r];\n              this.strokeAndPaint(t, e, i, s);\n            }\n          }, e;\n        }(e);\n\n        t.Flat = i;\n\n        var r = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.paintPie = function (e, i, n, r, s, a, o, l) {\n            t.prototype.paintPie.call(this, e, i, n, r, s, a, o, l);\n            var h = this.settings.pie.depth;\n\n            if (h > 0 && l.allSlices.length > 0) {\n              e.fillStyle = \"rgba(0,0,0,0.05)\";\n\n              for (var u = 0; u < [5, 10, 18].length; u++) {\n                var c = [5, 10, 18][u];\n                e.beginPath(), e.arc(i, n + c + h, s, a, o, !1), e.arc(i, n + c + h, r, o, a, !0), e.closePath(), e.fill();\n              }\n            }\n          }, e.prototype.paintSlices = function (t, e, i, n) {\n            var r = this.settings.pie.depth,\n                s = 2 * this.settings.advanced.renderQuality,\n                a = 1 / s,\n                o = r * s;\n            t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 1.5 * r, t.shadowColor = \"black\", t.fillStyle = \"black\";\n\n            for (var l = 0; l < n.length; l++) {\n              var h = n[l];\n              this.strokeSlice(t, e, i + r, h), t.fill();\n            }\n\n            t.shadowColor = null, t.shadowBlur = 0, t.lineWidth = 1;\n\n            for (var u = 0; u <= o; u++) {\n              for (var l = 0; l < n.length; l++) {\n                var h = n[l];\n                h.fillColor instanceof CanvasGradient ? d.Helpers.error(\"slice.fillColor cannot be gradient if `can` renderer is used\") : (this.strokeSlice(t, e, i + r - u * a, h), u >= o - 1 ? t.strokeStyle = d.Colors.derive(h.fillColor, 1.35, 1) : t.strokeStyle = d.Colors.derive(h.fillColor, .5 + u / o * .2, 1), t.stroke());\n              }\n            }\n\n            var c = Math.PI;\n            t.shadowBlur = r, t.shadowColor = \"rgba(0,0,0,0.1)\", t.fillStyle = \"black\";\n\n            for (var l = 0; l < n.length; l++) {\n              var h = n[l],\n                  p = h._renderParams,\n                  f = p[4],\n                  g = p[5];\n\n              if (f !== g) {\n                for (; f > c;) {\n                  f -= 2 * c, g -= 2 * c;\n                }\n\n                f < 0 ? g > 0 && (g = Math.min(g, c), this.strokeInnerShadowSlice(t, e, i, h, 0, g) && t.fill()) : g < c ? this.strokeInnerShadowSlice(t, e, i, h, f, g) && t.fill() : (f < c && this.strokeInnerShadowSlice(t, e, i, h, f, c) && t.fill(), g > 2 * c && this.strokeInnerShadowSlice(t, e, i, h, 2 * c, g) && t.fill());\n              }\n            }\n\n            for (var l = 0; l < n.length; l++) {\n              var h = n[l];\n              this.strokeAndPaint(t, e, i, h);\n            }\n          }, e.prototype.strokeInnerShadowSlice = function (t, e, i, n, r, s) {\n            var a = n._renderParams,\n                o = a[0] + 1,\n                l = Math.min(a[1] - 1, o + 10);\n            return !(o >= a[1] || l <= a[0]) && (r += 1 / o, s -= 1 / o, r >= s ? void 0 : (t.beginPath(), t.arc(e, i, l, r, s, !1), t.arc(e, i, o, s, r, !0), t.closePath(), !0));\n          }, e;\n        }(e);\n\n        t.Can = r;\n\n        var s = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n            this.g = t;\n\n            for (var r = 0; r < n.length; r++) {\n              var s = n[r];\n              this.strokeAndPaint(t, e, i, s), this.elegantGradient(e, i, s);\n            }\n          }, e.prototype.getRadialGradient = function (t, e, i, n, r, s, a) {\n            var o = Math.abs(Math.sin(a)),\n                l = this.g.createRadialGradient(t, e, i, n, r, s);\n            return this.addColorStops(l, o, a), l;\n          }, e.prototype.getLinearGradient = function (t, e, i, n, r, s, a, o) {\n            var l = a - n,\n                h = Math.sin(o),\n                u = Math.cos(o),\n                c = e + u * n,\n                d = i + h * n,\n                p = c + u * l,\n                f = d + h * l,\n                g = Math.abs(h),\n                v = this.g.createLinearGradient(c, d, p, f);\n            return this.addColorStops(v, g, o), v;\n          }, e.prototype.addColorStops = function (t, e, i) {\n            var n = \"0,0,0\",\n                r = \"255,255,255\",\n                s = r,\n                a = n;\n            (i <= 0 || i > Math.PI) && (s = n, a = r);\n            var o = .4 * e,\n                l = .2 * e,\n                h = .1 * e,\n                u = .3 * e,\n                c = .5 * e;\n            t.addColorStop(0, \"rgba(\" + s + \",\" + o.toFixed(3) + \")\"), t.addColorStop(.1, \"rgba(\" + s + \",\" + l.toFixed(3) + \")\"), t.addColorStop(.1, \"rgba(\" + s + \",\" + h.toFixed(3) + \")\"), t.addColorStop(.4, \"rgba(\" + n + \",0.1)\"), t.addColorStop(.9, \"rgba(\" + a + \",\" + h.toFixed(3) + \")\"), t.addColorStop(.95, \"rgba(\" + a + \",\" + u.toFixed(3) + \")\"), t.addColorStop(1, \"rgba(\" + a + \",\" + c.toFixed(3) + \")\");\n          }, e.prototype.elegantGradient = function (t, e, i) {\n            for (var n = i._renderParams[0], r = i._renderParams[1], s = i._renderParams[2], a = i._renderParams[3], o = this.settings.advanced.renderQuality, l = Math.PI / Math.max(1, 180 * o), h = s; h < a;) {\n              var u = Math.min(h + l, a);\n              this.g.beginPath(), this.g.arc(t, e, r, h, u), this.g.arc(t, e, n, u, h, !0), this.g.closePath(), d.Graphics.paint(this.g, {\n                fillColor: this.getRadialGradient(t, e, n, t, e, r, h)\n              }), h = u;\n            }\n          }, e;\n        }(e);\n\n        t.Smoothy = s;\n\n        var a = function (t) {\n          function e() {\n            return t.apply(this, arguments) || this;\n          }\n\n          return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {\n            this.g = t;\n\n            for (var r = 0; r < n.length; r++) {\n              var s = n[r];\n              this.strokeAndPaint(t, e, i, s), this.smartGradient(e, i, s);\n            }\n          }, e.prototype.getSmartGradient = function (t, e, i, n, r, s) {\n            var a,\n                o,\n                l = 0,\n                h = 0,\n                u = 0,\n                c = 0;\n            \"inside\" === r ? \"top\" === s ? (u = n - i, c = e, a = \"rgba(0,0,0,0.3)\", o = \"rgba(0,0,0,0)\") : (u = e, c = e + i, a = \"rgba(255,255,255,0)\", o = \"rgba(255,255,255,0.3)\") : \"top\" === s ? (c = e, a = \"rgba(255,255,255,0.3)\", o = \"rgba(255,255,255,0)\") : (u = e, c = e + n, a = \"rgba(0,0,0,0)\", o = \"rgba(0,0,0,0.3)\");\n\n            try {\n              var d = this.g.createLinearGradient(l, u, h, c);\n              return d.addColorStop(0, a), d.addColorStop(1, o), d;\n            } catch (t) {\n              throw \"Could not create linear gradient: \" + t;\n            }\n          }, e.prototype.smartOuterShineTop = function (t, e, i, n, r, s, a, o) {\n            if (!(r > 0 && s < Math.PI)) {\n              s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);\n              var l = {\n                _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],\n                x: 0,\n                y: 0,\n                fillColor: this.getSmartGradient(t, e, i, n, \"outside\", \"top\")\n              };\n              this.strokeAndPaint(this.g, t, e, l);\n            }\n          }, e.prototype.smartOuterShineBottom = function (t, e, i, n, r, s, a, o) {\n            if (!(s < 0 || r > Math.PI)) {\n              r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);\n              var l = {\n                _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],\n                x: 0,\n                y: 0,\n                fillColor: this.getSmartGradient(t, e, i, n, \"outside\", \"bottom\")\n              };\n              this.strokeAndPaint(this.g, t, e, l);\n            }\n          }, e.prototype.smartInnerShineTop = function (t, e, i, n, r, s, a, o) {\n            if (!(r > 0 && s < Math.PI)) {\n              s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);\n              var l = {\n                _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],\n                x: 0,\n                y: 0,\n                fillColor: this.getSmartGradient(t, e, i, n, \"inside\", \"top\")\n              };\n              this.strokeAndPaint(this.g, t, e, l);\n            }\n          }, e.prototype.smartInnerShineBottom = function (t, e, i, n, r, s, a, o) {\n            if (!(s < 0 || r > Math.PI)) {\n              r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);\n              var l = {\n                _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],\n                x: 0,\n                y: 0,\n                fillColor: this.getSmartGradient(t, e, i, n, \"inside\", \"bottom\")\n              };\n              this.strokeAndPaint(this.g, t, e, l);\n            }\n          }, e.prototype.smartGradient = function (t, e, i) {\n            t += i.x, e += i.y;\n            var n = i._renderParams[0],\n                r = i._renderParams[1],\n                s = i._renderParams[2],\n                a = i._renderParams[3],\n                o = i._renderParams[4],\n                l = i._renderParams[5];\n            this.smartOuterShineTop(t, e, n, r, s, a, o, l), this.smartOuterShineBottom(t, e, n, r, s, a, o, l), this.smartInnerShineTop(t, e, n, r, s, a, o, l), this.smartInnerShineBottom(t, e, n, r, s, a, o, l);\n          }, e;\n        }(e);\n\n        t.Bevel = a;\n\n        var o = function (t) {\n          function e() {\n            var e = t.apply(this, arguments) || this;\n            return e.currentSliceIndex = 0, e.inverseZeroSliceCap = !1, e;\n          }\n\n          return n(e, t), e.prototype.paintPie = function (t, e, i, n, r, s, a, o) {\n            o.fillColor && (t.beginPath(), t.arc(e, i, r, s, a, !1), t.arc(e, i, n, a, s, !0), t.closePath(), d.Graphics.fill(t, o)), this.settings.pie.endAngle - this.settings.pie.startAngle != 2 * Math.PI ? this.inverseZeroSliceCap = !0 : this.inverseZeroSliceCap = !1;\n          }, e.prototype.paintSlices = function (t, e, i, n) {\n            for (var r = 0; r < n.length; r++) {\n              var s = n[r];\n              this.currentSliceIndex = r, this.strokeAndPaint(t, e, i, s);\n            }\n          }, e.prototype.strokeSlice = function (t, e, i, n) {\n            var r = n._renderParams;\n            e += n.x, i += n.y;\n            var s = r[0],\n                a = r[1],\n                o = r[2],\n                l = r[3],\n                h = r[4],\n                u = r[5],\n                c = a * Math.abs(l - o),\n                d = a - s,\n                p = Math.min(.1 * Math.min(c, d), 3);\n            s + a === -2 && (s = 0, a = 0), t.beginPath(), \"zigzag\" === n.lineDecoration ? this.strokeZigZag(t, e, i, a, p, o, l) : t.arc(e, i, a, o, l, !1);\n            var f = (a - s) / 2,\n                g = s + f;\n\n            if (f > 0) {\n              var v = e + Math.cos(u) * g,\n                  m = i + Math.sin(u) * g;\n              t.arc(v, m, f, l, l + Math.PI, !1);\n            }\n\n            if (h === u ? t.lineTo(e + Math.cos(u) * s, i + Math.sin(h) * s) : t.arc(e, i, s, u, h, !0), f > 0) {\n              var v = e + Math.cos(h) * g,\n                  m = i + Math.sin(h) * g;\n              0 == this.currentSliceIndex && this.inverseZeroSliceCap ? t.arc(v, m, f, h + Math.PI, h, !1) : t.arc(v, m, f, h + Math.PI, h, !0);\n            }\n\n            t.closePath();\n          }, e.prototype.paintExpandableHilights = function (t, e, i, n) {\n            var r = this.settings.slice.expandableMarkStyle.distance,\n                s = this.settings.slice.expandableMarkStyle;\n            if (!(s.lineWidth <= 0)) for (var a = 0; a < n.length; a++) {\n              var o = n[a];\n\n              if (o.expandable) {\n                var l = o._renderParams,\n                    h = e + o.x,\n                    u = i + o.y,\n                    c = l[0],\n                    p = l[1],\n                    f = Math.max((c + p) / 2, p - r),\n                    g = (p - c) / 2,\n                    v = (Math.asin(g / c), p - r),\n                    m = c + g,\n                    y = g,\n                    S = (m * m - y * y - v * v) / (-2 * v),\n                    b = Math.sqrt(y * y - S * S),\n                    x = Math.atan(b / (v - S)),\n                    C = l[2];\n                0 == a && this.inverseZeroSliceCap ? C -= x : C += x;\n                var w = l[3] + x;\n                if (C > w) return;\n                t.beginPath(), t.arc(h, u, f, C, w), d.Graphics.paint(t, s);\n              }\n            }\n          }, e;\n        }(e);\n\n        t.Rounded = o;\n      }(r = e.Renderers || (e.Renderers = {}));\n\n      var O = function () {\n        function t(t) {\n          this.renderer = null, this.chart = t, this.settings = t.settings, this.scene = t.scene;\n        }\n\n        return t.prototype.onSceneChange = function (t) {\n          t.changes.settings && this.buildSeries();\n        }, t.prototype.buildSeries = function () {\n          var t = this.settings.pie.theme,\n              e = t.charAt(0).toUpperCase() + t.slice(1);\n\n          try {\n            this.renderer = new i.PieChart.Renderers[e](this);\n          } catch (e) {\n            throw \"Renderer \" + t + \" is not available: \" + e;\n          }\n        }, t.prototype.paintScene = function (t) {\n          for (var e = t.context, i = t.labelRenderer, n = t.isExport ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies, r = !1, s = 0; s < this.scene.pies.length; s++) {\n            var a = this.scene.pies[s];\n            !n && a.background || this.paintPie(e, i, a), r = r || a.background;\n          }\n\n          !t.isExport && (this.scene.hoverBack || this.scene.settings.advanced.backAlwaysVisible && r) && this.paintBackArrow(t);\n        }, t.prototype.paintBackArrow = function (t) {\n          var e = this.scene.assetsLoader.getAssetImage(this.scene.settings.advanced.backImage);\n\n          if (e) {\n            var i = this.scene.pies[this.scene.pies.length - 1],\n                n = .707106781186547,\n                r = i.x,\n                s = i.y,\n                a = this.settings.pie.depth;\n            s += (this.scene.pies.length - 1) * a;\n            var o = e.width / 2,\n                l = e.height / 2,\n                h = i.innerRadius * n,\n                u = Math.min(o, Math.max(h, o / 2)) / o,\n                c = Math.min(l, Math.max(h, l / 2)) / l,\n                p = Math.min(u, c),\n                f = t.context;\n\n            if (this.settings.advanced.backImageBackground) {\n              var g = this.settings.slice.margin,\n                  v = this.scene.currentInnerRadius,\n                  m = this.scene.currentRadius - v,\n                  y = Math.max(this.scene.pies[0].currentInnerRadius * m + v, g / 2);\n              f.beginPath(), f.arc(r, s, y, 0, 2 * Math.PI), f.closePath(), f.fillStyle = this.settings.advanced.backImageBackground, f.fill();\n            }\n\n            f.globalAlpha = .5, d.Graphics.drawImageHighQuality(f, e, r - o * p, s - l * p, 2 * o * p, 2 * l * p), f.globalAlpha = 1;\n          }\n        }, t.prototype.paintPie = function (t, e, i) {\n          var n = this.settings.slice.margin;\n          i.allSlices.length < 2 && (n = 0);\n          var r = this.scene.currentInnerRadius,\n              s = this.scene.currentRadius - r,\n              a = Math.max(i.currentInnerRadius * s + r, n / 2),\n              o = i.currentRadius * s + r,\n              l = i.currentStartAngle,\n              h = i.currentEndAngle,\n              u = h - l,\n              c = l;\n\n          if (o > 0 && u > 0) {\n            for (var p = a > 0 ? 1 / a : 0, f = 1 / o, g = n / 2 * p, v = n / 2 * f, m = [], y = 0; y < i.allSlices.length; y++) {\n              var S = i.allSlices[y],\n                  b = S.currentFraction * u;\n\n              if (!(S.currentFraction <= 0)) {\n                var x = c;\n                c += b;\n                var C = a + S.currentCutoutDistance,\n                    w = o + S.currentCutoutDistance,\n                    L = void 0,\n                    T = void 0;\n\n                if (b <= 4 * v) {\n                  var k = (x + c) / 2,\n                      M = b / 4;\n                  L = k - M, T = k + M;\n                } else L = x + v, T = c - v;\n\n                var A = x + g,\n                    I = c - g;\n                A > I && (A = I = (A + I) / 2), T < l || L > h || (L = Math.max(L, l), T = Math.min(T, h), A = Math.max(A, l), I = Math.min(I, h), A > I && (A = I = (A + I) / 2), S._renderParams = [C, w, L, T, A, I, S.fillColor, S.lineColor], S.fillColor = S.currentFillColor, S.lineColor = S.currentLineColor, m.push(S));\n              }\n            }\n\n            var P = i.x,\n                D = i.y;\n            this.renderer.paintPie(t, P, D, a, o, i.currentStartAngle, i.currentEndAngle, i), this.renderer.paintSlices(t, P, D, m), i === this.scene.peek() && this.renderer.paintExpandableHilights(t, P, D, m);\n\n            for (var N = 0; N < m.length; N++) {\n              var F = m[N];\n              F.fillColor = F._renderParams[6], F.lineColor = F._renderParams[7];\n            }\n\n            if (!i.removed) {\n              d.Graphics.clearShadow(t);\n\n              for (var y = 0; y < i.allSlices.length; y++) {\n                var S = i.allSlices[y];\n\n                if (S.currentIcon) {\n                  var O = this.scene.assetsLoader.getAssetImage(S.icon);\n\n                  if (O) {\n                    var E = S.currentIcon,\n                        R = P + E.x,\n                        H = D + E.y,\n                        z = Math.min(O.width / 2, E.hwidth),\n                        B = Math.min(O.height / 2, E.hheight);\n                    d.Graphics.drawImageHighQuality(t, O, R - z, H - B, 2 * z, 2 * B);\n                  }\n                }\n              }\n\n              c = l;\n\n              for (var y = 0; y < i.allSlices.length; y++) {\n                var S = i.allSlices[y],\n                    b = S.currentFraction * u,\n                    x = c;\n                c = x + b;\n                var U = Math.max(x, l),\n                    G = Math.min(c, h),\n                    V = (U + G) / 2,\n                    j = S === this.scene.hoverSlice,\n                    W = o + S.currentCutoutDistance;\n                S.currentInsideLabel && S.currentInsideLabel.visible && this.paintLabel(t, e, P, D, W, V, S.currentInsideLabel, j), S.currentLabel && S.currentLabel.visible && this.paintLabel(t, e, P, D, W, V, S.currentLabel, j);\n              }\n            }\n          }\n        }, t.prototype.paintLabel = function (t, e, i, n, r, s, a, o) {\n          var l,\n              h,\n              u = this.scene.y0 + 3,\n              c = u + this.scene.height - 6,\n              p = this.settings.labels,\n              f = a.x,\n              g = a.y,\n              v = a.hwidth,\n              m = r + p.connectorLength;\n\n          if (f < 0 ? (l = f + v, h = g) : f >= 0 && (l = f - v, h = g), p.connectors && l * l + h * h > r * r) {\n            var y = Math.sin(s),\n                S = Math.cos(s);\n            t.beginPath();\n            var b = i + r * S,\n                x = n + r * y;\n            t.moveTo(b, x);\n            var C = i + m * S,\n                w = n + m * y;\n            w = Math.min(Math.max(w, u), c), l += i, h += n, h = Math.min(Math.max(h, u), c);\n            var L = (r + m) / 2,\n                T = d.Geometry.rayIntersectsCircle(l - i, h - n, b - l, x - h, r),\n                k = d.Geometry.lineTouchingCircle(l - i, h - n, C - i, w - n, m);\n\n            if (T < .9 && k) {\n              for (var M = k.x, A = k.y, I = Math.atan2(A, M); I - s > Math.PI;) {\n                I -= 2 * Math.PI;\n              }\n\n              for (; I - s < -Math.PI;) {\n                I += 2 * Math.PI;\n              }\n\n              var P = I - s;\n              M += i, A += n, C = i + L * S, w = n + L * y, w = Math.min(Math.max(w, u), c);\n              var D = i + L * Math.cos(s + .2 * P),\n                  N = n + L * Math.sin(s + .2 * P);\n              N = Math.min(Math.max(N, u), c), t.quadraticCurveTo(C, w, D, N);\n              var F = i + m * Math.cos(I),\n                  O = n + m * Math.sin(I);\n              O = Math.min(Math.max(O, u), c), d.Graphics.arcBetweenTwoPoints(t, i, n, L, D, N, F, O), t.lineTo(l, h);\n            } else t.quadraticCurveTo(C, w, l, h);\n\n            var E = this.settings.slice.connectorStyle,\n                R = E.lineWidth;\n            o && (E.lineWidth += 2), d.Graphics.stroke(t, E), E.lineWidth = R;\n          }\n\n          e.paint(t, i + a.x, n + a.y, 1, a), d.Graphics.clearShadow(t);\n        }, t;\n      }();\n\n      e.PieRenderer = O;\n\n      var E = function () {\n        function t(t) {\n          this.chart = t, this.scene = t.scene;\n        }\n\n        return t.prototype.updatePie = function (t, e) {\n          var i = this.getPieData(t);\n          this.rectifyScrollOffsets(t, i);\n          var n = this.getForwardCount(t.id, i, t.offset),\n              r = n.numberOfSlices,\n              s = n.isReady;\n\n          if (t.data = i, t.loading = !s, s) {\n            var a = this.buildSlices(t, t.offset, r),\n                o = a.slices,\n                l = a.othersSlice,\n                h = a.previousSlice;\n            this.applyNewSlices(t, o, l, h, e);\n          }\n\n          return s;\n        }, t.prototype.scrollForward = function (t, e) {\n          var i = this.getPieData(t);\n          t.data = i;\n          var n,\n              r = !0;\n\n          if (null === e || void 0 === e) {\n            var s = this.getForwardCount(t.id, i, t.offset);\n            n = s.numberOfSlices, r = s.isReady, e = t.offset + n;\n          }\n\n          if (r) {\n            var s = this.getForwardCount(t.id, i, e);\n            n = s.numberOfSlices, r = s.isReady;\n          }\n\n          if (r) {\n            var a = this.buildSlices(t, e, n),\n                o = a.slices,\n                l = a.othersSlice,\n                h = a.previousSlice;\n\n            if (t.othersSlice) {\n              var u = Math.min(o.length, Math.max(0, t.offset + t.count - e));\n              this.fitSlicesInOrigin(t.othersSlice, o.slice(u), l), l || (l = t.othersSlice, l.fraction = 0, l.currentFraction = 0, l.removed = !0);\n            }\n\n            return t.offset = e, this.applyNewSlices(t, o, l, h), t.loading = !1, !0;\n          }\n\n          return t.loading = !0, !1;\n        }, t.prototype.scrollBackward = function (t, e) {\n          var i = this.getPieData(t);\n          t.data = i;\n          var n = !0,\n              r = 0;\n\n          if (i && i.done && t.offset > i.offset + i.values.length && (t.offset = i.offset + i.values.length), null == e) {\n            var s = this.getBackOffset(t.id, i, t.offset);\n            if (e = s.newOffset, n = s.isReady) do {\n              e += r;\n              var a = this.getForwardCount(t.id, i, e);\n              r = a.numberOfSlices, n = a.isReady;\n            } while (n && e + r < t.offset);\n          } else {\n            var a = this.getForwardCount(t.id, i, e);\n            r = a.numberOfSlices, n = a.isReady;\n          }\n\n          if (n) {\n            var o = this.buildSlices(t, e, r),\n                l = o.slices,\n                h = o.othersSlice,\n                u = o.previousSlice;\n\n            if (t.previousSlice) {\n              var c = Math.min(l.length, Math.max(0, t.offset - e));\n              this.fitSlicesInOrigin(t.previousSlice, l.slice(0, c), u), u || (u = t.previousSlice, u.fraction = 0, u.currentFraction = 0, u.removed = !0);\n            }\n\n            return t.offset = e, this.applyNewSlices(t, l, h, u), t.loading = !1, !0;\n          }\n\n          return t.loading = !0, !1;\n        }, t.prototype.fitSlicesInOrigin = function (t, e, i) {\n          for (var n = Math.max(1e-6, t.currentFraction), r = 0, s = 0; s < e.length; s++) {\n            var a = e[s];\n            r += a.fraction;\n          }\n\n          i && (r += i.fraction);\n\n          for (var o = n / r, s = 0; s < e.length; s++) {\n            var a = e[s];\n            a.currentFraction = a.fraction * o, a.currentFillColor = t.currentFillColor, a.currentLineColor = t.currentLineColor;\n          }\n\n          i && (i.currentFraction = i.fraction * o, i.currentFillColor = t.currentFillColor, i.currentLineColor = t.currentLineColor);\n        }, t.prototype.rectifyScrollOffsets = function (t, e) {\n          if (null == e) return void (t.scrollOffset = 0);\n          var i,\n              n = t.offset;\n\n          if (t.scrollOffset < 0) {\n            for (0 === n && (t.scrollOffset -= this.scene.settings.interaction.others.navigationFraction); t.scrollOffset < 0 && n - e.offset < e.values.length;) {\n              i = e.values[n - e.offset], t.scrollOffset += i.fraction / t.visibleFraction, n++;\n            }\n\n            var r = this.scene.settings.interaction.others.maxSlicesVisible + 1;\n            n + r > e.values.length && (t.scrollOffset = 0, n = Math.max(e.values.length - r, 0));\n          } else if (t.scrollOffset > 0) {\n            var s = 0;\n\n            for (1 === n && (s = this.scene.settings.interaction.others.navigationFraction); n > 0 && t.scrollOffset + s > e.values[n - e.offset - 1].fraction / t.visibleFraction;) {\n              i = e.values[n - e.offset - 1], t.scrollOffset -= i.fraction / t.visibleFraction, n--;\n            }\n\n            0 === n && (t.scrollOffset = 0);\n          }\n\n          t.offset = n;\n        }, t.prototype.getForwardCount = function (t, e, i) {\n          if (!e || e.offset > i || e.offset + e.values.length <= i) return !e || !e.done || e.offset > i ? (this.scene.mainData.requestPieData(t, i), {\n            numberOfSlices: 0,\n            isReady: !1\n          }) : {\n            numberOfSlices: 0,\n            isReady: !0\n          };\n          var n = e.offset,\n              r = n + e.values.length,\n              s = this.scene.settings.interaction.others,\n              a = s.minSliceFraction,\n              o = s.maxOthersFraction,\n              l = s.maxSlicesVisible;\n          if (!s.enabled || r - i <= s.minSlices) return e.done || this.scene.mainData.requestMorePieData(t), {\n            numberOfSlices: Math.max(r - i, 0),\n            isReady: e.done\n          };\n\n          for (var h = e.afterFraction, u = i; u <= r - 1; u++) {\n            h += e.values[u - n].fraction;\n          }\n\n          for (var c = 0, d = 0, p = e.done; c + i < r;) {\n            c++;\n            var f = e.values[i + c - n - 1].fraction;\n            d += f, h -= f;\n            var g = h / (h + d),\n                v = Math.min(g, o),\n                m = f / d * (1 - v);\n\n            if (c > l || m < a) {\n              e.done && c + i !== r && c--, p = !0;\n              break;\n            }\n          }\n\n          return p || this.scene.mainData.requestMorePieData(t), {\n            numberOfSlices: c,\n            isReady: p\n          };\n        }, t.prototype.getBackOffset = function (t, e, i) {\n          if (0 === i) return {\n            newOffset: 0,\n            isReady: !0\n          };\n          if (!e || e.offset >= i || !e.done && e.offset + e.values.length < i) return this.scene.mainData.requestPieData(t, Math.max(0, i - this.scene.mainData.dataSettings.itemsToLoad)), {\n            newOffset: 0,\n            isReady: !1\n          };\n          if (0 === i) return {\n            newOffset: 0,\n            isReady: !0\n          };\n\n          for (var n = e.offset, r = n + e.values.length, s = this.scene.settings.interaction.others.minSliceFraction, a = this.scene.settings.interaction.others.maxOthersFraction, o = this.scene.settings.interaction.others.maxSlicesVisible, l = e.afterFraction, h = i; h < r; h++) {\n            l += e.values[h - n].fraction;\n          }\n\n          for (var u = i, c = e.values[i - n - 1].fraction, d = 0, p = 0 === e.offset; u > e.offset;) {\n            u--, d += e.values[u - n].fraction;\n            var f = i - u,\n                g = Math.min(l / (l + d), a),\n                v = c / d * (1 - g);\n\n            if (0 === u || f > o || v < s) {\n              0 !== u && u++, p = !0;\n              break;\n            }\n          }\n\n          return p || this.scene.mainData.requestLessPieData(t), {\n            newOffset: u,\n            isReady: p\n          };\n        }, t.prototype.buildSlices = function (t, e, i) {\n          var n = this.scene.settings,\n              r = t.data;\n          if (!r) throw new Error(\"Internal error - buildSlices\");\n\n          for (var s = 0, a = [], o = e; o < e + i; o++) {\n            var l = new v(t, o);\n            l.data = r.values[o - r.offset], l.id = l.data.__id, s += l.data.fraction, a.push(l);\n          }\n\n          for (var h = n.interaction.others, u = r.afterFraction, c = r.afterSum, o = e + i; o < r.offset + r.values.length; o++) {\n            var d = r.values[o - r.offset];\n            c += d.value, u += d.fraction;\n          }\n\n          var p;\n          u > 0 && (e > 0 || r.values.length > h.minSlices) ? (p = new v(t, 1 / 0), p.data = {\n            value: c,\n            fraction: u,\n            name: n.localization.othersLabel\n          }) : p = null;\n          var f = null,\n              g = 0;\n\n          if (e > 0) {\n            for (var m = r.beforeSum, o = r.offset; o <= Math.min(e, r.offset + r.values.length) - 1; o++) {\n              m += Math.abs(r.values[o - r.offset].value);\n            }\n\n            f = new v(t, -1), g = h.navigationFraction, g += t.scrollOffset, f.data = {\n              value: m,\n              name: n.localization.previousLabel\n            }, f.fraction = g;\n          }\n\n          t.visibleFraction = (s + u) * (1 + g / (1 - g)), p && (u = Math.max(h.navigationFraction, u), u = Math.min(h.maxOthersFraction, u), p.fraction = u);\n          var y = (1 - g - u) / s;\n          s = 1 - g - u;\n\n          for (var S = 0; S < a.length; S++) {\n            var b = a[S];\n            b.fraction = b.data.fraction * y;\n          }\n\n          var x = n.slice.minFraction;\n          if (x > 0) for (var C = 0;;) {\n            for (var w = 0, L = 0, S = 0; S < a.length; S++) {\n              var b = a[S];\n              b.fraction <= x && (w += 1, L += b.fraction);\n            }\n\n            if (w === a.length) {\n              for (var T = s / a.length, S = 0; S < a.length; S++) {\n                var b = a[S];\n                b.fraction = T;\n              }\n\n              break;\n            }\n\n            y = (s - w * x) / (s - L);\n\n            for (var S = 0; S < a.length; S++) {\n              var b = a[S];\n              b.fraction <= x ? b.fraction = x : b.fraction = b.fraction * y;\n            }\n\n            if (w === C) break;\n            C = w;\n          }\n          return {\n            slices: a,\n            othersSlice: p,\n            previousSlice: f\n          };\n        }, t.prototype.applyNewSlices = function (t, e, i, n, r) {\n          void 0 === r && (r = !0);\n          var s = t.allSlices,\n              a = 0 === s.length,\n              o = [],\n              l = [];\n          s.length, e.length + (i ? 1 : 0) + (n ? 1 : 0);\n          n ? (t.previousSlice ? (t.previousSlice.removed = n.removed, t.previousSlice.data = n.data, t.previousSlice.fraction = n.fraction, t.previousSlice.value = n.value, r || this.jumpSliceToAnimationEnd(t.previousSlice)) : (a || (n.currentFraction = 0), t.previousSlice = n), l.push(t.previousSlice)) : t.previousSlice && (t.previousSlice.removed = !0, t.previousSlice.fraction = 0, l.push(t.previousSlice));\n\n          for (var h = {}, u = {}, c = {}, p = {}, f = 0; f < s.length; f++) {\n            var g = s[f];\n            (!g || g.index !== 1 / 0 && g.index !== -1) && (h[g.id] = g, null !== g.originalId && (u[g.originalId] = g));\n          }\n\n          for (var f = 0; f < e.length; f++) {\n            c[e[f].id] = e[f], null !== e[f].originalId && (p[e[f].originalId] = e[f]);\n          }\n\n          for (var v in h) {\n            var g = h[v],\n                m = c.hasOwnProperty(g.id),\n                y = p.hasOwnProperty(g.originalId);\n\n            if (m || y) {\n              var S = m ? c[g.id] : p[g.originalId];\n              g.removed = !1, g.fraction = S.fraction, g.data = S.data, g.index = S.index, S.currentFraction && r && (g.currentFraction = S.currentFraction, g._animatorF = null), r || this.jumpSliceToAnimationEnd(g), o.push(g), l.push(g);\n            } else g.removed = !0, g.fraction = 0, g.originalId || (g.originalId = g.id), g.id = d.Helpers.getIdentifierStr(), r && l.push(g);\n          }\n\n          for (var v in c) {\n            var S = c[v];\n            h.hasOwnProperty(S.id) || h.hasOwnProperty(S.originalId) || (S.currentFraction || a || (S.currentFraction = 0), r || this.jumpSliceToAnimationEnd(S), o.push(S), l.push(S));\n          }\n\n          var b = function b(t, e) {\n            return t.index > e.index ? 1 : t.index < e.index ? -1 : 0;\n          };\n\n          o.sort(b), l.sort(b), i ? (t.othersSlice ? (t.othersSlice.removed = i.removed, t.othersSlice.data = i.data, t.othersSlice.fraction = i.fraction, t.othersSlice.value = i.value, r || this.jumpSliceToAnimationEnd(t.othersSlice)) : (a || (i.currentFraction = 0), t.othersSlice = i), l.push(t.othersSlice)) : t.othersSlice && (l.push(t.othersSlice), t.othersSlice.removed = !0, t.othersSlice.fraction = 0), !r && t.othersSlice && this.jumpSliceToAnimationEnd(t.othersSlice), t.total = t.data ? t.data.total : 0, t.count = e.length, t.slices = o, t.allSlices = l;\n\n          for (var x = 0; x < l.length; x++) {\n            var C = l[x];\n            C.value = C.data.value, r || this.jumpSliceToAnimationEnd(C);\n          }\n\n          this.scene.updateOnPieChanged(t), this.resetSelection();\n        }, t.prototype.resetSelection = function () {\n          for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {\n            var n = i[e];\n            t.selectionIds.push(n.id), n.selected = !1;\n          }\n\n          return t.selection = [], t.selectionIds.length > 0;\n        }, t.prototype.jumpSliceToAnimationEnd = function (t) {\n          t._animatorF ? t._animatorF.jump(t.fraction) : t._animatorF = new d.Animator(t.fraction, t.fraction, this.scene.settings.interaction.animation.scrollDuration, \"<>\", 0), t.currentFraction = t.fraction;\n        }, t.prototype.getPieData = function (t) {\n          var e = this.scene.mainData.getPieData(t.id);\n          if (!e) return null;\n          var i = e.total;\n          if (i > 0) for (var n = 0; n < e.values.length; n++) {\n            var r = e.values[n];\n            r.fraction = Math.max(1e-9, r.value / i);\n          } else {\n            i = e.values.length;\n\n            for (var n = 0; n < e.values.length; n++) {\n              var r = e.values[n];\n              r.fraction = 1 / i;\n            }\n          }\n          return e.afterSum > 0 ? e.afterFraction = e.afterSum / i : e.afterFraction = 0, e.beforeSum > 0 ? e.beforeFraction = e.beforeSum / i : e.beforeFraction = 0, e;\n        }, t;\n      }();\n\n      e.PieBuilder = E;\n\n      var R = function (e) {\n        function i(t) {\n          var i = e.call(this) || this;\n          return i.animationOrder = 500, i.paintOrder = 30, i.updateOrder = 700, i.chart = t, i.scene = t.scene, i.renderer = new O(t), i.animator = new D(t), i.layout = new N(t, i), i.builder = new E(t), i;\n        }\n\n        return n(i, e), i.prototype.updatePie = function (t, e) {\n          return void 0 === e && (e = !0), this.builder.updatePie(t, e);\n        }, i.prototype.scrollForward = function (t, e) {\n          return this.builder.scrollForward(t, e);\n        }, i.prototype.scrollBackward = function (t, e) {\n          return this.builder.scrollBackward(t, e);\n        }, i.prototype.onSceneChange = function (t) {\n          this.renderer.onSceneChange(t);\n        }, i.prototype.doAnimations = function (t) {\n          var e = !1;\n\n          if (t.changes.settings || t.changes.pie || t.changes.bounds || t.changes.assets) {\n            var i = this.scene.peek();\n            i && this.chart.assetsLoaded && (e = this.layout.placeStack(i, t.context));\n          }\n\n          for (var n = this.animator.doAnimations(t), r = 0; r < n.length; r++) {\n            var i = n[r];\n            this.layout.placeLabels(i, t.context);\n          }\n\n          (e || n) && (t.changes.position = !0);\n        }, i.prototype.paintScene = function (t) {\n          this.renderer.paintScene(t);\n        }, i.prototype.getMovement = function (t, e) {\n          var i = e.x - e.dx - t.x,\n              n = e.y - e.dy - t.y,\n              r = e.x - t.x,\n              s = e.y - t.y,\n              a = d.Geometry.normalizeAngle(Math.atan2(n, i)),\n              o = d.Geometry.normalizeAngle(Math.atan2(s, r)),\n              l = d.Geometry.subtractAngle(o, a) / (t.currentEndAngle - t.currentStartAngle),\n              h = Math.sqrt(i * i + n * n),\n              u = Math.sqrt(r * r + s * s),\n              c = u - h;\n          return {\n            dfraction: l,\n            doffset: c\n          };\n        }, i.prototype.findPieAt = function (t, e, i) {\n          for (var n = this.scene.currentInnerRadius, r = this.scene.currentRadius - n, s = this.scene.pies.length - 1; s >= 0; s--) {\n            var a = this.scene.pies[s],\n                o = a.x,\n                l = a.y,\n                h = a.currentInnerRadius * r + n,\n                u = a.currentRadius * r + n,\n                c = Math.max(0, h - i);\n            c = u + i;\n            var d = c * c,\n                p = t - o,\n                f = e - l,\n                g = p * p + f * f;\n            if ((a.background || 1 === this.scene.pies.length) && g <= d) return a;\n          }\n\n          return null;\n        }, i.prototype.findSliceAt = function (e, i, n, r) {\n          for (var s = this.scene.currentInnerRadius, a = this.scene.currentRadius - s, o = this.scene.settings.theme == t.Internal.PieChart.Settings.RoundedTheme, l = this.scene.settings.pie.endAngle - this.scene.settings.pie.startAngle == 2 * Math.PI, h = this.scene.pies.length - 1; h >= 0; h--) {\n            var u = this.scene.pies[h];\n\n            if (!u.background) {\n              var c = u.x,\n                  d = u.y,\n                  p = r ? 0 : u.currentInnerRadius * a + s,\n                  f = u.currentRadius * a + s,\n                  g = Math.max(0, p - n);\n              g = f + n;\n\n              for (var v = e - c, m = i - d, y = v * v + m * m, S = Math.sqrt(y), b = v / S, x = m / S, C = u.currentStartAngle, w = u.currentEndAngle - C, L = Math.cos(C), T = Math.sin(C), k = L, M = T, A = (f - p) / 2, I = 0; I < u.allSlices.length; I++) {\n                var P = u.allSlices[I],\n                    D = L,\n                    N = T;\n\n                if (C += w * P.currentFraction, L = Math.cos(C), T = Math.sin(C), S >= p + P.currentCutoutDistance && S <= f + P.currentCutoutDistance) {\n                  var F = N * b - D * x,\n                      O = T * b - L * x,\n                      E = D * (p + P.currentCutoutDistance + A),\n                      R = N * (p + P.currentCutoutDistance + A);\n\n                  if (F < 0 && O > 0) {\n                    if (!o) return P;\n                    var H = Math.sqrt(Math.pow(v - E, 2) + Math.pow(m - R, 2));\n                    if (H > A) return P;\n                  }\n\n                  if (Math.abs(w * P.currentFraction) > Math.PI && (F < 0 && O < 0 || F > 0 && O > 0)) {\n                    if (!o) return P;\n                    var H = Math.sqrt(Math.pow(v - E, 2) + Math.pow(m - R, 2));\n                    if (H > A) return P;\n                  }\n\n                  if (o) {\n                    var z = Math.sqrt(Math.pow(v - E, 2) + Math.pow(m - R, 2)),\n                        B = L * (p + P.currentCutoutDistance + A),\n                        U = T * (p + P.currentCutoutDistance + A),\n                        G = Math.sqrt(Math.pow(v - B, 2) + Math.pow(m - U, 2));\n                    if (z > A && G <= A) return P;\n                  }\n                }\n              }\n\n              if (!l && o && u.allSlices && u.allSlices.length > 0) {\n                var P = u.allSlices[0],\n                    E = k * (p + P.currentCutoutDistance + A),\n                    R = M * (p + P.currentCutoutDistance + A),\n                    H = Math.sqrt(Math.pow(v - E, 2) + Math.pow(m - R, 2));\n                if (H < A) return P;\n              }\n            }\n          }\n\n          return null;\n        }, i.prototype.findLabelAt = function (t, e, i) {\n          for (var n = this.scene.pies.length - 1; n >= 0; n--) {\n            for (var r = this.scene.pies[n], s = t - r.x, a = e - r.y, o = 0; o < r.allSlices.length; o++) {\n              var l = r.allSlices[o];\n\n              if (l.currentLabel) {\n                var h = l.currentLabel;\n                if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= a && h.y + h.hheight >= a) return {\n                  slice: l,\n                  label: h\n                };\n              }\n\n              if (l.currentInsideLabel) {\n                var h = l.currentInsideLabel;\n                if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= a && h.y + h.hheight >= a) return {\n                  slice: l,\n                  label: h\n                };\n              }\n            }\n          }\n\n          return {\n            slice: null,\n            label: null\n          };\n        }, i;\n      }(d.ChartElement);\n\n      e.PieView = R;\n\n      var H = function (t) {\n        function e(e, i) {\n          var n = t.call(this, new S(e), new y(), i) || this;\n          return n.scene.loading = !1, n.selection = n.events.addElement(new T(n)), n.scene.view = new R(n), n.popup = n.events.addElement(new P(n)), n.legend = n.events.addElement(new f(n)), n.events.addElement(new k(n)), n.navigator = n.events.addElement(new I(n)), n.events.addElement(n.scene.view), n.finalInitialize(), n.navigator.setPie(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, \"init\"), n;\n        }\n\n        return n(e, t), e.prototype.createDataObj = function (t) {\n          return new l(this, t, !1);\n        }, e.prototype.getData = function (e) {\n          return t.prototype.getData.call(this, e);\n        }, e.prototype.createDomLayer = function () {\n          return new M(this);\n        }, e.prototype.onSettingsChanged = function (t) {\n          t.navigation && (t.navigation.initialDrilldown || t.navigation.initialOffset) && this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset), (t.labels || t.icons || t.pie || t.slice || t.interaction) && this.events.notifySceneChanges({\n            pie: !0\n          });\n        }, e.prototype.save = function () {\n          var t = this.saveSelection();\n          return JSON.stringify({\n            pie: this.navigator.getPie(),\n            offset: this.navigator.getPieOffset(),\n            selection: t\n          });\n        }, e.prototype.zoomOut = function (t, e) {\n          void 0 === t && (t = !0), void 0 === e && (e = \"api\"), this.setSelection([]), this.navigator.goBack(e);\n        }, e.prototype.zoomOutPossible = function () {\n          var t = this.scene;\n          return t.length() > 1 || t.peek().offset > 0;\n        }, e.prototype.restore = function (t, e) {\n          if (t) {\n            var i = JSON.parse(t);\n            this.setPie(i.pie, i.offset, e), this.setSelection(i.selection);\n          }\n        }, e.prototype.updateFilters = function () {\n          this.updateFilter(!0);\n        }, e.prototype.updateFilter = function (t) {\n          void 0 === t && (t = !1), this.log(\"Update filter\");\n          var e = {};\n\n          for (var i in this.settings._computedDataMap) {\n            e[i] = !0;\n          }\n\n          this.events.notifySceneChanges({\n            data: e,\n            dataDeep: t\n          });\n        }, e.prototype.setSelection = function (t, e) {\n          void 0 === e && (e = \"api\"), this.log(\"Set selection\");\n\n          for (var i = [], n = [], r = 0; r < t.length; r++) {\n            var s = t[r];\n            s instanceof v ? i.push(s) : d.Helpers.isString(s) ? n.push(s) : this.error(\"SetSelection: Selection contents must be Piechart_Slice object or string, got \" + s);\n          }\n\n          this.selection.setSelection(i, n, !1, e);\n        }, e.prototype.saveSelection = function () {\n          for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {\n            var i = this.scene.selection[e];\n            t.push(i.id);\n          }\n\n          return t;\n        }, e.prototype.exportVisibleData = function () {\n          var t = this.scene.peek();\n          return t ? l.exportValues(t.data) : [];\n        }, e.prototype.setPie = function (t, e, i, n) {\n          void 0 === i && (i = !0), void 0 === n && (n = \"api\"), this.log(\"Set pie\"), this.navigator.setPie(t, e, n);\n        }, e.prototype.setPieOffset = function (t, e, i) {\n          void 0 === e && (e = !0), void 0 === i && (i = \"api\"), this.log(\"Set pie offset\"), this.navigator.setPie(this.getPie(), t, i);\n        }, e.prototype.getPie = function () {\n          return this.navigator.getPie();\n        }, e.prototype.getActiveSlices = function () {\n          for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n            var i = this.scene.stack[e];\n            i.parentSlice && t.push(i.parentSlice);\n          }\n\n          return t;\n        }, e.prototype.getActivePies = function () {\n          return this.scene.stack;\n        }, e.prototype.expandSlice = function (t, e) {\n          return void 0 === e && (e = \"api\"), this.navigator.expandSlice(t, e);\n        }, e.prototype.getSliceDimensions = function (t, e) {\n          if (!Array.isArray(t)) return this.error(\"getSliceDimensions: slice Id must be an array\"), null;\n          if (t.length < 2) return null;\n          if (!e && this.scene.stack.length + 1 < t.length) return null;\n\n          for (var i, n = 0, r = 0; r < this.scene.stack.length; r++) {\n            if (i = this.scene.stack[r], i.id !== t[n]) return null;\n            if (n += 1, n === t.length - 1) break;\n          }\n\n          for (var s = t[n], a = 0; a < i.slices.length; a++) {\n            var o = i.slices[a];\n\n            if (o.id === s) {\n              var l = o._renderParams;\n              return l ? {\n                centerX: i.x,\n                centerY: i.y,\n                r0: l[0],\n                r1: l[1],\n                a0: l[2],\n                a1: l[3]\n              } : null;\n            }\n          }\n\n          return null;\n        }, e.prototype.saveNavigation = function () {\n          var t = this.scene.peek();\n          return !t || t.loading ? null : {\n            pie: this.navigator.getPie(),\n            offset: this.navigator.getPieOffset()\n          };\n        }, e.prototype.restoreNavigation = function (t, e, i) {\n          this.navigator.setPie(t.pie, t.offset, i);\n        }, e.prototype.doChartUpdateNotify = function (e) {\n          t.prototype.doChartUpdateNotify.call(this, e);\n          var i = this.createEventArguments(null, e);\n          this.dispatchEventParams(\"pieChange\", i, null), this.dispatchEventParams(\"pieReadyStateChanged\", i, null);\n        }, e.prototype.createEventArguments = function (t, e) {\n          var i = this.scene;\n          if (!i) return {\n            chart: this.api,\n            origin: e\n          };\n          var n = i.peek();\n          return {\n            chart: this.api,\n            origin: e,\n            pie: n,\n            offset: n && n.offset,\n            count: n && n.count,\n            selection: i.selection.slice(),\n            slice: i.hoverSlice,\n            hoverSlice: i.hoverSlice,\n            hoverPie: i.hoverPie,\n            label: i.hoverLabel,\n            hoverLabel: i.hoverLabel\n          };\n        }, e.prototype.defaultClick = function (t, e) {\n          this.selection.defaultClick(t, e);\n        }, e.prototype.remove = function () {\n          t.prototype.remove.call(this), this.popup.remove();\n        }, e;\n      }(d.Impl);\n\n      e.Impl = H;\n    }(a = i.PieChart || (i.PieChart = {})), function (t) {\n      var e = function () {\n        function t() {\n          this.enabled = !0, this.size = 40, this.defaultUnitWidth = 50, this.maxUnitWidth = 400, this.zoomOutUnitWidth = 20, this.labels = {\n            enabled: !0,\n            angle: 0,\n            lineSpacing: .2,\n            interLabelSpacing: .6,\n            textStyle: {\n              fillColor: \"#000\",\n              font: \"12px Arial\"\n            },\n            margin: 4,\n            padding: 0,\n            aspectRatio: 3,\n            allowOverflow: !1\n          }, this.title = {\n            enabled: !1,\n            aspectRatio: 0,\n            align: \"center\",\n            useFacetName: !0,\n            textStyle: {\n              font: \"13px Arial\",\n              fillColor: \"#000\"\n            }\n          };\n        }\n\n        return t;\n      }();\n\n      t.SettingsFacetAxis = e;\n\n      var i = function () {\n        function t(t, e) {\n          this.title = null, this.titleHeight = null, this.maxLabelWidth = 0, this.facet = e, this.chart = t, this.scene = this.chart.scene, this.options = this.scene.settings.facetAxis, this.currentItemWidth = 1, this.currentItemHeight = 1, this.createPanel(), this.createTitle();\n        }\n\n        return t.prototype.createPanel = function () {\n          this.panel = new d.ChartPanel(), this.panel.side = \"bottom\", this.panel.packingOrder = 100;\n        }, t.prototype.getPanel = function (e, i) {\n          var n = this.options,\n              r = this.panel;\n          this.rebuildLabels(e, i);\n          var s = this.maxLabelWidth,\n              a = this.reduceMarginNearZero(s, t.MAX_LABEL_SAFETY_MARGIN);\n          s += a;\n          var o = Math.max(n.size, s);\n          return n.enabled && o > 0 ? (r.desiredHeight = o, r.visible = !0, this.scene.bottomAxisSize = o) : (r.desiredHeight = 0, r.visible = !1, this.scene.bottomAxisSize = 0), r.enableClipping = !n.labels.allowOverflow, r;\n        }, t.prototype.reduceMarginNearZero = function (t, e) {\n          return t < 2 * e && (e = t / 2), e;\n        }, t.prototype.createTitle = function () {\n          this.options.title.enabled ? this.title = new d.Label(this.options.title) : (this.title = null, this.titleHeight = 0);\n        }, t.prototype.updateTitle = function (t, e) {\n          var i = this.title,\n              n = this.options.title,\n              r = this.facet.data ? this.facet.data.name : \"\",\n              s = (n.useFacetName ? r || n.text : n.text) || \"\";\n          i && (i.text = s, e.measure(t, i), s ? this.titleHeight = 2 * ((i.style.margin || 0) + i.hheight) : this.titleHeight = 0);\n        }, t.prototype.paintTitle = function (t, e) {\n          var i = this.title;\n\n          if (i) {\n            this.updateTitle(t, e);\n            var n = this.titleHeight;\n\n            if (n) {\n              var r = this.panel.left,\n                  s = this.panel.right,\n                  a = this.scene.y0,\n                  o = this.scene.height,\n                  l = a + o + this.scene.bottomAxisSize - n / 2,\n                  h = void 0,\n                  u = i.style.align;\n              h = (r + s) / 2, \"left\" === u && (h = r + i.hwidth), \"right\" === u && (h = s - i.hwidth), e.paint(t, h, l, 1, i);\n            }\n          }\n        }, t.prototype.paint = function (t, e, i, n) {\n          var r = this.options.labels;\n\n          if (n.length > 1 && this.panel.visible && r.enabled && this.chart.assetsLoaded) {\n            var s = t.context,\n                a = t.labelRenderer,\n                o = this.panel.top,\n                l = n[0];\n            this.paintTitle(s, a);\n            var h = this.facet.items,\n                u = (r.angle || 0) * Math.PI / 180,\n                c = Math.abs(Math.sin(u));\n            this.panel.pushClip(t), this.rebuildLabels(t, n);\n\n            for (var d = 0; d < h.length; d++) {\n              var p = n[d];\n\n              if (!(l > p)) {\n                var f = h[d],\n                    g = f.currentLabel;\n\n                if (f.currentLabel) {\n                  var v = Math.max.apply(Math, g.rows.rowWidths);\n\n                  if (l = p + g.x + v / 2, 0 !== u) {\n                    for (var m = 1, y = c * (n[d + 1] - n[d]), S = .001; y - S < g.lineHeight + (r.margin || 0) + (r.padding || 0);) {\n                      m++, y = c * (n[d + m] - n[d]);\n                    }\n\n                    l = n[d + m], void 0 === n[d + m] && (l = 1 / 0);\n                  }\n\n                  a.paint(s, p + g.x, o + g.y, 1, g);\n                }\n              }\n            }\n\n            this.panel.popClip(t);\n          }\n        }, t.prototype.shouldRebuildLabels = function (t, e, i) {\n          var n = !1;\n          return (Math.abs(1 - this.currentItemWidth / t) > .01 || Math.abs(1 - this.currentItemHeight / e) > .01) && (this.currentItemWidth = t, this.currentItemHeight = e, n = !0), i.changes && i.changes.settings && (n = !0), n;\n        }, t.prototype.rebuildLabels = function (t, e) {\n          this.layout = new d.LabelLayoutBase();\n          var i = this.facet.items,\n              n = this.panel.bottom - this.panel.top - this.titleHeight,\n              r = e[1] - e[0],\n              s = this.options.labels,\n              a = t.context,\n              o = t.labelRenderer,\n              l = this.shouldRebuildLabels(r, n, t),\n              h = 0,\n              u = d.Helpers.clone(this.options.labels);\n          u.aspectRatio = void 0;\n\n          for (var c = e[0], p = 0; p < i.length; p++) {\n            var f = e[p];\n\n            if (!(c > f)) {\n              var g = i[p],\n                  v = g.currentLabel,\n                  m = this.htmlDecodeLabel(g.label || g.data.name || s.text, this.layout, a);\n              g.currentLabel = null, m && (null === g.currentLabel || l || g.currentLabel.text !== m) && (h = this.updateMaxLabelWidth(u, m, o, a, h), v = this.buildLabel(a, m, r, n), g.currentLabel = v);\n            }\n          }\n\n          this.maxLabelWidth = h;\n        }, t.prototype.updateMaxLabelWidth = function (t, e, i, n, r) {\n          var s = this.computeLabelWidth(t, e, i, n);\n          return r = Math.max(s, r);\n        }, t.prototype.computeLabelWidth = function (t, e, i, n) {\n          var r = new d.Label(t);\n          r.text = e, i.measure(n, r);\n          var s = (r.style.angle || 0) * Math.PI / 180;\n          return this.rotatedLabelWidthAndHeight(s, r).width;\n        }, t.prototype.rotatedLabelWidthAndHeight = function (t, e) {\n          var i = 0,\n              n = 1;\n          0 !== t && (i = Math.sin(t), n = Math.cos(t)), n = Math.abs(n), i = Math.abs(i);\n          var r = 2 * e.hwidth,\n              s = 2 * e.hheight,\n              a = r * n + s * i,\n              o = s * n + r * i;\n          return {\n            width: o,\n            height: a\n          };\n        }, t.prototype.htmlDecodeLabel = function (t, e, i) {\n          if (null == t || 0 === t.length) return \"\";\n\n          for (var n = e.styleTagParser2(i, t, {}), r = \"\", s = 0, a = n.words, o = 0; o < a.length; o++) {\n            var l = a[o];\n            if (r += l.word, o === a.length - 1) break;\n            n.breaks[s] === o + 1 ? (r += \" \", s++) : l.spaceWidth && (r += \" \");\n          }\n\n          return r;\n        }, t.prototype.buildLabel = function (t, e, i, n) {\n          var r = new d.Label(this.options.labels),\n              s = r.style;\n          r.text = e;\n          var a = (s.angle || 0) * Math.PI / 180,\n              o = s.align;\n          o || (o = a > 0 ? \"left\" : a < 0 ? \"right\" : \"center\", s.align = o);\n\n          var l = function l(t, e, r) {\n            var s,\n                o,\n                l = 0,\n                h = 1;\n            0 !== a ? (l = Math.sin(a), h = Math.cos(a), o = r / Math.abs(l), s = i / 2) : (s = e / 2, o = 2 * t <= n ? e : 0);\n            var u, c;\n            return a > 0 ? (u = s + o / 2 * h - 2 * t * h, c = e / 2 * l) : a < 0 ? (u = s - o / 2 * h + 2 * t * h, c = -e / 2 * l) : (u = s, c = t), {\n              x: u,\n              y: c,\n              dx: h,\n              dy: l,\n              width: o\n            };\n          };\n\n          return this.layout.getFormatedText(t, r, i, n, l), r;\n        }, t;\n      }();\n\n      i.MAX_LABEL_SAFETY_MARGIN = 10, t.FacetAxis = i;\n\n      var r = function () {\n        function t() {\n          this.enabled = !0, this.tolerance = 4;\n        }\n\n        return t;\n      }();\n\n      t.SettingsInteractionSelection = r;\n\n      var s = function () {\n        function t() {\n          this.lineColor = \"rgba(0,0,0,0.5)\", this.lineWidth = 2, this.fillColor = \"rgba(30,160,220,0.15)\", this.behindSeries = !1;\n        }\n\n        return t;\n      }();\n\n      t.SettingsAreaStyleSelection = s;\n\n      var o = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.paintOrder = 15, i.updateOrder = 1e3, i.scene = null, i.events = null, i.currentItem = null, i.currentFacet = null, i.hoverEvent = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.settings = e.settings.interaction.selection, i.styleSettings = e.settings.area.style.selection, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i;\n        }\n\n        return n(e, t), e.prototype.paintScene = function (t) {\n          var e = this.scene,\n              i = e.selection,\n              n = !this.settings.enabled;\n\n          if (n || i && i.length) {\n            var r = e.width,\n                s = this.styleSettings,\n                a = s.lineWidth,\n                o = Math.round(e.x0),\n                l = Math.round(e.y0),\n                h = Math.round(l + e.height + e.bottomAxisSize),\n                u = e.height + e.bottomAxisSize,\n                c = [],\n                p = e.activeFacet;\n            if (n) for (var f = 0, g = p.items; f < g.length; f++) {\n              var v = g[f];\n              v.selected && c.push(v.index);\n            } else for (var m = 0; m < i.length; m++) {\n              var y = i[m];\n              y.facet === p && c.push(y.index);\n            }\n            c.sort(function (t, e) {\n              return t - e;\n            });\n            var S,\n                b = t.context;\n            e.transform && b.transform.apply(b, e.transform);\n\n            for (var m = 0; m < c.length;) {\n              for (var x = c[m], C = x; ++m < c.length && (S = c[m]) === C + 1;) {\n                C = S;\n              }\n\n              var w = e.getItemPlacement(p, x, C),\n                  L = Math.round(o + r * w.left),\n                  T = Math.round(o + r * w.right);\n              d.Graphics.pushClip(t, o, l, r, u), d.Graphics.rectStyle(b, s);\n              var k = L + a % 2 / 2,\n                  M = T + a % 2 / 2;\n              b.fillRect(k + a / 2, l, T - L - a, u), b.beginPath(), b.moveTo(k, l), b.lineTo(k, h), b.moveTo(M, l), b.lineTo(M, h), d.Graphics.stroke(b, s), d.Graphics.popClip(t);\n            }\n\n            e.invertedTransform && b.transform.apply(b, e.invertedTransform);\n          }\n        }, e.prototype.doAnimations = function (t) {\n          this.hoverEvent && this.onPointerMove(this.hoverEvent);\n        }, e.prototype.previewPointerDrag = function (t) {\n          this.hoverEvent = t;\n        }, e.prototype.onPointerMove = function (t) {\n          var e = this.chart,\n              i = e.scene;\n          this.hoverEvent = t;\n          var n = i.findItemAt(t.x, t.y);\n          n && (t.cursor = \"pointer\");\n          var r = e.renderer.hitTest(t.x, t.y);\n          if (e.legend) if (r) e.legend.notifyHoveredSeries(i.settings._computedSeries[r.seriesIndex]);else {\n            e.legend.notifyHoveredSeries(null);\n            var s = e.legend.getLastHoveredSeries();\n            s && (r = {\n              x0: null,\n              y0: null,\n              x1: null,\n              y1: null,\n              isMarker: !1,\n              seriesIndex: i.settings._computedSeries.indexOf(s)\n            });\n          }\n          (!r != !i.hoverSeriesItem || r && (r.seriesIndex !== i.hoverSeriesItem.seriesIndex || r.x0 !== i.hoverSeriesItem.x0)) && (i.hoverSeriesItem = r, t.changes.hover = !0), this.switchCurrentItem(n, t);\n        }, e.prototype.onPointerOut = function (t) {\n          this.hoverEvent = this.scene.hoverSeriesItem = null, this.events.notifySceneChanges({\n            selection: !0\n          }), t.changes.hover = !0, this.switchCurrentItem(null, t);\n        }, e.prototype.defaultClick = function (t, e) {\n          var i = e.clickItem;\n          i && (i.url ? (d.Helpers.openUrl(i.url, i.urlTarget), t.preventDefault()) : this.settings.enabled && t.ctrlKey || \"drilldown\" !== this.chart.settings.interaction.mode || !this.chart.expandItem(i, \"user\") || t.preventDefault());\n        }, e.prototype.getClickArgs = function (t) {\n          var e = this.scene.findItemAt(t.x, t.y, !0),\n              i = this.chart.createEventArguments(t, \"user\", e);\n          return e && (t.cursor = \"pointer\", i.clickOrigin = this.scene.xyInBottom(t.x, t.y) ? \"label\" : \"item\"), i;\n        }, e.prototype.onClick = function (t) {\n          var e = this.getClickArgs(t);\n          t.consumed = !0, this.chart.notifyClick(t, e), t.defaultPrevented || this.updateSelection(t, e.clickItem);\n        }, e.prototype.onLongPress = function (t) {\n          var e = this.scene.findItemAt(t.x, t.y);\n          this.updateSelection(t, e);\n        }, e.prototype.onRightClick = function (t) {\n          var e = this.getClickArgs(t);\n          this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0);\n        }, e.prototype.onDoubleClick = function (t) {\n          var e = this.getClickArgs(t);\n          this.chart.notifyDoubleClick(t, e), t.consumed = !0;\n        }, e.prototype.onTripleClick = function (t) {\n          var e = this.getClickArgs(t);\n          this.chart.notifyTripleClick(t, e), t.consumed = !0;\n        }, e.prototype.updateSelection = function (t, e) {\n          if (this.settings.enabled) {\n            var i = this.scene,\n                n = i.selection;\n            if (t.ctrlKey || \"toggle\" === this.chart.settings.interaction.mode) e && (e.selected = !e.selected, e.selected ? n.push(e) : d.Helpers.removeFromArray(n, e), this.setSelection(n, i.selectionIds, !0));else if (t.shiftKey) {\n              var r = i.activeFacet;\n\n              if (e && e.facet === r) {\n                for (var s = 0, a = 0; a < n.length; a++) {\n                  var o = n[a];\n\n                  if (o.facet === r) {\n                    s = o.index;\n                    break;\n                  }\n                }\n\n                var l = Math.min(e.index, s),\n                    h = Math.max(e.index, s);\n                n = new Array(h - l + 1);\n\n                for (var a = l; a <= h; a++) {\n                  n[a - l] = r.items[a];\n                }\n\n                this.setSelection(n);\n              }\n            } else !e || e.selected && 1 === n.length ? this.setSelection([]) : this.setSelection([e]);\n          }\n        }, e.prototype.switchCurrentItem = function (t, e) {\n          var i = this.chart.createEventArguments(e, \"user\");\n          t !== this.currentItem && (e.changes.current = !0, this.scene.hoverItem && (this.scene.hoverItem.active = !1), this.scene.hoverItem = t, this.currentItem = t, this.currentFacet = null, this.currentItem && (this.scene.hoverItem.active = !0, i.hoverItem = this.currentItem), this.events.notifySceneChanges({\n            items: !0\n          })), e.changes.hover && this.chart.notifyHoverChanged(e, i);\n        }, e.prototype.onSceneChange = function (t) {\n          if (t.changes.items) {\n            var e = this.chart;\n            this.updateSelectionIds() && (this.events.notifySceneChanges({\n              selection: !0\n            }), e.notifySelectionChanged(e.createEventArguments(null, \"api\")));\n          }\n        }, e.prototype.updateSelectionIds = function () {\n          for (var t = this.scene, e = [], i = 0, n = t.selectionIds; i < n.length; i++) {\n            for (var r = n[i], s = 0, a = t.stack; s < a.length; s++) {\n              for (var o = a[s], l = 0, h = o.items; l < h.length; l++) {\n                var u = h[l];\n\n                if (u.id === r) {\n                  e.push(u);\n                  break;\n                }\n              }\n            }\n          }\n\n          if (0 === e.length) return !1;\n\n          for (var c = 0, p = e; c < p.length; c++) {\n            var f = p[c];\n            f.selected || (f.selected = !0, t.selection.push(f)), d.Helpers.removeFromArrayHasty(t.selectionIds, f.id);\n          }\n\n          return !0;\n        }, e.prototype.setSelection = function (t, e, i, n) {\n          void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = \"user\"), this.scene.selectionIds = e;\n          var r = !1;\n          if (i) r = !0;else {\n            for (var s = 0; s < this.scene.selection.length; s++) {\n              var a = this.scene.selection[s];\n              t.indexOf(a) < 0 && (a.selected = !1, r = !0);\n            }\n\n            for (var s = 0; s < t.length; s++) {\n              var a = t[s];\n              a.selected || (a.selected = !0, r = !0);\n            }\n\n            this.scene.selection = t;\n          }\n          var o = this.updateSelectionIds();\n          r = r || o, r && (this.events.notifySceneChanges({\n            selection: !0\n          }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)));\n        }, e;\n      }(d.ChartElement);\n\n      t.Selection = o;\n\n      var h = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.animationOrder = 500, i.paintOrder = 25, i.updateOrder = 800, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          (t.changes.position || t.changes.navigation) && this.updatePopup(t);\n        }, e.prototype.getPopupAreaMouseMoved = function (t, e) {\n          if (!this.scene.xyInChartOrBottom(t, e) || !this.scene.activeFacet) return null;\n          var i = this.scene.activeFacet,\n              n = this.scene.xToPosition(t);\n          if (isNaN(n)) return null;\n          var r = Math.floor(n),\n              s = Math.ceil(n);\n          return r === s && (s = r + 1), r < i.offset || r >= i.items.length + i.offset ? null : {\n            t0: r,\n            t1: s\n          };\n        }, e.prototype.buildHeader = function (t, e) {\n          var i = this.scene.activeFacet,\n              n = i.items[t - i.offset],\n              r = n.label || n.data.name || \"\";\n          return \"<em></em><strong>\" + r + \"</strong>\";\n        }, e;\n      }(l.InfoPopup);\n\n      t.InfoPopup = h;\n\n      var u = function () {\n        function t() {\n          this.enabled = !0, this.enabledOnExport = !1, this.size = 28, this.style = {\n            fillColor: \"rgba(255,255,255,0.5)\",\n            lineColor: \"rgba(0,0,0,0.5)\",\n            hoverFillColor: \"rgba(255,255,255,0.9)\",\n            hoverLineColor: \"rgba(0,0,0,0.9)\"\n          };\n        }\n\n        return t;\n      }();\n\n      t.SettingsScrollButtons = u;\n\n      var c = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          i.paintOrder = 75, i.chart = e, i.scene = e.scene, i.settings = e.settings.scrollButtons, i.panels = [];\n\n          for (var n = 0; n < 2; n++) {\n            var r = new d.ChartPanel();\n            r.packingOrder = 115, r.side = 1 === n ? \"left\" : \"right\", r.location = \"inside\", r.align = \"center\", i.panels.push(r);\n          }\n\n          return i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          this.settings.enabled && (this.activeFacet = this.chart.scene.activeFacet, this.showLeft = Math.floor(this.activeFacet.from) > 0, this.showRight = Math.ceil(this.activeFacet.to) < this.activeFacet.totalCount);\n        }, e.prototype.getPanels = function (t) {\n          for (var e = 0; e < 2; e++) {\n            var i = this.panels[e];\n            i.visible = t ? this.settings.enabledOnExport : this.settings.enabled, i.desiredWidth = i.desiredHeight = this.settings.size;\n          }\n\n          return this.panels;\n        }, e.prototype.paintScene = function (t) {\n          var e = Boolean(this.chart.scene.transform) && this.chart.settings.horizontal;\n\n          if (this.panels[0].visible) {\n            var i = this.settings.style,\n                n = t.context;\n            n.fillStyle = i.fillColor, n.strokeStyle = i.lineColor, e && n.transform.apply(n, this.chart.scene.transform);\n\n            for (var r = this.settings.size, s = r / 2, a = r / 4, o = this.scene.y0 + this.scene.height / 2 - r / 2, l = 0; l < this.panels.length; l++) {\n              var h = this.panels[l],\n                  u = h.left;\n              this.showRight && \"right\" === h.side && (this.rightActive && (n.fillStyle = i.hoverFillColor, n.strokeStyle = i.hoverLineColor), n.beginPath(), n.fillRect(u, o, r, r), n.moveTo(u + s - a / 2 + 2, o + a), n.lineTo(u + s + a - 3, o + s), n.lineTo(u + s - a / 2 + 2, o + r - a), n.stroke()), this.showLeft && \"left\" === h.side && (this.leftActive && (n.fillStyle = i.hoverFillColor, n.strokeStyle = i.hoverLineColor), n.beginPath(), n.fillRect(u, o, r, r), n.moveTo(u + s + a / 2 - 2, o + a), n.lineTo(u + s - a + 3, o + s), n.lineTo(u + s + a / 2 - 2, o + r - a), n.stroke()), n.fillStyle = i.fillColor, n.strokeStyle = i.lineColor;\n            }\n\n            e && n.transform.apply(n, this.chart.scene.invertedTransform);\n          }\n        }, e.prototype.findItemAt = function (t, e, i) {\n          if (!this.panels[0].visible) return null;\n\n          for (var n = i.touch ? 10 : 0, r = 0; r < 2; r++) {\n            var s = this.panels[r];\n            if (t >= s.left - n && t <= s.right + n && e >= s.top - n && e <= s.bottom + n && (\"left\" === s.side && this.showLeft || \"right\" === s.side && this.showRight)) return s.side;\n          }\n\n          return null;\n        }, e.prototype.onClick = function (t) {\n          if (this.panels[0].visible) {\n            var e = d.Helpers.performanceNow(),\n                i = this.findItemAt(t.x, t.y, t);\n\n            if (null !== i) {\n              var n = this.chart.scrolling,\n                  r = this.activeFacet,\n                  s = r.from,\n                  a = r.to,\n                  o = r.totalCount,\n                  l = a - s;\n              \"right\" === i && (a + l > o ? (a = a - l + (o - a), n.goToPosition(a, o, !0, e, !0)) : n.goToPosition(a, a + l, !0, e, !0)), \"left\" === i && (s - l < 0 ? n.goToPosition(0, l, !0, e, !0) : n.goToPosition(s - l, s, !0, e, !0)), t.consumed = !0;\n            }\n          }\n        }, e.prototype.onPointerMove = function (t) {\n          var e = this.findItemAt(t.x, t.y, t);\n          null !== e ? (\"left\" === e && (this.leftActive = !0), \"right\" === e && (this.rightActive = !0), t.changes.hover = !0, t.consumed = !0) : (this.leftActive = !1, this.rightActive = !1);\n        }, e;\n      }(d.ChartElement);\n\n      t.ScrollButtons = c;\n\n      var p = \"#A8A7A8\",\n          f = function (t) {\n        function i(i) {\n          var n = t.call(this, d.SettingsMapping.FacetChartSettings) || this;\n          return n.area = new g(), n.data = [], n.filters = {\n            sliceFilter: null,\n            allowZeroValues: !0\n          }, n.navigation = {\n            initialDrilldown: [\"\"],\n            initialOffset: 0\n          }, n.items = {\n            style: {\n              label: null,\n              expandable: !0\n            },\n            styleFunction: null\n          }, n.chartTypes = {\n            columns: {\n              type: \"columns\"\n            },\n            line: {\n              type: \"line\"\n            },\n            candlestick: null\n          }, n.facetAxis = new e(), n.interaction = new y(), n.toolbar = new m(), n.legend = new l.SettingsLegend(), n.scrollButtons = new u(), n.localization.toolbar.zoomoutTitle = \"Zoom-out to previous level\", n.apply(i), n._initializing = !1, n;\n        }\n\n        return n(i, t), i.prototype.apply = function (e) {\n          if (this.applyCompatibility(e, [{\n            from: \"area.initialPieId\",\n            to: \"navigation.initialDrilldown\"\n          }, {\n            from: \"area.initialPieOffset\",\n            to: \"navigation.initialOffset\"\n          }]), e.series) for (var i = 0; i < e.series.length; i++) {\n            var n = e.series[i];\n            n && void 0 !== n.styleFunction && d.Helpers.error(\"Setting `series[\" + i + \"].styleFunction` is no longer supported. Consider using `items.styleFunction` instead. See the example: https://zoomcharts.com/developers/en/facet-chart/examples/series/stacked-colored.html\");\n          }\n          return t.prototype.apply.call(this, e, S);\n        }, i;\n      }(l.Settings);\n\n      f.DarkTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-dark\"\n        },\n        area: {\n          style: {\n            fillColor: \"rgba(28,26,28,1)\",\n            selection: {\n              lineColor: \"#838283\"\n            }\n          }\n        },\n        title: {\n          margin: 15,\n          style: {\n            fillColor: p\n          }\n        },\n        valueAxisDefault: {\n          style: {\n            valueLabel: {\n              textStyle: {\n                fillColor: p\n              }\n            },\n            title: {\n              textStyle: {\n                fillColor: p\n              }\n            }\n          }\n        },\n        facetAxis: {\n          labels: {\n            textStyle: {\n              fillColor: p\n            }\n          },\n          title: {\n            textStyle: {\n              fillColor: p\n            }\n          }\n        },\n        legend: {\n          text: {\n            fillColor: p\n          },\n          advanced: {\n            disabledSeries: {\n              textColor: \"rgba(168,167,168,0.5)\",\n              lineColor: \"rgba(117,117,117,0.3)\"\n            }\n          }\n        }\n      }, f.HorizontalTheme = {\n        horizontal: !0,\n        valueAxisDefault: {\n          side: \"right\",\n          style: {\n            valueLabel: {\n              angle: -90\n            }\n          }\n        },\n        facetAxis: {\n          labels: {\n            angle: -90\n          }\n        }\n      }, t.Settings = f;\n\n      var g = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.style = new v(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsArea);\n\n      t.SettingsArea = g;\n\n      var v = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.selection = new s(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsAreaStyle);\n\n      t.SettingsAreaStyle = v;\n\n      var m = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.logScale = !0, e.zoomOut = !0, e.enabled = !0, e.items = [new d.SettingsToolbarItem(\"fullscreen\", \"left\"), new d.SettingsToolbarItem(\"back\", \"left\"), new d.SettingsToolbarItem(\"zoomOut\", \"left\"), new d.SettingsToolbarItem(\"logScale\", \"right\"), new d.SettingsToolbarItem(\"export\", \"right\")], e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsToolbar);\n\n      t.SettingsToolbar = m;\n\n      var y = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.selection = new r(), e.mode = \"drilldown\", e.animation = {\n            scrollDuration: 500\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsInteraction);\n\n      t.SettingsInteraction = y;\n\n      var S = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.type = \"columns\", e.data = new b(), e;\n        }\n\n        return n(e, t), e.getMapping = function (t, e) {\n          if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n          switch (t ? t.type : e.type) {\n            case \"columns\":\n            case void 0:\n              return d.SettingsMapping.FacetChartSettingsSeriesColumns;\n\n            case \"line\":\n              return d.SettingsMapping.FacetChartSettingsSeriesLines;\n\n            default:\n              throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a series. Valid values are: columns, line.\");\n          }\n        }, e.createInstance = function (t, e) {\n          switch (e || t.type) {\n            case \"columns\":\n            case void 0:\n              return new x();\n\n            case \"line\":\n              return new C();\n\n            default:\n              throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a series. Valid values are: columns, line.\");\n          }\n        }, e;\n      }(l.SettingsSeries);\n\n      t.SettingsSeries = S;\n\n      var b = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.field = null, e.valueFunction = null, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesData);\n\n      t.SettingsSeriesData = b;\n\n      var x = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.style = new L(), e.data = new b(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesColumns);\n\n      t.SettingsSeriesColumns = x;\n\n      var C = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = new b(), e.style = new w(), e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesLines);\n\n      t.SettingsSeriesLines = C;\n\n      var w = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.markerStyleFunction = null, e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesLinesStyle);\n\n      t.SettingsSeriesLinesStyle = w;\n\n      var L = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.previewContents = !1, e.previewLineColor = \"rgba(255,255,255,.5)\", e;\n        }\n\n        return n(e, t), e;\n      }(l.SettingsSeriesColumnsStyle);\n\n      t.SettingsSeriesColumnsStyle = L;\n\n      var T = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(L);\n\n      t.SettingsFacetStyle = T;\n\n      var k = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.sortField = null, e.dataFunction = null, e.preloaded = null, e;\n        }\n\n        return n(e, t), e;\n      }(a.SettingsData);\n\n      t.SettingsData = k;\n\n      var M = function () {\n        function t() {\n          this.id = null, this.data = null, this.items = [], this.parentItem = null, this.activeItemId = null, this.offset = 0, this.count = 0, this.totalCount = 0, this.from = 0, this.to = 0, this.left = 0, this.right = 1, this.opacity = 1, this.loading = null, this.rebuild = !0;\n        }\n\n        return t.prototype.getActiveItem = function () {\n          if (!this.activeItemId) return null;\n\n          for (var t = 0; t < this.items.length; t++) {\n            var e = this.items[t];\n            if (e.id === this.activeItemId) return e;\n          }\n\n          return null;\n        }, t;\n      }();\n\n      t.Facet = M;\n\n      var A = function () {\n        function t(t, e, i, n) {\n          this.expandable = !0, this.selected = !1, this.active = !1, this.url = null, this.urlTarget = null, this.values = [], this.innerFacet = null, this.label = null, this.currentLabel = null, this.facet = t, this.id = e, this.index = i, this.data = n;\n        }\n\n        return t;\n      }();\n\n      t.Item = A;\n\n      var I = function () {\n        function t(t, e, i, n, r) {\n          this.value = 0, this.label = null, this.currentLabel = null, this.style = new T(), this.previewData = null, this.data = n, this.index = i, this.id = e, this.facet = t, this.seriesId = r;\n        }\n\n        return t;\n      }();\n\n      t.ItemValue = I;\n\n      var P = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.data = null, e.stack = [], e.activeFacet = null, e.hoverItem = null, e.selection = [], e.selectionIds = [], e;\n        }\n\n        return n(e, t), e.prototype.xToPosition = function (t) {\n          var e = this.activeFacet,\n              i = this.x0 + e.left * this.width,\n              n = this.x0 + e.right * this.width,\n              r = e.from + (t - i) / (n - i) * (e.to - e.from);\n          return r;\n        }, e.prototype.positionToX = function (t) {\n          var e = this.activeFacet,\n              i = this.x0 + e.left * this.width,\n              n = this.x0 + e.right * this.width;\n          return i + (t - e.from) * (n - i) / (e.to - e.from);\n        }, e.prototype.timeToX = function (t) {\n          return this.positionToX(t);\n        }, e.prototype.xToTime = function (t) {\n          return this.xToPosition(t);\n        }, e.prototype.length = function () {\n          return this.stack.length;\n        }, e.prototype.peek = function () {\n          return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n        }, e.prototype.push = function (t, e) {\n          var i = this.peek();\n          if (i && !e) for (var n = 0; n < i.items.length; n++) {\n            var r = i.items[n];\n\n            if (r.data.__id === t.id) {\n              e = r;\n              break;\n            }\n          }\n\n          if (e) {\n            t.parentItem = e, e.innerFacet = t;\n            var s = this.getItemPlacement(e.facet, e.index);\n            t.left = s.left, t.right = s.right, i.activeItemId = e.id;\n          } else i && (i.activeItemId = null);\n\n          this.stack.push(t), this.activeFacet = t;\n        }, e.prototype.pop = function () {\n          if (this.stack.length > 0) {\n            var t = this.stack.pop();\n            t.parentItem && (t.parentItem.facet.activeItemId = null);\n          }\n\n          return this.stack.length > 0 ? this.activeFacet = this.peek() : this.activeFacet = null, this.activeFacet;\n        }, e.prototype.getParent = function (t) {\n          for (var e = null, i = 0; i < this.stack.length; i++) {\n            var n = this.stack[i];\n            if (n === t) return e;\n            e = n;\n          }\n\n          return null;\n        }, e.prototype.getChild = function (t) {\n          for (var e = null, i = 0; i < this.stack.length; i++) {\n            var n = this.stack[i];\n            if (e === t) return n;\n            e = n;\n          }\n\n          return null;\n        }, e.prototype.updateLinks = function (t) {\n          var e = this.getParent(t),\n              i = this.getChild(t);\n          if (e && !t.parentItem) for (var n = 0; n < e.items.length; n++) {\n            var r = e.items[n];\n\n            if (r.id === t.id) {\n              t.parentItem = r, e.activeItemId = r.id;\n              break;\n            }\n          }\n          if (i && !i.parentItem) for (var n = 0; n < t.items.length; n++) {\n            var r = t.items[n];\n\n            if (r.id === i.id) {\n              i.parentItem = r, t.activeItemId = r.id;\n              break;\n            }\n          }\n        }, e.prototype.getItemPlacement = function (t, e, i) {\n          void 0 === i && (i = e);\n          var n = t.to - t.from,\n              r = t.from,\n              s = (e - r) / n,\n              a = (i - r + 1) / n;\n          return {\n            left: t.left + s * (t.right - t.left),\n            right: t.left + a * (t.right - t.left)\n          };\n        }, e.prototype.getFacetPlacementFromItem = function (t, e, i) {\n          var n = t.facet,\n              r = t.index,\n              s = r + 1,\n              a = (r - n.from) / (n.to - n.from),\n              o = (s - n.from) / (n.to - n.from),\n              l = e - a * (e - i) / (a - o),\n              h = l + (e - i) / (a - o);\n          return {\n            left: l,\n            right: h\n          };\n        }, e.prototype.findItemAt = function (t, e, i) {\n          var n = this.activeFacet;\n\n          if (n) {\n            if (!i && !this.xyInChart(t, e)) return null;\n            if (i && !this.xyInChartOrBottom(t, e)) return null;\n            var r = Math.floor(this.xToPosition(t));\n            if (r >= n.offset && r < n.offset + n.count) return n.items[r - n.offset];\n          }\n\n          return null;\n        }, e;\n      }(l.Scene);\n\n      t.Scene = P;\n\n      var D = function (t) {\n        function e(e) {\n          var i = t.call(this, e) || this;\n          return i.animationOrder = 100, i.paintOrder = 10, i.updateOrder = 1100, i.animatingFacet = null, i.leftAnimator = null, i.rightAnimator = null, i.activePieReady = !1, i._shouldZoomOut = !1, i;\n        }\n\n        return n(e, t), e.prototype.setState = function (t, e, i, n) {\n          if (0 === t.length) return void this.chart.error(\"setPie - array needs at least one item.\");\n\n          for (var r = 0; this.scene.length() > t.length;) {\n            this.scene.pop(), r++;\n          }\n\n          for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) {\n            this.scene.pop(), r++;\n          }\n\n          for (; this.scene.length() < t.length;) {\n            var s = t[this.scene.length()];\n            this.drillDown(s, null), r++;\n          }\n\n          var a = this.scene.peek();\n\n          if (this.facet = a, r && this.goToPositionDragging(a.from, a.to), a.offset !== e || i && a.count !== i) {\n            var o = e,\n                l = void 0;\n            l = i > 0 ? o + i : e + a.count, r ? (this.goToPositionDragging(o, l), this.animateFillChart()) : this.goToPosition(o, l, !0, d.Helpers.performanceNow(), !0);\n          } else r && this.animateFillChart();\n\n          this.chart.notifyChartUpdate(n), r && this.events.notifySceneChanges({\n            navigation: !0\n          });\n        }, e.prototype.getState = function () {\n          for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n            var i = this.scene.stack[e];\n            t.push(i.id);\n          }\n\n          var n = this.scene.peek();\n          return {\n            idArray: t,\n            offset: n.offset,\n            count: n.count\n          };\n        }, e.prototype.goUp = function (t) {\n          if (this.scene.length() > 1) {\n            this.scene.pop();\n            var e = this.facet = this.scene.peek();\n            this.goToPositionDragging(e.from, e.to), this.animateFillChart(), this.events.notifySceneChanges({\n              navigation: !0\n            }), this.updateAndNotifyCurrent(t);\n          } else this.goToPosition(0, this.getMaxItems(), !0, d.Helpers.performanceNow(), !0);\n        }, e.prototype.getMaxItems = function () {\n          var t = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;\n          return this.facet.data.totalCount && (t = Math.min(t, this.facet.data.totalCount)), t;\n        }, e.prototype.drillDown = function (t, e) {\n          this.stopAnimations();\n          var i = new M();\n          i.id = t, this.scene.push(i, null), this.chart.builder.updateFacet(i), this.facet = i, this.setFrom(i.from), this.setTo(i.to), this.animateFillChart(), this.events.notifySceneChanges({\n            navigation: !0\n          }), this.updateAndNotifyCurrent(e);\n        }, e.prototype.updateAndNotifyCurrent = function (t) {\n          this.chart.builder.updateFacet(this.facet), this.chart.notifyChartUpdate(t);\n        }, e.prototype.onSceneChange = function (t) {\n          var e = this.facet,\n              i = t.timeStamp,\n              n = t.changes.settingsChanges;\n\n          if (n && n.series) {\n            t.changes.items = !0;\n\n            for (var r = 0; r < this.scene.stack.length; r++) {\n              var s = this.scene.stack[r];\n              this.chart.builder.rebuildValues(s);\n            }\n          }\n\n          if ((t.changes.pieChartPieIds || t.changes.dataArrived || t.changes.data) && (this.activePieReady = !1, t.changes.data || t.changes.dataArrived)) for (var a = t.changes.pieChartPieIds || Object.create(null), o = 0; o < this.scene.stack.length; o++) {\n            var s = this.scene.stack[o],\n                l = !s.data || s === e || a[s.id] || t.changes.dataDeep;\n            l && (s.rebuild = !0, this.chart.builder.updateFacet(s, t), t.changes.items = !0, this.activePieReady = this.activePieReady || s === e && !s.loading);\n          }\n          this.activePieReady && this.scene.width > 0 && (this.activePieReady = !1, this.inertiaT.finished(i) && e.from < e.to && (this.setFrom(e.from), this.setTo(e.to), this.animateFillChart()), this.chart.notifyChartUpdate(null));\n        }, e.prototype.doAnimations = function (e) {\n          var i = this.facet;\n\n          if (this.animatingFacet) {\n            i.left = this.leftAnimator.get(e.timeStamp), i.right = this.rightAnimator.get(e.timeStamp);\n            var n = this.leftAnimator.finished(e.timeStamp) || this.rightAnimator.finished(e.timeStamp);\n            n && (this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null), this.events.notifySceneChanges({\n              position: !0\n            }), e.animating = !0;\n          } else i.opacity = 1;\n\n          this.layoutFacets();\n\n          for (var r = 0; r < this.scene.stack.length; r++) {\n            i = this.scene.stack[r], this.chart.builder.updateFacet(i, e);\n          }\n\n          t.prototype.doAnimations.call(this, e);\n        }, e.prototype.xyInArea = function (t, e) {\n          return this.scene.xyInChartOrBottom(t, e);\n        }, e.prototype.xyToPosition = function (t, e) {\n          return this.scene.xToPosition(t);\n        }, e.prototype.onGoHome = function (t, e) {\n          return {\n            from: 0,\n            to: e - t,\n            origin: 0\n          };\n        }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {\n          t < 0 && (e -= t, t = 0);\n          var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);\n          t = s.from, e = s.to;\n          var a = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);\n          return a ? void this.goToPosition(a.from, a.to, !0, n, !0) : void (this.wheelOrigin = null);\n        }, e.prototype.onStartDragging = function (t, e, i) {\n          this.stopAnim();\n        }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {\n          var s = e - t,\n              a = this.facet,\n              o = a.totalCount,\n              l = 0,\n              h = 1,\n              u = !1;\n          return this.scene.stack.length > 1 && (s > 2 * o || this.scene.width / s < this.scene.settings.facetAxis.zoomOutUnitWidth) && (u = !0), this._shouldZoomOut = u, a.left = l, a.right = h, {\n            from: t,\n            to: e\n          };\n        }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {\n          if (this._shouldZoomOut) return this._shouldZoomOut = !1, this.goUp(\"user\"), null;\n          var s = this.snap(t, e, i, n, r);\n          return t = s.from, e = s.to, this.animateFillChart(), this.chart.notifyChartUpdate(\"user\"), {\n            from: t,\n            to: e\n          };\n        }, e.prototype.onPositionChanged = function (t, e) {\n          var i = this.facet;\n          i.from = t, i.to = e, this.chart.builder.updateFacet(i), this.events.notifySceneChanges({\n            position: !0\n          });\n        }, e.prototype.onAnimationDone = function (t, e) {\n          this.chart.notifyChartUpdate(null), this.chart.notifyAnimationDone();\n        }, e.prototype.snap = function (t, e, i, n, r) {\n          var s = this.facet,\n              a = s.totalCount;\n          s.right < 1 && (0 === s.right && (s.right = 1e-10), e = t + (e - t) / s.right), s.left > 0 && (1 === s.left && (s.left = 1 - 1e-10), t = e - (e - t) / (1 - s.left));\n          var o = this.scene.width / (e - t),\n              l = o;\n          a > 0 && (l = Math.max(l, this.scene.width / a)), l = Math.min(this.scene.settings.facetAxis.maxUnitWidth, l);\n          var h = o / l;\n          if (t = i + (t - i) * h, e = i + (e - i) * h, t = Math.round(t), e = Math.round(e), t < 0) e -= t, t = 0;else if (e > a) {\n            var u = Math.max(0, a - (e - t));\n            e = e - t + u, t = u;\n          }\n          return {\n            from: t,\n            to: e\n          };\n        }, e.prototype.animateFillChart = function () {\n          0 === this.facet.left && 1 === this.facet.right && this.animatingFacet === this.facet || (this.animatingFacet = this.facet, this.leftAnimator = new d.Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, \"<>\"), this.rightAnimator = new d.Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, \"<>\"), this.events.notifySceneChanges({\n            requestPaint: !0\n          }));\n        }, e.prototype.stopAnim = function () {\n          var t = this.facet;\n          this.animatingFacet && (t.opacity = 1, this.animatingFacet = null), this.leftAnimator && (t.left = this.leftAnimator.get(1 / 0), this.leftAnimator = null), this.rightAnimator && (t.right = this.rightAnimator.get(1 / 0), this.rightAnimator = null), this.layoutFacets();\n        }, e.prototype.layoutFacets = function () {\n          for (var t = this.scene.stack.length - 2; t >= 0; t--) {\n            var e = this.scene.stack[t + 1],\n                i = this.scene.stack[t];\n\n            if (e.parentItem) {\n              var n = this.scene.getFacetPlacementFromItem(e.parentItem, e.left, e.right);\n              i.left = n.left, i.right = n.right;\n            }\n\n            i.opacity = e.left > 0 || e.right < 1 ? .5 : 0;\n          }\n\n          this._shouldZoomOut ? (this.facet.opacity = .65, this.facet.parentItem && this.facet.parentItem.facet && (this.facet.parentItem.facet.opacity = 1)) : this.facet.opacity = 1;\n        }, e;\n      }(l.Scrolling);\n\n      t.Scrolling = D;\n\n      var N = function () {\n        function t(t, e, n) {\n          this.bounds = {\n            x0: 0,\n            y0: 0,\n            width: 0,\n            height: 0\n          }, this.facet = n, this.chart = e, this.scene = this.chart.scene, this.valueAxis = new l.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.xes = [], this.facetAxis = new i(e, n), this.r = new l.Renderer(this.chart, this.valueAxis);\n        }\n\n        return t.prototype.getPanels = function (t) {\n          var e = this.valueAxis.getPanels(!0);\n          return e.push(this.facetAxis.getPanel(t, this.xes)), e;\n        }, t.prototype.setPanels = function (t) {\n          this.valueAxis.setPanels(t), this.facetAxis.panel = t[t.length - 1];\n        }, t.prototype.doAnimations = function (t, e) {\n          var i = e.x0,\n              n = e.y0,\n              r = e.width,\n              s = e.height,\n              a = this.facet,\n              o = a.offset,\n              l = a.left,\n              h = a.right;\n          l = i + r * l, h = i + r * h;\n          var u = Math.max(i, l),\n              c = Math.min(i + r, h);\n          this.bounds = {\n            x0: u,\n            y0: n,\n            width: c - u,\n            height: s\n          };\n          var d = t.changes;\n\n          if (d.position || d.data || d.bounds || d.items) {\n            for (var p = (h - l) / (a.to - a.from), f = l - a.from * p, g = a.count, v = o, m = o + g, y = new Array(g + 1), S = new Array(g + 1), b = v; b < m + 1; b++) {\n              y[b - v] = b, S[b - v] = b * p + f;\n            }\n\n            this.xes = S;\n\n            for (var x = new Array(this.scene.settings._computedSeries.length), C = 0; C < x.length; C++) {\n              for (var w = new Array(g), L = new Array(g), T = new Array(g), b = v; b < m; b++) {\n                var k = this.facet.items[b - o],\n                    M = k.values[C];\n                w[b - v] = M.value, T[b - v] = 1, L[b - v] = M;\n              }\n\n              x[C] = {\n                xes: S,\n                times: y,\n                counts: T,\n                fromIndex: 0,\n                toIndex: g + 1,\n                values: w,\n                config: L,\n                externalItems: function externalItems(t, e) {\n                  return this.config.slice(t, e);\n                }\n              };\n            }\n\n            this.r.process(x);\n          }\n\n          this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t);\n        }, t.prototype.paintScene = function (t) {\n          var e = t.context,\n              i = this.bounds,\n              n = this.facet.opacity,\n              r = 1 === n ? n : .2;\n          0 !== n && (e.globalAlpha = r, this.valueAxis.paintUnder(t), e.globalAlpha = n, d.Graphics.pushClip(t, i.x0, i.y0, i.width, i.height), this.r.paint(t), d.Graphics.popClip(t), e.globalAlpha = r, this.facetAxis.paint(t, i.x0, i.width, this.xes), this.valueAxis.paint(t), e.globalAlpha = 1);\n        }, t;\n      }();\n\n      t.Layer = N;\n\n      var F = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 400, i.paintOrder = 5, i.updateOrder = 1200, i.chart = e, i.scene = i.chart.scene, i.events = i.chart.events, i.layers = [], i.panels = [], i;\n        }\n\n        return n(e, t), e.prototype.onSceneChange = function (t) {\n          var e = t.changes,\n              i = this.chart.settings.horizontal;\n\n          if (e.settings || e.navigation || e.linearChartSeries || e.linearChartValueAxis || i) {\n            var n = e.settingsChanges;\n            e.linearChartValueAxis || n && n.facetAxis ? (e.bounds = !0, this.layers = []) : e.linearChartSeries && (this.layers = []);\n\n            for (var r = 0; r < this.layers.length; r++) {\n              var s = this.layers[r];\n              s.facet !== this.scene.stack[r] && (this.layers = this.layers.slice(0, r));\n            }\n\n            for (; this.layers.length < this.scene.stack.length;) {\n              var a = this.scene.stack[this.layers.length],\n                  o = new N(t, this.chart, a);\n              this.layers.push(o);\n            }\n\n            0 === this.layers.length && this.layers.push(new N(t, this.chart, new M())), this.updatePanels(t), i && (e.bounds = !0);\n          }\n        }, e.prototype.updatePanels = function (t) {\n          var e = this.layers[0].getPanels(t);\n          this.panels = e.filter(function (t) {\n            return null != t;\n          });\n\n          for (var i = 0; i < this.layers.length; i++) {\n            this.layers[i].setPanels(e);\n          }\n        }, e.prototype.getPanels = function () {\n          return this.panels;\n        }, e.prototype.doAnimations = function (t) {\n          for (var e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.doAnimations(t, this.scene);\n          }\n        }, e.prototype.paintScene = function (t) {\n          var e = this.chart.settings.horizontal,\n              i = t.context;\n          e && i.transform.apply(i, this.chart.scene.transform);\n\n          for (var n = 0; n < this.layers.length; n++) {\n            var r = this.layers[n];\n            r.paintScene(t);\n          }\n\n          e && i.transform.apply(i, this.chart.scene.invertedTransform);\n        }, e.prototype.exportData = function (t, e) {\n          return this.layers[this.layers.length - 1].r.exportData(t, e);\n        }, e.prototype.hitTest = function (t, e) {\n          var i = this.scene,\n              n = this.layers;\n          return i.xyInChart(t, e) && n.length > 0 ? n[n.length - 1].r.hitTest(t, e, i.settings.interaction.selection.tolerance) : null;\n        }, e;\n      }(d.ChartElement);\n\n      t.Renderer = F;\n\n      var O = function () {\n        function t(t) {\n          this.chart = t, this.scene = t.scene, this.loading = !1;\n        }\n\n        return t.prototype.updateFacet = function (t, e) {\n          void 0 === e && (e = null);\n          var i = this.chart.getData(\"default\"),\n              n = t.data;\n          if ((!n || e && (e.changes.data || e.changes.dataArrived || e.changes.filters)) && (n = t.data = i.getPieData(t.id), !n)) return t.loading = !0, void i.requestPieData(t.id, Math.floor(t.from));\n          var r = !1;\n\n          if (this.scene.width && (!(t.from < t.to) || t.rebuild)) {\n            t.rebuild = !1;\n            var s = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth)),\n                a = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));\n            n.totalCount && (a = Math.min(n.totalCount, a)), a = Math.max(s, a), t.offset = Math.floor(t.from), t.count = 0, t.to = t.from + Math.floor(a), t.items = [];\n          }\n\n          var o = Math.max(0, Math.floor(t.from) - 2),\n              l = Math.ceil(t.to + 2),\n              h = n.values.length + n.offset,\n              u = n.offset;\n          t.loading = !1, u > o && (o = u, i.requestLessPieData(t.id), t.loading = !0), h < l && (l = h, n.done || (i.requestMorePieData(t.id), t.loading = !0));\n          var c = t.offset + t.items.length;\n          if ((l < t.offset || o > c) && (t.offset = o, t.items = [], c = o), o > t.offset) t.items = t.items.slice(o - t.offset);else if (o < t.offset) {\n            for (var d = [], p = o; p <= t.offset - 1; p++) {\n              d.push(this.buildItem(t, n, p));\n            }\n\n            t.items = d.concat(t.items), r = !0;\n          }\n          if (t.offset = o, l < c) t.items = t.items.slice(0, l - t.offset);else if (l > c) {\n            for (var p = c; p < l; p++) {\n              t.items.push(this.buildItem(t, n, p));\n            }\n\n            r = !0;\n          }\n\n          if (t.count = t.items.length, t.totalCount = Math.max(t.offset + t.count, n.totalCount || 0), r) {\n            if (e) e.changes.items = !0, e.changes.changedItems || (e.changes.changedItems = {}), e.changes.changedItems[t.id] = !0;else {\n              var f = {};\n              f[t.id] = !0, this.chart.events.notifySceneChanges({\n                items: !0,\n                changedItems: f\n              });\n            }\n            this.resetSelection() && this.chart.events.notifySceneChanges({\n              items: !0\n            });\n          }\n\n          this.scene.updateLinks(t);\n        }, t.prototype.resetSelection = function () {\n          for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {\n            var n = i[e];\n            t.selectionIds.push(n.id), n.selected = !1;\n          }\n\n          return t.selection = [], t.selectionIds.length > 0;\n        }, t.prototype.rebuildValues = function (t) {\n          for (var e = 0; e < t.items.length; e++) {\n            var i = t.items[e];\n            this.updateItem(i);\n          }\n        }, t.prototype.buildItem = function (t, e, i) {\n          var n = e.values[i - e.offset],\n              r = new A(t, n.__id, i, n);\n          return this.updateItem(r), r;\n        }, t.prototype.updateItem = function (t) {\n          for (var e = [], i = 0; i < this.scene.settings._computedSeries.length; i++) {\n            var n = this.scene.settings._computedSeries[i],\n                r = new I(t.facet, t.id, t.index, t.data, n.id);\n            t.data ? r.value = this.getSeriesValue(t.data, n) : r.value = null, e.push(r);\n          }\n\n          t.values = e;\n        }, t.prototype.getSeriesValue = function (t, e) {\n          var i = e.data.valueFunction,\n              n = null;\n          if (i) n = i(t);else {\n            var r = e.data.field || \"value\";\n            n = t[r];\n          }\n          return d.Helpers.tryParseFloat(n, null);\n        }, t.prototype.buildPreviewData = function (t, e) {\n          var i = t.id,\n              n = this.scene.mainData,\n              r = n.getPieData(i),\n              s = null;\n          if (r) {\n            if (r.offset > 0) n.requestLessPieData(t.id);else {\n              s = [];\n\n              for (var a = 0, o = 0; o < r.values.length; o++) {\n                var l = r.values[o],\n                    h = this.getSeriesValue(l, e);\n                s.push(h), a += h;\n              }\n\n              if (a > 0) {\n                a = 1 / a;\n\n                for (var u = 0; u < s.length; u++) {\n                  s[u] = s[u] * a;\n                }\n              } else s = null;\n            }\n          } else t.expandable && n.canExpand(i) && n.requestPieData(t.id, 0);\n          return s;\n        }, t;\n      }();\n\n      t.Builder = O;\n\n      var E = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 200, i.paintOrder = 20, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i;\n        }\n\n        return n(e, t), e.prototype.doAnimations = function (t) {\n          var e = t.changes;\n\n          if (e.settings || e.items || e.selection || e.navigation || e.style) {\n            var i = this.scene.activeFacet;\n            if (i) for (this.computeFacetStyleRec(i); i && i.parentItem;) {\n              i = i.parentItem.facet, this.computeFacetStyleRec(i);\n            }\n          }\n        }, e.prototype.computeFacetStyleRec = function (t) {\n          this.computeFacetStyle(t);\n\n          for (var e = 0; e < t.items.length; e++) {\n            var i = t.items[e];\n            this.computeItemStyle(t, i), i.innerFacet && this.computeFacetStyleRec(i.innerFacet);\n          }\n        }, e.prototype.computeFacetStyle = function (t) {}, e.prototype.computeItemStyle = function (t, e) {\n          var i = this.scene.settings._computedSeries;\n          if (d.Helpers.extendStyleTo(this.scene.settings.items.style, e), e.data.style && d.SettingsHelper.updateRecursive(e, e.data.style, d.SettingsMapping.FacetChartSettingsFacetStyle, {}), e.id === e.facet.activeItemId) for (var n = 0; n < e.values.length; n++) {\n            var r = e.values[n];\n            r.style.fillColor = null, r.style.lineColor = null;\n          } else for (var n = 0; n < e.values.length; n++) {\n            var r = e.values[n];\n            d.Helpers.extendStyleTo(i[n].style, r.style);\n          }\n          if (this.scene.settings.items.styleFunction ? (this.scene.settings.items.styleFunction(e, e.data), e.label && !d.Helpers.isString(e.label) && (e.label = \"\" + e.label)) : e.data.name && (e.label = e.data.name), e.id !== e.facet.activeItemId) for (var n = 0; n < e.values.length; n++) {\n            var r = e.values[n],\n                s = i[n];\n            r.style.previewContents ? r.previewData = this.chart.builder.buildPreviewData(e, s) : r.previewData = null;\n          } else e.values[e.values.length - 1].previewData = null;\n        }, e;\n      }(d.ChartElement);\n\n      t.Styles = E;\n\n      var R = function (t) {\n        function e(e, i) {\n          var n = t.call(this, new f(e), new P(), i) || this;\n          return n.builder = new O(n), n.renderer = n.events.addElement(new F(n)), n.scrolling = n.events.addElement(new D(n)), n.selection = n.events.addElement(new o(n)), n.events.addElement(new E(n)), n.infoPopup = new h(n), n.events.addElement(n.infoPopup), n.events.addElement(new l.Highlights(n)), n.scrollButtons = n.events.addElement(new c(n)), n.finalInitialize(), n.scrolling.setState(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, 0, \"init\"), n;\n        }\n\n        return n(e, t), e.prototype.createDataObj = function (t) {\n          return new a.Data(this, t, !0);\n        }, e.prototype.getData = function (e) {\n          return t.prototype.getData.call(this, e);\n        }, e.prototype.onSettingsChanged = function (t) {\n          var e = {\n            settings: !0,\n            settingsChanges: t,\n            items: !1\n          };\n          t.navigation && this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, \"api\"), (t.series || t.interaction) && (e.items = !0), this.events.notifySceneChanges(e), (t.data || t.facetAxis) && this.updateSize(!0);\n        }, e.prototype.updateFilters = function () {\n          return this.updateFilter(!0);\n        }, e.prototype.updateFilter = function (t) {\n          void 0 === t && (t = !1), this.log(\"Update filter\");\n          var e = {};\n\n          for (var i in this.settings._computedDataMap) {\n            e[i] = !0;\n          }\n\n          this.events.notifySceneChanges({\n            data: e,\n            dataDeep: t\n          });\n        }, e.prototype.setSelection = function (t, e) {\n          void 0 === e && (e = \"api\"), this.log(\"Set selection\");\n\n          for (var i = [], n = [], r = 0; r < t.length; r++) {\n            var s = t[r];\n            s instanceof A ? i.push(s) : d.Helpers.isString(s) ? n.push(s) : this.error(\"SetSelection: Selection contents must be FacetChart.Item object or string, got \" + typeof s);\n          }\n\n          this.selection.setSelection(i, n, !1, e);\n        }, e.prototype.exportVisibleData = function () {\n          var t = this.scene.peek();\n          return t ? a.Data.exportValues(t.data) : [];\n        }, e.prototype.setPie = function (t, e, i, n) {\n          void 0 === i && (i = null), void 0 === n && (n = !0), this.log(\"Set pie\"), this.scrolling.setState(t, e, i, \"api\");\n        }, e.prototype.getPie = function () {\n          return this.scrolling.getState().idArray;\n        }, e.prototype.getPieOffset = function () {\n          return this.scrolling.getState().offset;\n        }, e.prototype.getActiveItems = function () {\n          for (var t = [], e = 0; e < this.scene.stack.length; e++) {\n            var i = this.scene.stack[e];\n            i.parentItem && t.push(i.parentItem);\n          }\n\n          return t;\n        }, e.prototype.getActiveFacets = function () {\n          return this.scene.stack;\n        }, e.prototype.zoomOut = function (t, e) {\n          void 0 === t && (t = !0), void 0 === e && (e = \"api\"), this.setSelection([]), this.scrolling.goUp(e);\n        }, e.prototype.zoomOutPossible = function () {\n          var t = this.scene;\n          return t.length() > 1 || t.peek() && t.peek().offset > 0;\n        }, e.prototype.getBottomHeight = function () {\n          return this.scene.chartHeight - this.settings.facetAxis.size;\n        }, e.prototype.expandItem = function (t, e) {\n          var i = t.facet;\n\n          if (i === this.scene.peek()) {\n            var n = t.id;\n            if (t.expandable && this.scene.mainData.canExpand(n)) return this.setSelection([]), this.scrolling.drillDown(n, e), !0;\n          }\n\n          return !1;\n        }, e.prototype.saveNavigation = function () {\n          var t = this.scene.peek();\n          return !t || this.scrolling.isActive() ? null : this.scrolling.getState();\n        }, e.prototype.restoreNavigation = function (t, e, i) {\n          return this.scrolling.setState(t.idArray, t.offset, t.count, i);\n        }, e.prototype.save = function () {\n          for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {\n            var i = this.scene.selection[e];\n            t.push(i.id);\n          }\n\n          var n = this.scrolling.getState();\n          return JSON.stringify({\n            pie: n.idArray,\n            offset: n.offset,\n            count: n.count,\n            selection: t\n          });\n        }, e.prototype.restore = function (t, e) {\n          if (t) {\n            var i = JSON.parse(t);\n            this.setPie(i.pie, i.offset, i.count, e), this.setSelection(i.selection);\n          }\n        }, e.prototype.createEventArguments = function (t, e, i) {\n          var n = this.scene;\n          if (!n) return {\n            chart: this.api,\n            origin: e\n          };\n          var r = n.peek(),\n              s = i && i.facet,\n              a = n.hoverSeriesItem,\n              o = a && null != a.seriesIndex ? n.settings._computedSeries[a.seriesIndex] : null;\n          return {\n            chart: this.api,\n            origin: e,\n            facet: r,\n            offset: r && r.offset,\n            count: r && r.count,\n            hoverItem: n.hoverItem,\n            hoverSeries: o,\n            hoverMarker: !!a && a.isMarker,\n            selection: n.selection.slice(),\n            clickItem: i,\n            clickFacet: s,\n            clickOrigin: null\n          };\n        }, e.prototype.defaultClick = function (t, e) {\n          this.selection.defaultClick(t, e);\n        }, e.prototype.remove = function () {\n          t.prototype.remove.call(this), this.infoPopup.remove();\n        }, e;\n      }(l.Impl);\n\n      t.Impl = R;\n    }(s = i.FacetChart || (i.FacetChart = {})), function (e) {\n      function r(t) {\n        return t ? t.properties && t.properties.id && d.Helpers.isString(t.properties.id) ? t.properties.id : t.id : null;\n      }\n\n      function s(t) {\n        if (!Array.isArray(t)) return \"GeoJSON LineString data contained invalid coordinate collection.\";\n        if (t.length < 2) return \"GeoJSON LineString data must contain at least 2 points.\";\n\n        for (var e = new Array(2 * t.length), i = 0; i < t.length; i++) {\n          var n = t[i];\n          if (!n || !d.Helpers.isNumber(n[0]) || !d.Helpers.isNumber(n[1])) return \"GeoJSON LineString data contained invalid coordinates.\";\n          e[2 * i] = n[0], e[2 * i + 1] = n[1];\n        }\n\n        return e;\n      }\n\n      function a(t, e) {\n        if (!Array.isArray(t)) return \"GeoJSON Polygon data contained invalid coordinate collection.\";\n        if (t.length < 1) return \"GeoJSON Polygon data doesn't contain any LinearRings.\";\n\n        for (var i = 0; i < t.length; i++) {\n          var n = s(t[i]);\n          if (d.Helpers.isString(n)) return n;\n          e.push(n);\n        }\n\n        return null;\n      }\n\n      function o(t) {\n        return d.Helpers.isNumber(t[0]) && d.Helpers.isNumber(t[1]) ? [t[0], t[1]] : \"GeoJSON data contained invalid coordinates.\";\n      }\n\n      function l(t) {\n        var e = [],\n            i = a(t.coordinates, e);\n        return i ? i : e;\n      }\n\n      function h(t) {\n        var e = t.coordinates;\n        if (!Array.isArray(e)) return \"GeoJSON MultiPolygon data contained invalid coordinates\";\n        if (e.length < 1) return \"GeoJSON MultiPolygon data doesn't contain any Polygons.\";\n\n        for (var i = [], n = 0; n < e.length; n++) {\n          var r = a(e[n], i);\n          if (r) return r;\n        }\n\n        return i;\n      }\n\n      function c(t) {\n        var e = s(t.coordinates);\n        return d.Helpers.isString(e) ? e : [e];\n      }\n\n      function p(t) {\n        var e = t.coordinates;\n        if (!Array.isArray(e)) return \"GeoJSON MultiLineString data contained invalid coordinates\";\n        if (e.length < 1) return \"GeoJSON MultiLineString data doesn't contain any lines.\";\n\n        for (var i = new Array(e.length), n = 0; n < e.length; n++) {\n          var r = s(e[n]);\n          if (d.Helpers.isString(r)) return r;\n          i[n] = r;\n        }\n\n        return i;\n      }\n\n      function f(t, e, i, n, s, a) {\n        d.Helpers.isString(e) ? a(e, n) : t.push({\n          _x: 0,\n          _y: 0,\n          id: r(n),\n          loaded: !0,\n          coordinates: e,\n          type: i,\n          shapeFeature: n,\n          shapeGeometry: s\n        });\n      }\n\n      function g(t, e, i, n) {\n        if (!Array.isArray(e.coordinates)) return void n(\"GeoJSON data contained invalid object.\", i);\n\n        switch (e.type) {\n          case \"Point\":\n            f(t, o(e.coordinates), \"point\", i, e, n);\n            break;\n\n          case \"MultiPoint\":\n            var r = e;\n            if (Array.isArray(r.coordinates)) for (var s = 0; s < r.coordinates.length; s++) {\n              f(t, o(r.coordinates[s]), \"point\", i, e, n);\n            } else n(\"GeoJSON data contained invalid MultiPoint object.\", i);\n            break;\n\n          case \"LineString\":\n            f(t, c(e), \"line\", i, e, n);\n            break;\n\n          case \"MultiLineString\":\n            f(t, p(e), \"line\", i, e, n);\n            break;\n\n          case \"Polygon\":\n            f(t, l(e), \"polygon\", i, e, n);\n            break;\n\n          case \"MultiPolygon\":\n            f(t, h(e), \"polygon\", i, e, n);\n            break;\n\n          default:\n            return void n('GeoJSON data contained unknown object with type \"' + e.type + '\" .', i);\n        }\n      }\n\n      function v(t, e, i, n) {\n        if (\"GeometryCollection\" === e.type) {\n          var r = e;\n          if (Array.isArray(r.geometries)) for (var s = 0; s < r.geometries.length; s++) {\n            v(t, r.geometries[s], i, n);\n          } else n(\"GeoJSON data contained invalid GeometryCollection object.\", i);\n        } else g(t, e, i, n);\n      }\n\n      function m(t, e, i) {\n        return e.geometry && \"Feature\" === e.type ? void v(t, e.geometry, e, i) : void i(\"GeoJSON data contained invalid feature object.\", e);\n      }\n\n      function y(t, e, i) {\n        if (!Array.isArray(e.features) || \"FeatureCollection\" !== e.type) return void i(\"GeoJSON data contained invalid FeatureCollection object.\", null);\n\n        for (var n = 0; n < e.features.length; n++) {\n          m(t, e.features[n], i);\n        }\n      }\n\n      function S(t, e) {\n        function i(t, i) {\n          e.error(\"Error: \" + t + \" Feature id: '\" + r(i) + \"'\");\n        }\n\n        if (!t) return [];\n        var n = [];\n\n        switch (t.type) {\n          case \"FeatureCollection\":\n            y(n, t, i);\n            break;\n\n          case \"Feature\":\n            m(n, t, i);\n            break;\n\n          case \"GeometryCollection\":\n            v(n, t, null, i);\n            break;\n\n          case \"Point\":\n          case \"MultiPoint\":\n          case \"LineString\":\n          case \"MultiLineString\":\n          case \"Polygon\":\n          case \"MultiPolygon\":\n            g(n, t, null, i);\n            break;\n\n          default:\n            return void i('GeoJSON data contained unknown object with type \"' + t.type + '\" .', null);\n        }\n\n        for (var s = {\n          \"##default\": 0\n        }, a = 0; a < n.length; a++) {\n          var o = n[a];\n          null == o.id ? o.id = \"##default\" + d.Helpers.SeparatorChar + s[\"##default\"]++ : d.Helpers.hasProperty(s, o.id) ? o.id += d.Helpers.SeparatorChar + s[o.id]++ : s[o.id] = 0;\n        }\n\n        return n;\n      }\n\n      e.convertFromGeoJson = S;\n\n      var b = function () {\n        function t(t, e, i) {\n          this.nodes = {}, this.links = {}, this.area = new d.AreaCollection(), this.requestedArea = new d.AreaCollection(), this.pendingArea = null, this.cacheId = i, this.id = e, this.level = t;\n        }\n\n        return t;\n      }();\n\n      e.DataLayer = b;\n\n      var x = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.dataFunction = null, e.preloaded = null, e.prefetchRatio = 1, e.bounds = [-180, -85.0511287798, 180, 85.0511287798], e.wrapLng = !0, e.maxRequestRect = [256, 256], e.perBoundsData = !0, e.perZoomData = !1, e.perDrilldownData = !1, e.useGridBasedAggregation = !1, e.aggregationGridSize = 100, e.aggregationMinCount = 5, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsData);\n\n      e.SettingsData = x;\n\n      var C = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e, i) || this;\n          n.layers = {}, n.pendingLayers = [], n.nextId = 0, n.aggregationGridSize = 1, n.zoomLevel = null, n.projectFun = function (t, e) {\n            return n.chart.scene.project(t, e);\n          }, n.unprojectFun = function (t, e) {\n            return n.chart.scene.unproject(t, e);\n          };\n          var r = n.projectFun(n.dataSettings.bounds[0], n.dataSettings.bounds[1]),\n              s = n.projectFun(n.dataSettings.bounds[2], n.dataSettings.bounds[3]);\n          return n.projectedBounds = new d.Rect(Math.min(r.x, s.x), Math.min(r.y, s.y), Math.max(r.x, s.x), Math.max(r.y, s.y)), n;\n        }\n\n        return n(e, t), e.prototype.getProjectedBounds = function () {\n          return this.projectedBounds;\n        }, e.prototype.setViewParams = function (t, e, i, n, r) {\n          this.dataSettings.perZoomData ? this.zoomLevel = e : this.zoomLevel = null, this.aggregationGridSize = t, this.loadDataArea = this.buildRectArea(r), this.returnDataArea = this.buildRectArea(n), this.visibleArea = this.buildRectArea(i), this.pendingLayers = [];\n        }, e.prototype.getLayer = function (t) {\n          var e = \"\",\n              i = null;\n          t && (e += \"\" + t), null !== this.zoomLevel && (e += \"#z\" + this.zoomLevel, i = this.zoomLevel);\n          var n;\n          return n = this.layers.hasOwnProperty(e) ? this.layers[e] : this.layers[e] = new b(i, t, e), this.lastLayer = n, n;\n        }, e.prototype.getData = function (t) {\n          var e,\n              i = this.getLayer(t);\n          i.area.coversArea(this.loadDataArea) ? (i.pendingArea = new d.AreaCollection(), e = !1) : i.requestedArea.coversArea(this.loadDataArea) ? e = this.hasPendingRequests() : (i.pendingArea = this.loadDataArea.makeCopy().subtractArea(i.requestedArea), i.pendingArea.isEmpty() || (this.pendingLayers.indexOf(i) < 0 && this.pendingLayers.push(i), this.scheduleRequests(!0)), e = this.hasPendingRequests());\n          var n = this.applyFilters(i, this.returnDataArea);\n          return this.chart.log(\"Data: returned \" + n.nodes.length + \" nodes and \" + n.links.length + \" links for ID: \" + t + \", loading=\" + e), {\n            nodes: n.nodes,\n            links: n.links,\n            hasData: i.area.intersectsArea(this.visibleArea),\n            loading: e\n          };\n        }, e.prototype.applyFilters = function (t, e) {\n          var i,\n              n,\n              r = e.toRects(),\n              s = this.settings.filters.nodeFilter,\n              a = [],\n              o = [],\n              l = {};\n\n          for (var h in t.nodes) {\n            var u = t.nodes[h],\n                c = u._bounds,\n                d = !s || s(u);\n            if (d) for (i = 0; i < r.length; i++) {\n              if (n = r[i], n.overlapsRect(c.x0, c.y0, c.x1, c.y1)) {\n                a.push(u), l[h] = !0;\n                break;\n              }\n            }\n          }\n\n          for (var h in t.links) {\n            var p = t.links[h],\n                f = l[p.from],\n                g = l[p.to];\n            if (f || g) o.push(p), f || (l[p.from] = !0, a.push(t.nodes[p.from])), g || (l[p.to] = !0, a.push(t.nodes[p.to]));else {\n              var v = t.nodes[p.from],\n                  m = t.nodes[p.to];\n\n              if (v._x && m._x) {\n                var y = v._x,\n                    S = v._y,\n                    b = m._x,\n                    x = m._y;\n\n                for (i = 0; i < r.length; i++) {\n                  if (n = r[i], n.intersectsSegment(y, S, b, x)) {\n                    a.push(v), a.push(m), l[p.from] = !0, l[p.to] = !0;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          return {\n            nodes: a,\n            links: o\n          };\n        }, e.prototype.unprojectRect = function (t) {\n          var e = this.unprojectFun(t.x0, t.y0),\n              i = this.unprojectFun(t.x1, t.y1);\n          return new d.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat));\n        }, e.prototype.projectRect = function (t) {\n          var e = this.projectFun(t.x0, t.y0),\n              i = this.projectFun(t.x1, t.y1);\n          return new d.Rect(Math.min(e.x, i.x), Math.min(e.y, i.y), Math.max(e.x, i.x), Math.max(e.y, i.y));\n        }, e.prototype.buildRectArea = function (t) {\n          var e = this.projectedBounds,\n              i = t.x0,\n              n = t.y0,\n              r = t.x1,\n              s = t.y1,\n              a = new d.AreaCollection();\n\n          if (n = Math.max(n, e.y0), s = Math.min(s, e.y1), this.dataSettings.wrapLng) {\n            var o = e.x1 - e.x0;\n            if (r - i > o) i = e.x0, r = e.x1;else {\n              for (; i < e.x0;) {\n                i += o, r += o;\n              }\n\n              for (; i > e.x1;) {\n                i -= o, r -= o;\n              }\n            }\n            r <= e.x1 ? a.addRect(new d.Rect(i, n, r, s)) : (a.addRect(new d.Rect(i, n, e.x1, s)), a.addRect(new d.Rect(e.x0, n, r - o, s)));\n          } else a.addRect(t.clone().clip(e));\n\n          return a;\n        }, e.prototype.buildRequest = function () {\n          if (this.pendingLayers.length > 0) {\n            var t = this.pendingLayers[0],\n                e = t.pendingArea.findOverlappingRect(this.dataSettings.maxRequestRect[0], this.dataSettings.maxRequestRect[1]);\n            t.pendingArea.subtractRect(e), t.pendingArea.isEmpty() && d.Helpers.removeFromArray(this.pendingLayers, t);\n            var i = e,\n                n = [],\n                r = [];\n\n            if (this.dataSettings.useGridBasedAggregation) {\n              var s = this.buildAggregationRequest(e);\n              i = s.rectangle, n = s.xcuts, r = s.ycuts;\n            }\n\n            t.requestedArea.addRect(i);\n            var a = this.unprojectRect(i);\n            return {\n              id: t.id,\n              layerId: t.cacheId,\n              west: a.x0,\n              north: a.y1,\n              east: a.x1,\n              south: a.y0,\n              zoom: this.zoomLevel,\n              aggregateLat: r,\n              aggregateLng: n,\n              aggregateMinItems: this.dataSettings.aggregationMinCount\n            };\n          }\n\n          return null;\n        }, e.prototype.buildAggregationRequest = function (t) {\n          for (var e = this.aggregationGridSize, i = Math.floor(t.x0 / e) * e, n = Math.ceil(t.x1 / e) * e, r = Math.floor(t.y0 / e) * e, s = Math.ceil(t.y1 / e) * e, a = this.dataSettings.bounds[0], o = this.dataSettings.bounds[1], l = this.dataSettings.bounds[2], h = this.dataSettings.bounds[3], u = [], c = [], p = i; p <= n; p += e) {\n            u.push(Math.min(Math.max(this.unprojectFun(p, r).lng, a), l));\n          }\n\n          for (var f = r; f <= s; f += e) {\n            c.push(Math.min(Math.max(this.unprojectFun(i, f).lat, o), h));\n          }\n\n          return {\n            rectangle: new d.Rect(i, r, n, s),\n            xcuts: u,\n            ycuts: c\n          };\n        }, e.prototype.dataFunc = function (t, e, i) {\n          var n = this.dataSettings;\n          if (n.dataFunction) n.dataFunction(t, e, i);else if (n.url) {\n            var r = [[\"id\", t.id], [\"south\", t.south.toString(10)], [\"west\", t.west.toString(10)], [\"north\", t.north.toString(10)], [\"east\", t.east.toString(10)]];\n            (t.aggregateLat.length || t.aggregateLng.length) && (r.push([\"aggregateLat\", t.aggregateLat.join(\",\")]), r.push([\"aggregateLng\", t.aggregateLng.join(\",\")]), r.push([\"aggregateMinItems\", t.aggregateMinItems.toString(10)])), null !== t.zoom && r.push([\"zoom\", t.zoom.toString(10)]), d.Data.doRequest(n.url, n, r, e, i);\n          } else i({\n            error: \"Chart configuration does not define data retrieval function\"\n          });\n        }, e.prototype.verifyData = function (t, e) {\n          \"geojson\" === this.dataSettings.format.toLowerCase() && (e.nodes = S(e, this.chart));\n          var i = !0;\n          e.hasOwnProperty(\"nodes\") || (e.nodes = []), e.hasOwnProperty(\"links\") || (e.links = []);\n          var n = d.Helpers.tryParseFloat(e.west, t ? t.west : 1 / 0),\n              r = d.Helpers.tryParseFloat(e.east, t ? t.east : -(1 / 0)),\n              s = d.Helpers.tryParseFloat(e.north, t ? t.north : 1 / 0),\n              a = d.Helpers.tryParseFloat(e.south, t ? t.south : -(1 / 0));\n          e._bounds = new d.Rect(n, a, r, s);\n\n          for (var o = {}, l = 0; l < e.nodes.length; l++) {\n            var h = e.nodes[l];\n            if (Array.isArray(h.coordinates) || (this.chart.error(\"Data response: Node has no coordinates, or not an array\"), i = !1), h.aggregate) d.Helpers.isNumber(h.count) || (this.chart.error(\"Aggregated node needs `count` field that contains a number.\"), i = !1);else if (h.hasOwnProperty(\"id\")) {\n              var u = h.id.toString();\n              o.hasOwnProperty(u) && this.chart.error(\"Data response: Multiple nodes with same id: \" + u), o[u] = !0;\n            } else this.chart.error(\"Data response: Node without ID\"), i = !1;\n          }\n\n          for (var c = {}, p = 0; p < e.links.length; p++) {\n            var f = e.links[p];\n            f.hasOwnProperty(\"id\") ? c.hasOwnProperty(f.id) && this.chart.error(\"Data response: Multiple links with the same ID: \" + f.id) : f.id = d.Helpers.SeparatorChar + (this.nextId++).toString(10), o[f.from] || o[f.to] || this.chart.error(\"Data response: Returned link that does not match any node: \" + f.id), c[f.id] = !0;\n          }\n\n          return i;\n        }, e.prototype.addVerifiedData = function (t, e) {\n          var i, n;\n          t ? (n = t.id, i = t.layerId) : (i = \"\", n = \"\");\n          var r,\n              s,\n              a = this.layers[i];\n          if (a || (a = this.getLayer(n)), e.clearCache) a.nodes = {}, a.links = {}, a.area = new d.AreaCollection(), a.area.addRect(this.projectedBounds);else if (e._bounds.x0 !== 1 / 0) {\n            var o = this.projectRect(e._bounds);\n\n            for (var l in a.nodes) {\n              r = a.nodes[l], o.overlaps(r._bounds) && delete a.nodes[l];\n            }\n\n            for (var l in a.links) {\n              s = a.links[l], a.nodes[s.from] && a.nodes[s.to] || delete a.links[l];\n            }\n\n            a.area.addRect(o);\n          } else a.area.addRect(this.projectedBounds);\n\n          for (var h = {}, u = 0; u < e.nodes.length; u++) {\n            r = e.nodes[u], r.loaded = !0, r.aggregate ? (r.id = d.Helpers.SeparatorChar + this.nextId, this.nextId++, a.nodes[r.id] = r) : (h[r.id] = !0, a.nodes.hasOwnProperty(r.id) ? d.Helpers.extendDeep(a.nodes[r.id], r) : a.nodes[r.id] = r), r.coordinates && (Array.isArray(r.coordinates[0]) ? this.prepareShape(r) : this.preparePoint(r));\n          }\n\n          for (var c = {}, p = 0; p < e.links.length; p++) {\n            s = e.links[p], c[s.id] = !0, a.links[s.id] = s;\n          }\n\n          var f = {};\n          f[n || \"\"] = {\n            nodes: h,\n            links: c\n          };\n          var g = {};\n          return g[this.dataSettings.id] = f, {\n            geoChartDataNodesIds: g\n          };\n        }, e.prototype.prepareShape = function (t) {\n          for (var e = [], i = d.Rect.createEmpty(), n = 0; n < t.coordinates.length; n++) {\n            var r = t.coordinates[n],\n                s = this.projectLineString(r, i);\n            e.push(s);\n          }\n\n          t._bounds = i, t._coordinates = e;\n        }, e.prototype.preparePoint = function (t) {\n          if (2 !== t.coordinates.length) return void this.chart.error(\"Point coordinates must be an array of two numbers.\");\n          var e = t.coordinates,\n              i = e[0],\n              n = e[1],\n              r = this.projectFun(i, n);\n          t._x = r.x, t._y = r.y, t._bounds = new d.Rect(r.x, r.y, r.x, r.y);\n        }, e.prototype.projectLineString = function (t, e) {\n          for (var i = [], n = 0; n < t.length - 1; n += 2) {\n            var r = this.projectFun(t[n], t[n + 1]);\n            i.push(r.x), i.push(r.y), e.addPoint(r.x, r.y);\n          }\n\n          return i;\n        }, e.prototype.exportAreas = function () {\n          var t = this.lastLayer.area.toRects(),\n              e = this.lastLayer.requestedArea.toRects(),\n              i = this.lastLayer.pendingArea.toRects();\n          return this.projectRects(t), this.projectRects(e), this.projectRects(i), {\n            areasRects: t,\n            reqAreasRects: e,\n            pendingAreasRects: i\n          };\n        }, e.prototype.projectRects = function (t) {\n          for (var e = 0; e < t.length; e++) {\n            var i = t[e],\n                n = this.projectFun(i.x0, i.y0);\n\n            if (i.x0 = n.x, i.y0 = n.y, n = this.projectFun(i.x1, i.y1), i.x1 = n.x, i.y1 = n.y, i.y1 < i.y0) {\n              var r = i.y0;\n              i.y0 = i.y1, i.y1 = r;\n            }\n          }\n        }, e;\n      }(d.Data);\n\n      e.Data = C, e.Leaflet = null, \"undefined\" != typeof L && (e.Leaflet = L);\n\n      var w = function () {\n        function t(t, e, i) {\n          var n = this;\n          this.layers = i, this.chartContainer = e, this.chart = t, this.wasDragged = null, this.wasZoomed = !1, this.translate = null, this.updatePosDelegate = function () {\n            return n.updatePos();\n          }, this.onZoomDelegate = function (t) {\n            return n.onZoom(t);\n          }, this.viewResetDelegate = function () {\n            return n.viewReset();\n          }, this.userActionEndDelegate = function () {\n            return n.userActionEnd();\n          }, this.userActionStartDelegate = function () {\n            return n.userActionStart();\n          };\n        }\n\n        return t.prototype.extendLayer = function (t) {\n          var e = this,\n              i = t.onAdd,\n              n = t.onRemove;\n          t.onAdd = function (n) {\n            return e.onAdd(n), i ? i.call(t, n) : t;\n          }, t.onRemove = function (i) {\n            return e.onRemove(i), n ? n.call(t, i) : t;\n          };\n        }, t.prototype.onAdd = function (t) {\n          return this.map = t, t.getPanes().overlayPane.appendChild(this.chartContainer), t.on(\"move\", this.updatePosDelegate, this), t.on(\"zoomanim\", this.onZoomDelegate, this), t.on(\"viewreset\", this.viewResetDelegate, this), t.on(\"moveend\", this.userActionEndDelegate, this), t.on(\"movestart\", this.userActionStartDelegate, this), this.updatePos(), this;\n        }, t.prototype.onRemove = function (t) {\n          return t.getPanes().overlayPane.removeChild(this.chartContainer), t.off(\"move\", this.updatePosDelegate, this), t.off(\"zoomanim\", this.onZoomDelegate, this), t.off(\"viewreset\", this.viewResetDelegate, this), t.off(\"moveend\", this.userActionEndDelegate, this), t.off(\"movestart\", this.userActionStartDelegate, this), this;\n        }, t.prototype.userActionStart = function () {\n          this.wasDragged = !0;\n        }, t.prototype.userActionEnd = function () {\n          var t;\n          t = this.wasDragged === !0 ? \"user\" : null === this.wasDragged ? \"init\" : \"api\", this.chart.notifyChartUpdate(t), this.wasDragged = !1;\n        }, t.prototype.viewReset = function () {\n          this.updatePos(), this.userActionEnd();\n        }, t.prototype.setTranslate = function () {\n          null !== this.translate && (this.chartContainer.style[e.Leaflet.DomUtil.TRANSFORM] = this.translate, this.chartContainer.style[e.Leaflet.DomUtil.TRANSFORM + \"Origin\"] = \"50% 50%\", this.translate = null);\n        }, t.prototype.getTranslateString = function (t) {\n          var e = L.Browser.webkit3d,\n              i = \"translate\" + (e ? \"3d\" : \"\") + \"(\",\n              n = (e ? \",0\" : \"\") + \")\";\n          return i + t.x + \"px,\" + t.y + \"px\" + n;\n        }, t.prototype.updatePos = function () {\n          if (this.map) {\n            var t = this.map.options.crs,\n                i = this.chart.scene;\n            this.offset = this.map.containerPointToLayerPoint(e.Leaflet.point(0, 0)), this.chartContainer.setAttribute(\"class\", \" \"), this.translate = this.getTranslateString(this.offset);\n            var n = this.map.getPixelBounds(),\n                r = t.transformation.untransform(n.min, t.scale(this.map.getZoom()));\n            r = t.transformation.transform(r, t.scale(0));\n            var s = t.transformation.untransform(n.max, t.scale(this.map.getZoom()));\n            s = t.transformation.transform(s, t.scale(0));\n            var a = this.map.getZoom();\n            a !== i.zoomLevel && (i.zoom = Math.pow(2, a), i.zoomLevel = a, this.wasZoomed = !0), i.centerX = (s.x + r.x) / 2, i.centerY = (s.y + r.y) / 2, this.chart.events && !this.layers.resizing && (this.wasZoomed ? (this.chart.events.notifySceneChanges({\n              zoom: !0,\n              position: !0\n            }), this.wasZoomed = !1) : this.chart.events.notifySceneChanges({\n              position: !0\n            }));\n          }\n        }, t.prototype.onZoom = function (t) {\n          var i = this.map.getZoomScale(t.zoom),\n              n = this.map.latLngToLayerPoint(t.center).subtract(this.map.containerPointToLayerPoint(this.map.getSize().divideBy(2))),\n              r = n.multiplyBy(-i).add(this.map.containerPointToLayerPoint(e.Leaflet.point(0, 0)));\n          this.chartContainer.setAttribute(\"class\", \" leaflet-zoom-animated\"), this.translate = this.getTranslateString(r) + \" scale(\" + i + \") \", this.setTranslate(), this.wasZoomed = !0;\n        }, t;\n      }(),\n          T = function () {\n        function t() {\n          this.enabled = !0, this.type = \"tile\", this.url = \"https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png\", this.params = {\n            subdomains: \"abcd\",\n            attribution: '&copy; <a target=\"_blank\" href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a>, &copy; <a href=\"https://cartodb.com/attributions\" target=\"_blank\">CartoDB</a>'\n          };\n        }\n\n        return t;\n      }();\n\n      e.SettingsBackground = T;\n\n      var k = function (t) {\n        function i(e) {\n          var i = t.call(this, e) || this;\n          return i.animationOrder = 100, i.resizing = !1, i._focusHandler = function () {\n            return i.containerOnFocusChange();\n          }, i;\n        }\n\n        return n(i, t), i.prototype.createDom = function (n) {\n          var r = this;\n          t.prototype.createDom.call(this, n), this.leafletContainer = d.Helpers.createDom(\"div\", \"DVSL-leaflet\", null, null), this.container.insertBefore(this.leafletContainer, this.canvas), this.container.removeChild(this.canvas), this.container.removeChild(this.outerBorder), this.container.removeChild(this.interactionContainer), this.interactionContainer.appendChild(this.canvas), this.canvas.style.position = \"static\", this.outerBorder = null, this.menuContainer.className = \"DVSL-menu-container\", this.itemLayer = new w(this.chart, this.interactionContainer, this), i.setContainerStyle(this.leafletContainer), this.chart.scene.project = function (t, e) {\n            return r.projectFunc(t, e);\n          }, this.chart.scene.unproject = function (t, e) {\n            return r.unprojectFunc(t, e);\n          }, null != e.Leaflet ? this.createMap() : this.chart.assetsLoader.ensureAssetsList([\"assets://leaflet.js\"], function (t) {\n            return r.leafletLoaded(t);\n          }), d.Helpers.listen(this.interactionContainer, \"focus\", this._focusHandler), d.Helpers.listen(this.interactionContainer, \"blur\", this._focusHandler), d.Helpers.listen(this.leafletContainer, \"focus\", this._focusHandler), d.Helpers.listen(this.leafletContainer, \"blur\", this._focusHandler);\n        }, i.prototype.containerOnFocusChange = function () {\n          if (this.map) {\n            var t = d.Helpers.isParentOf(this.container, document.activeElement),\n                e = this.map.scrollWheelZoom;\n            t || !this.chart.settings.advanced.pointer.mouseWheelRequiresFocus ? e.enable() : e.disable();\n          }\n        }, i.prototype.leafletLoaded = function (t) {\n          if (!this.removed) {\n            if (\"undefined\" == typeof L) throw new Error(\"`leaflet.js` was loaded but the global variable `L` was not found. Please make sure that `L.noConflict()` is not called.\");\n            e.Leaflet = L, this.createMap(), t && this.chart.notifyChartUpdate(\"api\");\n          }\n        }, i.prototype.ensureMap = function () {\n          if (!this.map) throw new Error(\"This method is only available after leaflet.js has been loaded.\");\n        }, i.prototype.createMap = function () {\n          var t = this.chart.settings.navigation,\n              i = {\n            maxZoom: t.maxZoom,\n            minZoom: t.minZoom,\n            zoomDelta: 10,\n            worldCopyJump: !1\n          };\n          this.map = e.Leaflet.map(this.leafletContainer, i), this.map.attributionControl.setPrefix(\"\");\n          var n = t.maxBounds;\n\n          if (this.map.setMaxBounds(new e.Leaflet.LatLngBounds(new e.Leaflet.LatLng(n.south, n.west), new e.Leaflet.LatLng(n.north, n.east))), this.createMapBackground(), L.Layer) {\n            var r = new L.Layer();\n            this.itemLayer.extendLayer(r), this.map.addLayer(r);\n          } else this.map.addLayer(this.itemLayer);\n\n          this.crs = this.map.options.crs, this.containerOnFocusChange(), this.chart.domLayerCreated();\n        }, i.prototype.createMapBackground = function () {\n          var t = this.map,\n              i = this.tileLayer;\n          i && (t.removeLayer(i), i = null);\n          var n = this.scene.settings.background;\n          n.enabled && (\"tile\" === n.type ? (i = e.Leaflet.tileLayer(n.url, n.params), t.addLayer(i)) : \"wms\" === n.type && (i = e.Leaflet.tileLayer.wms(n.url, n.params), t.addLayer(i))), this.tileLayer = i;\n        }, i.prototype.onSceneChange = function (t) {\n          this.itemLayer.setTranslate();\n        }, i.prototype.remove = function () {\n          this.removed = !0, d.Helpers.unlisten(this.interactionContainer, \"focus\", this._focusHandler), d.Helpers.unlisten(this.interactionContainer, \"blur\", this._focusHandler), d.Helpers.unlisten(this.leafletContainer, \"focus\", this._focusHandler), d.Helpers.unlisten(this.leafletContainer, \"blur\", this._focusHandler), this.map && this.map.remove(), this.map = null;\n        }, i.prototype.updateSettings = function (i) {\n          if (t.prototype.updateSettings.call(this, i), !this.removed && this.leafletContainer && (this.map && i.background && this.createMapBackground(), i.navigation && ((i.navigation.minZoom || i.navigation.maxZoom) && d.Helpers.warn(\"Changing of navigation.minZoom or navigation.maxZoom with updateSettings() is not yet supported.\"), this.map && i.navigation.maxBounds))) {\n            var n = i.navigation.maxBounds;\n            this.map.setMaxBounds(new e.Leaflet.LatLngBounds(new e.Leaflet.LatLng(n.south, n.west), new e.Leaflet.LatLng(n.north, n.east)));\n          }\n        }, i.prototype.projectFunc = function (t, i) {\n          return this.ensureMap(), this.crs.latLngToPoint(new e.Leaflet.LatLng(i, t), 0);\n        }, i.prototype.unprojectFunc = function (t, i) {\n          return this.ensureMap(), this.crs.pointToLatLng(new e.Leaflet.Point(t, i), 0);\n        }, i.prototype.doAnimations = function (e) {\n          if (t.prototype.doAnimations.call(this, e), e.changes.bounds) {\n            var i = this.scene;\n            i.x0 = i.chartLeft, i.y0 = i.chartTop, i.width = i.chartWidth, i.height = i.chartHeight, i.leftMargin = 0, i.rightMargin = 0, i.topMargin = 0, i.bottomMargin = 0, this.map && (this.resizing = !0, this.map.invalidateSize(null), this.resizing = !1), this.interactionContainer.style.width = i.chartWidth + \"px\", this.interactionContainer.style.height = i.chartHeight + \"px\";\n          }\n        }, i;\n      }(d.DomLayer);\n\n      e.DomLayer = k;\n\n      var M = function () {\n        function t() {\n          this.enabled = !1, this.distance = 60, this.maxZoom = 18, this.weightFunction = null, this.ignoreZeroWeight = !1;\n        }\n\n        return t;\n      }();\n\n      e.SettingsAggregation = M;\n\n      var A = function () {\n        function t(t, e, i) {\n          this.zoom = e.zoom, this.scene = e, this.settings = t, this.chart = i;\n        }\n\n        return t.orientation = function (t, e, i) {\n          var n = (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x);\n          return 0 === n ? 0 : n > 0 ? 1 : -1;\n        }, t.distanceLineToPoint = function (t, e, i) {\n          var n = Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));\n          return Math.abs((i.x - t.x) * (e.y - t.y) - (i.y - t.y) * (e.x - t.x)) / n;\n        }, t.prototype.findMainNodes = function (t, e) {\n          var i = this.settings;\n          i.ignoreZeroWeight && (t = t.slice());\n          var n = {},\n              r = {},\n              s = {},\n              a = d.Helpers.isFunction(i.weightFunction);\n\n          if (a) {\n            for (var o = t.length - 1; o >= 0; o--) {\n              var l = t[o],\n                  h = i.weightFunction(l);\n\n              if (i.ignoreZeroWeight && 0 === h) {\n                var u = t.pop();\n                o < t.length && (t[o] = u);\n              } else s[l.id] = h;\n            }\n\n            t.sort(function (t, e) {\n              return s[e.id] - s[t.id];\n            });\n          }\n\n          for (var c, p, f, g = this.zoom / (i.distance / 2), v = [], m = {}, o = 0; o < t.length; o++) {\n            var l = t[o],\n                y = Math.floor(l._x * g),\n                S = Math.floor(l._y * g);\n\n            if (c = r[y] || (r[y] = {}), void 0 === c[S] && void 0 === c[S - 1] && void 0 === c[S + 1] && (p = r[y - 1] || (r[y - 1] = {}), void 0 === p[S] && void 0 === p[S - 1] && void 0 === p[S + 1] && (f = r[y + 1] || (r[y + 1] = {}), void 0 === f[S] && void 0 === f[S - 1] && void 0 === f[S + 1]))) {\n              c[S] = v.length, c[S + 1] = v.length, c[S - 1] = v.length, p[S] = v.length, p[S + 1] = v.length, p[S - 1] = v.length, f[S] = v.length, f[S + 1] = v.length, f[S - 1] = v.length;\n              var b = a ? s[l.id] || 0 : 1,\n                  x = {\n                id: \"__aggr_\" + l.id,\n                aggregatedWeight: b,\n                _originalWeight: b,\n                _x: l._x,\n                _y: l._y,\n                _bounds: l._bounds,\n                aggregatedNodes: [l],\n                loaded: !0\n              };\n              v.push(x), n[l.id] = x, m[o] = !0;\n            }\n          }\n\n          for (var C = [], o = 0; o < t.length; o++) {\n            if (!m[o]) {\n              var l = t[o],\n                  y = Math.floor(l._x * g),\n                  S = Math.floor(l._y * g),\n                  w = v[r[y][S]];\n\n              if (!w) {\n                c = r[y] || (r[y] = {}), p = r[y - 1] || (r[y - 1] = {}), f = r[y + 1] || (r[y + 1] = {}), C.push(c[S]), C.push(c[S - 1]), C.push(c[S + 1]), C.push(p[S]), C.push(p[S - 1]), C.push(p[S + 1]), C.push(f[S]), C.push(f[S - 1]), C.push(f[S + 1]);\n\n                for (var L = 1 / 0; C.length > 0;) {\n                  var T = C.pop();\n\n                  if (void 0 !== T) {\n                    var k = v[T],\n                        M = (k._x - l._x) * (k._x - l._x) + (k._y - l._y) * (k._y - l._y);\n                    M < L && (L = M, w = k);\n                  }\n                }\n              }\n\n              var h = a ? s[l.id] || 0 : 1;\n              (w.aggregatedWeight > 0 || h > 0) && (w._x = (w._x * w.aggregatedWeight + l._x * h) / (w.aggregatedWeight + h), w._y = (w._y * w.aggregatedWeight + l._y * h) / (w.aggregatedWeight + h)), w._originalWeight < h && (w._originalWeight = h, w.id = \"__aggr_\" + l.id), n[l.id] = w, w.aggregatedNodes.push(l), w.aggregatedWeight += h;\n            }\n          }\n\n          for (var o = 0; o < v.length; o++) {\n            var l = v[o],\n                A = this.scene.unproject(l._x, l._y);\n            l.coordinates = [A.lng, A.lat];\n          }\n\n          if (i.postProcessAggregatedNodes) {\n            var I = [];\n            i.postProcessAggregatedNodes(v, n, I);\n\n            for (var o = 0; o < I.length; o++) {\n              var l = I[o],\n                  P = this.scene.project(l.coordinates[0], l.coordinates[1]);\n              l._x = P.x, l._y = P.y;\n            }\n          }\n\n          var D = this.aggregateLinks(e, n);\n          return this.findConvexShapes(v), {\n            nodes: v,\n            links: D\n          };\n        }, t.prototype.aggregateLinks = function (t, e) {\n          for (var i = [], n = {}, r = 0; r < t.length; r++) {\n            var s = t[r],\n                a = e[s.from],\n                o = e[s.to];\n\n            if (a && o) {\n              var l = void 0,\n                  h = a.id + \"-\" + o.id;\n              d.Helpers.hasProperty(n, h) ? n[h].aggregatedLinks.push(s) : (l = {\n                id: h,\n                from: a.id,\n                to: o.id,\n                aggregatedLinks: [s]\n              }, i.push(l), n[h] = l);\n            }\n          }\n\n          return i;\n        }, t.prototype.findConvexShapes = function (e) {\n          for (var i = 0; i < e.length; i++) {\n            for (var n = [], r = e[i].aggregatedNodes, s = r[0], a = r[0], o = 1; o < r.length; o++) {\n              var l = r[o];\n              l._x <= s._x && (s = r[o]), l._x >= a._x && (a = r[o]);\n            }\n\n            for (var h = [], u = [], o = 0; o < r.length; o++) {\n              var l = r[o];\n\n              if (null != l) {\n                var c = t.orientation({\n                  x: s._x,\n                  y: s._y\n                }, {\n                  x: a._x,\n                  y: a._y\n                }, {\n                  x: l._x,\n                  y: l._y\n                });\n                c > 0 ? h.push(l) : c < 0 && u.push(l);\n              }\n            }\n\n            var d = [s],\n                p = {};\n            n = [], this.separateOuterPoints(s, a, u, n, p), d = d.concat(n.sort(function (t, e) {\n              return t._x - e._x;\n            })), d.push(a), n = [], this.separateOuterPoints(a, s, h, n, p), d = d.concat(n.sort(function (t, e) {\n              return e._x - t._x;\n            })), e[i].convexShape = d;\n          }\n        }, t.prototype.separateOuterPoints = function (e, i, n, r, s) {\n          if (0 !== n.length) {\n            if (1 === n.length) return s[n[0].id] = 1, void r.push(n[0]);\n\n            for (var a = 0, o = null, l = 0; l < n.length; l++) {\n              var h = n[l],\n                  u = t.distanceLineToPoint({\n                x: e._x,\n                y: e._y\n              }, {\n                x: i._x,\n                y: i._y\n              }, {\n                x: h._x,\n                y: h._y\n              });\n              u > a && (a = u, o = h);\n            }\n\n            s[o.id] || (r.push(o), s[o.id] = 1);\n\n            for (var c = [], d = [], l = 0; l < n.length; l++) {\n              var h = n[l];\n\n              if (!s[h.id]) {\n                var p = t.orientation({\n                  x: e._x,\n                  y: e._y\n                }, {\n                  x: o._x,\n                  y: o._y\n                }, {\n                  x: h._x,\n                  y: h._y\n                });\n                0 !== p && p < 0 && d.push(h);\n                var f = t.orientation({\n                  x: o._x,\n                  y: o._y\n                }, {\n                  x: i._x,\n                  y: i._y\n                }, {\n                  x: h._x,\n                  y: h._y\n                });\n                0 !== f && f < 0 && c.push(h);\n              }\n            }\n\n            this.separateOuterPoints(e, o, d, r, s), this.separateOuterPoints(o, i, c, r, s);\n          }\n        }, t.prototype.aggregate = function (t, e) {\n          if (this.zoom > Math.pow(2, this.settings.maxZoom)) {\n            var i = [],\n                n = [],\n                r = this.settings.weightFunction,\n                s = this.settings.ignoreZeroWeight,\n                a = d.Helpers.isFunction(r),\n                o = void 0,\n                l = Object.create(null);\n\n            for (o = 0; o < t.length; o++) {\n              var h = t[o],\n                  u = a ? r(h) : 1;\n              0 === u && s ? l[h.id] = !0 : i.push({\n                id: \"__aggr_\" + h.id,\n                aggregatedWeight: u,\n                _x: h._x,\n                _y: h._y,\n                _bounds: h._bounds,\n                coordinates: h.coordinates,\n                aggregatedNodes: [h],\n                loaded: !0\n              });\n            }\n\n            for (o = 0; o < e.length; o++) {\n              var c = e[o];\n              s && l[c.from] || l[c.to] || n.push({\n                from: \"__aggr_\" + c.from,\n                to: \"__aggr_\" + c.to,\n                id: \"__aggr_\" + c.from + \"-__aggr_\" + c.to,\n                aggregatedLinks: [c]\n              });\n            }\n\n            return {\n              nodes: i,\n              links: n\n            };\n          }\n\n          return this.findMainNodes(t, e);\n        }, t;\n      }();\n\n      e.Aggregation = A;\n\n      var I = function (t) {\n        function e(i) {\n          var n = t.call(this, d.SettingsMapping.GeoChartSettings) || this;\n          return n._computedLayers = [], n.theme = e.FlatTheme, n.area = new P(), n.background = new T(), n.data = [], n.style = {\n            fadeTime: 200,\n            selection: {\n              fillColor: \"rgba(200, 200, 255 ,0.7)\",\n              sizeConstant: 5,\n              sizeProportional: .2\n            }\n          }, n.layerTypes = {\n            shapes: {\n              type: \"shapes\"\n            },\n            items: {\n              type: \"items\",\n              style: {\n                item: {\n                  hoverEffect: !1,\n                  zIndex: 0\n                }\n              }\n            },\n            aggregateOnShapes: {\n              type: \"aggregateOnShapes\"\n            },\n            charts: {\n              type: \"charts\"\n            }\n          }, n.layersDefault = null, n.layers = [], n.navigation = {\n            initialLat: 40,\n            initialLng: 25,\n            initialZoom: 3,\n            minZoom: 0,\n            maxZoom: 18,\n            maxBounds: {\n              west: -200,\n              north: -85,\n              east: 200,\n              south: 85\n            },\n            initialDrilldown: [\"\"],\n            drilldownLayer: \"default\"\n          }, n.filters = {\n            nodeFilter: null\n          }, n.interaction = new B(), n.toolbar = new d.SettingsToolbar(!1, [new d.SettingsToolbarItem(\"fullscreen\")], \"bottom\", \"left\"), n.advanced.assets.push({\n            url: \"assets://leaflet.css\",\n            required: function required() {\n              return !d.Helpers.isStyleSheetDefined(\"leaflet-tile\", \"visibility\");\n            }\n          }), n.area.defaultHeight = 500, n.advanced.style.loadingArcStyle.r = 15, n.advanced.style.loadingArcStyle.lineColor = \"red\", n.advanced.style.loadingArcStyle.lineWidth = 7, n.apply(i), n._initializing = !1, n;\n        }\n\n        return n(e, t), e.prototype.apply = function (e) {\n          this.applyCompatibility(e, [{\n            from: \"layersDefault\",\n            alternative: \"layerTypes\"\n          }]), e.toolbar && d.Helpers.error(\"`toolbar` is not supported on GeoChart\");\n          var i = t.prototype.apply.call(this, e);\n          return (this._initializing || i.layers || i.layerTypes) && (this._computedLayers = d.SettingsHelper.mergeDefaultValues(this.layers, this.layersDefault, this.layerTypes, F.createInstance, F.getMapping, \"layers\")), i;\n        }, e;\n      }(u.Settings);\n\n      I.FlatTheme = {\n        advanced: {\n          themeCSSClass: \"DVSL-flat\"\n        }\n      }, e.Settings = I;\n\n      var P = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.style = new D(), e;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsArea);\n\n      e.SettingsArea = P;\n\n      var D = function (t) {\n        function e() {\n          return t.apply(this, arguments) || this;\n        }\n\n        return n(e, t), e;\n      }(d.SettingsAreaStyle);\n\n      e.SettingsAreaStyle = D;\n\n      var N = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.aggregatedShape = {\n            mode: 1,\n            lineColor: \"rgba(0,0,128,0.5)\",\n            lineWidth: 1,\n            fillColor: \"rgba(0,0,128,0.3)\"\n          }, e.scaleObjectsWithZoom = !1, e.node.radius = 10, e.node.fillColor = \"orange\", e.node.lineColor = \"red\", e.linkLabel.scaleWithSize = !1, e.linkLabel.scaleWithZoom = !1, e.linkLabel.backgroundStyle.fillColor = \"white\", e.linkLabel.backgroundStyle.lineColor = \"black\", e.nodeLabel.scaleWithSize = !1, e.nodeLabel.scaleWithZoom = !1, e.nodeLabel.backgroundStyle.fillColor = \"white\", e.nodeLabel.backgroundStyle.lineColor = \"black\", e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsNodesLayerStyle);\n\n      e.SettingsNodesLayerStyle = N;\n\n      var F = function () {\n        function t() {\n          this.enabled = !0, this.id = \"default\", this.name = \"\", this.type = \"shapes\", this.minZoom = 0, this.maxZoom = 20, this.perZoomStyle = !1, this.data = {\n            id: \"default\"\n          };\n        }\n\n        return t.getMapping = function (t, e) {\n          if (t && e.type && t.type !== e.type) throw new Error(\"It is not possible to change the value of `type` property for an existing layer.\");\n\n          switch (t ? t.type : e.type) {\n            case \"shapes\":\n              return d.SettingsMapping.GeoChartSettingsLayerShapes;\n\n            case \"items\":\n              return d.SettingsMapping.GeoChartSettingsLayerItems;\n\n            case \"charts\":\n              return d.SettingsMapping.GeoChartSettingsLayerCharts;\n\n            case \"aggregateOnShapes\":\n              return d.SettingsMapping.GeoChartSettingsLayerAggregated;\n\n            default:\n              throw new Error(\"The value '\" + e.type + \"' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.\");\n          }\n        }, t.createInstance = function (t, e) {\n          switch (e || t.type) {\n            case \"shapes\":\n              return new O();\n\n            case \"items\":\n              return new E();\n\n            case \"charts\":\n              return new z();\n\n            case \"aggregateOnShapes\":\n              return new H();\n\n            default:\n              throw new Error(\"The value '\" + (e || t.type) + \"' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.\");\n          }\n        }, t;\n      }();\n\n      e.SettingsLayerBase = F;\n\n      var O = function (t) {\n        function i() {\n          var i = t.call(this) || this;\n          return i.style = new e.SettingsShapesLayerStyle(), i.type = \"shapes\", i;\n        }\n\n        return n(i, t), i;\n      }(F);\n\n      e.SettingsLayerShapes = O;\n\n      var E = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.style = new N(), e.aggregation = new M(), e.layout = new V(), e.auras = new u.SettingsNodesLayerAuras(), e.type = \"items\", e;\n        }\n\n        return n(e, t), e;\n      }(F);\n\n      e.SettingsLayerItems = E;\n\n      var R = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.shapesLayer = null, e;\n        }\n\n        return n(e, t), e;\n      }(F);\n\n      e.SettingsLayerOverlay = R;\n\n      var H = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.aggregationField = null, e.aggregation = \"count\", e.aggregationFunction = null, e.styleFunction = null, e.type = \"aggregateOnShapes\", e;\n        }\n\n        return n(e, t), e;\n      }(R);\n\n      e.SettingsLayerAggregated = H;\n\n      var z = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.chartType = \"piechart\", e.settings = null, e.settingsFunction = null, e.autoSize = !1, e.data = {\n            id: null\n          }, e.type = \"charts\", e;\n        }\n\n        return n(e, t), e;\n      }(R);\n\n      e.SettingsLayerCharts = z;\n\n      var B = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.mode = \"drilldown\", e.zooming = new U(), e.nodesMovable = !1, e.selection.enabled = !1, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsInteraction);\n\n      e.SettingsInteraction = B;\n\n      var U = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.zoomInOnDoubleClick = !0, e;\n        }\n\n        return n(e, t), e;\n      }(u.SettingsInteractionZooming);\n\n      e.SettingsInteractionZooming = U;\n\n      var G = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 2e3, i.updateOrder = 1100, i.scene = null, i.events = null, i.currentObject = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.dragPointers = {}, i;\n        }\n\n        return n(e, t), e.prototype.onPointerMove = function (t) {\n          this.updateCurrentObject(t), this.currentObject && (this.updateCursor(t), t.hovered = !0);\n        }, e.prototype.onPointerOut = function (t) {\n          this.switchCurrentObject(null, null, t);\n        }, e.prototype.onPointerDown = function (t) {\n          this.updateCurrentObject(t);\n          var e = this.currentObject;\n          e instanceof u.Node && (this.updateSelection(t, e, !0), this.updateCursor(t), this.scene.settings.interaction.nodesMovable && (this.setPointerNode(t, e), t.consumed = !0));\n        }, e.prototype.onPointerUp = function (t) {\n          this.dragPointers[t.identifier] && (this.dragPointers[t.identifier].dragging && (t.consumed = !0, this.updateLastNode(t, this.dragPointers[t.identifier].node)), this.updateCursor(t), this.setPointerNode(t, null));\n        }, e.prototype.onPointerCancel = function (t) {\n          this.onPointerUp(t);\n        }, e.prototype.onPointerDrag = function (t) {\n          var e = this.dragPointers[t.identifier];\n\n          if (e) {\n            var i = this.scene.fromDisplay(t.x, t.y),\n                n = i.x,\n                r = i.y;\n            e.mouseX = t.x, e.mouseY = t.y, e.dragging = !0, this.dragNodes(e, n, r, this.scene.settings.interaction.selection.lockNodesOnMove), this.updateCursor(t), t.consumed = !0;\n          }\n        }, e.prototype.onClick = function (t) {\n          this.scene.xyInChart(t.x, t.y) && ((!this.currentObject || !this.scene.settings.interaction.selection.nodesSelectable && this.currentObject.isNode || !this.scene.settings.interaction.selection.linksSelectable && this.currentObject.isLink) && this.updateSelection(t, null, !1), this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n        }, e.prototype.onRightClick = function (t) {\n          if (this.scene.xyInChart(t.x, t.y)) {\n            var e = this.buildEventArgs(t);\n            this.updateSelection(t, this.currentObject, !1), this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0);\n          }\n        }, e.prototype.onDoubleClick = function (t) {\n          this.scene.xyInChart(t.x, t.y) && (this.chart.notifyDoubleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n        }, e.prototype.onTripleClick = function (t) {\n          this.scene.xyInChart(t.x, t.y) && (this.chart.notifyTripleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0));\n        }, e.prototype.doAnimations = function (t) {\n          for (var e in this.dragPointers) {\n            var i = this.dragPointers[e],\n                n = this.scene.fromDisplay(i.mouseX, i.mouseY),\n                r = n.x,\n                s = n.y;\n            this.dragNodes(i, r, s, !1), t.changes.coordinates = !0;\n          }\n        }, e.prototype.updateSelection = function (t, e, i) {\n          this.scene.settings.interaction.selection.enabled && (t.shiftKey || t.ctrlKey || !(!e || !this.scene.settings.interaction.selection.nodesSelectable && e.isNode || !this.scene.settings.interaction.selection.linksSelectable && e.isLink) ? e && t.ctrlKey ? (e.selected ? this.scene.removeFromSelection(e) : this.scene.addToSelection(e), this.notifySelectionChanged(\"user\")) : e && t.shiftKey || i && e.selected ? this.scene.addToSelection(e) && this.notifySelectionChanged(\"user\") : e && this.setSelection([e], \"user\") : this.setSelection([], \"user\"));\n        }, e.prototype.dragNodes = function (t, e, i, n) {\n          var r = e + t.x - t.node.x,\n              s = i + t.y - t.node.y;\n\n          if (0 !== r || 0 !== s) {\n            if (this.moveNode(t.node, r, s, n), t.extraNodes && t.extraNodes.length > 0) for (var a = 0; a < t.extraNodes.length; a++) {\n              this.moveNode(t.extraNodes[a], r, s, n);\n            }\n            this.events.notifySceneChanges({\n              coordinates: !0\n            });\n          }\n        }, e.prototype.moveNode = function (t, e, i, n) {\n          if (t.x += e, t.y += i, n && (t.userLock = !0), !this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {\n            var r = this.scene.getVisibleBounds(),\n                s = 1.2 * t.renderHwidth / this.scene.zoom,\n                a = 1.2 * t.renderHheight / this.scene.zoom;\n            t.x = Math.min(Math.max(t.x, r.x0 + s), r.x1 - s), t.y = Math.min(Math.max(t.y, r.y0 + a), r.y1 - a);\n          }\n        }, e.prototype.setPointerNode = function (t, e) {\n          var i = t.identifier,\n              n = this.dragPointers[i];\n\n          if (n) {\n            if (n.node.locks--, n.extraNodes && n.extraNodes.length > 0) for (var r = 0; r < n.extraNodes.length; r++) {\n              n.extraNodes[r].locks--;\n            }\n            delete this.dragPointers[i];\n          }\n\n          if (e) {\n            var s = this.scene.fromDisplay(t.x, t.y),\n                a = s.x,\n                o = s.y,\n                l = null;\n\n            if (!d.Helpers.hasProperties(this.dragPointers) && this.scene.selection.length > 0) {\n              l = [];\n\n              for (var r = 0; r < this.scene.selection.length; r++) {\n                var h = this.scene.selection[r];\n                h !== e && h instanceof u.Node && (h.locks++, l.push(h));\n              }\n            }\n\n            this.dragPointers[t.identifier] = {\n              x: e.x - a,\n              y: e.y - o,\n              node: e,\n              extraNodes: l,\n              mouseX: t.x,\n              mouseY: t.y,\n              dragging: !1\n            }, e.locks++;\n          }\n        }, e.prototype.updateCurrentObject = function (t) {\n          if (this.chart.renderer && this.scene.xyInChart(t.x, t.y)) {\n            var e = this.chart.renderer.findObjectAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);\n            this.switchCurrentObject(e ? e.object : null, e ? e.details : null, t);\n          }\n        }, e.prototype.updateCursor = function (t) {\n          this.currentObject && this.currentObject.cursor ? t.cursor = this.currentObject.cursor : t.cursor = \"default\";\n        }, e.prototype.switchCurrentObject = function (t, e, i) {\n          t === this.currentObject && e === this.currentItem || (i.changes.current = !0, this.scene.setActiveObject(t, e), this.currentObject = t, this.currentItem = e, this.chart.notifyHoverChanged(i, this.chart.createEventArguments(null, \"api\")));\n        }, e.prototype.buildEventArgs = function (t) {\n          var e = this.chart.createEventArguments(t, \"user\");\n          e.clickItem = this.currentItem;\n          var i = this.currentObject;\n          return i instanceof u.Node ? (e.clickNode = i, this.updateLastNode(t, i)) : e.clickLink = i, e;\n        }, e.prototype.updateLastNode = function (t, e) {\n          this.scene.lastClickedNode = e, this.scene.settings.interaction.zooming.autoZoomAfterClick && (this.scene.autoZoomMode = !0, t.changes.zoom = !0);\n        }, e.prototype.setSelection = function (t, e) {\n          var i = this.scene.setSelection(t);\n          i && this.notifySelectionChanged(e);\n        }, e.prototype.notifySelectionChanged = function (t) {\n          this.events.notifySceneChanges({\n            selection: !0\n          }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, t));\n        }, e;\n      }(d.ChartElement);\n\n      e.Selection = G;\n\n      var V = function () {\n        function t() {\n          this.mode = \"static\", this.nodeSpacing = 3, this.anchorStrength = 1;\n        }\n\n        return t;\n      }();\n\n      e.SettingsNodesLayout = V;\n\n      var j = function () {\n        function t() {}\n\n        return t;\n      }(),\n          W = function () {\n        function t(t, e, i) {\n          this.initialLoad = !0, this.scene = t, this.settings = i, this.layer = e, this.random = new d.Random(1);\n        }\n\n        return t.isNodeLocked = function (t) {\n          return t.userLock || t.locks > 0 || t.anchorMode === u.NodeAnchorMode.Fixed;\n        }, t.prototype.doAnimations = function (e, n) {\n          var r = this,\n              s = !1,\n              a = this.layer.hasTopologyChanges(),\n              o = \"dynamic\" === this.settings.mode;\n\n          if (o && \"undefined\" == typeof i.Chipmunk) {\n            if (t.cpRequestInitiated) return;\n            if (this.scene.assetsLoader.loadAssetsList([{\n              url: \"assets://cp.js\",\n              required: function required() {\n                return \"undefined\" == typeof i.Chipmunk;\n              }\n            }], function () {\n              r.layer.events.notifySceneChanges({\n                requestPaint: !0\n              });\n            })) return void (t.cpRequestInitiated = !0);\n          }\n\n          for (var l = this.layer.nodes(), h = this.layer.getGeometry(), u = 0; u < l.length; u += 1) {\n            var c = l[u];\n            c.shape.adaptToViewport(h.txm, h.txa, h.tym, h.tya, h.zoom);\n          }\n\n          if (this.initialLoad && (a = !0, n = !0), a && (this.random = new d.Random(1), this.placeNewNodes(o), s = !0), o) {\n            this.placeModifiedNodes();\n            var p = this.updateLayout(e.dtime, a, n, e.changes.zoom);\n            p && (e.animating = !0, s = !0);\n          } else this.placeModifiedNodes(), this.computeNodeAnchorCoordinates();\n\n          s && (e.changes.position = !0), this.initialLoad = !1;\n        }, t.prototype.computeNodeAnchorCoordinates = function () {\n          for (var t = this.layer.getNodesSceneZoom(), e = 0, i = this.layer.nodes(); e < i.length; e++) {\n            var n = i[e],\n                r = n.shape.getAnchor();\n            n.x = n.anchorX - r.x * t, n.y = n.anchorY - r.y * t;\n          }\n        }, t.prototype.placeNewNodes = function (t) {\n          for (var e = this.layer.getNodesSceneZoom(), i = 0, n = this.layer.nodes(); i < n.length; i++) {\n            var r = n[i],\n                s = r.shape.getAnchor();\n            r.anchorX = r.data._x, r.anchorY = r.data._y, null !== r.x && null !== r.y || (r.x = r.anchorX - s.x * e, r.y = r.anchorY - s.y * e, t && (r.x += this.random.get() * e));\n          }\n        }, t.prototype.placeModifiedNodes = function () {\n          for (var t in this.layer.modifiedNodes) {\n            var e = this.layer.modifiedNodes[t];\n            e.anchorX = e.data._x, e.anchorY = e.data._y;\n          }\n        }, t.prototype.removeNode = function (t) {\n          var e = this.idToState[t.id],\n              i = this.cpSpace;\n          i.removeShape(e.shape), e.locked || (i.removeBody(e.body), i.removeShape(e.anchorShape)), delete this.idToState[t.id];\n        }, t.prototype.addNode = function (t, e) {\n          var n = new j(),\n              r = this.cpSpace,\n              s = this.layer.getNodesSceneZoom(),\n              a = t.shape.getAnchor();\n\n          if (n.locked = e, this.idToState[t.id] = n, !e) {\n            var o = r.addBody(new i.Chipmunk.Body(1, 1 / 0));\n            n.body = o, o.setPos(i.Chipmunk.v(t.x + a.x * s, t.y + a.y * s));\n          }\n\n          return n;\n        }, t.prototype.updateLayout = function (e, n, r, s) {\n          this.cpSpace || (this.cpSpace = new i.Chipmunk.Space(), this.cpSpace.sleepTimeThreshold = 1, this.cpSpace.damping = .2, this.idToState = {}, n = !0);\n          var a = this.cpSpace,\n              o = this.idToState,\n              l = this.settings.nodeSpacing,\n              h = this.settings.anchorStrength,\n              u = this.layer.getNodesSceneZoom();\n          this.zoom = u, this.cpSpace.collisionSlop = 2 * u, this.cpSpace.idleSpeedThreshold = 5 * u;\n          var c = this.layer.nodes();\n\n          if (n) {\n            for (var p in this.layer.deletedNodes) {\n              this.removeNode(this.layer.deletedNodes[p]);\n            }\n\n            for (var p in this.layer.newNodes) {\n              var f = this.layer.newNodes[p];\n              this.addNode(f, t.isNodeLocked(f));\n            }\n          }\n\n          if (r || n) for (var g = 0; g < c.length; g += 1) {\n            var f = c[g],\n                v = o[f.id],\n                m = t.isNodeLocked(f),\n                y = null;\n            v && m === v.locked || (v && (v.body && (y = v.body.p), this.removeNode(f)), v = this.addNode(f, m));\n            var S = (Math.max(f.bounds.w(), f.bounds.h()) + l) / 2 * u,\n                b = f.shape.getAnchor(),\n                x = f.anchorX,\n                C = f.anchorY;\n\n            if (s || v.prevAX !== x || v.prevAY !== C || v.prevR !== S) {\n              if (v.locked) {\n                var w = v.shape;\n                w && a.removeShape(w), y || (y = i.Chipmunk.v(x - b.x * u, C - b.y * u)), y.x -= b.x * u, y.y -= b.y * u, w = a.addShape(new i.Chipmunk.CircleShape(a.staticBody, S, y)), v.p = y, w.setElasticity(0), w.setFriction(0), v.shape = w;\n              } else {\n                if (v.prevR !== S) {\n                  var w = v.shape;\n                  w && a.removeShape(w), w = a.addShape(new i.Chipmunk.CircleShape(v.body, S, i.Chipmunk.v(-b.x * u, -b.y * u))), w.setElasticity(0), w.setFriction(0), v.shape = w;\n                }\n\n                if (s || v.prevAX !== x || v.prevAY !== C) {\n                  var L = v.anchorShape;\n                  L && a.removeShape(L), L = a.addShape(new i.Chipmunk.CircleShape(a.staticBody, 2 * u, i.Chipmunk.v(x, C))), L.setElasticity(0), L.setFriction(0), v.anchorShape = L;\n                }\n              }\n\n              v.prevAX = x, v.prevAY = C, v.prevR = S;\n            }\n          }\n\n          for (var g = 0; g < c.length; g += 1) {\n            var f = c[g],\n                v = o[f.id];\n\n            if (!v.locked) {\n              var T = f.anchorX,\n                  k = f.anchorY,\n                  M = v.body.p.x,\n                  A = v.body.p.y,\n                  I = v.body,\n                  P = M - T,\n                  D = A - k,\n                  N = I.vx,\n                  F = I.vy;\n              P += .5 * N, D += .5 * F;\n              var O = -Math.abs(3 * P) * d.Helpers.sign(P),\n                  E = 0;\n              E = D < 0 ? -2 * D : -5 * D, I.f = i.Chipmunk.v(O * h, E * h);\n            }\n          }\n\n          a.step(1 / 60);\n\n          for (var R = !0, g = 0; g < c.length; g += 1) {\n            var f = c[g],\n                v = o[f.id],\n                b = f.shape.getAnchor();\n            v.locked ? v.p ? (f.x = v.p.x, f.y = v.p.y) : (f.x = f.data._x - b.x * u, f.y = f.data._y - b.y * u) : (f.x = v.body.p.x - b.x * u, f.y = v.body.p.y - b.y * u, R = R && v.body.isSleeping());\n          }\n\n          return !R;\n        }, t;\n      }();\n\n      W.cpRequestInitiated = !1, e.NodesLayout = W;\n\n      var Z = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e, i, n) || this;\n          return r.layout = null, r.hoveredNode = null, r.layout = new W(e.scene, r, i.layout), r;\n        }\n\n        return n(e, t), e.prototype.postprocessStyle = function (e) {\n          t.prototype.postprocessStyle.call(this, e);\n          var i = e.changes.zoom || this.hasStyleChanges();\n          this.layout.doAnimations(e, i);\n        }, e.prototype.paintHoverShape = function (t) {\n          var e = this.style.aggregatedShape;\n\n          switch (e.mode) {\n            case 0:\n              break;\n\n            default:\n            case 1:\n              if (null === this.hoveredNode || !this.hoveredNode.hovered || this.hoveredNode.removed) {\n                var i = this.modifiedNodes;\n                this.hoveredNode = null;\n\n                for (var n in i) {\n                  if (i[n].hovered) {\n                    this.hoveredNode = i[n];\n                    break;\n                  }\n                }\n              }\n\n              this.hoveredNode && this.paintConvex(this.hoveredNode, t, e);\n              break;\n\n            case 2:\n              for (var r = this.nodes(), s = 0; s < r.length; s++) {\n                var a = r[s];\n                a.removed || this.paintConvex(a, t, e);\n              }\n\n              break;\n\n            case 3:\n              for (var o = this.nodes(), s = 0; s < o.length; s++) {\n                var a = o[s];\n                !a.removed && a.selected && this.paintConvex(a, t, e);\n              }\n\n          }\n        }, e.prototype.paintConvex = function (t, e, i) {\n          var n = t.data,\n              r = n.convexShape;\n\n          if (r && !(r.length < 2)) {\n            var s = this.getGeometry(),\n                a = {},\n                o = d.Graphics.beginStrokeAndFill(e, i);\n            a[r[0].id] = 1, o.moveTo(r[0]._x * s.txm + s.txa, r[0]._y * s.tym + s.tya);\n\n            for (var l = 1; l < r.length; l++) {\n              a[r[l].id] = 1, o.lineTo(r[l]._x * s.txm + s.txa, r[l]._y * s.tym + s.tya);\n            }\n\n            o.closePath(), d.Graphics.endStrokeAndFill(e, o, i);\n\n            for (var l = 0; l < n.aggregatedNodes.length; l++) {\n              var h = n.aggregatedNodes[l];\n              a[h.id] || (o = d.Graphics.beginStroke(e, i), o.arc(h._x * s.txm + s.txa, h._y * s.tym + s.tya, 1, 0, 2 * Math.PI, !1), d.Graphics.endStroke(e, o, i));\n            }\n          }\n        }, e.prototype.paint = function (e) {\n          this.paintHoverShape(e.context), t.prototype.paint.call(this, e);\n        }, e;\n      }(u.NodesLayer);\n\n      e.NodesLayer = Z;\n\n      var Y = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n          return e.stack = [], e.zoomLevel = 0, e.mainDataEnabled = !1, e.project = null, e.unproject = null, e;\n        }\n\n        return n(e, t), e.prototype.push = function (t) {\n          return this.stack.push(t);\n        }, e.prototype.peek = function () {\n          return 0 === this.stack.length ? null : this.stack[this.stack.length - 1];\n        }, e.prototype.pop = function () {\n          return 0 === this.stack.length ? null : this.stack.pop();\n        }, e.prototype.getVisibleBoundsLatLon = function () {\n          var t = this.fromDisplay(this.x0, this.y0),\n              e = t.x,\n              i = t.y;\n          t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);\n          var n = t.x,\n              r = t.y;\n          return this.unprojectRect(new d.Rect(e, i, n, r));\n        }, e.prototype.unprojectRect = function (t) {\n          var e = this.unproject(t.x0, t.y0),\n              i = this.unproject(t.x1, t.y1);\n          return new d.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat));\n        }, e;\n      }(u.Scene);\n\n      e.Scene = Y;\n\n      var q = function (t) {\n        function e() {\n          var e = t.apply(this, arguments) || this;\n          return e.shapeSimplificationPrecision = 1.5, e.node = {\n            fillColor: \"#c7dae0\",\n            lineColor: null,\n            lineWidth: null,\n            radius: 30,\n            shadowColor: null,\n            lineDash: null,\n            expandable: !1\n          }, e;\n        }\n\n        return n(e, t), e;\n      }(N);\n\n      e.SettingsShapesLayerStyle = q;\n\n      var _ = function (t) {\n        function e(e, i) {\n          return t.call(this, e, i) || this;\n        }\n\n        return n(e, t), e.prototype.postprocessNode = function (t) {\n          t.currentItems = [], t.label, this.postprocessItems(t);\n        }, e.prototype.postprocessLink = function (t) {\n          var e = [];\n\n          if (t.label) {\n            var i = new d.Label(t.labelStyle);\n            i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i);\n          }\n\n          t.currentItems = e, this.postprocessItems(t);\n        }, e;\n      }(u.ItemsStyle);\n\n      e.ShapesStyle = _;\n\n      var X = function (t) {\n        function e(e, i) {\n          var n = t.call(this, e, i) || this;\n          return n.style = i.style, n;\n        }\n\n        return n(e, t), e.prototype.createStyleUpdater = function (t) {\n          return new _(t, this);\n        }, e.prototype.paintSelection = function (t, e, i) {\n          var n = this.getGeometry(),\n              r = n.txm,\n              s = n.txa,\n              a = n.tym,\n              o = n.tya,\n              l = 1 / r,\n              h = t.context,\n              u = this.style.selection;\n          h.beginPath();\n\n          for (var c = 0; c < e.length; c++) {\n            for (var d = e[c], p = 0, f = this.getNodeCoords(d, l); p < f.length; p++) {\n              var g = f[p],\n                  v = g[0] * r + s,\n                  m = g[1] * a + o;\n              h.moveTo(v, m);\n\n              for (var y = 2; y <= g.length - 2; y += 2) {\n                h.lineTo(g[y] * r + s, g[y + 1] * a + o);\n              }\n\n              h.closePath();\n            }\n          }\n\n          h.fillStyle = u.fillColor, h.strokeStyle = u.fillColor, h.lineWidth = 2 * u.sizeConstant, h.fill(), h.stroke();\n        }, e.prototype.paintLinks = function (t, e) {}, e.prototype.paintNodes = function (t, e) {\n          for (var i = t.context, n = this.getGeometry(), r = n.txm, s = n.txa, a = n.tym, o = n.tya, l = n.zoom, h = n.x0w, u = n.y0w, c = n.x1w, p = n.y1w, f = 1 / r, g = l > this.style.nodeDetailMinZoom, v = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * f * f, m = this.style.nodeLabelScaleBase, y = 0; y < e.length; y++) {\n            var S = e[y];\n            if (S.removed) this.deleteNode(S);else if (S.data) {\n              var b = S.bounds;\n\n              if (!(b.x1 < h || b.x0 > c || b.y1 < u || b.y0 > p)) {\n                var x = S.opacity,\n                    C = g && b.area() > v || S.hovered;\n\n                if (x < 1 && (i.globalAlpha = x), C) {\n                  S.items.sort(function (t, e) {\n                    return t.zIndex - e.zIndex;\n                  });\n                  var w = (b.x1 + b.x0) / 2 * r + s,\n                      L = (b.y1 + b.y0) / 2 * a + o,\n                      T = (b.x1 - b.x0) / 2 * r,\n                      k = (b.y1 - b.y0) / 2 * a;\n                  this.paintNodeDetails(S, w, L, T, k, l, m, t, !0);\n                }\n\n                if (S.fillColor || S.lineColor) {\n                  for (var M = d.Graphics.beginStrokeAndFill(i, S), A = 0, I = this.getNodeCoords(S, f); A < I.length; A++) {\n                    var P = I[A],\n                        D = P[0] * r + s,\n                        N = P[1] * a + o;\n                    M.moveTo(D, N);\n\n                    for (var F = 2; F <= P.length - 2; F += 2) {\n                      M.lineTo(P[F] * r + s, P[F + 1] * a + o);\n                    }\n\n                    M.closePath();\n                  }\n\n                  d.Graphics.endStrokeAndFill(i, M, S);\n                }\n\n                if (C) {\n                  var w = (b.x1 + b.x0) / 2 * r + s,\n                      L = (b.y1 + b.y0) / 2 * a + o,\n                      T = (b.x1 - b.x0) / 2 * r,\n                      k = (b.y1 - b.y0) / 2 * a;\n                  this.paintNodeDetails(S, w, L, T, k, l, m, t, !1);\n                }\n\n                x < 1 && (i.globalAlpha = 1);\n              }\n            }\n          }\n\n          return !1;\n        }, e.prototype.findObjectAt = function (t, e, i) {\n          for (var n = this.scene.fromDisplay(t, e), r = n.x, s = n.y, a = 1 / this.scene.zoom, o = i * a, l = null, h = this.nodes(), u = h.length - 1; u >= 0; u--) {\n            var c = h[u];\n\n            if (!c.removed) {\n              var p = this.getNodeCoords(c, a),\n                  f = d.Geometry.distanceToPolygonSq(r, s, p),\n                  g = o * o;\n              if (f <= 0) return {\n                object: c,\n                details: null\n              };\n\n              if (f < g) {\n                var v = Math.sqrt(f);\n                v < o && (o = v, l = c);\n              }\n            }\n          }\n\n          return {\n            object: l,\n            details: null\n          };\n        }, e.prototype.getNodeCoords = function (t, e) {\n          var i = this.style.shapeSimplificationPrecision;\n          if (!(i > 0)) return t.coordinates;\n          i *= e;\n          var n = t.coordinatesCachePrecision;\n          if (n <= i && 2 * n > i) return t.coordinatesCache;\n          var r,\n              s = [];\n          r = n < i ? t.coordinatesCache : t.coordinates;\n\n          for (var a = 0; a < r.length; a++) {\n            var o = r[a],\n                l = d.Geometry.computeBoundsSize(o);\n            l > 4 * i && (o.length > 10 && (o = d.Geometry.simplify(o, i)), s.push(o));\n          }\n\n          return t.coordinatesCachePrecision = i, t.coordinatesCache = s, s;\n        }, e;\n      }(u.ItemsLayer);\n\n      e.ShapesLayer = X;\n\n      var Q = function (t) {\n        function e(e, i, n) {\n          var r = t.call(this, e) || this;\n          return r.layerSettings = n, r.parentId = null, r.baseLayer = i, r;\n        }\n\n        return n(e, t), e.prototype.findObjectAt = function (t, e, i) {\n          return null;\n        }, e.prototype.nodes = function () {\n          return this.baseLayer.nodes();\n        }, e.prototype.links = function () {\n          return this.baseLayer.links();\n        }, e.prototype.getModified = function () {\n          return this.baseLayer.getModified();\n        }, e.prototype.hasTopologyChanges = function () {\n          return this.baseLayer.hasTopologyChanges();\n        }, e.prototype.hasStyleChanges = function () {\n          return this.baseLayer.hasStyleChanges();\n        }, e.prototype.getGeometry = function () {\n          return this.baseLayer.getGeometry();\n        }, e;\n      }(d.Layer);\n\n      e.OverlayLayerBase = Q;\n\n      var J = function (e) {\n        function i(t, i, n, r) {\n          var s = e.call(this, t, i, n) || this;\n          return s.idToChart = {}, s.chart = r, s;\n        }\n\n        return n(i, e), i.prototype.updateStyle = function (t) {}, i.prototype.postprocessStyle = function (t) {\n          for (var e in this.baseLayer.newNodes) {\n            var i = this.baseLayer.newNodes[e];\n            this.idToChart[e] = this.createChart(i);\n          }\n\n          var n;\n\n          for (var e in this.baseLayer.modifiedNodes) {\n            var i = this.baseLayer.modifiedNodes[e];\n            this.baseLayer.newNodes.hasOwnProperty(e) || (n = this.idToChart[e], n ? this.updateChart(n, i) : this.idToChart[e] = this.createChart(i));\n          }\n\n          for (var e in this.baseLayer.deletedNodes) {\n            n = this.idToChart[e], n && (delete this.idToChart[e], this.removeChart(n));\n          }\n\n          for (var r = 0, s = this.nodes(); r < s.length; r++) {\n            var i = s[r];\n            n = this.idToChart[i.id], n && this.updateXY(n, i);\n          }\n        }, i.prototype.paint = function (t) {}, i.prototype.createChart = function (e) {\n          var i = this.layerSettings.chartType,\n              n = this.getChartSettings(e);\n          if (!n) return null;\n          n.parentChart = this.chart.api, n.area ? n.area.width || (n.area.width = 100, n.area.height = 100) : n.area = {\n            width: 100,\n            height: 100\n          };\n          var r;\n          return r = \"piechart\" === i ? new t.PieChart(n) : \"facetchart\" === i ? new t.FacetChart(n) : \"timechart\" === i ? new t.TimeChart(n) : null;\n        }, i.prototype.getChartSettings = function (t) {\n          return this.layerSettings.settingsFunction ? this.layerSettings.settingsFunction(t, t.data) : this.layerSettings.settings;\n        }, i.prototype.updateChart = function (t, e) {\n          var i = this.getChartSettings(e);\n          t.updateSettings(i);\n        }, i.prototype.removeChart = function (t) {\n          t.remove();\n        }, i.prototype.updateXY = function (t, e) {\n          var i = this.scene.toDisplay(e.x, e.y),\n              n = i.x,\n              r = i.y,\n              s = 0,\n              a = 0,\n              o = t._impl.settings.area;\n          if (this.layerSettings.autoSize) throw \"TODO: implement autoSize\";\n          s = o.width, a = o.height;\n          var l = n - s / 2,\n              h = r - a / 2;\n          o.left === l && o.top === h && o.width === s && o.height === a || t.updateSettings({\n            area: {\n              left: n - s / 2,\n              top: r - a / 2,\n              width: s,\n              height: a\n            }\n          });\n        }, i.prototype.remove = function () {\n          for (var t in this.idToChart) {\n            this.removeChart(this.idToChart[t]);\n          }\n\n          this.idToChart = {};\n        }, i;\n      }(Q);\n\n      e.ChartsLayer = J;\n\n      var K = function () {\n        function t(t, e, i, n) {\n          this.drilldownId = n, this.layerSettings = i, this.data = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.layer = this.createLayer(), this.layer.drilldownId = this.drilldownId, this.dataBounds = d.Rect.createEmpty(), this.expandedNode = null;\n        }\n\n        return t.calculateShapeCentroid = function (t) {\n          var e,\n              i,\n              n = 0,\n              r = 0;\n\n          for (e = 0; e < t.coordinates.length; e++) {\n            i = d.Geometry.calculatePolyArea(t.coordinates[e]), Math.abs(i) > Math.abs(r) && (r = i, n = e);\n          }\n\n          if (0 === r) return t.x = (t.bounds.x0 + t.bounds.x1) / 2, void (t.y = (t.bounds.y0 + t.bounds.y1) / 2);\n          var s = d.Geometry.calculatePolyCentroid(t.coordinates[n], r);\n          t.x = s.x, t.y = s.y;\n        }, t.prototype.createLayer = function () {\n          return \"shapes\" === this.layerSettings.type ? new X(this.scene, this.layerSettings) : \"items\" === this.layerSettings.type ? new e.NodesLayer(this.chart, this.layerSettings, !1) : null;\n        }, t.prototype.onSceneChange = function (t) {\n          var e,\n              i,\n              n,\n              r = this.data.dataSettings,\n              s = this.layerSettings,\n              a = r.prefetchRatio;\n          r.perBoundsData ? (e = this.chart.scene.getVisibleBounds(), i = e.clone().inflate(1 + a / 2), n = e.clone().inflate(1 + a)) : i = n = e = this.data.getProjectedBounds();\n          var o = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[r.id] || {})[this.drilldownId || \"\"] : null,\n              l = s instanceof E && s.aggregation.enabled;\n\n          if (this.dataBounds.isEmpty() || o || !e.isInside(this.dataBounds) || t.changes.zoom && (r.perZoomData || l)) {\n            this.loading = !1, this.data.setViewParams(r.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, e, i, n);\n            var h = this.data.getData(this.drilldownId),\n                u = h.nodes,\n                c = h.links,\n                d = h.hasData,\n                p = h.loading,\n                f = u.length;\n\n            if (d || f > 0) {\n              if (this.chart.log(\"Layer \" + this.layerSettings.id + \": Updating view rect to \" + i + \", contains \" + f + \" objects\"), l) {\n                var g = new A(s.aggregation, this.scene, this.chart),\n                    v = g.aggregate(u, c);\n                u = v.nodes, c = v.links;\n              }\n\n              this.applyVisibleNodes(this.layer, u, c, null), this.dataBounds = i;\n            }\n\n            this.loading = p;\n          } else e.area() * (1 + a) * (1 + a) < this.dataBounds.area() / 5 && (i = e.inflate(1 + a), this.chart.log(\"Layer \" + this.layerSettings.id + \": Shrinking view to \" + i), this.shrinkVisibleBounds(i), this.dataBounds = i);\n\n          if (s.perZoomStyle && t.changes.zoom) {\n            for (var m = 0, y = this.layer.nodes(); m < y.length; m++) {\n              this.layer.touchNode(y[m]);\n            }\n\n            for (var S = 0, b = this.layer.links(); S < b.length; S++) {\n              this.layer.touchLink(b[S]);\n            }\n          }\n        }, t.prototype.updateStyle = function (t) {\n          this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), this.layer.updateStyle(t);\n        }, t.prototype.postprocessStyle = function (t) {\n          this.layer.postprocessStyle(t);\n        }, t.prototype.remove = function () {}, t.prototype.paint = function (t) {\n          this.layer.paint(t);\n        }, t.prototype.findObjectAt = function (t, e, i) {\n          return this.layer.findObjectAt(t, e, i);\n        }, t.prototype.findObjectById = function (t) {\n          return this.layer.findObjectById(t);\n        }, t.prototype.touchObject = function (t) {\n          var e = this.layer,\n              i = e.findObjectById(t);\n          i && e.touchNodeOrLink(i);\n        }, t.prototype.setExpandedNode = function (t) {\n          this.expandedNode && (this.expandedNode.expanded = !1, this.layer.touchNode(this.expandedNode), this.expandedNode = null), t && (this.expandedNode = this.layer.idToNode[t], this.expandedNode && (this.expandedNode.expanded = !0, this.layer.touchNode(this.expandedNode)));\n        }, t.prototype.applyVisibleNodes = function (e, i, n, r) {\n          for (var s = e.idToNode, a = {}, o = {}, l = \"shapes\" === this.layerSettings.type, h = 0; h < i.length; h++) {\n            var u = i[h],\n                c = l && u._coordinates || !l && u.hasOwnProperty(\"_x\");\n\n            if (c) {\n              var d = u.id;\n              a[d] = !0;\n              var p = e.addNode(d);\n              p.data = u, l && (p.coordinates = u._coordinates, p.bounds = u._bounds, t.calculateShapeCentroid(p)), p.parentNode = r;\n            }\n          }\n\n          for (var f = 0; f < n.length; f++) {\n            var g = n[f],\n                v = e.addLink(g.id, g.from, g.to);\n            v.data = g, o[v.id] = !0;\n          }\n\n          for (var d in s) {\n            var p = s[d];\n\n            if (!a.hasOwnProperty(d)) {\n              e.removeNode(p);\n\n              for (var m = 0; m < p.links.length; m++) {\n                e.removeLink(p.links[m]);\n              }\n            }\n          }\n\n          var y = e.idToLink;\n\n          for (var d in y) {\n            o.hasOwnProperty(d) || e.removeLink(y[d]);\n          }\n        }, t.prototype.shrinkVisibleBounds = function (t) {\n          for (var e in this.layer.idToNode) {\n            var i = this.layer.idToNode[e];\n            i.data._bounds.isOutside(t) && this.layer.removeNode(i);\n          }\n        }, t;\n      }(),\n          $ = function () {\n        function t(t, e, i, n) {\n          this.data = null, this.drilldownId = n, this.layerSettings = i, this.baseLayer = e, this.chart = t, this.scene = t.scene, this.loading = !1, this.layer = this.createLayer();\n        }\n\n        return t.prototype.createLayer = function () {\n          return \"charts\" === this.layerSettings.type ? new J(this.scene, this.baseLayer.layer, this.layerSettings, this.chart) : null;\n        }, t.prototype.onSceneChange = function (t) {}, t.prototype.updateStyle = function (t) {\n          this.layer.updateStyle(t);\n        }, t.prototype.postprocessStyle = function (t) {\n          this.layer.postprocessStyle(t);\n        }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {\n          this.layer.paint(t);\n        }, t.prototype.findObjectAt = function (t, e, i) {\n          return null;\n        }, t.prototype.findObjectById = function (t) {\n          return null;\n        }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {\n          this.layer.remove();\n        }, t;\n      }(),\n          tt = function () {\n        function t(t, e, i, n, r) {\n          this.firstTime = !0, this.drilldownId = r, this.layerSettings = n, this.data = i, this.baseLayer = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.dataBounds = d.Rect.createEmpty(), this.nodeToAggregated = {}, this.pendingNodes = {};\n        }\n\n        return t.prototype.onSceneChange = function (t) {\n          if (this.firstTime || this.layerSettings.perZoomStyle && t.changes.zoom || t.changes.data) {\n            this.firstTime = !1;\n\n            for (var e = this.baseLayer.layer, i = 0, n = e.nodes(); i < n.length; i++) {\n              e.touchNode(n[i]);\n            }\n\n            for (var r = 0, s = e.links(); r < s.length; r++) {\n              e.touchLink(s[r]);\n            }\n          }\n        }, t.prototype.updateStyle = function (t) {\n          var e = this.data.dataSettings,\n              i = this.layerSettings,\n              n = this.baseLayer.layer.modifiedNodes,\n              r = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[e.id] || {})[this.drilldownId || \"\"] : null;\n\n          if (d.Helpers.hasProperties(n) || d.Helpers.hasProperties(r)) {\n            var s = i.styleFunction;\n\n            for (var a in n) {\n              var o = n[a];\n              this.nodeToAggregated.hasOwnProperty(o.id) ? s(o, this.nodeToAggregated[o.id]) : this.pendingNodes[a] = o;\n            }\n\n            if (!d.Helpers.hasProperties(this.pendingNodes)) return void (this.loading = !1);\n            var l;\n\n            if (e.perBoundsData) {\n              l = d.Rect.createEmpty();\n\n              for (var a in this.pendingNodes) {\n                var o = this.pendingNodes[a];\n                l.addRect(o.data._bounds);\n              }\n            } else l = this.data.getProjectedBounds();\n\n            this.data.setViewParams(e.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, l, l, l);\n            var h = this.data.getData(this.drilldownId),\n                u = h.nodes,\n                c = h.loading;\n\n            if (!c) {\n              for (var a in this.pendingNodes) {\n                var o = this.pendingNodes[a],\n                    p = this.computeAggr(o.data._bounds, o.data._coordinates, u);\n                this.nodeToAggregated[o.id] = p, s && s(o, p);\n              }\n\n              this.pendingNodes = {};\n            }\n\n            this.loading = c;\n          }\n        }, t.prototype.postprocessStyle = function (t) {}, t.prototype.computeAggr = function (t, e, i) {\n          var n = this.layerSettings;\n\n          if (n.aggregationFunction) {\n            for (var r = new Array(), s = 0; s < i.length; s++) {\n              var a = i[s],\n                  o = a._x,\n                  l = a._y;\n              t.containsPoint(o, l) && d.Geometry.isInsidePolygon(o, l, e) && r.push(a);\n            }\n\n            return n.aggregationFunction(r);\n          }\n\n          var h = n.aggregation,\n              u = n.aggregationField,\n              c = 0,\n              p = function p() {\n            for (; c < i.length && (!t.containsPoint(i[c]._x, i[c]._y) || !d.Geometry.isInsidePolygon(i[c]._x, i[c]._y, e));) {\n              c += 1;\n            }\n\n            return c < i.length;\n          },\n              f = function f() {\n            var t = i[c][u];\n            return c += 1, t;\n          };\n\n          return d.Helpers.aggregate(h, p, f);\n        }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {}, t.prototype.findObjectAt = function (t, e, i) {\n          return null;\n        }, t.prototype.findObjectById = function (t) {\n          return null;\n        }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {}, t;\n      }(),\n          et = function () {\n        function t(t, e, i, n) {\n          this.layers = [], this.firstTime = !0, this.layerSettings = n, this.data = i, this.renderer = e, this.chart = t, this.loading = !0, this.scene = t.scene;\n        }\n\n        return t.prototype.onSceneChange = function (t) {\n          if (t.changes.navigation || this.firstTime) {\n            this.firstTime = !1;\n\n            for (var e = this.scene.stack, i = 0; i < Math.min(this.layers.length, e.length) && e[i] === this.layers[i].drilldownId;) {\n              i += 1;\n            }\n\n            for (; this.layers.length > i;) {\n              var n = this.layers.pop();\n              this.renderer.removeSimpleLayer(n);\n              var r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;\n              r && r.setExpandedNode(null);\n            }\n\n            for (; this.layers.length < e.length;) {\n              var s = e[this.layers.length],\n                  r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;\n              r && r.setExpandedNode(s);\n              var n = this.renderer.createSimpleLayer(this.data, this.layerSettings, s);\n              if (!n) break;\n              this.layers.push(n);\n            }\n          }\n\n          this.loading = !1;\n\n          for (var a = 0; a < this.layers.length; a++) {\n            var o = this.layers[a];\n            o.onSceneChange(t), this.loading = this.loading || o.loading;\n          }\n        }, t.prototype.updateStyle = function (t) {\n          for (var e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.updateStyle(t);\n          }\n        }, t.prototype.postprocessStyle = function (t) {\n          for (var e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.postprocessStyle(t);\n          }\n        }, t.prototype.paint = function (t) {\n          for (var e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.paint(t);\n          }\n        }, t.prototype.findObjectAt = function (t, e, i) {\n          for (var n = this.layers.length - 1; n >= 0; n--) {\n            var r = this.layers[n].findObjectAt(t, e, i);\n            if (r && r.object) return r;\n          }\n\n          return null;\n        }, t.prototype.findObjectById = function (t) {\n          for (var e = this.layers.length - 1; e >= 0; e--) {\n            var i = this.layers[e].findObjectById(t);\n            if (i) return i;\n          }\n\n          return null;\n        }, t.prototype.touchObject = function (t) {\n          for (var e = 0; e <= this.layers.length; e++) {\n            this.layers[e].touchObject(t);\n          }\n        }, t.prototype.remove = function () {\n          for (var t = 0; t < this.layers.length; t++) {\n            var e = this.layers[t];\n            this.renderer.removeSimpleLayer(e);\n          }\n\n          this.layers = [];\n        }, t;\n      }(),\n          it = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 900, i.paintOrder = 10, i.updateOrder = 10, i.layers = [], i.idToLayer = {}, i.idToSimpleLayer = {}, i.drilldownLayer = null, i.chart = e, i.scene = e.scene, i.events = e.events, i;\n        }\n\n        return n(e, t), e.prototype.createData = function (t) {\n          var e = null;\n          return t.id && (e = this.chart.getData(t.id)), e;\n        }, e.prototype.createSimpleLayer = function (t, e, i) {\n          var n;\n\n          if (e instanceof R) {\n            var r = this.idToSimpleLayer[e.shapesLayer + i];\n            if (!r) return this.chart.error(\"ItemsOnShape layer: shapesLayer \" + e.shapesLayer + \" not found, must come first in the layers array.\"), null;\n            \"charts\" === e.type ? n = new $(this.chart, r, e, i) : \"aggregateOnShapes\" === e.type && (n = new tt(this.chart, r, t, e, i));\n          } else n = new K(this.chart, t, e, i);\n\n          return this.idToSimpleLayer[e.id + i] = n, n;\n        }, e.prototype.removeLayer = function (t) {\n          t instanceof et ? t.remove() : this.removeSimpleLayer(t);\n        }, e.prototype.removeSimpleLayer = function (t) {\n          t.remove();\n          var e = t.layerSettings.id + t.drilldownId;\n          delete this.idToSimpleLayer[e];\n        }, e.prototype.onSceneChange = function (t) {\n          var e = !1,\n              i = t.changes,\n              n = i.settingsChanges;\n\n          if (n && (n.layers || n.layerTypes)) {\n            for (var r in n.layers) {\n              var s = this.idToLayer[r];\n              s && (this.removeLayer(s), delete this.idToLayer[r]);\n            }\n\n            e = !0;\n          } else (i.zoom || i.data) && (e = !0);\n\n          if (e) {\n            var a = this.idToLayer;\n            this.layers = [], this.idToLayer = {};\n            var o = this.scene.zoomLevel;\n            this.drilldownLayer = null;\n\n            for (var l = this.scene.settings.navigation.drilldownLayer, h = 0; h < this.chart.settings._computedLayers.length; h++) {\n              var u = this.chart.settings._computedLayers[h],\n                  c = u.enabled && u.minZoom <= o && u.maxZoom >= o,\n                  d = a[u.id];\n\n              if (c) {\n                var p = this.createData(u.data),\n                    f = !1;\n\n                if (p && p.dataSettings.perDrilldownData && (f = !0), u instanceof R) {\n                  var g = this.idToLayer[u.shapesLayer];\n\n                  if (!g) {\n                    this.chart.error(\"Overlay layer: shapeLayer \" + u.shapesLayer + \" not found, must come first in the layers array.\");\n                    continue;\n                  }\n\n                  d && d.baseLayer !== g && (this.removeLayer(d), d = null), f = f || g.data.dataSettings.perDrilldownData;\n                }\n\n                var s = void 0;\n                if (d && d.data === p) s = d;else if (d && this.removeLayer(d), f) s = new et(this.chart, this, p, u);else if (s = this.createSimpleLayer(p, u, null), !s) continue;\n                u.id === l && (this.drilldownLayer = s), this.layers.push(s), this.idToLayer[u.id] = s;\n              } else d && this.removeLayer(d);\n            }\n\n            for (var r in a) {\n              var s = a[r];\n              this.idToLayer.hasOwnProperty(r) || this.removeLayer(s);\n            }\n          }\n\n          for (var v = 0; v < this.layers.length; v++) {\n            var s = this.layers[v];\n            s.onSceneChange(t);\n          }\n        }, e.prototype.doAnimations = function (t) {\n          for (var e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.updateStyle(t);\n          }\n\n          for (var n = !1, e = 0; e < this.layers.length; e++) {\n            var i = this.layers[e];\n            i.postprocessStyle(t), n = n || i.loading;\n          }\n\n          this.scene.loading = n;\n        }, e.prototype.paintScene = function (t) {\n          d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);\n\n          for (var e = !1, i = 0; i < this.layers.length; i++) {\n            var n = this.layers[i];\n            n.paint(t), e = e || n.loading;\n          }\n\n          d.Graphics.popClip(t), this.scene.loading = e;\n        }, e.prototype.findObjectById = function (t) {\n          for (var e = this.layers.length - 1; e >= 0; e--) {\n            var i = this.layers[e],\n                n = i.findObjectById(t);\n            if (n) return n;\n          }\n\n          return null;\n        }, e.prototype.touchObjects = function (t) {\n          for (var e = this.layers.length - 1; e >= 0; e--) {\n            for (var i = this.layers[e], n = 0; n < t.length; n++) {\n              i.touchObject(t[n]);\n            }\n          }\n        }, e.prototype.findObjectAt = function (t, e, i) {\n          for (var n = this.layers.length - 1; n >= 0; n--) {\n            var r = this.layers[n],\n                s = r.findObjectAt(t, e, i);\n            if (s && s.object) return s;\n          }\n\n          return null;\n        }, e;\n      }(d.ChartElement);\n\n      e.Renderer = it;\n\n      var nt = function (t) {\n        function e(e) {\n          var i = t.call(this) || this;\n          return i.animationOrder = 1e3, i.paintOrder = 5, i.updateOrder = 1300, i.chart = e, i.scene = i.chart.scene, i;\n        }\n\n        return n(e, t), e.prototype.showInitialNodes = function () {\n          var t = this.scene.settings.navigation.initialDrilldown;\n          return this.scene.stack = t, this.chart.events.notifySceneChanges({\n            navigation: !0\n          });\n        }, e.prototype.onPanZoom = function () {}, e.prototype.onNewDataObject = function () {}, e.prototype.expandNode = function (t) {\n          var e = t.layer.drilldownId,\n              i = t.id;\n          if (i === this.scene.peek()) return !1;\n\n          for (; this.scene.peek() !== e;) {\n            this.scene.pop();\n          }\n\n          return this.scene.push(i), this.chart.events.notifySceneChanges({\n            navigation: !0\n          }), !0;\n        }, e.prototype.collapseNode = function (t) {\n          throw \"Not implemented\";\n        }, e;\n      }(d.Navigator);\n\n      e.Navigator = nt;\n\n      var rt = !1,\n          st = function (t) {\n        function e(e, i) {\n          var n = t.call(this, new I(e), new Y(), i) || this;\n          return n.events.forceFloating = !0, n._map = n._map || null, n._pendingZoomLevel = null, n._pendingLatitude = null, n._pendingBounds = null, n.navigator = n.events.addElement(new nt(n)), n.menu = n.events.addElement(new u.Menu(n)), n.info = n.events.addElement(new u.InfoPopup(n)), n.selection = n.events.addElement(new G(n)), n._map && (n.renderer = n.events.addElement(new it(n))), n.navigator.showInitialNodes(), n.finalInitialize(), n;\n        }\n\n        return n(e, t), e.prototype.getMap = function () {\n          return this._map;\n        }, e.prototype.domLayerCreated = function () {\n          return rt || (d.Helpers.compareVersions(L.version, [0, 7]) || this.error(\"ZoomCharts requires Leaflet.js version 0.7.0 or newer. The loaded version is \" + L.version), rt = !0), this._map ? void this.applyGestureSettings() : (this._map = this._domLayer.map, null != this._pendingLatitude ? this.setView(this._pendingLatitude, this._pendingLongitude, this._pendingZoomLevel) : (null !== this.settings.navigation.initialLat && this.setView(this.settings.navigation.initialLat, this.settings.navigation.initialLng, this.settings.navigation.initialZoom), null != this._pendingZoomLevel && this.setZoomLevel(this._pendingZoomLevel)), null != this._pendingBounds && this.setBounds(this._pendingBounds), this.events && (this.renderer = this.events.addElement(new it(this)), this.events.notifySceneChanges({\n            settings: !0,\n            settingsChanges: this.settings,\n            zoom: !0,\n            bounds: !0\n          })), this.applyGestureSettings(), void (this.scene.loading = !1));\n        }, e.prototype.createDomLayer = function () {\n          return this._domLayer = new k(this), this._domLayer;\n        }, e.prototype.createDataObj = function (t) {\n          return new C(this, t);\n        }, e.prototype.getData = function (e) {\n          return t.prototype.getData.call(this, e);\n        }, e.prototype.onSettingsChanged = function (t) {\n          var e = {},\n              i = t.navigation && t.navigation.initialDrilldown;\n          i && this.navigator.showInitialNodes(), t.filters && (e.filters = !0), t.style && (e.style = !0), this.events.notifySceneChanges(e);\n        }, e.prototype.saveNavigation = function () {\n          return this._map ? this.scene.getVisibleBoundsLatLon() : null;\n        }, e.prototype.restoreNavigation = function (t) {\n          this.setBounds(t);\n        }, e.prototype.save = function () {\n          return \"\";\n        }, e.prototype.restore = function (t, e) {}, e.prototype.setZoomLevel = function (t) {\n          this._map ? this._map.setZoom(t) : this._pendingZoomLevel = t;\n        }, e.prototype.setView = function (t, e, i) {\n          this._map ? this._map.setView(L.latLng(t, e), i) : (this._pendingLatitude = t, this._pendingLongitude = e, this._pendingZoomLevel = i);\n        }, e.prototype.setBounds = function (t) {\n          if (this._map) {\n            var e = t;\n            if (void 0 !== e.east) this._map.fitBounds(L.latLngBounds(L.latLng(e.south, e.west), L.latLng(e.north, e.east)));else {\n              var i = t;\n\n              this._map.fitBounds(L.latLngBounds(L.latLng(i.y1, i.x0), L.latLng(i.y0, i.x1)));\n            }\n          } else this._pendingBounds = t;\n        }, e.prototype.getNodeDimensions = function (t) {\n          var e = t;\n          if (d.Helpers.isString(t) && (e = this.getNode(t)), !e) return null;\n          var i = this.scene.toDisplay(e.x, e.y),\n              n = i.x,\n              r = i.y,\n              s = e.hHeight * this.scene.zoom,\n              a = e.hWidth * this.scene.zoom;\n          return {\n            x: n,\n            y: r,\n            radius: s,\n            hwidth: a\n          };\n        }, e.prototype.expandNode = function (t) {\n          var e = null;\n          e = d.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.expandNode(e);\n        }, e.prototype.collapseNode = function (t) {\n          var e = null;\n          e = d.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.collapseNode(e);\n        }, e.prototype.getNode = function (t) {\n          var e = this.renderer ? this.renderer.findObjectById(t) : null;\n          return e instanceof u.Node || (e = null), e;\n        }, e.prototype.getLink = function (t) {\n          var e = this.renderer ? this.renderer.findObjectById(t) : null;\n          return e instanceof u.Link || (e = null), e;\n        }, e.prototype.hideMenu = function () {\n          this.menu.hideMenu();\n        }, e.prototype.defaultClick = function (t, e) {\n          var i = \"drilldown\" === this.settings.interaction.mode,\n              n = e.clickNode;\n          i && n && n.expandable && this.navigator.expandNode(n) && (this.setBounds(this.scene.unprojectRect(n.data._bounds)), t.preventDefault());\n        }, e.prototype.defaultRightClick = function (t, e) {\n          e.clickNode && (this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault());\n        }, e.prototype.applyGestureSettings = function () {\n          var t = this._map;\n          this.settings.interaction.zooming.zoomInOnDoubleClick === !1 && t.doubleClickZoom.disable(), this.settings.interaction.zooming.doubleClickZoom && (t.options.zoomDelta = this.settings.interaction.zooming.doubleClickZoom);\n        }, e;\n      }(u.Impl);\n\n      e.Impl = st;\n    }(r = i.GeoChart || (i.GeoChart = {}));\n  }(i = t.Internal || (t.Internal = {})), function (t) {\n    var e;\n    !function (t) {\n      t[t.always = 2] = \"always\", t[t.auto = 1] = \"auto\", t[t.never = 0] = \"never\";\n    }(e = t.BaseSettingsValueAxisBaseLineLabelMode || (t.BaseSettingsValueAxisBaseLineLabelMode = {}));\n    var i;\n    !function (t) {\n      t[t.always = 2] = \"always\", t[t.disabled = 0] = \"disabled\", t[t.hovered = 1] = \"hovered\", t[t.selected = 3] = \"selected\";\n    }(i = t.GeoChartSettingsAggregatedShapeStyleMode || (t.GeoChartSettingsAggregatedShapeStyleMode = {}));\n  }(_e2 = t.Configuration || (t.Configuration = {}));\n\n  var r = function (t) {\n    function e(n) {\n      var r = t.call(this) || this;\n      return r.typeName = \"NetChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n        return new i.NetChart.Impl(t, r);\n      }, n) : r._impl = new i.NetChart.Impl(n, r), r;\n    }\n\n    return n(e, t), e.prototype.updateSettings = function (e) {\n      return t.prototype.updateSettings.call(this, e), this;\n    }, e.prototype.replaceSettings = function (e) {\n      return t.prototype.replaceSettings.call(this, e), this;\n    }, e.prototype.addData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.addData(t, e);\n    }, e.prototype.removeData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.removeData(t, e);\n    }, e.prototype.replaceData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.replaceData(t, e);\n    }, e.prototype.hideMenu = function () {\n      return this._impl.hideMenu(), this;\n    }, e.prototype.showNodeMenu = function (t) {\n      \"string\" == typeof t && (t = this._impl.getNode(t)), this._impl.showNodeMenu(t);\n    }, e.prototype.updateStyle = function (t) {\n      t ? (this._impl.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null);\n    }, e.prototype.getNode = function (t) {\n      return this._impl.getNode(t);\n    }, e.prototype.getLink = function (t) {\n      return this._impl.getLink(t);\n    }, e.prototype.showNode = function (t) {\n      return this._impl.showNode(t);\n    }, e.prototype.hideNode = function (t) {\n      return this._impl.hideNode(t);\n    }, e.prototype.expandNode = function (t) {\n      return this._impl.expandNode(t);\n    }, e.prototype.addFocusNode = function (t, e) {\n      return void 0 === e && (e = -1), null == e && (e = -1), this._impl.addFocusNode(t, e);\n    }, e.prototype.removeFocusNode = function (t) {\n      return this._impl.removeFocusNode(t);\n    }, e.prototype.clearFocus = function () {\n      return this._impl.clearFocus();\n    }, e.prototype.collapseNode = function (t) {\n      return this._impl.collapseNode(t);\n    }, e.prototype.closeNode = function (t) {\n      return this._impl.closeNode(t);\n    }, e.prototype.lockNode = function (t, e, i) {\n      return this._impl.lockNode(t, e, i);\n    }, e.prototype.unlockNode = function (t) {\n      return this._impl.unlockNode(t);\n    }, e.prototype.zoom = function (t, e) {\n      return void 0 === e && (e = !0), null != t && this._impl.setZoom(t, !!e), this._impl.scene.zoom;\n    }, e.prototype.resetLayout = function () {\n      return this._impl.resetLayout();\n    }, e.prototype.selection = function (t) {\n      return t && this._impl.setSelection(t), this._impl.scene.selection;\n    }, e.prototype.zoomIn = function (t, e) {\n      return void 0 === e && (e = !0), this.scrollIntoView(t);\n    }, e.prototype.nodes = function () {\n      return this._impl.getCurrentNodes();\n    }, e.prototype.links = function () {\n      return this._impl.getCurrentLinks();\n    }, e.prototype.getNodeDimensions = function (t) {\n      return this._impl.getNodeDimensions(t);\n    }, e.prototype.exportData = function (t, e) {\n      return void 0 === t && (t = !0), void 0 === e && (e = !0), this._impl.exportData(!!t, !!e);\n    }, e.prototype.scrollIntoView = function (t, e) {\n      this._impl.scrollIntoView(t, e);\n    }, e.prototype.on = function (e, i) {\n      t.prototype.on.call(this, e, i);\n    }, e;\n  }(i.Base.Api);\n\n  r.themes = {\n    flat: i.NetChart.Settings.FlatTheme,\n    dark: i.NetChart.Settings.DarkTheme\n  }, r.chartFactoryMethod = null, t.NetChart = r, i.Base.Helpers.exportSymbol(\"NetChart\", t.NetChart);\n\n  var s = function (t) {\n    function e(n) {\n      var r = t.call(this) || this;\n      return r._cachedApiCalls = [], r.typeName = \"TimeChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n        return new i.TimeChart.Impl(t, r);\n      }, n) : r._impl = new i.TimeChart.Impl(n, r), r;\n    }\n\n    return n(e, t), e.prototype._getImpl = function () {\n      return this._impl;\n    }, e.prototype._notifyAssetsLoaded = function () {\n      var t = this._cachedApiCalls;\n\n      if (null !== t) {\n        this._cachedApiCalls = null;\n\n        for (var e = 0; e < t.length; e++) {\n          t[e]();\n        }\n      }\n    }, e.prototype.updateSettings = function (e) {\n      return t.prototype.updateSettings.call(this, e), this;\n    }, e.prototype.replaceSettings = function (e) {\n      return t.prototype.replaceSettings.call(this, e), this;\n    }, e.prototype.on = function (e, i) {\n      t.prototype.on.call(this, e, i);\n    }, e.prototype.time = function (t, e, n) {\n      var r = this;\n      void 0 === n && (n = !0);\n      var s = this._impl,\n          a = s.scene,\n          o = i.TimeChart.TimeStep.timeUnitDiffs,\n          l = !s.displayUnit || o[s.displayUnit.unit] < o.d;\n\n      if (null != t && null != e) {\n        if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n          r.time(t, e, n);\n        }), [null, null];\n        s.setTimeRange(a.timestampToInternal(+t, l), a.timestampToInternal(+e, l), n);\n      }\n\n      return [a.timestampFromInternal(s.timeStart, l), a.timestampFromInternal(s.timeEnd, l)];\n    }, e.prototype.targetTime = function () {\n      var t = this._impl,\n          e = t.scene,\n          n = t.scrolling,\n          r = i.TimeChart.TimeStep.timeUnitDiffs,\n          s = n.targetUnit || t.displayUnit;\n      if (!s) return [null, null];\n      var a = !t.displayUnit || r[t.displayUnit.unit] < r.d;\n      return [e.timestampFromInternal(n.getFrom(), a), e.timestampFromInternal(n.getTo(), a)];\n    }, e.prototype.targetDisplayUnit = function () {\n      var t = this._impl,\n          e = t.scrolling.targetUnit || t.displayUnit || t.scene.displayUnit;\n      return e ? e.toString() : null;\n    }, e.prototype.addData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.addData(t, e);\n    }, e.prototype.replaceData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.replaceData(t, e);\n    }, e.prototype.setDisplayPeriod = function (t, e, i) {\n      var n = this;\n      return void 0 === i && (i = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {\n        n.setDisplayPeriod(t, e, i);\n      }) : void this._impl.setDisplayPeriod(t, e, null, i);\n    }, e.prototype.displayUnit = function (t, e, n) {\n      var r = this;\n\n      if (void 0 === e && (e = !0), void 0 !== n && i.Base.Helpers.warn(\"TimeChart.displayUnit() no longer supports the `rescale` parameter.\"), t) {\n        if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n          r.displayUnit(t, e);\n        }), null;\n\n        this._impl.setDisplayUnit(t, e, \"api\", !0);\n      }\n\n      return this._impl.displayUnit ? this._impl.displayUnit.toString() : null;\n    }, e.prototype.selection = function (t, e) {\n      var n = this,\n          r = this._impl,\n          s = r.scene,\n          a = i.TimeChart.TimeStep.timeUnitDiffs,\n          o = !r.displayUnit || a[r.displayUnit.unit] < a.d;\n\n      if (void 0 !== t && void 0 !== e) {\n        if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {\n          n.selection(t, e);\n        }), [null, null];\n        r.setSelection(null === t ? null : s.timestampToInternal(+t, o), null === e ? null : s.timestampToInternal(+e, o));\n      }\n\n      return [s.timestampFromInternal(r.scene.selectionStart, o), s.timestampFromInternal(r.scene.selectionEnd, o)];\n    }, e.prototype.scroll = function (t, e, i) {\n      return void 0 === e && (e = !0), void 0 === i && (i = !1), this._impl.scroll(t, e);\n    }, e.prototype.zoomOut = function (t, e) {\n      var n = this;\n      return void 0 === e && (e = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {\n        n.zoomOut(t, e);\n      }) : void this._impl.zoomOut(e, \"api\", i.TimeChart.TimeStep.parse(t));\n    }, e.prototype.zoomIn = function (t, e, n) {\n      var r = this;\n      if (void 0 === e && (e = null), void 0 === n && (n = !0), this._cachedApiCalls) return void this._cachedApiCalls.push(function () {\n        r.zoomIn(t, e, n);\n      });\n      var s = this._impl,\n          a = i.TimeChart.TimeStep.parse(t);\n\n      if (null != e) {\n        var o = a || s.displayUnit,\n            l = i.TimeChart.TimeStep.timeUnitDiffs,\n            h = !o || l[o.unit] < l.d;\n        e = s.scene.timestampToInternal(+e, h);\n      }\n\n      s.zoomIn(a, e, n, \"api\");\n    }, e.prototype.replaceSeries = function (t) {\n      return this._impl.deprecated(\"replaceSeries\", \"replaceSettings\"), this.replaceSettings({\n        series: t\n      });\n    }, e.prototype.exportVisibleData = function () {\n      return this._impl.exportVisibleData();\n    }, e.prototype.showInfoPopup = function (t, e, n) {\n      var r = this;\n      if (this._cachedApiCalls) return void this._cachedApiCalls.push(function () {\n        r.showInfoPopup(t, e, n);\n      });\n      var s = this._impl,\n          a = s.scene,\n          o = i.TimeChart.TimeStep.timeUnitDiffs,\n          l = !s.displayUnit || o[s.displayUnit.unit] < o.d;\n      s.showInfoPopup(null == t ? null : a.timestampToInternal(+t, l), null == e ? null : a.timestampToInternal(+e, l), n);\n    }, e.prototype.getEnabledSeries = function () {\n      return this._impl.getEnabledSeries();\n    }, e.prototype.getSeries = function () {\n      return this._impl.getSeries();\n    }, e;\n  }(i.Base.Api);\n\n  s.themes = {\n    flat: i.TimeChart.Settings.FlatTheme,\n    round: i.TimeChart.Settings.RoundTheme,\n    gradient: i.TimeChart.Settings.GradientTheme,\n    static: i.TimeChart.Settings.StaticChart,\n    dark: i.TimeChart.Settings.DarkTheme\n  }, s.chartFactoryMethod = null, t.TimeChart = s, i.Base.Helpers.exportSymbol(\"TimeChart\", t.TimeChart);\n\n  var a = function (t) {\n    function e(n) {\n      var r = t.call(this) || this;\n      return r.typeName = \"PieChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n        return new i.PieChart.Impl(t, r);\n      }, n) : r._impl = new i.PieChart.Impl(n, r), r;\n    }\n\n    return n(e, t), e.prototype.updateSettings = function (e) {\n      return t.prototype.updateSettings.call(this, e), this;\n    }, e.prototype.replaceSettings = function (e) {\n      return t.prototype.replaceSettings.call(this, e), this;\n    }, e.prototype.updateFilter = function () {\n      return this._impl.updateFilter(), this;\n    }, e.prototype.addData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.addData(t, e);\n    }, e.prototype.replaceData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.replaceData(t, e);\n    }, e.prototype.selection = function (t) {\n      if (t) if (Array.isArray(t)) {\n        for (var e = t.slice(), n = 0; n < e.length; n++) {\n          var r = e[n];\n          r instanceof i.PieChart.Slice ? e[n] = r.id : i.Base.Helpers.isString(r) || this._impl.error(\"PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.\");\n        }\n\n        this._impl.setSelection(e);\n      } else this._impl.error(\"PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.\");\n      return this._impl.scene.selection.slice();\n    }, e.prototype.getPie = function () {\n      return this._impl.getPie();\n    }, e.prototype.getPieOffset = function () {\n      return this._impl.navigator.getPieOffset();\n    }, e.prototype.setPie = function (t, e) {\n      return void 0 === e && (e = 0), null == e && (e = 0), this._impl.setPie(t, e), this;\n    }, e.prototype.setPieOffset = function (t) {\n      return this._impl.setPieOffset(t), this;\n    }, e.prototype.getActiveSlices = function () {\n      return this._impl.getActiveSlices();\n    }, e.prototype.getActivePies = function () {\n      return this._impl.getActivePies();\n    }, e.prototype.getActivePie = function () {\n      var t = this._impl.getActivePies();\n\n      return t[t.length - 1];\n    }, e.prototype.expandSlice = function (t) {\n      return this._impl.expandSlice(t, \"api\");\n    }, e.prototype.getSliceDimensions = function (t, e) {\n      return void 0 === e && (e = !1), null == e && (e = !1), this._impl.getSliceDimensions(t, e);\n    }, e.prototype.on = function (e, i) {\n      t.prototype.on.call(this, e, i);\n    }, e;\n  }(i.Base.Api);\n\n  a.themes = {\n    dark: i.PieChart.Settings.DarkTheme,\n    flat: i.PieChart.Settings.FlatTheme,\n    bevel: i.PieChart.Settings.BevelTheme,\n    gradient: i.PieChart.Settings.GradientTheme,\n    raised: i.PieChart.Settings.CanTheme,\n    rounded: i.PieChart.Settings.RoundedTheme\n  }, a.chartFactoryMethod = null, t.PieChart = a, i.Base.Helpers.exportSymbol(\"PieChart\", t.PieChart);\n\n  var o = function (t) {\n    function e(n) {\n      var r = t.call(this) || this;\n      return r.typeName = \"FacetChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n        return new i.FacetChart.Impl(t, r);\n      }, n) : r._impl = new i.FacetChart.Impl(n, r), r;\n    }\n\n    return n(e, t), e.prototype.updateSettings = function (e) {\n      return t.prototype.updateSettings.call(this, e), this;\n    }, e.prototype.replaceSettings = function (e) {\n      return t.prototype.replaceSettings.call(this, e), this;\n    }, e.prototype.addData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.addData(t, e);\n    }, e.prototype.replaceData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.replaceData(t, e);\n    }, e.prototype.updateFilter = function () {\n      return this._impl.updateFilter(), this;\n    }, e.prototype.selection = function (t) {\n      if (t) if (Array.isArray(t)) {\n        for (var e = t.slice(), n = 0; n < e.length; n++) {\n          var r = e[n];\n          r instanceof i.FacetChart.Item ? e[n] = r.id : i.Base.Helpers.isString(r) || this._impl.error(\"FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.\");\n        }\n\n        this._impl.setSelection(e);\n      } else this._impl.error(\"FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.\");\n      return this._impl.scene.selection.slice();\n    }, e.prototype.setPie = function (t, e, i) {\n      return void 0 === e && (e = 0), void 0 === i && (i = null), Array.isArray(t) || (t = [t]), this._impl.setPie(t, e, i), this;\n    }, e.prototype.getPie = function () {\n      return this._impl.getPie();\n    }, e.prototype.getPieOffset = function () {\n      return this._impl.getPieOffset();\n    }, e.prototype.getActiveItems = function () {\n      return this._impl.getActiveItems();\n    }, e.prototype.getActiveFacets = function () {\n      return this._impl.getActiveFacets();\n    }, e.prototype.getActiveFacet = function () {\n      var t = this._impl.getActiveFacets();\n\n      return t[t.length - 1];\n    }, e.prototype.expandSlice = function (t) {\n      return this._impl.expandItem(t, \"api\");\n    }, e.prototype.replaceSeries = function (t) {\n      return this._impl.deprecated(\"replaceSeries\", \"replaceSettings\"), this.replaceSettings({\n        series: t\n      });\n    }, e.prototype.on = function (e, i) {\n      t.prototype.on.call(this, e, i);\n    }, e.prototype.getEnabledSeries = function () {\n      return this._impl.getEnabledSeries();\n    }, e.prototype.getSeries = function () {\n      return this._impl.getSeries();\n    }, e;\n  }(i.Base.Api);\n\n  o.themes = {\n    dark: i.FacetChart.Settings.DarkTheme,\n    horizontal: i.FacetChart.Settings.HorizontalTheme\n  }, o.chartFactoryMethod = null, t.FacetChart = o, i.Base.Helpers.exportSymbol(\"FacetChart\", t.FacetChart);\n\n  var l = function (t) {\n    function e(n) {\n      var r = t.call(this) || this;\n      return r.typeName = \"GeoChart\", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {\n        return new i.GeoChart.Impl(t, r);\n      }, n) : r._impl = new i.GeoChart.Impl(n, r), r;\n    }\n\n    return n(e, t), e.prototype.updateSettings = function (e) {\n      return t.prototype.updateSettings.call(this, e), this;\n    }, e.prototype.replaceSettings = function (e) {\n      return t.prototype.replaceSettings.call(this, e), this;\n    }, e.prototype.addData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.addData(t, e);\n    }, e.prototype.replaceData = function (t, e) {\n      null == e && (e = \"default\"), this._impl.replaceData(t, e);\n    }, e.prototype.hideMenu = function () {\n      return this._impl.hideMenu(), this;\n    }, e.prototype.getNode = function (t) {\n      return this._impl.getNode(t);\n    }, e.prototype.updateStyle = function (t) {\n      t ? this._impl.renderer && (this._impl.renderer.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null);\n    }, e.prototype.selection = function (t) {\n      return t && this._impl.setSelection(t), this._impl.scene.selection;\n    }, e.prototype.bounds = function (t) {\n      t && this._impl.setBounds(t);\n\n      var e = this._impl.scene.getVisibleBoundsLatLon();\n\n      return {\n        east: e.x1,\n        north: e.y1,\n        west: e.x0,\n        south: e.y0\n      };\n    }, e.prototype.back = function () {\n      return this._impl.back(), this;\n    }, e.prototype.zoomLevel = function (t) {\n      return t && this._impl.setZoomLevel(t), this._impl.scene.zoomLevel;\n    }, e.prototype.getNodeDimensions = function (t) {\n      return this._impl.getNodeDimensions(t);\n    }, e.prototype.leaflet = function () {\n      return this._impl.getMap();\n    }, e.prototype.on = function (e, i) {\n      t.prototype.on.call(this, e, i);\n    }, e;\n  }(i.Base.Api);\n\n  l.themes = {\n    flat: i.GeoChart.Settings.FlatTheme\n  }, l.chartFactoryMethod = null, t.GeoChart = l, i.Base.Helpers.exportSymbol(\"GeoChart\", t.GeoChart), i.Base.Helpers.exportSymbol(\"ZoomCharts\", t);\n}(ZoomCharts || (ZoomCharts = {})), function (t) {\n  t.epsilon = 1e-5;\n\n  var e = function () {\n    function e(t) {\n      this.values = new Float32Array(4), void 0 !== t && (this.xyzw = t);\n    }\n\n    return Object.defineProperty(e.prototype, \"x\", {\n      get: function get() {\n        return this.values[0];\n      },\n      set: function set(t) {\n        this.values[0] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"y\", {\n      get: function get() {\n        return this.values[1];\n      },\n      set: function set(t) {\n        this.values[1] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"z\", {\n      get: function get() {\n        return this.values[2];\n      },\n      set: function set(t) {\n        this.values[2] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"w\", {\n      get: function get() {\n        return this.values[3];\n      },\n      set: function set(t) {\n        this.values[3] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xy\", {\n      get: function get() {\n        return [this.values[0], this.values[1]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xyz\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xyzw\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2], this.values[3]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.at = function (t) {\n      return this.values[t];\n    }, e.prototype.reset = function () {\n      for (var t = 0; t < 4; t++) {\n        this.values[t] = 0;\n      }\n    }, e.prototype.copy = function (t) {\n      t || (t = new e());\n\n      for (var i = 0; i < 4; i++) {\n        t.values[i] = this.values[i];\n      }\n\n      return t;\n    }, e.prototype.roll = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z,\n          n = this.w;\n      return Math.atan2(2 * (t * e + n * i), n * n + t * t - e * e - i * i);\n    }, e.prototype.pitch = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z,\n          n = this.w;\n      return Math.atan2(2 * (e * i + n * t), n * n - t * t - e * e + i * i);\n    }, e.prototype.yaw = function () {\n      return Math.asin(2 * (this.x * this.z - this.w * this.y));\n    }, e.prototype.equals = function (e, i) {\n      void 0 === i && (i = t.epsilon);\n\n      for (var n = 0; n < 4; n++) {\n        if (Math.abs(this.values[n] - e.at(n)) > i) return !1;\n      }\n\n      return !0;\n    }, e.prototype.setIdentity = function () {\n      return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this;\n    }, e.prototype.calculateW = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z;\n      return this.w = -Math.sqrt(Math.abs(1 - t * t - e * e - i * i)), this;\n    }, e.prototype.inverse = function () {\n      var t = e.dot(this, this);\n      if (!t) return this.xyzw = [0, 0, 0, 0], this;\n      var i = t ? 1 / t : 0;\n      return this.x *= -i, this.y *= -i, this.z *= -i, this.w *= i, this;\n    }, e.prototype.conjugate = function () {\n      return this.values[0] *= -1, this.values[1] *= -1, this.values[2] *= -1, this;\n    }, e.prototype.length = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z,\n          n = this.w;\n      return Math.sqrt(t * t + e * e + i * i + n * n);\n    }, e.prototype.normalize = function (t) {\n      t || (t = this);\n      var e = this.x,\n          i = this.y,\n          n = this.z,\n          r = this.w,\n          s = Math.sqrt(e * e + i * i + n * n + r * r);\n      return s ? (s = 1 / s, t.x = e * s, t.y = i * s, t.z = n * s, t.w = r * s, t) : (t.x = 0, t.y = 0, t.z = 0, t.w = 0, t);\n    }, e.prototype.add = function (t) {\n      for (var e = 0; e < 4; e++) {\n        this.values[e] += t.at(e);\n      }\n\n      return this;\n    }, e.prototype.multiply = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = t.x,\n          a = t.y,\n          o = t.z,\n          l = t.w;\n      return this.x = e * l + r * s + i * o - n * a, this.y = i * l + r * a + n * s - e * o, this.z = n * l + r * o + e * a - i * s, this.w = r * l - e * s - i * a - n * o, this;\n    }, e.prototype.multiplyVec3 = function (t, e) {\n      e || (e = new i());\n      var n = t.x,\n          r = t.y,\n          s = t.z,\n          a = this.x,\n          o = this.y,\n          l = this.z,\n          h = this.w,\n          u = h * n + o * s - l * r,\n          c = h * r + l * n - a * s,\n          d = h * s + a * r - o * n,\n          p = -a * n - o * r - l * s;\n      return e.x = u * h + p * -a + c * -l - d * -o, e.y = c * h + p * -o + d * -a - u * -l, e.z = d * h + p * -l + u * -o - c * -a, e;\n    }, e.prototype.toMat3 = function (t) {\n      t || (t = new o());\n      var e = this.x,\n          i = this.y,\n          n = this.z,\n          r = this.w,\n          s = e + e,\n          a = i + i,\n          l = n + n,\n          h = e * s,\n          u = e * a,\n          c = e * l,\n          d = i * a,\n          p = i * l,\n          f = n * l,\n          g = r * s,\n          v = r * a,\n          m = r * l;\n      return t.init([1 - (d + f), u + m, c - v, u - m, 1 - (h + f), p + g, c + v, p - g, 1 - (h + d)]), t;\n    }, e.prototype.toMat4 = function (t) {\n      t || (t = new r());\n      var e = this.x,\n          i = this.y,\n          n = this.z,\n          s = this.w,\n          a = e + e,\n          o = i + i,\n          l = n + n,\n          h = e * a,\n          u = e * o,\n          c = e * l,\n          d = i * o,\n          p = i * l,\n          f = n * l,\n          g = s * a,\n          v = s * o,\n          m = s * l;\n      return t.init([1 - (d + f), u + m, c - v, 0, u - m, 1 - (h + f), p + g, 0, c + v, p - g, 1 - (h + d), 0, 0, 0, 0, 1]), t;\n    }, e.dot = function (t, e) {\n      return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w;\n    }, e.sum = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x + i.x, n.y = t.y + i.y, n.z = t.z + i.z, n.w = t.w + i.w, n;\n    }, e.product = function (t, i, n) {\n      n || (n = new e());\n      var r = t.x,\n          s = t.y,\n          a = t.z,\n          o = t.w,\n          l = i.x,\n          h = i.y,\n          u = i.z,\n          c = i.w;\n      return n.x = r * c + o * l + s * u - a * h, n.y = s * c + o * h + a * l - r * u, n.z = a * c + o * u + r * h - s * l, n.w = o * c - r * l - s * h - a * u, n;\n    }, e.cross = function (t, i, n) {\n      n || (n = new e());\n      var r = t.x,\n          s = t.y,\n          a = t.z,\n          o = t.w,\n          l = i.x,\n          h = i.y,\n          u = i.z,\n          c = i.w;\n      return n.x = o * u + a * c + r * h - s * l, n.y = o * c - r * l - s * h - a * u, n.z = o * l + r * c + s * u - a * h, n.w = o * h + s * c + a * l - r * u, n;\n    }, e.shortMix = function (t, i, n, r) {\n      if (r || (r = new e()), n <= 0) return r.xyzw = t.xyzw, r;\n      if (n >= 1) return r.xyzw = i.xyzw, r;\n      var s = e.dot(t, i),\n          a = i.copy();\n      s < 0 && (a.inverse(), s = -s);\n      var o, l;\n      if (s > .9999) o = 1 - n, l = 0 + n;else {\n        var h = Math.sqrt(1 - s * s),\n            u = Math.atan2(h, s),\n            c = 1 / h;\n        o = Math.sin((1 - n) * u) * c, l = Math.sin((0 + n) * u) * c;\n      }\n      return r.x = o * t.x + l * a.x, r.y = o * t.y + l * a.y, r.z = o * t.z + l * a.z, r.w = o * t.w + l * a.w, r;\n    }, e.mix = function (t, i, n, r) {\n      r || (r = new e());\n      var s = t.x * i.x + t.y * i.y + t.z * i.z + t.w * i.w;\n      if (Math.abs(s) >= 1) return r.xyzw = t.xyzw, r;\n      var a = Math.acos(s),\n          o = Math.sqrt(1 - s * s);\n      if (Math.abs(o) < .001) return r.x = .5 * t.x + .5 * i.x, r.y = .5 * t.y + .5 * i.y, r.z = .5 * t.z + .5 * i.z, r.w = .5 * t.w + .5 * i.w, r;\n      var l = Math.sin((1 - n) * a) / o,\n          h = Math.sin(n * a) / o;\n      return r.x = t.x * l + i.x * h, r.y = t.y * l + i.y * h, r.z = t.z * l + i.z * h, r.w = t.w * l + i.w * h, r;\n    }, e.fromAxisAngle = function (t, i, n) {\n      n || (n = new e()), i *= .5;\n      var r = Math.sin(i);\n      return n.x = t.x * r, n.y = t.y * r, n.z = t.z * r, n.w = Math.cos(i), n;\n    }, e;\n  }();\n\n  e.identity = new e().setIdentity(), t.quat = e;\n\n  var i = function () {\n    function i(t) {\n      this.valueX = 0, this.valueY = 0, this.valueZ = 0, void 0 !== t && (this.xyz = t);\n    }\n\n    return Object.defineProperty(i.prototype, \"x\", {\n      get: function get() {\n        return this.valueX;\n      },\n      set: function set(t) {\n        this.valueX = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"y\", {\n      get: function get() {\n        return this.valueY;\n      },\n      set: function set(t) {\n        this.valueY = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"z\", {\n      get: function get() {\n        return this.valueZ;\n      },\n      set: function set(t) {\n        this.valueZ = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"xy\", {\n      get: function get() {\n        return [this.valueX, this.valueY];\n      },\n      set: function set(t) {\n        this.valueX = t[0], this.valueY = t[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"xyz\", {\n      get: function get() {\n        return [this.valueX, this.valueY, this.valueZ];\n      },\n      set: function set(t) {\n        this.valueX = t[0], this.valueY = t[1], this.valueZ = t[2];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.getValues = function () {\n      var t = new Float32Array(3);\n      return t[0] = this.valueX, t[1] = this.valueY, t[2] = this.valueZ, t;\n    }, i.prototype.at = function (t) {\n      return 0 === t ? this.valueX : 1 === t ? this.valueY : 2 == t ? this.valueZ : -1;\n    }, i.prototype.reset = function () {\n      this.x = 0, this.y = 0, this.z = 0;\n    }, i.prototype.copy = function (t) {\n      return t || (t = new i()), t.x = this.x, t.y = this.y, t.z = this.z, t;\n    }, i.prototype.negate = function (t) {\n      return t || (t = this), t.x = -this.x, t.y = -this.y, t.z = -this.z, t;\n    }, i.prototype.equals = function (e, i) {\n      return void 0 === i && (i = t.epsilon), !(Math.abs(this.x - e.x) > i) && !(Math.abs(this.y - e.y) > i) && !(Math.abs(this.z - e.z) > i);\n    }, i.prototype.length = function () {\n      return Math.sqrt(this.squaredLength());\n    }, i.prototype.squaredLength = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z;\n      return t * t + e * e + i * i;\n    }, i.prototype.add = function (t) {\n      return this.x += t.x, this.y += t.y, this.z += t.z, this;\n    }, i.prototype.subtract = function (t) {\n      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;\n    }, i.prototype.multiply = function (t) {\n      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;\n    }, i.prototype.divide = function (t) {\n      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;\n    }, i.prototype.scale = function (t, e) {\n      return e || (e = this), e.x *= t, e.y *= t, e.z *= t, e;\n    }, i.prototype.normalize = function (t) {\n      t || (t = this);\n      var e = this.length();\n      return 1 === e ? this : 0 === e ? (t.x = 0, t.y = 0, t.z = 0, t) : (e = 1 / e, t.x *= e, t.y *= e, t.z *= e, t);\n    }, i.prototype.multiplyByMat3 = function (t, e) {\n      return e || (e = this), t.multiplyVec3(this, e);\n    }, i.prototype.multiplyByQuat = function (t, e) {\n      return e || (e = this), t.multiplyVec3(this, e);\n    }, i.prototype.toQuat = function (t) {\n      t || (t = new e());\n      var n = new i(),\n          r = new i();\n      return n.x = Math.cos(.5 * this.x), r.x = Math.sin(.5 * this.x), n.y = Math.cos(.5 * this.y), r.y = Math.sin(.5 * this.y), n.z = Math.cos(.5 * this.z), r.z = Math.sin(.5 * this.z), t.x = r.x * n.y * n.z - n.x * r.y * r.z, t.y = n.x * r.y * n.z + r.x * n.y * r.z, t.z = n.x * n.y * r.z - r.x * r.y * n.z, t.w = n.x * n.y * n.z + r.x * r.y * r.z, t;\n    }, i.cross = function (t, e, n) {\n      n || (n = new i());\n      var r = t.x,\n          s = t.y,\n          a = t.z,\n          o = e.x,\n          l = e.y,\n          h = e.z;\n      return n.x = s * h - a * l, n.y = a * o - r * h, n.z = r * l - s * o, n;\n    }, i.dot = function (t, e) {\n      var i = t.x,\n          n = t.y,\n          r = t.z,\n          s = e.x,\n          a = e.y,\n          o = e.z;\n      return i * s + n * a + r * o;\n    }, i.distance = function (t, e) {\n      e.x - t.x, e.y - t.y, e.z - t.z;\n      return Math.sqrt(this.squaredDistance(t, e));\n    }, i.squaredDistance = function (t, e) {\n      var i = e.x - t.x,\n          n = e.y - t.y,\n          r = e.z - t.z;\n      return i * i + n * n + r * r;\n    }, i.direction = function (t, e, n) {\n      n || (n = new i());\n      var r = t.x - e.x,\n          s = t.y - e.y,\n          a = t.z - e.z,\n          o = Math.sqrt(r * r + s * s + a * a);\n      return 0 === o ? (n.x = 0, n.y = 0, n.z = 0, n) : (o = 1 / o, n.x = r * o, n.y = s * o, n.z = a * o, n);\n    }, i.mix = function (t, e, n, r) {\n      return r || (r = new i()), r.x = t.x + n * (e.x - t.x), r.y = t.y + n * (e.y - t.y), r.z = t.z + n * (e.z - t.z), r;\n    }, i.sum = function (t, e, n) {\n      return n || (n = new i()), n.x = t.x + e.x, n.y = t.y + e.y, n.z = t.z + e.z, n;\n    }, i.difference = function (t, e, n) {\n      return n || (n = new i()), n.x = t.x - e.x, n.y = t.y - e.y, n.z = t.z - e.z, n;\n    }, i.product = function (t, e, n) {\n      return n || (n = new i()), n.x = t.x * e.x, n.y = t.y * e.y, n.z = t.z * e.z, n;\n    }, i.quotient = function (t, e, n) {\n      return n || (n = new i()), n.x = t.x / e.x, n.y = t.y / e.y, n.z = t.z / e.z, n;\n    }, i;\n  }();\n\n  i.zero = new i([0, 0, 0]), i.one = new i([1, 1, 1]), i.up = new i([0, 1, 0]), i.right = new i([1, 0, 0]), i.forward = new i([0, 0, 1]), t.vec3 = i;\n\n  var n = function () {\n    function e(t) {\n      this.values = new Float32Array(4), void 0 !== t && (this.xyzw = t);\n    }\n\n    return Object.defineProperty(e.prototype, \"x\", {\n      get: function get() {\n        return this.values[0];\n      },\n      set: function set(t) {\n        this.values[0] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"y\", {\n      get: function get() {\n        return this.values[1];\n      },\n      set: function set(t) {\n        this.values[1] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"z\", {\n      get: function get() {\n        return this.values[2];\n      },\n      set: function set(t) {\n        this.values[2] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"w\", {\n      get: function get() {\n        return this.values[3];\n      },\n      set: function set(t) {\n        this.values[3] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xy\", {\n      get: function get() {\n        return [this.values[0], this.values[1]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xyz\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xyzw\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2], this.values[3]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"r\", {\n      get: function get() {\n        return this.values[0];\n      },\n      set: function set(t) {\n        this.values[0] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"g\", {\n      get: function get() {\n        return this.values[1];\n      },\n      set: function set(t) {\n        this.values[1] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"b\", {\n      get: function get() {\n        return this.values[2];\n      },\n      set: function set(t) {\n        this.values[2] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"a\", {\n      get: function get() {\n        return this.values[3];\n      },\n      set: function set(t) {\n        this.values[3] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rg\", {\n      get: function get() {\n        return [this.values[0], this.values[1]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rgb\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rgba\", {\n      get: function get() {\n        return [this.values[0], this.values[1], this.values[2], this.values[3]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.at = function (t) {\n      return this.values[t];\n    }, e.prototype.reset = function () {\n      this.x = 0, this.y = 0, this.z = 0, this.w = 0;\n    }, e.prototype.copy = function (t) {\n      return t || (t = new e()), t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w, t;\n    }, e.prototype.negate = function (t) {\n      return t || (t = this), t.x = -this.x, t.y = -this.y, t.z = -this.z, t.w = -this.w, t;\n    }, e.prototype.equals = function (e, i) {\n      return void 0 === i && (i = t.epsilon), !(Math.abs(this.x - e.x) > i) && !(Math.abs(this.y - e.y) > i) && !(Math.abs(this.z - e.z) > i) && !(Math.abs(this.w - e.w) > i);\n    }, e.prototype.length = function () {\n      return Math.sqrt(this.squaredLength());\n    }, e.prototype.squaredLength = function () {\n      var t = this.x,\n          e = this.y,\n          i = this.z,\n          n = this.w;\n      return t * t + e * e + i * i + n * n;\n    }, e.prototype.add = function (t) {\n      return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;\n    }, e.prototype.subtract = function (t) {\n      return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;\n    }, e.prototype.multiply = function (t) {\n      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;\n    }, e.prototype.divide = function (t) {\n      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;\n    }, e.prototype.scale = function (t, e) {\n      return e || (e = this), e.x *= t, e.y *= t, e.z *= t, e.w *= t, e;\n    }, e.prototype.normalize = function (t) {\n      t || (t = this);\n      var e = this.length();\n      return 1 === e ? this : 0 === e ? (t.x *= 0, t.y *= 0, t.z *= 0, t.w *= 0, t) : (e = 1 / e, t.x *= e, t.y *= e, t.z *= e, t.w *= e, t);\n    }, e.prototype.multiplyMat4 = function (t, e) {\n      return e || (e = this), t.multiplyVec4(this, e);\n    }, e.mix = function (t, i, n, r) {\n      return r || (r = new e()), r.x = t.x + n * (i.x - t.x), r.y = t.y + n * (i.y - t.y), r.z = t.z + n * (i.z - t.z), r.w = t.w + n * (i.w - t.w), r;\n    }, e.sum = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x + i.x, n.y = t.y + i.y, n.z = t.z + i.z, n.w = t.w + i.w, n;\n    }, e.difference = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x - i.x, n.y = t.y - i.y, n.z = t.z - i.z, n.w = t.w - i.w, n;\n    }, e.product = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x * i.x, n.y = t.y * i.y, n.z = t.z * i.z, n.w = t.w * i.w, n;\n    }, e.quotient = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x / i.x, n.y = t.y / i.y, n.z = t.z / i.z, n.w = t.w / i.w, n;\n    }, e;\n  }();\n\n  n.zero = new n([0, 0, 0, 1]), n.one = new n([1, 1, 1, 1]), t.vec4 = n;\n\n  var r = function () {\n    function e(t) {\n      this.values = new Float32Array(16), void 0 !== t && this.init(t);\n    }\n\n    return e.prototype.getValues = function () {\n      return this.values;\n    }, e.prototype.at = function (t) {\n      return this.values[t];\n    }, e.prototype.init = function (t) {\n      for (var e = 0; e < 16; e++) {\n        this.values[e] = t[e];\n      }\n\n      return this;\n    }, e.prototype.reset = function () {\n      for (var t = 0; t < 16; t++) {\n        this.values[t] = 0;\n      }\n    }, e.prototype.copy = function (t) {\n      t || (t = new e());\n\n      for (var i = 0; i < 16; i++) {\n        t.values[i] = this.values[i];\n      }\n\n      return t;\n    }, e.prototype.all = function () {\n      for (var t = [], e = 0; e < 16; e++) {\n        t[e] = this.values[e];\n      }\n\n      return t;\n    }, e.prototype.row = function (t) {\n      return [this.values[4 * t + 0], this.values[4 * t + 1], this.values[4 * t + 2], this.values[4 * t + 3]];\n    }, e.prototype.col = function (t) {\n      return [this.values[t], this.values[t + 4], this.values[t + 8], this.values[t + 12]];\n    }, e.prototype.equals = function (e, i) {\n      void 0 === i && (i = t.epsilon);\n\n      for (var n = 0; n < 16; n++) {\n        if (Math.abs(this.values[n] - e.at(n)) > i) return !1;\n      }\n\n      return !0;\n    }, e.prototype.determinant = function () {\n      var t = this.values[0],\n          e = this.values[1],\n          i = this.values[2],\n          n = this.values[3],\n          r = this.values[4],\n          s = this.values[5],\n          a = this.values[6],\n          o = this.values[7],\n          l = this.values[8],\n          h = this.values[9],\n          u = this.values[10],\n          c = this.values[11],\n          d = this.values[12],\n          p = this.values[13],\n          f = this.values[14],\n          g = this.values[15],\n          v = t * s - e * r,\n          m = t * a - i * r,\n          y = t * o - n * r,\n          S = e * a - i * s,\n          b = e * o - n * s,\n          x = i * o - n * a,\n          C = l * p - h * d,\n          w = l * f - u * d,\n          L = l * g - c * d,\n          T = h * f - u * p,\n          k = h * g - c * p,\n          M = u * g - c * f;\n      return v * M - m * k + y * T + S * L - b * w + x * C;\n    }, e.prototype.setIdentity = function () {\n      return this.values[0] = 1, this.values[1] = 0, this.values[2] = 0, this.values[3] = 0, this.values[4] = 0, this.values[5] = 1, this.values[6] = 0, this.values[7] = 0, this.values[8] = 0, this.values[9] = 0, this.values[10] = 1, this.values[11] = 0, this.values[12] = 0, this.values[13] = 0, this.values[14] = 0, this.values[15] = 1, this;\n    }, e.prototype.setViewTransform = function (t, e, i, n, r) {\n      return this.values[0] = t, this.values[1] = 0, this.values[2] = 0, this.values[3] = 0, this.values[4] = 0, this.values[5] = i, this.values[6] = 0, this.values[7] = 0, this.values[8] = 0, this.values[9] = 0, this.values[10] = 1, this.values[11] = 0, this.values[12] = e, this.values[13] = n, this.values[14] = 0, this.values[15] = 1, this;\n    }, e.prototype.transpose = function () {\n      var t = this.values[1],\n          e = this.values[2],\n          i = this.values[3],\n          n = this.values[6],\n          r = this.values[7],\n          s = this.values[11];\n      return this.values[1] = this.values[4], this.values[2] = this.values[8], this.values[3] = this.values[12], this.values[4] = t, this.values[6] = this.values[9], this.values[7] = this.values[13], this.values[8] = e, this.values[9] = n, this.values[11] = this.values[14], this.values[12] = i, this.values[13] = r, this.values[14] = s, this;\n    }, e.prototype.inverse = function () {\n      var t = this.values[0],\n          e = this.values[1],\n          i = this.values[2],\n          n = this.values[3],\n          r = this.values[4],\n          s = this.values[5],\n          a = this.values[6],\n          o = this.values[7],\n          l = this.values[8],\n          h = this.values[9],\n          u = this.values[10],\n          c = this.values[11],\n          d = this.values[12],\n          p = this.values[13],\n          f = this.values[14],\n          g = this.values[15],\n          v = t * s - e * r,\n          m = t * a - i * r,\n          y = t * o - n * r,\n          S = e * a - i * s,\n          b = e * o - n * s,\n          x = i * o - n * a,\n          C = l * p - h * d,\n          w = l * f - u * d,\n          L = l * g - c * d,\n          T = h * f - u * p,\n          k = h * g - c * p,\n          M = u * g - c * f,\n          A = v * M - m * k + y * T + S * L - b * w + x * C;\n      return A ? (A = 1 / A, this.values[0] = (s * M - a * k + o * T) * A, this.values[1] = (-e * M + i * k - n * T) * A, this.values[2] = (p * x - f * b + g * S) * A, this.values[3] = (-h * x + u * b - c * S) * A, this.values[4] = (-r * M + a * L - o * w) * A, this.values[5] = (t * M - i * L + n * w) * A, this.values[6] = (-d * x + f * y - g * m) * A, this.values[7] = (l * x - u * y + c * m) * A, this.values[8] = (r * k - s * L + o * C) * A, this.values[9] = (-t * k + e * L - n * C) * A, this.values[10] = (d * b - p * y + g * v) * A, this.values[11] = (-l * b + h * y - c * v) * A, this.values[12] = (-r * T + s * w - a * C) * A, this.values[13] = (t * T - e * w + i * C) * A, this.values[14] = (-d * S + p * m - f * v) * A, this.values[15] = (l * S - h * m + u * v) * A, this) : null;\n    }, e.prototype.multiply = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = this.values[4],\n          a = this.values[5],\n          o = this.values[6],\n          l = this.values[7],\n          h = this.values[8],\n          u = this.values[9],\n          c = this.values[10],\n          d = this.values[11],\n          p = this.values[12],\n          f = this.values[13],\n          g = this.values[14],\n          v = this.values[15],\n          m = t.at(0),\n          y = t.at(1),\n          S = t.at(2),\n          b = t.at(3);\n      return this.values[0] = m * e + y * s + S * h + b * p, this.values[1] = m * i + y * a + S * u + b * f, this.values[2] = m * n + y * o + S * c + b * g, this.values[3] = m * r + y * l + S * d + b * v, m = t.at(4), y = t.at(5), S = t.at(6), b = t.at(7), this.values[4] = m * e + y * s + S * h + b * p, this.values[5] = m * i + y * a + S * u + b * f, this.values[6] = m * n + y * o + S * c + b * g, this.values[7] = m * r + y * l + S * d + b * v, m = t.at(8), y = t.at(9), S = t.at(10), b = t.at(11), this.values[8] = m * e + y * s + S * h + b * p, this.values[9] = m * i + y * a + S * u + b * f, this.values[10] = m * n + y * o + S * c + b * g, this.values[11] = m * r + y * l + S * d + b * v, m = t.at(12), y = t.at(13), S = t.at(14), b = t.at(15), this.values[12] = m * e + y * s + S * h + b * p, this.values[13] = m * i + y * a + S * u + b * f, this.values[14] = m * n + y * o + S * c + b * g, this.values[15] = m * r + y * l + S * d + b * v, this;\n    }, e.prototype.multiplyVec3 = function (t) {\n      var e = t.x,\n          n = t.y,\n          r = t.z;\n      return new i([this.values[0] * e + this.values[4] * n + this.values[8] * r + this.values[12], this.values[1] * e + this.values[5] * n + this.values[9] * r + this.values[13], this.values[2] * e + this.values[6] * n + this.values[10] * r + this.values[14]]);\n    }, e.prototype.multiplyVec4 = function (t, e) {\n      e || (e = new n());\n      var i = t.x,\n          r = t.y,\n          s = t.z,\n          a = t.w;\n      return e.x = this.values[0] * i + this.values[4] * r + this.values[8] * s + this.values[12] * a, e.y = this.values[1] * i + this.values[5] * r + this.values[9] * s + this.values[13] * a, e.z = this.values[2] * i + this.values[6] * r + this.values[10] * s + this.values[14] * a, e.w = this.values[3] * i + this.values[7] * r + this.values[11] * s + this.values[15] * a, e;\n    }, e.prototype.toMat3 = function () {\n      return new o([this.values[0], this.values[1], this.values[2], this.values[4], this.values[5], this.values[6], this.values[8], this.values[9], this.values[10]]);\n    }, e.prototype.toInverseMat3 = function () {\n      var t = this.values[0],\n          e = this.values[1],\n          i = this.values[2],\n          n = this.values[4],\n          r = this.values[5],\n          s = this.values[6],\n          a = this.values[8],\n          l = this.values[9],\n          h = this.values[10],\n          u = h * r - s * l,\n          c = -h * n + s * a,\n          d = l * n - r * a,\n          p = t * u + e * c + i * d;\n      return p ? (p = 1 / p, new o([u * p, (-h * e + i * l) * p, (s * e - i * r) * p, c * p, (h * t - i * a) * p, (-s * t + i * n) * p, d * p, (-l * t + e * a) * p, (r * t - e * n) * p])) : null;\n    }, e.prototype.translateFromVector = function (t) {\n      return this.translate(t.x, t.y, t.z);\n    }, e.prototype.translate = function (t, e, i) {\n      return this.values[12] += this.values[0] * t + this.values[4] * e + this.values[8] * i, this.values[13] += this.values[1] * t + this.values[5] * e + this.values[9] * i, this.values[14] += this.values[2] * t + this.values[6] * e + this.values[10] * i, this.values[15] += this.values[3] * t + this.values[7] * e + this.values[11] * i, this;\n    }, e.prototype.setDrawLineMatrix = function (t, e, i, n, r, s, a, o) {\n      return this.values[0] = i * r, this.values[1] = -n * r, this.values[2] = 0, this.values[3] = 0, this.values[4] = n * s, this.values[5] = i * s, this.values[6] = 0, this.values[7] = 0, this.values[8] = a, this.values[9] = o, this.values[10] = s, this.values[11] = 0, this.values[12] = t, this.values[13] = e, this.values[14] = 0, this.values[15] = 1, this;\n    }, e.prototype.scaleFromVector = function (t) {\n      return this.scale(t.x, t.y, t.z);\n    }, e.prototype.scale = function (t, e, i) {\n      return this.values[0] *= t, this.values[1] *= t, this.values[2] *= t, this.values[3] *= t, this.values[4] *= e, this.values[5] *= e, this.values[6] *= e, this.values[7] *= e, this.values[8] *= i, this.values[9] *= i, this.values[10] *= i, this.values[11] *= i, this;\n    }, e.prototype.rotateFromVector = function (t, e) {\n      return this.rotate(t, e.x, e.y, e.z);\n    }, e.prototype.rotate = function (t, e, i, n) {\n      var r = Math.sqrt(e * e + i * i + n * n);\n      if (!r) return null;\n      1 !== r && (r = 1 / r, e *= r, i *= r, n *= r);\n      var s = Math.sin(t),\n          a = Math.cos(t),\n          o = 1 - a,\n          l = this.values[0],\n          h = this.values[1],\n          u = this.values[2],\n          c = this.values[3],\n          d = this.values[4],\n          p = this.values[5],\n          f = this.values[6],\n          g = this.values[7],\n          v = this.values[8],\n          m = this.values[9],\n          y = this.values[10],\n          S = this.values[11],\n          b = e * e * o + a,\n          x = i * e * o + n * s,\n          C = n * e * o - i * s,\n          w = e * i * o - n * s,\n          L = i * i * o + a,\n          T = n * i * o + e * s,\n          k = e * n * o + i * s,\n          M = i * n * o - e * s,\n          A = n * n * o + a;\n      return this.values[0] = l * b + d * x + v * C, this.values[1] = h * b + p * x + m * C, this.values[2] = u * b + f * x + y * C, this.values[3] = c * b + g * x + S * C, this.values[4] = l * w + d * L + v * T, this.values[5] = h * w + p * L + m * T, this.values[6] = u * w + f * L + y * T, this.values[7] = c * w + g * L + S * T, this.values[8] = l * k + d * M + v * A, this.values[9] = h * k + p * M + m * A, this.values[10] = u * k + f * M + y * A, this.values[11] = c * k + g * M + S * A, this;\n    }, e.frustum = function (t, i, n, r, s, a) {\n      var o = i - t,\n          l = r - n,\n          h = a - s;\n      return new e([2 * s / o, 0, 0, 0, 0, 2 * s / l, 0, 0, (i + t) / o, (r + n) / l, -(a + s) / h, -1, 0, 0, -(a * s * 2) / h, 0]);\n    }, e.perspective = function (t, i, n, r) {\n      var s = n * Math.tan(t / 2),\n          a = s * i;\n      return e.frustum(-a, a, -s, s, n, r);\n    }, e.orthographic = function (t, i, n, r, s, a) {\n      var o = i - t,\n          l = r - n,\n          h = a - s;\n      return new e([2 / o, 0, 0, 0, 0, 2 / l, 0, 0, 0, 0, -2 / h, 0, -(t + i) / o, -(r + n) / l, -(a + s) / h, 1]);\n    }, e.lookAt = function (t, n, r) {\n      if (void 0 === r && (r = i.up), t.equals(n)) return this.identity;\n      var s = i.difference(t, n).normalize(),\n          a = i.cross(r, s).normalize(),\n          o = i.cross(s, a).normalize();\n      return new e([a.x, o.x, s.x, 0, a.y, o.y, s.y, 0, a.z, o.z, s.z, 0, -i.dot(a, t), -i.dot(o, t), -i.dot(s, t), 1]);\n    }, e.multiplyToNewMatrix = function (t, i) {\n      var n = new e();\n      return e.product(t, i, n);\n    }, e.product = function (t, i, n) {\n      var r = t.at(0),\n          s = t.at(1),\n          a = t.at(2),\n          o = t.at(3),\n          l = t.at(4),\n          h = t.at(5),\n          u = t.at(6),\n          c = t.at(7),\n          d = t.at(8),\n          p = t.at(9),\n          f = t.at(10),\n          g = t.at(11),\n          v = t.at(12),\n          m = t.at(13),\n          y = t.at(14),\n          S = t.at(15),\n          b = i.at(0),\n          x = i.at(1),\n          C = i.at(2),\n          w = i.at(3),\n          L = i.at(4),\n          T = i.at(5),\n          k = i.at(6),\n          M = i.at(7),\n          A = i.at(8),\n          I = i.at(9),\n          P = i.at(10),\n          D = i.at(11),\n          N = i.at(12),\n          F = i.at(13),\n          O = i.at(14),\n          E = i.at(15);\n      return n ? (n.init([b * r + x * l + C * d + w * v, b * s + x * h + C * p + w * m, b * a + x * u + C * f + w * y, b * o + x * c + C * g + w * S, L * r + T * l + k * d + M * v, L * s + T * h + k * p + M * m, L * a + T * u + k * f + M * y, L * o + T * c + k * g + M * S, A * r + I * l + P * d + D * v, A * s + I * h + P * p + D * m, A * a + I * u + P * f + D * y, A * o + I * c + P * g + D * S, N * r + F * l + O * d + E * v, N * s + F * h + O * p + E * m, N * a + F * u + O * f + E * y, N * o + F * c + O * g + E * S]), n) : new e([b * r + x * l + C * d + w * v, b * s + x * h + C * p + w * m, b * a + x * u + C * f + w * y, b * o + x * c + C * g + w * S, L * r + T * l + k * d + M * v, L * s + T * h + k * p + M * m, L * a + T * u + k * f + M * y, L * o + T * c + k * g + M * S, A * r + I * l + P * d + D * v, A * s + I * h + P * p + D * m, A * a + I * u + P * f + D * y, A * o + I * c + P * g + D * S, N * r + F * l + O * d + E * v, N * s + F * h + O * p + E * m, N * a + F * u + O * f + E * y, N * o + F * c + O * g + E * S]);\n    }, e;\n  }();\n\n  r.identity = new r().setIdentity(), t.mat4 = r;\n\n  var s = function () {\n    function e(t) {\n      this.values = new Float32Array(4), void 0 !== t && this.init(t);\n    }\n\n    return e.prototype.at = function (t) {\n      return this.values[t];\n    }, e.prototype.init = function (t) {\n      for (var e = 0; e < 4; e++) {\n        this.values[e] = t[e];\n      }\n\n      return this;\n    }, e.prototype.reset = function () {\n      for (var t = 0; t < 4; t++) {\n        this.values[t] = 0;\n      }\n    }, e.prototype.copy = function (t) {\n      t || (t = new e());\n\n      for (var i = 0; i < 4; i++) {\n        t.values[i] = this.values[i];\n      }\n\n      return t;\n    }, e.prototype.all = function () {\n      for (var t = [], e = 0; e < 4; e++) {\n        t[e] = this.values[e];\n      }\n\n      return t;\n    }, e.prototype.row = function (t) {\n      return [this.values[2 * t + 0], this.values[2 * t + 1]];\n    }, e.prototype.col = function (t) {\n      return [this.values[t], this.values[t + 2]];\n    }, e.prototype.equals = function (e, i) {\n      void 0 === i && (i = t.epsilon);\n\n      for (var n = 0; n < 4; n++) {\n        if (Math.abs(this.values[n] - e.at(n)) > i) return !1;\n      }\n\n      return !0;\n    }, e.prototype.determinant = function () {\n      return this.values[0] * this.values[3] - this.values[2] * this.values[1];\n    }, e.prototype.setIdentity = function () {\n      return this.values[0] = 1, this.values[1] = 0, this.values[2] = 0, this.values[3] = 1, this;\n    }, e.prototype.transpose = function () {\n      var t = this.values[1];\n      return this.values[1] = this.values[2], this.values[2] = t, this;\n    }, e.prototype.inverse = function () {\n      var t = this.determinant();\n      if (!t) return null;\n      t = 1 / t;\n      var e = this.values[0];\n      return this.values[0] = t * this.values[3], this.values[1] = t * -this.values[1], this.values[2] = t * -this.values[2], this.values[3] = t * e, this;\n    }, e.prototype.multiply = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3];\n      return this.values[0] = e * t.at(0) + i * t.at(2), this.values[1] = e * t.at(1) + i * t.at(3), this.values[2] = n * t.at(0) + r * t.at(2), this.values[3] = n * t.at(1) + r * t.at(3), this;\n    }, e.prototype.rotate = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = Math.sin(t),\n          a = Math.cos(t);\n      return this.values[0] = e * a + i * s, this.values[1] = e * -s + i * a, this.values[2] = n * a + r * s, this.values[3] = n * -s + r * a, this;\n    }, e.prototype.multiplyVec2 = function (t, e) {\n      var i = t.x,\n          n = t.y;\n      return e ? (e.xy = [i * this.values[0] + n * this.values[1], i * this.values[2] + n * this.values[3]], e) : new a([i * this.values[0] + n * this.values[1], i * this.values[2] + n * this.values[3]]);\n    }, e.prototype.scale = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = t.x,\n          a = t.y;\n      return this.values[0] = e * s, this.values[1] = i * a, this.values[2] = n * s, this.values[3] = r * a, this;\n    }, e.product = function (t, i, n) {\n      var r = t.at(0),\n          s = t.at(1),\n          a = t.at(2),\n          o = t.at(3);\n      return n ? (n.init([r * i.at(0) + s * i.at(2), r * i.at(1) + s * i.at(3), a * i.at(0) + o * i.at(2), a * i.at(1) + o * i.at(3)]), n) : new e([r * i.at(0) + s * i.at(2), r * i.at(1) + s * i.at(3), a * i.at(0) + o * i.at(2), a * i.at(1) + o * i.at(3)]);\n    }, e;\n  }();\n\n  s.identity = new s().setIdentity(), t.mat2 = s;\n\n  var a = function () {\n    function e(t) {\n      this.values = new Float32Array(2), void 0 !== t && (this.xy = t);\n    }\n\n    return Object.defineProperty(e.prototype, \"x\", {\n      get: function get() {\n        return this.values[0];\n      },\n      set: function set(t) {\n        this.values[0] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"y\", {\n      get: function get() {\n        return this.values[1];\n      },\n      set: function set(t) {\n        this.values[1] = t;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"xy\", {\n      get: function get() {\n        return [this.values[0], this.values[1]];\n      },\n      set: function set(t) {\n        this.values[0] = t[0], this.values[1] = t[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.at = function (t) {\n      return this.values[t];\n    }, e.prototype.reset = function () {\n      this.x = 0, this.y = 0;\n    }, e.prototype.copy = function (t) {\n      return t || (t = new e()), t.x = this.x, t.y = this.y, t;\n    }, e.prototype.negate = function (t) {\n      return t || (t = this), t.x = -this.x, t.y = -this.y, t;\n    }, e.prototype.equals = function (e, i) {\n      return void 0 === i && (i = t.epsilon), !(Math.abs(this.x - e.x) > i) && !(Math.abs(this.y - e.y) > i);\n    }, e.prototype.length = function () {\n      return Math.sqrt(this.squaredLength());\n    }, e.prototype.squaredLength = function () {\n      var t = this.x,\n          e = this.y;\n      return t * t + e * e;\n    }, e.prototype.add = function (t) {\n      return this.x += t.x, this.y += t.y, this;\n    }, e.prototype.subtract = function (t) {\n      return this.x -= t.x, this.y -= t.y, this;\n    }, e.prototype.multiply = function (t) {\n      return this.x *= t.x, this.y *= t.y, this;\n    }, e.prototype.divide = function (t) {\n      return this.x /= t.x, this.y /= t.y, this;\n    }, e.prototype.scale = function (t, e) {\n      return e || (e = this), e.x *= t, e.y *= t, e;\n    }, e.prototype.normalize = function (t) {\n      t || (t = this);\n      var e = this.length();\n      return 1 === e ? this : 0 === e ? (t.x = 0, t.y = 0, t) : (e = 1 / e, t.x *= e, t.y *= e, t);\n    }, e.prototype.multiplyMat2 = function (t, e) {\n      return e || (e = this), t.multiplyVec2(this, e);\n    }, e.prototype.multiplyMat3 = function (t, e) {\n      return e || (e = this), t.multiplyVec2(this, e);\n    }, e.cross = function (t, e, n) {\n      n || (n = new i());\n      var r = t.x,\n          s = t.y,\n          a = e.x,\n          o = e.y,\n          l = r * o - s * a;\n      return n.x = 0, n.y = 0, n.z = l, n;\n    }, e.dot = function (t, e) {\n      return t.x * e.x + t.y * e.y;\n    }, e.distance = function (t, e) {\n      return Math.sqrt(this.squaredDistance(t, e));\n    }, e.squaredDistance = function (t, e) {\n      var i = e.x - t.x,\n          n = e.y - t.y;\n      return i * i + n * n;\n    }, e.direction = function (t, i, n) {\n      n || (n = new e());\n      var r = t.x - i.x,\n          s = t.y - i.y,\n          a = Math.sqrt(r * r + s * s);\n      return 0 === a ? (n.x = 0, n.y = 0, n) : (a = 1 / a, n.x = r * a, n.y = s * a, n);\n    }, e.mix = function (t, i, n, r) {\n      r || (r = new e());\n      var s = t.x,\n          a = t.y,\n          o = i.x,\n          l = i.y;\n      return r.x = s + n * (o - s), r.y = a + n * (l - a), r;\n    }, e.sum = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x + i.x, n.y = t.y + i.y, n;\n    }, e.difference = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x - i.x, n.y = t.y - i.y, n;\n    }, e.product = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x * i.x, n.y = t.y * i.y, n;\n    }, e.quotient = function (t, i, n) {\n      return n || (n = new e()), n.x = t.x / i.x, n.y = t.y / i.y, n;\n    }, e;\n  }();\n\n  a.zero = new a([0, 0]), a.one = new a([1, 1]), t.vec2 = a;\n\n  var o = function () {\n    function n(t) {\n      this.values = new Float32Array(9), void 0 !== t && this.init(t);\n    }\n\n    return n.prototype.at = function (t) {\n      return this.values[t];\n    }, n.prototype.init = function (t) {\n      for (var e = 0; e < 9; e++) {\n        this.values[e] = t[e];\n      }\n\n      return this;\n    }, n.prototype.reset = function () {\n      for (var t = 0; t < 9; t++) {\n        this.values[t] = 0;\n      }\n    }, n.prototype.copy = function (t) {\n      t || (t = new n());\n\n      for (var e = 0; e < 9; e++) {\n        t.values[e] = this.values[e];\n      }\n\n      return t;\n    }, n.prototype.all = function () {\n      for (var t = [], e = 0; e < 9; e++) {\n        t[e] = this.values[e];\n      }\n\n      return t;\n    }, n.prototype.row = function (t) {\n      return [this.values[3 * t + 0], this.values[3 * t + 1], this.values[3 * t + 2]];\n    }, n.prototype.col = function (t) {\n      return [this.values[t], this.values[t + 3], this.values[t + 6]];\n    }, n.prototype.equals = function (e, i) {\n      void 0 === i && (i = t.epsilon);\n\n      for (var n = 0; n < 9; n++) {\n        if (Math.abs(this.values[n] - e.at(n)) > i) return !1;\n      }\n\n      return !0;\n    }, n.prototype.determinant = function () {\n      var t = this.values[0],\n          e = this.values[1],\n          i = this.values[2],\n          n = this.values[3],\n          r = this.values[4],\n          s = this.values[5],\n          a = this.values[6],\n          o = this.values[7],\n          l = this.values[8],\n          h = l * r - s * o,\n          u = -l * n + s * a,\n          c = o * n - r * a;\n      return t * h + e * u + i * c;\n    }, n.prototype.setIdentity = function () {\n      return this.values[0] = 1, this.values[1] = 0, this.values[2] = 0, this.values[3] = 0, this.values[4] = 1, this.values[5] = 0, this.values[6] = 0, this.values[7] = 0, this.values[8] = 1, this;\n    }, n.prototype.transpose = function () {\n      var t = this.values[1],\n          e = this.values[2],\n          i = this.values[5];\n      return this.values[1] = this.values[3], this.values[2] = this.values[6], this.values[3] = t, this.values[5] = this.values[7], this.values[6] = e, this.values[7] = i, this;\n    }, n.prototype.inverse = function () {\n      var t = this.values[0],\n          e = this.values[1],\n          i = this.values[2],\n          n = this.values[3],\n          r = this.values[4],\n          s = this.values[5],\n          a = this.values[6],\n          o = this.values[7],\n          l = this.values[8],\n          h = l * r - s * o,\n          u = -l * n + s * a,\n          c = o * n - r * a,\n          d = t * h + e * u + i * c;\n      return d ? (d = 1 / d, this.values[0] = h * d, this.values[1] = (-l * e + i * o) * d, this.values[2] = (s * e - i * r) * d, this.values[3] = u * d, this.values[4] = (l * t - i * a) * d, this.values[5] = (-s * t + i * n) * d, this.values[6] = c * d, this.values[7] = (-o * t + e * a) * d, this.values[8] = (r * t - e * n) * d, this) : null;\n    }, n.prototype.multiply = function (t) {\n      var e = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = this.values[4],\n          a = this.values[5],\n          o = this.values[6],\n          l = this.values[7],\n          h = this.values[8],\n          u = t.at(0),\n          c = t.at(1),\n          d = t.at(2),\n          p = t.at(3),\n          f = t.at(4),\n          g = t.at(5),\n          v = t.at(6),\n          m = t.at(7),\n          y = t.at(8);\n      return this.values[0] = u * e + c * r + d * o, this.values[1] = u * i + c * s + d * l, this.values[2] = u * n + c * a + d * h, this.values[3] = p * e + f * r + g * o, this.values[4] = p * i + f * s + g * l, this.values[5] = p * n + f * a + g * h, this.values[6] = v * e + m * r + y * o, this.values[7] = v * i + m * s + y * l, this.values[8] = v * n + m * a + y * h, this;\n    }, n.prototype.multiplyVec2 = function (t, e) {\n      var i = t.x,\n          n = t.y;\n      return e ? (e.xy = [i * this.values[0] + n * this.values[3] + this.values[6], i * this.values[1] + n * this.values[4] + this.values[7]], e) : new a([i * this.values[0] + n * this.values[3] + this.values[6], i * this.values[1] + n * this.values[4] + this.values[7]]);\n    }, n.prototype.multiplyVec3 = function (t, e) {\n      var n = t.x,\n          r = t.y,\n          s = t.z;\n      return e ? (e.xyz = [n * this.values[0] + r * this.values[3] + s * this.values[6], n * this.values[1] + r * this.values[4] + s * this.values[7], n * this.values[2] + r * this.values[5] + s * this.values[8]], e) : new i([n * this.values[0] + r * this.values[3] + s * this.values[6], n * this.values[1] + r * this.values[4] + s * this.values[7], n * this.values[2] + r * this.values[5] + s * this.values[8]]);\n    }, n.prototype.toMat4 = function (t) {\n      return t ? (t.init([this.values[0], this.values[1], this.values[2], 0, this.values[3], this.values[4], this.values[5], 0, this.values[6], this.values[7], this.values[8], 0, 0, 0, 0, 1]), t) : new r([this.values[0], this.values[1], this.values[2], 0, this.values[3], this.values[4], this.values[5], 0, this.values[6], this.values[7], this.values[8], 0, 0, 0, 0, 1]);\n    }, n.prototype.toQuat = function () {\n      var t = this.values[0],\n          i = this.values[1],\n          n = this.values[2],\n          r = this.values[3],\n          s = this.values[4],\n          a = this.values[5],\n          o = this.values[6],\n          l = this.values[7],\n          h = this.values[8],\n          u = t - s - h,\n          c = s - t - h,\n          d = h - t - s,\n          p = t + s + h,\n          f = 0,\n          g = p;\n      u > g && (g = u, f = 1), c > g && (g = c, f = 2), d > g && (g = d, f = 3);\n      var v = .5 * Math.sqrt(g + 1),\n          m = .25 / v,\n          y = new e();\n\n      switch (f) {\n        case 0:\n          y.w = v, y.x = (a - l) * m, y.y = (o - n) * m, y.z = (i - r) * m;\n          break;\n\n        case 1:\n          y.w = (a - l) * m, y.x = v, y.y = (i + r) * m, y.z = (o + n) * m;\n          break;\n\n        case 2:\n          y.w = (o - n) * m, y.x = (i + r) * m, y.y = v, y.z = (a + l) * m;\n          break;\n\n        case 3:\n          y.w = (i - r) * m, y.x = (o + n) * m, y.y = (a + l) * m, y.z = v;\n      }\n\n      return y;\n    }, n.prototype.rotate = function (t, e) {\n      var i = e.x,\n          n = e.y,\n          r = e.z,\n          s = Math.sqrt(i * i + n * n + r * r);\n      if (!s) return null;\n      1 !== s && (s = 1 / s, i *= s, n *= s, r *= s);\n      var a = Math.sin(t),\n          o = Math.cos(t),\n          l = 1 - o,\n          h = this.values[0],\n          u = this.values[1],\n          c = this.values[2],\n          d = this.values[4],\n          p = this.values[5],\n          f = this.values[6],\n          g = this.values[8],\n          v = this.values[9],\n          m = this.values[10],\n          y = i * i * l + o,\n          S = n * i * l + r * a,\n          b = r * i * l - n * a,\n          x = i * n * l - r * a,\n          C = n * n * l + o,\n          w = r * n * l + i * a,\n          L = i * r * l + n * a,\n          T = n * r * l - i * a,\n          k = r * r * l + o;\n      return this.values[0] = h * y + d * S + g * b, this.values[1] = u * y + p * S + v * b, this.values[2] = c * y + f * S + m * b, this.values[3] = h * x + d * C + g * w, this.values[4] = u * x + p * C + v * w, this.values[5] = c * x + f * C + m * w, this.values[6] = h * L + d * T + g * k, this.values[7] = u * L + p * T + v * k, this.values[8] = c * L + f * T + m * k, this;\n    }, n.product = function (t, e, i) {\n      var r = t.at(0),\n          s = t.at(1),\n          a = t.at(2),\n          o = t.at(3),\n          l = t.at(4),\n          h = t.at(5),\n          u = t.at(6),\n          c = t.at(7),\n          d = t.at(8),\n          p = e.at(0),\n          f = e.at(1),\n          g = e.at(2),\n          v = e.at(3),\n          m = e.at(4),\n          y = e.at(5),\n          S = e.at(6),\n          b = e.at(7),\n          x = e.at(8);\n      return i ? (i.init([p * r + f * o + g * u, p * s + f * l + g * c, p * a + f * h + g * d, v * r + m * o + y * u, v * s + m * l + y * c, v * a + m * h + y * d, S * r + b * o + x * u, S * s + b * l + x * c, S * a + b * h + x * d]), i) : new n([p * r + f * o + g * u, p * s + f * l + g * c, p * a + f * h + g * d, v * r + m * o + y * u, v * s + m * l + y * c, v * a + m * h + y * d, S * r + b * o + x * u, S * s + b * l + x * c, S * a + b * h + x * d]);\n    }, n;\n  }();\n\n  o.identity = new o().setIdentity(), t.mat3 = o;\n}(GLMath || (GLMath = {}));","map":null,"metadata":{},"sourceType":"script"}